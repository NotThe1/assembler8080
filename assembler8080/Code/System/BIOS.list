0001: 0000                ;	Pages 165/493 &  204/493  Programmers CPM Handbook by Andy Johnston-Laird
0002: 0000                					               
0003: 0000                                    
0004: 0000                INopCode	EQU		0DBH  
0005: 0000                OUTopCode	EQU		0D3H 
0006: 0000                SPACE		EQU		020H    
0007: 0000                SLASH		EQU		02FH    
0008: 0000                ; programmers CPM Handbook by Andy Johnson
0009: 0000                                    
0010: 0000                                    
0011: 0000                VERSION		EQU		'0A'		;Equates for the sign-on Screen
0012: 0000                MONTH		EQU		'08'		; '08'
0013: 0000                DAY			EQU		'25'		; '09'
0014: 0000                Year		EQU		'45'		; '15'
0015: 0000                                    
0016: 0000                MemorySize	EQU 64   
0017: 0000                                    
0018: 0000                CCPLength	EQU 0800H	; Constant
0019: 0000                BDOSLength	EQU 0E00H	; Constant	0E00H
0020: 0000                BIOSLength	EQU 0A00H	; Constant 0900H
0021: 0000                                    
0022: 0000                LengthInK	EQU ((CCPLength + BDOSLength + BIOSLength) /1024) + 1
0023: 0000                LengthInBytes	EQU (CCPLength + BDOSLength + BIOSLength)
0024: 0000                                    
0025: 0000                                    
0026: 0000                ;CCPEntry	EQU	((MemorySize - LengthInK) * (0 + 1024))
0027: 0000                CCPEntry	EQU 0E000H		; forced calculation
0028: 0000                                    
0029: 0000                BDOSEntry	EQU	CCPEntry + CCPLength + 6
0030: 0000                BIOSEntry	EQU	CCPEntry + CCPLength + BDOSLength
0031: 0000                                    
0032: 0000                                    
0033: 0000                ;;;	DefaultDisk	EQU	0004H
0034: 0000                PageZero:	ORG 0000H		; Start of page Zero
0035: 0000     C303F6     	JMP		WarmBootEntry	; warm start
0036: 0003                IOBYTE:             
0037: 0003     01         	DB		01H				; IOBYTE- Console is assigned the CRT device
0038: 0004                DefaultDisk:        
0039: 0004     00         	DB		00H				; Current default drive (A)
0040: 0005     C306E8     	JMP		BDOSEntry		; jump to BDOS entry
0041: 0008                	DS		028H			; interrupt locations 1-5 not used
0042: 0030                	DS		008H			; interrupt location 6 is reserved
0043: 0038     C30000     	JMP		0000H			; rst 7 used only by DDT & SID programs
0044: 003B                	DS		005H			; not currently used
0045: 0040                	DS		010H			; reserved for scratch by CBIOS- not used by CP/M
0046: 0050                	DS		00CH			; not currently used
0047: 005C                FCB:                
0048: 005C                	DS		021H			; Default FCB for transient programs
0049: 007D                RandomRecordPosition:
0050: 007D                	DS		003H			; optional random record position
0051: 0080                DefaultDiskBuffer:  
0052: 0080                	DS		080H			; default 128- byte disk buffer,
0053: 0100                							; also filled with the command line from CCP
0054: 0100                	                   
0055: 0100                                    
0056: 0100                                    
0057: 0100                	ORG		BIOSEntry		; Assemble code at BIOS address
0058: F600                CodeStart:		        
0059: F600                		; BIOS jum Vector 
0060: F600                		                  
0061: F600     C3F9F6     	JMP	BOOT			; 00 Checked
0062: F603                WarmBootEntry:      
0063: F603     C325FE     	JMP	WBOOT			; 01 Checked
0064: F606     C362F8     	JMP	CONST			; 02 Checked
0065: F609     C378F8     	JMP	CONIN			; 03 Checked
0066: F60C     C386F8     	JMP	CONOUT			; 04 Checked
0067: F60F     C3ACF8     	JMP	LIST			; 05 Not Yet Checked
0068: F612     C3BCF8     	JMP	PUNCH			; 06 Not Yet Checked
0069: F615     C3CDF8     	JMP	READER			; 07 Not Yet Checked
0070: F618     C3D3FB     	JMP	HOME			; 08 Not Yet Checked			302		FBD3
0071: F61B     C32BFB     	JMP	SELDSK			; 09 Checked	
0072: F61E     C358FB     	JMP	SETTRK			; 0A Checked
0073: F621     C35EFB     	JMP	SETSEC			; 0B Checked			221		FB5E
0074: F624     C365FB     	JMP	SETDMA			; 0C Checked			230		FB65
0075: F627     C3FBFB     	JMP	READ			; 0D Not Yet Checked			398		FBFB
0076: F62A     C315FC     	JMP	WRITE			; 0E Not Yet Checked			426		FC15
0077: F62D     C394F8     	JMP	LISTST			; 0F Not Yet Checked
0078: F630     C3CDFB     	JMP	SECTRAN			; 10 Not Yet Checked
0079: F633                	                   
0080: F633                PhysicalSectorSize	EQU	512			; for the 5.25" disk the 8" size is 128, 
0081: F633                DiskBuffer:         
0082: F633                	DS	PhysicalSectorSize	
0083: F833                AfterDiskBuffer		EQU	$
0084: F833                                    
0085: F833                		ORG		DiskBuffer		; wind the location counter back
0086: F633                                    
0087: F633                InitializeStream:		; used by the initialization subroutine. Layout:
0088: F633                						;	DB	Port number to be initialized
0089: F633                						;	DB	Number of bytes to be output
0090: F633                						;	DB	xx.xx.xx.xx.xx.xx data to be output
0091: F633                						;	:           
0092: F633                						;	:           
0093: F633                						;	DB	Port numbe of 00H terminator
0094: F633                						;	Console does not need to be initalized. it was done in the PROM
0095: F633                                    
0096: F633     00         		DB	00H			; no setup needed !!CommunicationStatusPort	; intel 8251 ?
0097: F634     06         		DB	06H		; number of bytes
0098: F635     00         		DB	0		; get chip ready by sending data out to it
0099: F636     00         		DB	0              
0100: F637     00         		DB	0              
0101: F638     42         		DB	042H;	; Reset and raise data terminal ready
0102: F639     6E         		DB	06Eh	; 1 stop bit, no parity, 8bits/char baud rate / 16
0103: F63A     25         		DB	025H	;Raise request to send, and enable transmit and receive
0104: F63B                		                  
0105: F63B     DF         		DB	CommunicationBaudMode;	Intel 8253 time
0106: F63C     01         		DB	01H		; number of bytes
0107: F63D     B6         		DB	0B6H	; select counter2, load LS Byte
0108: F63E                		                  
0109: F63E     DE         		DB	CommunicationBaudRate
0110: F63F     02         		DB	02H		; number of bytes
0111: F640     3800       		DW	0038H	; 1200 baud rate
0112: F642                		                  
0113: F642     00         		DB	0		; port number of 0 terminates
0114: F643                		                  
0115: F643                ;  Equates for the sign in message
0116: F643                                    
0117: F643                CR		EQU	0DH		; Carriage Return
0118: F643                LF		EQU	0AH		; Line Feed
0119: F643                                    
0120: F643                SignOnMessage:		; Main sign on message
0121: F643     43502F4D20322E322E 		DB	'CP/M 2.2.'    
0122: F64C                ;		DB	'(2.2.)'      
0123: F64C     4130       		DW	VERSION        
0124: F64E     20         		DB	SPACE          
0125: F64F     3830       		DW	MONTH          
0126: F651     2F         		DB	SLASH			; /    
0127: F652     3532       		DW	DAY            
0128: F654     2F         		DB	SLASH			; /    
0129: F655     3534       		DW	YEAR           
0130: F657     0D0A0A     		DB	CR,LF,LF       
0131: F65A                		                  
0132: F65A     53494D504C452042494F530D0A0A 		DB	'Simple BIOS',CR,LF,LF
0133: F668     4449534B20434F4E46494755524154494F4E203A0D0A0A 		DB	'Disk Configuration :',CR,LF,LF	
0134: F67F                                    
0135: F67F     2020202020413A20302E3335204D4259544520352220464C4F5050590D0A 		DB	'     A: 0.35 MByte 5" Floppy',CR,LF
0136: F69D     2020202020423A20302E3335204D4259544520352220464C4F5050590D0A0A 		DB	'     B: 0.35 MByte 5" Floppy',CR,LF,LF
0137: F6BC     2020202020433A20302E3234204D4259544520382220464C4F5050590D0A 		DB	'     C: 0.24 MByte 8" Floppy',CR,LF
0138: F6DA     2020202020443A20302E3234204D4259544520382220464C4F5050590D0A 		DB	'     D: 0.24 MByte 8" Floppy',CR,LF
0139: F6F8                                    
0140: F6F8                		                  
0141: F6F8     00         		DB	00             
0142: F6F9                		                  
0143: F6F9                	                   
0144: F6F9                ;219--------------------BOOT-----------------------------	
0145: F6F9                	                   
0146: F6F9                	BOOT:		; entered directly from the BIOS JMP vector
0147: F6F9                				; Control transfered by the CP/M bootstrap loader
0148: F6F9                				; initial state will be determined by the PROM
0149: F6F9                				                
0150: F6F9                				; setting up 8251 & 8253 --
0151: F6F9     F3         	DI                 
0152: F6FA                					; on this system the console is already initialized so the
0153: F6FA                					; InitializeStream is not used here
0154: F6FA     2133F6     	LXI		H,InitializeStream		;HL-> Data stream for port initialization (none here)
0155: F6FD                InitializeLoop:     
0156: F6FD     7E         	MOV		A,M					; get port #
0157: F6FE     B7         	ORA		A					; if 00H then done
0158: F6FF     CA13F7     	JZ		InitializeComplete
0159: F702                	                   
0160: F702     320AF7     	STA		InitializePort		; set up OUT instruction
0161: F705     23         	INX		H					; HL -> count # of bytes to output
0162: F706     4E         	MOV		C,M					; get byte count
0163: F707                InitializeNextByte: 
0164: F707     23         	INX		H	            
0165: F708     7E         	MOV		A,M					; get next byte
0166: F709     D3         	DB		OUTopCode			; OUT instruction output to correct port
0167: F70A                InitializePort:     
0168: F70A     00         	DB		0					; set by above code (self modifying code!!!!!)
0169: F70B     0D         	DCR		C					; Count down
0170: F70C     C207F7     	JNZ		InitializeNextByte
0171: F70F     23         	INX		H					; HL-> next port number
0172: F710     C3FDF6     	JMP		InitializeLoop		; go back for more
0173: F713                ;----------- above not needed with the console ------------------------	
0174: F713                                    
0175: F713                InitializeComplete: 
0176: F713     3E01       	MVI		A,01H				; set up for terminal to be console
0177: F715     320300     	STA		IOBYTE				; save in Page 0
0178: F718     2143F6     	LXI		H,SignonMessage
0179: F71B     CD33F8     	CALL	DisplayMessage		; display the signon message
0180: F71E                	                   
0181: F71E     AF         	XRA		A					; Set default disk to A: (0)
0182: F71F     320400     	STA		DefaultDisk   
0183: F722     FB         	EI							; enable the interrupts
0184: F723                	                   
0185: F723     C340F8     	JMP		EnterCPM			; Complete initialization and enter CP/M
0186: F726                								; by going to the Console Command Processor
0187: F726                ;271---------------End of Cold Boot Initialization Code--------------
0188: F726                                    
0189: F726                		ORG AfterDiskBuffer		; reset Location Counter
0190: F833                		                  
0191: F833                		                  
0192: F833                						; HL points at a Zero-Byte terminated string to be output
0193: F833                DisplayMessage:     
0194: F833     7E         	MOV		A,M					; get next message byte
0195: F834     B7         	ORA		A					; terminator (a = 0)?
0196: F835     C8         	RZ							; Yes, thes return to caller
0197: F836                	                   
0198: F836     4F         	MOV		C,A					; prepare for output
0199: F837     E5         	PUSH	HL					; save message pointer
0200: F838     CD86F8     	CALL	CONOUT				; go to main console output routine	*******
0201: F83B     E1         	POP		H             
0202: F83C     23         	INX		H 					; point at next character
0203: F83D     C333F8     	JMP		DisplayMessage		; loop till done
0204: F840                	                   
0205: F840                EnterCPM:           
0206: F840     3EC3       	MVI		A,0C3H				; JMP op code
0207: F842     320000     	STA		0000H				; set up the jump in location 0000H
0208: F845     320500     	STA		0005H				; and at location 0005H
0209: F848                	                   
0210: F848     2103F6     	LXI		H,WarmBootEntry		; get BIOS vector address
0211: F84B     220100     	SHLD	0001H				; put address in location 1
0212: F84E                	                   
0213: F84E     2106E8     	LXI		H,BDOSEntry			; Get BDOS entry point address
0214: F851     220600     	SHLD	0006H				; put address at location 5
0215: F854                	                   
0216: F854     018000     	LXI		B,DefaultDiskBuffer	; set disk I/O address to default
0217: F857     CD65FB     	CALL	SETDMA				; use normal BIOS routine		****************************************************************
0218: F85A                	                   
0219: F85A     FB         	EI                 
0220: F85B     3A0400     	LDA		DefaultDisk		; Transfer current default disk to
0221: F85E     4F         	MOV		C,A				; Console Command Processor
0222: F85F     C300E0     	JMP		CCPEntry		; transfer to CCP
0223: F862                		                  
0224: F862                		                  
0225: F862                		                  
0226: F862                ;IOBYTE	EQU		0003H		;I/O redirection byte
0227: F862                                    
0228: F862                ;333--------------------CONST----------------------------
0229: F862                	; Entered directly from BIOS JMP vector, returns Register A
0230: F862                	; 00H -> No data   
0231: F862                	; 0FFH -> there is data
0232: F862                CONST:              
0233: F862     CD6AF8     	CALL	GetConsoleStatus	; return A= zero or not zero
0234: F865     B7         	ORA		A             
0235: F866     C8         	RZ							; if 0 no returning data
0236: F867     3EFF       	MVI		A,0FFH				; else indicate there is data
0237: F869     C9         	RET                
0238: F86A                	                   
0239: F86A                GetConsoleStatus:   
0240: F86A     3A0300     	LDA		IOBYTE		; Get IO redirection byte
0241: F86D     CDDCF8     	CALL	SelectRoutine	; these routines return to the caller of GetConsoleStatus
0242: F870     F6F8       	DW		TTYInStatus				; 00  <- IOBYTE bits 1,0
0243: F872     FCF8       	DW		TerminalInStatus		; 01
0244: F874     02F9       	DW		CommunicationInStatus	; 10
0245: F876     08F9       	DW		DummyInStatus			; 11
0246: F878                	                   
0247: F878                CONIN:              
0248: F878                	; Get console Input character entered directly from the BIOS jmp Vector
0249: F878                	; return the character from the console in the A register.
0250: F878                	; most significant bit will be 0. except when "reader" (communication)
0251: F878                	; port has input , all 8 bits are reurned
0252: F878                	;                  
0253: F878                	; normally this follows a call to CONST ( a blocking call) to indicates a char is ready.
0254: F878     3A0300     	LDA		IOBYTE				; get i/o redirection byte
0255: F87B     CDDCF8     	CALL 	SelectRoutine
0256: F87E                			; Vectors to device routines
0257: F87E     20F9       	DW		TTYInput			; 00 <- IOBYTE bits 1,0
0258: F880     26F9       	DW		TerminalInput		; 01
0259: F882     2FF9       	DW		CommunicationInput	; 10
0260: F884     35F9       	DW		DummyInput			; 11
0261: F886                	                   
0262: F886                CONOUT:             
0263: F886                	; Console output, entered directly from BIOS JMP Vector. it outputs the 
0264: F886                	; character in the C register to the appropriate device according to
0265: F886                	; bits 1,0 of IOBYTE
0266: F886     3A0300     	LDA		IOBYTE				; get i/o redirection byte
0267: F889     CDDCF8     	CALL 	SelectRoutine
0268: F88C                			; Vectors to device routines
0269: F88C     38F9       	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0270: F88E     3EF9       	DW		TerminalOutput		; 01
0271: F890     44F9       	DW		CommunicationOutput	; 10
0272: F892     4AF9       	DW		DummyOutput			; 11
0273: F894                	                   
0274: F894                LISTST:             
0275: F894                	; List Device (output) status entered directly from the BIOS JMP Vector
0276: F894                	; returns in A the list device status that indicates if the device will
0277: F894                	; accept another character the IOBYTE's bits 7,6 determin the physical device
0278: F894                	; A = 00H (zero flag set): cannot accpet data
0279: F894                	; A = 0FFH ( zero flag cleared): can accept data
0280: F894     CD9CF8     	CALL	GetListStatus	; return  A = 0 or non-zero	
0281: F897     B7         	ORA		A				; set flags
0282: F898     C8         	RZ						; exit if not ready
0283: F899     3EFF       	MVI		a,0FFH			; else set retuen value for ok
0284: F89B     C9         	RET	               
0285: F89C                	; exit             
0286: F89C                GetListStatus:      
0287: F89C     3A0300     	LDA		IOBYTE        
0288: F89F     07         	RLC						; move bits 7,6
0289: F8A0     07         	RLC						; to 1,0  
0290: F8A1     CDDCF8     	CALL	SelectRoutine 
0291: F8A4     0BF9       	DW		TTYOutStatus			; 00 <- IOBYTE bits 1,0
0292: F8A6     11F9       	DW		TerminalOutStatus		; 01
0293: F8A8     17F9       	DW		CommunicationOutStatus	; 10
0294: F8AA     1DF9       	DW		DummyOutStatus			; 11
0295: F8AC                	                   
0296: F8AC                LIST:					; List output
0297: F8AC                						; entered directly from the BIOS JMP Vector
0298: F8AC                						; outputs the data in Register C
0299: F8AC     3A0300     	LDA		IOBYTE        
0300: F8AF     07         	RLC						; move bits 7,6
0301: F8B0     07         	RLC						; to 1,0  
0302: F8B1     CDDCF8     	CALL	SelectRoutine 
0303: F8B4     38F9       	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0304: F8B6     3EF9       	DW		TerminalOutput		; 01
0305: F8B8     44F9       	DW		CommunicationOutput	; 10
0306: F8BA     4AF9       	DW		DummyOutput			; 11
0307: F8BC                	                   
0308: F8BC                PUNCH:					; Punch output
0309: F8BC                						; entered directly from the BIOS JMP Vector
0310: F8BC                						; outputs the data in Register C
0311: F8BC     3A0300     	LDA		IOBYTE        
0312: F8BF     07         	RLC						; move bits 5,4
0313: F8C0     07         	RLC                
0314: F8C1     07         	RLC						; to 1,0  
0315: F8C2     CDDCF8     	CALL	SelectRoutine 
0316: F8C5     38F9       	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0317: F8C7     4AF9       	DW		DummyOutput			; 01
0318: F8C9     44F9       	DW		CommunicationOutput	; 10
0319: F8CB     3EF9       	DW		TerminalOutput		; 11
0320: F8CD                	                   
0321: F8CD                READER:					; Reader Input
0322: F8CD                						; entered directly from the BIOS JMP Vector
0323: F8CD                						; inputs data into the A register
0324: F8CD     3A0300     	LDA		IOBYTE        
0325: F8D0     07         	RLC						; move bits 3,2  to 1,0
0326: F8D1     CDDCF8     	CALL	SelectRoutine 
0327: F8D4     38F9       	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0328: F8D6     4AF9       	DW		DummyOutput			; 01
0329: F8D8     44F9       	DW		CommunicationOutput	; 10
0330: F8DA     3EF9       	DW		TerminalOutput		; 11
0331: F8DC                	                   
0332: F8DC                SelectRoutine:	     
0333: F8DC                		; SelectRoutine. When called, the calling code has a vector table immediately following it.
0334: F8DC                		; it is used to get the correct physical routine determined by the IOBYTE bits for the
0335: F8DC                		; logical device. (00,01,10,11). 
0336: F8DC                		; It will transfer control to a specified address following its calling address
0337: F8DC                		; according to the values in bits 1, 0 in A.		
0338: F8DC                                    
0339: F8DC     07         	RLC				; Shift select values into bits 2,1 in order to do word arithmetic
0340: F8DD                SelectRoutine21:	; entry point if bits already in 2,1
0341: F8DD     E606       	ANI		06H		; isolate bits 2 and 1
0342: F8DF     E3         	XTHL			; HL-> first word of address after CALL instruction
0343: F8E0     5F         	MOV		E,A		; Add on selection value to address table base
0344: F8E1     1600       	MVI		D,00H         
0345: F8E3     19         	DAD		D		; HL-> now has the selected routine
0346: F8E4     7E         	MOV		A,M		; LS Byte
0347: F8E5     23         	INX		H		; HL-> MS byte
0348: F8E6     66         	MOV		H,M		; MS byte
0349: F8E7     6F         	MOV		L,A		; HL->routine
0350: F8E8     E3         	XTHL			; top of stack -> routine
0351: F8E9     C9         	RET				; transfer control to the selected routine
0352: F8EA                                    
0353: F8EA                	                   
0354: F8EA                ;------------------------- Input/Output Equates---------------------------------------
0355: F8EA                                    
0356: F8EA                TTYStatusPort				EQU	0EDH
0357: F8EA                TTYDataPort					EQU	0ECH
0358: F8EA                TTYOutputReady				EQU	01H		; Status Mask
0359: F8EA                TTYInputReady				EQU	02H		; Status Mask
0360: F8EA                                    
0361: F8EA                TerminalStatusPort			EQU	02H
0362: F8EA                TerminalDataPort			EQU	01H
0363: F8EA                TerminalOutputReady			EQU	80H		; Status Mask - ready for output
0364: F8EA                TerminalInputReady			EQU	07FH	; Status Mask - bytes yet to have been read
0365: F8EA                                    
0366: F8EA                CommunicationStatusPort		EQU	0EDH
0367: F8EA                CommunicationDataPort		EQU	0ECH
0368: F8EA                CommunicationOutputReady	EQU	01H		; Status Mask
0369: F8EA                CommunicationInputReady		EQU	02H		; Status Mask
0370: F8EA                                    
0371: F8EA                CommunicationBaudMode		EQU	0DFH
0372: F8EA                CommunicationBaudRate		EQU	0DEH
0373: F8EA                                    
0374: F8EA                TTYTable:           
0375: F8EA     ED         		DB		TTYStatusPort 
0376: F8EB     EC         		DB		TTYDataPort   
0377: F8EC     01         		DB		TTYOutputReady
0378: F8ED     02         		DB		TTYInputReady 
0379: F8EE                TerminalTable:      
0380: F8EE     02         		DB		TerminalStatusPort
0381: F8EF     01         		DB		TerminalDataPort
0382: F8F0     80         		DB		TerminalOutputReady
0383: F8F1     7F         		DB		TerminalInputReady
0384: F8F2                CommunicationTable: 
0385: F8F2     ED         		DB		CommunicationStatusPort
0386: F8F3     EC         		DB		CommunicationDataPort
0387: F8F4     01         		DB		CommunicationOutputReady
0388: F8F5     02         		DB		CommunicationInputReady
0389: F8F6                ;------------------------- Input/Output Equates---------------------------------------
0390: F8F6                                    
0391: F8F6                                    
0392: F8F6                ;590----------------------routines called by SelectRoutine----------------------------
0393: F8F6                TTYInStatus:        
0394: F8F6     21EAF8     		LXI		H,TTYTable				;HL-> control table
0395: F8F9     C34BF9     		JMP		InputStatus				; use of JMP, InputStatus will execute thr RETurn
0396: F8FC                TerminalInStatus:   
0397: F8FC     21EEF8     		LXI		H,TerminalTable			;HL-> control table
0398: F8FF     C34BF9     		JMP		InputStatus				; use of JMP, InputStatus will execute thr RETurn
0399: F902                CommunicationInStatus:
0400: F902     21F2F8     		LXI		H,CommunicationTable	;HL-> control table
0401: F905     C34BF9     		JMP		InputStatus				; use of JMP, InputStatus will execute thr RETurn
0402: F908                DummyInStatus:      
0403: F908     3EFF       		MVI		A,0FFH					; Dummy always indicates data ready
0404: F90A     C9         		RET               
0405: F90B                		                  
0406: F90B                TTYOutStatus:       
0407: F90B     21EAF8     		LXI		H,TTYTable				;HL-> control table
0408: F90E     C356F9     		JMP		OutputStatus			; use of JMP, OutputStatus will execute thr RETurn
0409: F911                TerminalOutStatus:  
0410: F911     21EEF8     		LXI		H,TerminalTable			;HL-> control table
0411: F914     C356F9     		JMP		OutputStatus			; use of JMP, OutputStatus will execute thr RETurn
0412: F917                CommunicationOutStatus:
0413: F917     21F2F8     		LXI		H,CommunicationTable	;HL-> control table
0414: F91A     C356F9     		JMP		OutputStatus			; use of JMP, OutputStatus will execute thr RETurn
0415: F91D                DummyOutStatus:     
0416: F91D     3EFF       		MVI		A,0FFH					; Dummy always indicates ready to output data
0417: F91F     C9         		RET               
0418: F920                                    
0419: F920                TTYInput:           
0420: F920     21EAF8     		LXI		H,TTYTable				;HL-> control table
0421: F923     C360F9     		JMP		InputData				; use of JMP, InputStatus will execute thr RETurn
0422: F926                TerminalInput:      
0423: F926     21EEF8     		LXI		H,TerminalTable			;HL-> control table
0424: F929     CD60F9     		CALL	InputData				;** special **
0425: F92C     E67F       		ANI		07FH					; Strip off high order bit
0426: F92E     C9         		RET	              
0427: F92F                CommunicationInput: 
0428: F92F     21F2F8     		LXI		H,CommunicationTable	;HL-> control table
0429: F932     C360F9     		JMP		InputData				; use of JMP, InputStatus will execute thr RETurn
0430: F935                DummyInput:         
0431: F935     3E1A       		MVI		A,01AH					; Dummy always returns EOF
0432: F937     C9         		RET               
0433: F938                		                  
0434: F938                TTYOutput:          
0435: F938     21EAF8     		LXI		H,TTYTable				;HL-> control table
0436: F93B     C370F9     		JMP		OutputData				; use of JMP, InputStatus will execute thr RETurn
0437: F93E                TerminalOutput:     
0438: F93E     21EEF8     		LXI		H,TerminalTable			;HL-> control table
0439: F941     C370F9     		JMP		OutputData				; use of JMP, InputStatus will execute thr RETurn
0440: F944                CommunicationOutput:
0441: F944     21F2F8     		LXI		H,CommunicationTable	;HL-> control table
0442: F947     C370F9     		JMP		OutputData				; use of JMP, InputStatus will execute thr RETurn
0443: F94A                DummyOutput:        
0444: F94A     C9         		RET						; Dummy always discards the data
0445: F94B                                    
0446: F94B                ;680---------------------General purpose low-level drivers-------------------
0447: F94B                                    
0448: F94B                ; On entry, HL points to appropriate control table, for output Register C contains the data to output
0449: F94B                                    
0450: F94B                InputStatus:					; return- A = 00H no incoming data
0451: F94B     7E         		MOV		A,M				; get status port
0452: F94C     3250F9     		STA		InputStatusPort	;** self modifying code
0453: F94F     DB         		DB		INopCode		; IN opcode
0454: F950                InputStatusPort:    
0455: F950     00         		DB		00H				; <- set from above
0456: F951     23         		INX		H				; move HL to point to input data mask
0457: F952     23         		INX		H            
0458: F953     23         		INX		H            
0459: F954     A6         		ANA		M				; mask with input status
0460: F955     C9         		RET						; return with status (00 nothing, FF - data available)
0461: F956                		                  
0462: F956                OutputStatus:						; return - A = 00H not ready
0463: F956     7E         		MOV		A,M          
0464: F957     325BF9     		STA		OutputStatusPort
0465: F95A     DB         		DB		INopCode			; IN opcode
0466: F95B                OutputStatusPort:   
0467: F95B     00         		DB		00H					; <- set from above
0468: F95C     23         		INX		H					;HL , Output status mask
0469: F95D     23         		INX		H            
0470: F95E     A6         		ANA		M					; mask with output status, 00 = Not ready
0471: F95F     C9         		RET               
0472: F960                		                  
0473: F960                InputData:							; return with next character
0474: F960     E5         		PUSH	H					; save control table pointer
0475: F961     CD4BF9     		CALL	InputStatus  
0476: F964     E1         		POP		H					; restore the control table
0477: F965     CA60F9     		JZ		InputData			; wait until incoming data
0478: F968     23         		INX		H					; HL <- data port
0479: F969     7E         		MOV		A,M					; get data port
0480: F96A     326EF9     		STA		InputDataPort		; modify code here
0481: F96D     DB         		DB		INopCode			; do the actual I/O
0482: F96E                InputDataPort:      
0483: F96E     00         		DB		00H					; <- set from above
0484: F96F     C9         		RET							; return with data in A
0485: F970                		                  
0486: F970                OutputData:							; data in Register C is output
0487: F970     E5         		PUSH	H					; save control table pointer
0488: F971     CD56F9     		CALL	OutputStatus 
0489: F974     E1         		POP		H					; restore table pointer
0490: F975     CA70F9     		JZ		OutputData			; wait until incoming data
0491: F978     23         		INX		H					; HL <- data port
0492: F979     7E         		MOV		A,M					; get data port
0493: F97A     327FF9     		STA		OutputDataPort		; store it here Modify the code
0494: F97D     79         		MOV		A,C					; get the data to output
0495: F97E     D3         		DB		OUTopCode			; Do the I/O here !!
0496: F97F                OutputDataPort:     
0497: F97F     00         		DB		00H					; <- set from above
0498: F980     C9         		RET               
0499: F981                		                  
0500: F981                ;746,795            
0501: F981                ;  page 175 -----------------High Level Diskette drivers--------------------	
0502: F981                                    
0503: F981                                    
0504: F981                                    
0505: F981                					; listing starts on page 175/493 FIgure 6-4
0506: F981                					; in Programmers CPM Handbook by
0507: F981                					; Andy Johnston-Laird
0508: F981                                    
0509: F981                ;	ORG	0F981H	; Continue from bios.asm
0510: F981                ; PhysicalSectorSize	EQU	512			; for the 5.25" disk the 8" size is 128,
0511: F981                	                   
0512: F981                ; 					High level diskette drivers
0513: F981                ;                   
0514: F981                ;                   
0515: F981                ; These drivers perform the following functions:
0516: F981                ;                   
0517: F981                ; SELDSK		Select a specific disk and return the address of
0518: F981                ;				the appropriate disk parameter header
0519: F981                ; SETTRK		Set the track number for the next read or write
0520: F981                ; SETSEC		Set the sector number for the next read or write
0521: F981                ; SETDMA		Set the DMA (read/write) address for the next read or write
0522: F981                ; SECTRAN	Translate a logical sector number into a physical
0523: F981                ; HOME		Set the track to 0 so that the next read or write will
0524: F981                ;				be on Track 0  
0525: F981                ;                   
0526: F981                ; In addition, the high-level drivers are responsible for making
0527: F981                ; the 5 1/4"" floppy diskettes that use a 512-byte sector appear
0528: F981                ; to CP/M as though they use a 128-byte sector. They do this
0529: F981                ; by using what is called blocking/de-blocking code,
0530: F981                ; described in more detail later in this listing.
0531: F981                ;                   
0532: F981                ;                   
0533: F981                ; 					Disk Parameter Tables
0534: F981                ;                   
0535: F981                ; As discussed in Chapter 3, these describe the physical
0536: F981                ; characteristics of the disk drives. In this example BIOS,
0537: F981                ; there are two types of disk drives: standard single-sided,
0538: F981                ; single-density 8", and double-sided, double-density 5 1/4"
0539: F981                ; diskettes.        
0540: F981                ;                   
0541: F981                ; The standard 8" diskettes do not need the blocking/de-blocking
0542: F981                ; code, but the 5 1/4" drives do. Therefore an additional
0543: F981                ; byte has been prefixed to the disk parameter block to
0544: F981                ; tell the disk drivers each logical disk's physical
0545: F981                ; diskette type, and whether or not it needs de-blocking.
0546: F981                ;                   
0547: F981                ;                   
0548: F981                ; 					Disk Definition Tables
0549: F981                ;                   
0550: F981                ; These consists of disk parameter headers, with one entry
0551: F981                ; per logical disk driver, and disk parameter blocks, with
0552: F981                ; either one parameter block per logical disk or the same
0553: F981                ; parameter block for several logical disks.
0554: F981                ;                   
0555: F981                DiskParameterHeaders:		; described in chapter 3
0556: F981                                    
0557: F981                		; Logical Disk A: (5 1/4" Diskette)
0558: F981     6BFB       	DW	Floppy5SkewTable				; 5 1/4" skew table
0559: F983     0000       	DW	0								; Rel pos for file (0-3)
0560: F985     0000       	DW	0								; Last Selected Track #
0561: F987     0000       	DW	0								; Last Selected Sector #
0562: F989     C1F9       	DW	DirectoryBuffer 
0563: F98B     42FA       	DW	Floppy5ParameterBlock
0564: F98D     61FA       	DW	DiskAWorkArea   
0565: F98F     C1FA       	DW	DiskAAllocationVector
0566: F991                	                   
0567: F991                		; Logical Disk B: (5 1/4" Diskette)
0568: F991     6BFB       	DW	Floppy5SkewTable	; shares the same skew table as A:
0569: F993     0000       	DW	0								; Rel pos for file (0-3)
0570: F995     0000       	DW	0								; Last Selected Track #
0571: F997     0000       	DW	0								; Last Selected Sector #
0572: F999     C1F9       	DW	DirectoryBuffer		; all disks use this buffer
0573: F99B     42FA       	DW	Floppy5ParameterBlock
0574: F99D     81FA       	DW	DiskBWorkArea   
0575: F99F     D7FA       	DW	DiskBAllocationVector
0576: F9A1                	                   
0577: F9A1                		; Logical Disk C: (8" Floppy)
0578: F9A1     B3FB       	DW	Floppy8SkewTable	; 8" skew table
0579: F9A3     0000       	DW	0								; Rel pos for file (0-3)
0580: F9A5     0000       	DW	0								; Last Selected Track #
0581: F9A7     0000       	DW	0								; Last Selected Sector #
0582: F9A9     C1F9       	DW	DirectoryBuffer		; all disks use this buffer
0583: F9AB     52FA       	DW	Floppy8ParameterBlock
0584: F9AD     A1FA       	DW	DiskCWorkArea   
0585: F9AF     EDFA       	DW	DiskCAllocationVector
0586: F9B1                	                   
0587: F9B1                		; Logical Disk D: (8" Floppy)
0588: F9B1     6BFB       	DW	Floppy5SkewTable	; shares the same skew table as A:
0589: F9B3     0000       	DW	0								; Rel pos for file (0-3)
0590: F9B5     0000       	DW	0								; Last Selected Track #
0591: F9B7     0000       	DW	0								; Last Selected Sector #
0592: F9B9     C1F9       	DW	DirectoryBuffer		; all disks use this buffer
0593: F9BB     52FA       	DW	Floppy8ParameterBlock
0594: F9BD     B1FA       	DW	DiskDWorkArea   
0595: F9BF     0CFB       	DW	DiskDAllocationVector
0596: F9C1                	                   
0597: F9C1                DirectoryBuffer:	DS	128
0598: FA41                                    
0599: FA41                	; Disk Types       
0600: FA41                Floppy5		EQU		1 		; 5 1/4" mini floppy
0601: FA41                Floppy8		EQU		2 		; 8"  floppy (SS SD)
0602: FA41                                    
0603: FA41                	; blocking/de-blocking indicator
0604: FA41                NeedDeblocking	EQU 	080H	; Sector size > 128 bytes
0605: FA41                                    
0606: FA41                                    
0607: FA41                	; Disk Parameter Blocks
0608: FA41                	                   
0609: FA41                	; 5 1/4" mini floppy
0610: FA41                							; extra byte prefixed to indicate 
0611: FA41                							; disk type and blocking required
0612: FA41     81         	DB	Floppy5 + NeedDeblocking
0613: FA42                	                   
0614: FA42                Floppy5ParameterBlock:
0615: FA42     4800       	DW	048H				; 128-byte sectors per track- (72)
0616: FA44     04         	DB	04H					; Block shift ( 4=> 2K)
0617: FA45     0F         	DB	0FH					; Block mask
0618: FA46     01         	DB	01 					; Extent mask
0619: FA47     AE00       	DW	0AEH 				; Maximum allocation block number (174)
0620: FA49     7F00       	DW	07FH 				; Number of directory entries - 1 (127)
0621: FA4B     C0         	DB	0C0H				; Bit map for reserving 1 alloc. block
0622: FA4C     00         	DB	00					;  for file directory
0623: FA4D     2000       	DW	020H				;Disk change work area size (32)
0624: FA4F     0100       	DW	01					; Number of tracks before directory
0625: FA51                	                   
0626: FA51                	; Standard 8" floppy
0627: FA51                							; extra byte prefixed to DPB for 
0628: FA51                							;  this version of the BIOS
0629: FA51     02         	DB	Floppy8				; Indicates disk type and the fact
0630: FA52                							;   that no de-blocking is required
0631: FA52                	                   
0632: FA52                Floppy8ParameterBlock:
0633: FA52     1A00       	DW	01AH				; sectors per track (26)
0634: FA54     03         	DB	03					; Block shift (3=>1K)
0635: FA55     07         	DB	07					; Block mask
0636: FA56     00         	DB	00 					; Extent mask
0637: FA57     F200       	DW	0F2H 				; Maximum allocation block number (242)
0638: FA59     3F00       	DW	03FH 				; Number of directory entries - 1 (63)
0639: FA5B     C0         	DB	0C0H				; Bit map for reserving 2 alloc. block
0640: FA5C     00         	DB	00					;  for file directory
0641: FA5D     1000       	DW	010H				;Disk change work area size (16)
0642: FA5F     0200       	DW	02					; Number of tracks before directory
0643: FA61                	                   
0644: FA61                			; Disk work area 
0645: FA61                	                   
0646: FA61                	; These are used by the BDOS to detect any unexpected
0647: FA61                	; change of diskette. The BDOS will automatically set
0648: FA61                	; such a changed diskette to read-only status.
0649: FA61                	                   
0650: FA61                DiskAWorkArea:	DS	020H		; A:
0651: FA81                DiskBWorkArea:	DS	020H		; B:
0652: FAA1                DiskCWorkArea:	DS	010H		; C:
0653: FAB1                DiskDWorkArea:	DS	010H		; D:
0654: FAC1                                    
0655: FAC1                	                   
0656: FAC1                			; Disk allocation vectors
0657: FAC1                			                 
0658: FAC1                		; These are used by the BDOS to maintain a bit map of
0659: FAC1                		; which allocation blocks are used and which are free.
0660: FAC1                		; One byte is used for eight allocation blocks, hence the
0661: FAC1                		; expression of the form (allocation blocks/8)+1
0662: FAC1                                    
0663: FAC1                DiskAAllocationVector:	DS		(174/8)+1 	; A:
0664: FAD7                DiskBAllocationVector:	DS		(174/8)+1 	; B:
0665: FAED                	                   
0666: FAED                DiskCAllocationVector:	DS		(242/8)+1 	; C:
0667: FB0C                DiskDAllocationVector:	DS		(242/8)+1 	; A:
0668: FB2B                	                   
0669: FB2B                NumberOfLogicalDisks	EQU 4
0670: FB2B                                    
0671: FB2B                                    
0672: FB2B                		;  Disk routines  
0673: FB2B                		                  
0674: FB2B                ;**********************
0675: FB2B                ;SELDSK - Select disk in C. C=0 for A: 1 for B: etc.
0676: FB2B                ;  Return the address of the appropriate disk parameter header
0677: FB2B                ;  in HL, or 0000H if selected disk does not exist		
0678: FB2B                ;**********************	
0679: FB2B                SELDSK:             
0680: FB2B     210000     	LXI		H,00H				; Assume an error
0681: FB2E     79         	MOV		A,C 				; Check if  requested disk is valid
0682: FB2F     FE04       	CPI		NumberOfLogicalDisks
0683: FB31     D0         	RNC							; return if > max number of Disks
0684: FB32                	                   
0685: FB32     32EAFB     	STA		SelectedDisk		; save disk number
0686: FB35     6F         	MOV		L,A					; make disk into word number
0687: FB36     2600       	MVI		H,0           
0688: FB38                		; Compute offset down disk parameter table by multiplying by parameter
0689: FB38                		; header length (16 bytes)
0690: FB38     29         	DAD		H             
0691: FB39     29         	DAD		H             
0692: FB3A     29         	DAD		H             
0693: FB3B     29         	DAD		H					; pointing at right one
0694: FB3C     1181F9     	LXI		D,DiskParameterHeaders		; get base address
0695: FB3F     19         	DAD		D					; DE -> appropriate DPH
0696: FB40     E5         	PUSH	H					; Save DPH address access disk parameter block to extract special
0697: FB41                								;    prefix byte that identifies disk type and whether de-blocking
0698: FB41                								;    is required
0699: FB41     110A00     	LXI		D,10				; Get DPB pointer offset in DPH
0700: FB44     19         	DAD		D					; DE -> DPB address
0701: FB45     5E         	MOV		E,M					; Get DPB address in DE
0702: FB46     23         	INX		H             
0703: FB47     56         	MOV		D,M	          
0704: FB48     EB         	XCHG						; DE ->DPB
0705: FB49     2B         	DCX		H					; DE -> prefix byte
0706: FB4A     7E         	MOV		A,M					; get Disk Type/Blocking byte
0707: FB4B                								; Disk Type bottom nibble - Blocking MSB (bit 7)
0708: FB4B     E60F       	ANI		0FH					; isolate disk type
0709: FB4D     32FAFB     	STA		DiskType			; save for use in low level driver
0710: FB50     7E         	MOV		A,M					; get another copy
0711: FB51     E680       	ANI		NeedDeblocking		; determin if deblocking is required and
0712: FB53     32F9FB     	STA		DeblockingRequired	; save for low level driver
0713: FB56     E1         	POP		H					; recover DPH pointer
0714: FB57     C9         	RET                
0715: FB58                                    
0716: FB58                ;**********************	
0717: FB58                ;SETTRK - Set logical track for next read or write
0718: FB58                ;		Track is in BC   
0719: FB58                ;**********************	
0720: FB58                SETTRK:             
0721: FB58     60         	MOV		H,B					; select track in BC on entry
0722: FB59     69         	MOV		L,C           
0723: FB5A     22EBFB     	SHLD	SelectedTrack		; save for low level driver	
0724: FB5D     C9         	RET                
0725: FB5E                	                   
0726: FB5E                ;**********************	
0727: FB5E                ;SETSEC - Set logical sector for next read or write
0728: FB5E                ;		Sector is in C   
0729: FB5E                ;**********************
0730: FB5E                SETSEC:             
0731: FB5E     79         	MOV		A,C           
0732: FB5F     32EDFB     	STA		SelectedSector		; save for low level driver	
0733: FB62     C9         	RET                
0734: FB63                	                   
0735: FB63                ;**********************
0736: FB63                ;SetDMA - Set DMA (input/output) address for next read or write
0737: FB63                ;       Address in BC
0738: FB63                ;**********************
0739: FB63     0000       DMAAddress:	DW	0				; DMA address
0740: FB65                SETDMA:             
0741: FB65     69         	MOV		L,C					; select address in BC on entry
0742: FB66     60         	MOV		H,B           
0743: FB67     2263FB     	SHLD	DMAAddress			; save for low level driver	
0744: FB6A     C9         	RET                
0745: FB6B                	                   
0746: FB6B                			; Translate logical sector number to physical
0747: FB6B                			                 
0748: FB6B                			; Sector translation tables
0749: FB6B                			; These tables are indexed using the logical sector number
0750: FB6B                			; and contain the corresponding physical sector number
0751: FB6B                                    
0752: FB6B                                    
0753: FB6B                ;**********************
0754: FB6B                ;	Skew tables       
0755: FB6B                ;**********************
0756: FB6B                                    
0757: FB6B                Floppy5SkewTable:			; each physical sector contains four
0758: FB6B                							;  128-byte sectors
0759: FB6B                							             
0760: FB6B                ;	,		Physical 128b 	Logical 128b	Physical 512-byte
0761: FB6B     00010203   	DB		00,01,02,03		;00,01,02,03				0	)
0762: FB6F     10111213   	DB		16,17,18,19		;04,05,06,07				4	)
0763: FB73     20212223   	DB		32,33,34,35		;08,09,10,11				8	)
0764: FB77     0C0D0E0F   	DB		12,13,14,15		;12,13,14,15				3	)Head
0765: FB7B     1C1D1E1F   	DB		28,29,30,31		;16,17,18,19				7	) 0
0766: FB7F     08090A0B   	DB		08,09,10,11		;20,21,22,23				2	)
0767: FB83     18191A1B   	DB		24,25,26,27		;24,25,26,27				6	)
0768: FB87     04050607   	DB		04,05,06,07		;28,29,30,31				1	)
0769: FB8B     14151617   	DB		20,21,22,23		;32,33,34,35				5	)
0770: FB8F                	                   
0771: FB8F     24252627   	DB		36,37,38,39		;36,37,38,39				0	]
0772: FB93     34353637   	DB		52,53,54,55		;40,41,42,43				4	]
0773: FB97     44454647   	DB		68,69,70,71		;44,45,46,47				8	]
0774: FB9B     30313233   	DB		48,49,50,51		;48,49,50,51				3	]Head
0775: FB9F     40414243   	DB		64,65,66,67		;52,53,54,55				7	] 0
0776: FBA3     2C2D2E2F   	DB		44,45,46,47		;56,57,58,59				2	]
0777: FBA7     3C3D3E3F   	DB		60,61,62,63		;60,61,62,63				6	]
0778: FBAB     28292A2B   	DB		40,41,42,43		;63,65,66,67				1	]
0779: FBAF     38393A3B   	DB		56,57,58,59		;68,69,70,71				5	]
0780: FBB3                	                   
0781: FBB3                Floppy8SkewTable:			; Standard 8" Driver
0782: FBB3                	;		01,02,03,04,05,06,07,08,09,10		; Logical Sectors
0783: FBB3     01070D1319050B111703 	DB		01,07,13,19,25,05,11,17,23,03		; Physical Sectors
0784: FBBD                	                   
0785: FBBD                	;		11,12,13,14,15,16,17,18,19,20		; Logical Sectors	
0786: FBBD     090F1502080E141A060C 	DB		09,15,21,02,08,14,20,26,06,12		; Physical Sectors
0787: FBC7                	                   
0788: FBC7                	;		21,22,23,24,25,26					; Logical Sectors	
0789: FBC7     1218040A1016 	DB		18,24,04,10,16,22					; Physical Sectors
0790: FBCD                	                   
0791: FBCD                ;**********************
0792: FBCD                ;SECTRAN - Translate logical sector to physical
0793: FBCD                ;	on Entry:	BC= logical sector number
0794: FBCD                ;				DE-> appropriate skew table
0795: FBCD                ;	on Exit:	HL = physical sector number
0796: FBCD                ;**********************
0797: FBCD                SECTRAN:            
0798: FBCD     EB         	XCHG			;HL -> skew table base
0799: FBCE     09         	DAD		B		; Add on logical sector number
0800: FBCF     6E         	MOV		L,M		; Get physical sector number
0801: FBD0     2600       	MVI		H,00H	; make into a word
0802: FBD2     C9         	RET                
0803: FBD3                	                   
0804: FBD3                ;**********************
0805: FBD3                ;HOME - Home the selected logical disk to track 0.
0806: FBD3                ;	Before doing this, a check must be made to see if the
0807: FBD3                ;	physical disk buffer has information that must be
0808: FBD3                ;	written out. This is indicated by a flag, MustWriteBuffer,
0809: FBD3                ;	set in the de-blocking code
0810: FBD3                ;**********************	
0811: FBD3                HOME:               
0812: FBD3     3AE9FB     	LDA		MustWriteBuffer		; check flag
0813: FBD6     B7         	ORA		A             
0814: FBD7     C2DDFB     	JNZ		HomeNoWrite   
0815: FBDA     32E8FB     	STA		DataInDiskBuffer	; no, so indicate empty buffer
0816: FBDD                HomeNoWrite:        
0817: FBDD     0E00       	MVI		C,00H				; Set to track 0
0818: FBDF     CD58FB     	CALL	SETTRK				; no, physical, only logical
0819: FBE2     C9         	RET                
0820: FBE3                                    
0821: FBE3                ;*******************************************************************************
0822: FBE3                ;					 More tables  
0823: FBE3                ; Data written to or read from the mini-floppy drive is transferred via a
0824: FBE3                ; physical buffer that is actually 512 bytes long (it was declared at the front
0825: FBE3                ; of the BIOS and holds the "one-time" initialization code used for the
0826: FBE3                ; cold boot procedure.)
0827: FBE3                ;                   
0828: FBE3                ; The blocking/de-blocking code attempts to minimize the amount of actual
0829: FBE3                ; disk I/O by storing the disk,track, and physical sector currently residing
0830: FBE3                ; in the Physical Buffer. If a read request is for a 128 byte CP/M "sector"
0831: FBE3                ; that is already in the physical buffer, then no disk access occurs
0832: FBE3                ;*******************************************************************************
0833: FBE3                AllocationBlockSize		EQU		0800H		; 2048
0834: FBE3                PhysicalSecPerTrack		EQU		012H		; 18
0835: FBE3                CPMSecPerPhysical		EQU		PhysicalSectorSize/128
0836: FBE3                CPMSecPerTrack			EQU		CPMSecPerPhysical * PhysicalSecPerTrack
0837: FBE3                SectorMask				EQU		CPMSecPerPhysical - 1
0838: FBE3                SectorBitShift			EQU		02H			; LOG2(CPMSecPerPhysical)
0839: FBE3                                    
0840: FBE3                ;*******************************************************************************
0841: FBE3                ; These are the values handed over by the BDOS when it calls the Writer operation
0842: FBE3                ; The allocated.unallocated indicates whether the BDOS is set to write to an
0843: FBE3                ; unallocated allocation block (it only indicates this for the first 128 byte
0844: FBE3                ; sector write) or to an allocation block that has already been allocated to a
0845: FBE3                ; file. The BDOS also indicates if it is set to write to the file directory
0846: FBE3                ;*******************************************************************************
0847: FBE3                WriteAllocated			EQU		00H
0848: FBE3                WriteDirectory			EQU		01H
0849: FBE3                WriteUnallocated		EQU		02H
0850: FBE3                                    
0851: FBE3     00         WriteType:				DB		00H		; The type of write indicated by BDOS
0852: FBE4                                    
0853: FBE4                	;       variables for physical sector
0854: FBE4                	; These are moved and compared as a group, DO NOT ALTER
0855: FBE4                InBufferDkTrkSec:   
0856: FBE4     00         InBufferDisk:			DB		00H
0857: FBE5     0000       InBufferTrack:			DW		00H
0858: FBE7     00         InBufferSector:			DB		00H
0859: FBE8                                    
0860: FBE8     00         DataInDiskBuffer:		DB		00H		; when non-zero, the disk buffer has data from disk
0861: FBE9                                    
0862: FBE9     00         MustWriteBuffer:		DB		00H		; Non-zero when data has been written into DiskBuffer,
0863: FBEA                										;	but not yet written out to the disk
0864: FBEA                										          
0865: FBEA                	;     variables for selected disk, track and sector
0866: FBEA                	; These are moved and compared as a group, DO NOT ALTER
0867: FBEA                SelectedDkTrkSec:   
0868: FBEA     00         SelectedDisk:			DB		00H
0869: FBEB     0000       SelectedTrack:			DW		00H
0870: FBED     00         SelectedSector:			DB		00H
0871: FBEE                                    
0872: FBEE                	;Selected physical sector derived from selected (CP/M) sector by shifting it
0873: FBEE                	;	right the number of of bits specified by SectorBitShift
0874: FBEE     00         SelectedPhysicalSector:	DB		00H
0875: FBEF                                    
0876: FBEF     00         SelectedDiskType:		DB		00H		; Set by SELDSK to indicate either , 8" or 5 1/4" floppy 
0877: FBF0     00         SelectedDiskDeblock:	DB		00H		; Set by SELDSK to indicate whether de-blocking is required
0878: FBF1                                    
0879: FBF1                	; Parameters for writing to a previously unallocated allocation block
0880: FBF1                	; These are moved and compared as a group, DO NOT ALTER
0881: FBF1                UnallocatedDkTrkSec:
0882: FBF1     00         UnallocatedDisk:		DB		00H
0883: FBF2     0000       UnallocatedTrack:		DW		00H
0884: FBF4     00         UnallocatedSector:		DB		00H
0885: FBF5     00         UnalocatedlRecordCount:	DB		00H		; Number of unallocated "records"in current previously unallocated allocation block.
0886: FBF6                                    
0887: FBF6     00         DiskErrorFlag:			DB		00H		; Non-Zero - unrecoverable error output "Bad Sector" message
0888: FBF7                                    
0889: FBF7                	; Flags used inside the de-blocking code
0890: FBF7     00         PrereadSectorFlag:		DB		00H		; non-zero if physical sector must be read into the disk buffer
0891: FBF8                										; either before a write to a allocated block can occur, or
0892: FBF8                										; for a normal CP/M 128 byte sector read
0893: FBF8     00         ReadFlag:				DB		00H		; Non-zero when a CP/M 128 byte sector is to be read
0894: FBF9     00         DeblockingRequired:		DB		00H		; Non-zero when the selected disk needs de-blocking (set in SELDSK)
0895: FBFA     00         DiskType:				DB		00H		; Indicate 8" or 5 1/4" selected  (set in SELDSK)
0896: FBFB                                    
0897: FBFB                ; 180/493           
0898: FBFB                                    
0899: FBFB                ;************************************************************************************************
0900: FBFB                ;        READ       
0901: FBFB                ; Read in the 128-byte CP/M sector specified by previous calls to select disk and to set track  and 
0902: FBFB                ; sector. The sector will be read into the address specified in the previous call to set DMA address
0903: FBFB                ;                   
0904: FBFB                ; If reading from a disk drive using sectors larger than 128 bytes, de-blocking code will be used
0905: FBFB                ; to unpack a 128-byte sector from  the physical sector. 
0906: FBFB                ;************************************************************************************************
0907: FBFB                READ:               
0908: FBFB     3AF9FB     		LDA		DeblockingRequired
0909: FBFE     B7         		ORA		A            
0910: FBFF     CA4EFD     		JZ		ReadNoDeblock			; if 0 use normal non-blocked read (128 byte sectors)
0911: FC02                ; The de-blocking algorithm used is such that a read operation can be viewed UP until the actual
0912: FC02                ; data transfer as though it was the first write to an unallocated allocation block. 
0913: FC02                										; else its a 512 byte sector
0914: FC02     AF         		XRA		A						; set record count to 0
0915: FC03     32F5FB     		STA		UnalocatedlRecordCount
0916: FC06     3C         		INR		A            
0917: FC07     32F8FB     		STA		ReadFlag			; Set to non zero to indicate that this is a read
0918: FC0A     32F7FB     		STA		PrereadSectorFlag		; force pre-read
0919: FC0D     3E02       		MVI		A,WriteUnallocated		; fake de-blocking code into responding as if this
0920: FC0F     32E3FB     		STA		WriteType				;  is the first write to an unallocated allocation block
0921: FC12     C36EFC     		JMP		PerformReadWrite		; use common code to execute read
0922: FC15                		                  
0923: FC15                ;************************************************************************************************
0924: FC15                ;		WRITE            
0925: FC15                ;Write a 128-byte sector from the current DMA address to the previously $elected disk, track, and sector.
0926: FC15                ;                   
0927: FC15                ; On arrival here, the BOOS will have set register C to indicate whether this write operation is to:
0928: FC15                ;	00H [WriteAllocated]	 An already allocated allocation block (which means a pre-read of the sector may be needed),
0929: FC15                ;	01H [WriteDirectory]	 To the directory (in which case the data will be written to the disk immediately),
0930: FC15                ;	02H	[WriteUnallocated]	 To the first 128-byte sector of a previously unallocated allocation block (In which case no pre-read is required).
0931: FC15                ;                   
0932: FC15                ; Only writes to the directory take place immediately.
0933: FC15                ; In all other cases, the data will be moved from the DMA address into the disk buffer,
0934: FC15                ; and only written out when circumstance, force the transfer.
0935: FC15                ; The number of physical disk operations can therefore be reduced considerably.
0936: FC15                ;************************************************************************************************
0937: FC15                WRITE:              
0938: FC15     3AF9FB     		LDA		DeblockingRequired
0939: FC18     B7         		ORA		A            
0940: FC19     CA49FD     		JZ		WriteNoDeblock			; if 0 use non-blocked write
0941: FC1C                ; Buffered I/O      
0942: FC1C     AF         		XRA		A            
0943: FC1D     32F8FB     		STA		ReadFlag				; Set to zero to indicate that this is not a read
0944: FC20     79         		MOV		A,C          
0945: FC21     32E3FB     		STA		WriteType				; save the BDOS write type
0946: FC24     FE02       		CPI		WriteUnallocated		; first write to an unallocated allocation block ?
0947: FC26     C237FC     		JNZ		CheckUnallocatedBlock	; No, - in the middle of writing to an unallocated block ?
0948: FC29                										; Yes, It is the first write to unallocated allocation block.
0949: FC29                ; Initialize  variables associated with unallocated writes
0950: FC29     3E10       		MVI		A,AllocationBlockSize/ 128	; Number of 128 byte sectors
0951: FC2B     32F5FB     		STA		UnalocatedlRecordCount
0952: FC2E     21EAFB     		LXI		H,SelectedDkTrkSec		; copy disk, track & sector into unallocated variables
0953: FC31     11F1FB     		LXI		D,UnallocatedDkTrkSec
0954: FC34     CD31FD     		CALL 	MoveDkTrkSec
0955: FC37                		                  
0956: FC37                	; Check if this is not the first write to an unallocated allocation block -- if it is,
0957: FC37                	; the unallocated record count has just been set to the number of 128-byte sectors in the allocation block
0958: FC37                CheckUnallocatedBlock:
0959: FC37     3AF5FB     		LDA		UnalocatedlRecordCount
0960: FC3A     B7         		ORA		A            
0961: FC3B     CA66FC     		JZ		RequestPreread			; No - write to an unallocated block
0962: FC3E     3D         		DCR		A						; decrement 128 byte sectors left
0963: FC3F     32F5FB     		STA		UnalocatedlRecordCount
0964: FC42                		                  
0965: FC42     21EAFB     		LXI		H,SelectedDkTrkSec		; same Disk, Track & sector as for those in an unallocated block
0966: FC45     11F1FB     		LXI		D,UnallocatedDkTrkSec
0967: FC48     CD25FD     		CALL	CompareDkTrkSec			; are they the same
0968: FC4B     C266FC     		JNZ		RequestPreread			; NO - do a pre-read
0969: FC4E                										;Compare$DkSTrkSec  returns with  DE -> Unallocated$Sector , HL -> UnallocatedSSector 
0970: FC4E     EB         		XCHG              
0971: FC4F     34         		INR	M             
0972: FC50     7E         		MOV		A,M          
0973: FC51     FE48       		CPI		CPMSecPerTrack			; Sector > maximum on track ?
0974: FC53     DA5FFC     		JC		NoTrackChange			; No ( A < M)
0975: FC56     3600       		MVI		M,00H					; Yes
0976: FC58     2AF2FB     		LHLD	UnallocatedTrack
0977: FC5B     23         		INX		H						; increment track 
0978: FC5C     22F2FB     		SHLD	UnallocatedTrack
0979: FC5F                NoTrackChange:      
0980: FC5F     AF         		XRA		A            
0981: FC60     32F7FB     		STA		PrereadSectorFlag		; clear flag
0982: FC63     C36EFC     		JMP		PerformReadWrite
0983: FC66                		                  
0984: FC66                RequestPreread:     
0985: FC66     AF         		XRA		A            
0986: FC67     32F5FB     		STA		UnalocatedlRecordCount	; not a write into an unallocated block
0987: FC6A     3C         		INR		A            
0988: FC6B     32F7FB     		STA		PrereadSectorFlag		; set flag
0989: FC6E                ;*******************************************************
0990: FC6E                ; Common code to execute both reads and writes of 128-byte sectors	
0991: FC6E                ;*******************************************************	
0992: FC6E                PerformReadWrite:   
0993: FC6E     AF         		XRA		A						; Assume no disk error will occur
0994: FC6F     32F6FB     		STA		DiskErrorFlag
0995: FC72     3AEDFB     		LDA		SelectedSector
0996: FC75     1F         		RAR								; Convert selected 128-byte sector
0997: FC76     1F         		RAR								; into physical sector by dividing by 4
0998: FC77     E63F       		ANI		03FH					; remove unwanted bits
0999: FC79     32EEFB     		STA		SelectedPhysicalSector
1000: FC7C     21E8FB     		LXI		H,DataInDiskBuffer		; see if there is any data here ?
1001: FC7F     7E         		MOV		A,M          
1002: FC80     3601       		MVI		M,001H					; force there is data here for after the actual read
1003: FC82     B7         		ORA		A						; really is there any data here ?
1004: FC83     CAA3FC     		JZ		ReadSectorIntoBuffer	; NO - go read into buffer
1005: FC86                ;                   
1006: FC86                		; The buffer does have a physical sector in it, Note: The disk, track, and PHYSICAL sector
1007: FC86                		; in the buffer need to be checked, hence the use of the CompareDkTrk subroutine.
1008: FC86     11E4FB     		LXI		D,InBufferDkTrkSec
1009: FC89     21EAFB     		LXI		H,SelectedDkTrkSec		; get the requested sector
1010: FC8C     CD20FD     		CALL	CompareDkTrk			; is it in the buffer ? 
1011: FC8F     C29CFC     		JNZ		SectorNotInBuffer		; NO, it must be read
1012: FC92                		; Yes, it is in the buffer
1013: FC92     3AE7FB     		LDA		InBufferSector			; get the sector
1014: FC95     21EEFB     		LXI		H,SelectedPhysicalSector
1015: FC98     BE         		CMP		M						; Check if correct physical sector
1016: FC99     CAC0FC     		JZ		SectorInBuffer			; Yes - it is already in memory
1017: FC9C                		; No, it will have to be read in over current contents of buffer
1018: FC9C                SectorNotInBuffer:  
1019: FC9C     3AE9FB     		LDA		MustWriteBuffer
1020: FC9F     B7         		ORA		A						; do we need to write ?
1021: FCA0     C491FD     		CNZ		WritePhysical			; if yes - write it out
1022: FCA3                                    
1023: FCA3                ReadSectorIntoBuffer:
1024: FCA3                		; indicate the  selected disk, track, and sector now residing in buffer
1025: FCA3     3AEAFB     		LDA		SelectedDisk 
1026: FCA6     32E4FB     		STA		InBufferDisk 
1027: FCA9     2AEBFB     		LHLD	SelectedTrack
1028: FCAC     22E5FB     		SHLD	InBufferTrack
1029: FCAF     3AEEFB     		LDA		SelectedPhysicalSector
1030: FCB2     32E7FB     		STA		InBufferSector
1031: FCB5                		                  
1032: FCB5     3AF7FB     		LDA		PrereadSectorFlag		; do we need to pre-read
1033: FCB8     B7         		ORA		A            
1034: FCB9     C496FD     		CNZ		ReadPhysical			; yes - pre-read the sector
1035: FCBC                		                  
1036: FCBC                ; At this point the data is in the buffer.
1037: FCBC                ; Either it was already here, or we returned from ReadPhysical
1038: FCBC                                    
1039: FCBC     AF         		XRA		A						; reset the flag
1040: FCBD     32E9FB     		STA		MustWriteBuffer			; and store it away
1041: FCC0                		                  
1042: FCC0                ; Selected sector on correct track and  disk is already 1n the buffer.
1043: FCC0                ; Convert the selected CP/M(128-byte sector into relative address down the buffer. 
1044: FCC0                SectorInBuffer:     
1045: FCC0     3AEDFB     		LDA		SelectedSector
1046: FCC3     E603       		ANI		SectorMask				; only want the least bits
1047: FCC5     6F         		MOV		L,A						; to calculate offset into 512 byte buffer
1048: FCC6     2600       		MVI		H,00H					; Multiply by 128
1049: FCC8     29         		DAD		H						; *2  
1050: FCC9     29         		DAD		H						; *4  
1051: FCCA     29         		DAD		H						; *8  
1052: FCCB     29         		DAD		H						; *16 
1053: FCCC     29         		DAD		H						; *32 
1054: FCCD     29         		DAD		H						; *64 
1055: FCCE     29         		DAD		H						; *128
1056: FCCF     1133F6     		LXI		D,DiskBuffer 
1057: FCD2     19         		DAD		D						; HL -> 128-byte sector number start address
1058: FCD3     EB         		XCHG							; DE -> sector in the disk buffer
1059: FCD4     2A63FB     		LHLD	DMAAddress				; Get DMA address (set in SETDMA)
1060: FCD7     EB         		XCHG							; assume a read so :
1061: FCD8                										; DE -> DMA Address & HL -> sector in disk buffer
1062: FCD8     0E10       		MVI		C,128/8					; 8 bytes per move (loop count)
1063: FCDA                ;                   
1064: FCDA                ;  At this point -  
1065: FCDA                ;	C	->	loop count   
1066: FCDA                ;	DE	->	DMA address 
1067: FCDA                ;	HL	->	sector in disk buffer
1068: FCDA                ;                   
1069: FCDA     3AF8FB     		LDA		ReadFlag				; Move into or out of buffer /
1070: FCDD     B7         		ORA		A						; 0 => Write, non Zero => Read
1071: FCDE     C2E6FC     		JNZ		BufferMove				; Move out of buffer
1072: FCE1                		                  
1073: FCE1     3C         		INR		A						; going to force a write
1074: FCE2     32E9FB     		STA		MustWriteBuffer
1075: FCE5     EB         		XCHG							; DE <--> HL
1076: FCE6                		                  
1077: FCE6                ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
1078: FCE6                BufferMove:         
1079: FCE6     7E         		MOV		A,M						; Get byte from source
1080: FCE7     12         		STAX	D						; Put into destination
1081: FCE8     13         		INX		D						; update pointers
1082: FCE9     23         		INX		H            
1083: FCEA                		                  
1084: FCEA     7E         		MOV		A,M	         
1085: FCEB     12         		STAX	D            
1086: FCEC     13         		INX		D            
1087: FCED     23         		INX		H            
1088: FCEE                		                  
1089: FCEE     7E         		MOV		A,M          
1090: FCEF     12         		STAX	D            
1091: FCF0     13         		INX		D            
1092: FCF1     23         		INX		H            
1093: FCF2                		                  
1094: FCF2     7E         		MOV		A,M	         
1095: FCF3     12         		STAX	D            
1096: FCF4     13         		INX		D            
1097: FCF5     23         		INX		H            
1098: FCF6                		                  
1099: FCF6     7E         		MOV		A,M          
1100: FCF7     12         		STAX	D            
1101: FCF8     13         		INX		D            
1102: FCF9     23         		INX		H            
1103: FCFA                		                  
1104: FCFA     7E         		MOV		A,M          
1105: FCFB     12         		STAX	D            
1106: FCFC     13         		INX		D            
1107: FCFD     23         		INX		H            
1108: FCFE                		                  
1109: FCFE     7E         		MOV		A,M	         
1110: FCFF     12         		STAX	D            
1111: FD00     13         		INX		D            
1112: FD01     23         		INX		H            
1113: FD02                		                  
1114: FD02     7E         		MOV		A,M          
1115: FD03     12         		STAX	D            
1116: FD04     13         		INX		D            
1117: FD05     23         		INX		H            
1118: FD06                		                  
1119: FD06     0D         		DCR		C						; count down on loop counter
1120: FD07     C2E6FC     		JNZ		BufferMove				; repeat till done (CP/M sector moved)
1121: FD0A                ; end of loop       
1122: FD0A                		                  
1123: FD0A     3AE3FB     		LDA		WriteType				; write to directory ?
1124: FD0D     FE01       		CPI		WriteDirectory
1125: FD0F     3AF6FB     		LDA		DiskErrorFlag			; get flag in case of a delayed read or write
1126: FD12     C0         		RNZ								; return if delayed read or write
1127: FD13                		                  
1128: FD13     B7         		ORA		A						; Any disk errors ?
1129: FD14     C0         		RNZ								; yes - abandon attempt to write to directory
1130: FD15                		                  
1131: FD15     AF         		XRA		A            
1132: FD16     32E9FB     		STA		MustWriteBuffer			; clear flag
1133: FD19     CD91FD     		CALL	WritePhysical
1134: FD1C     3AF6FB     		LDA		DiskErrorFlag			; return error flag to caller
1135: FD1F     C9         		RET               
1136: FD20                ;********************************************************************
1137: FD20                                    
1138: FD20                		                  
1139: FD20                                    
1140: FD20                ; Compares just the disk and track   pointed to by DE and HL (used for Blocking/Deblocking)
1141: FD20                CompareDkTrk:			    
1142: FD20     0E03       		MVI		C,03H			; Disk(1), Track(2)
1143: FD22     C327FD     		JMP		CompareDkTrkSecLoop
1144: FD25                CompareDkTrkSec:				;Compares just the disk and track   pointed to by DE and HL 
1145: FD25     0E04       		MVI		C,04H			; Disk(1), Track(2), Sector(1)
1146: FD27                CompareDkTrkSecLoop:
1147: FD27     1A         		LDAX	D            
1148: FD28     BE         		CMP		M            
1149: FD29     C0         		RNZ						; Not equal
1150: FD2A     13         		INX	D             
1151: FD2B     23         		INX	H             
1152: FD2C     0D         		DCR		C            
1153: FD2D     C8         		RZ						; return they match (zero flag set)
1154: FD2E     C327FD     		JMP		CompareDkTrkSecLoop	; keep going
1155: FD31                                    
1156: FD31                ;********************************************************************
1157: FD31                                    
1158: FD31                ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE 
1159: FD31                MoveDkTrkSec:       
1160: FD31     0E04       		MVI		C,04H			; Disk(1), Track(2), Sector(1)
1161: FD33                MoveDkTrkSecLoop:   
1162: FD33     7E         		MOV		A,M          
1163: FD34     12         		STAX	D            
1164: FD35     13         		INX		D            
1165: FD36     23         		INX		H            
1166: FD37     0D         		DCR		C            
1167: FD38     C8         		RZ					; exit loop done
1168: FD39     C333FD     		JMP		MoveDkTrkSecLoop
1169: FD3C                		                  
1170: FD3C                ;**************************************************************************************************
1171: FD3C                ;  There are two "smart" disk controllers on this system, one for the 8" floppy diskette drives,
1172: FD3C                ; and one for the 5 1/4" mini-diskette drives
1173: FD3C                ;                   
1174: FD3C                ;  The controllers are "hard-wired" to monitor certain locations in memory to detect when they are to
1175: FD3C                ; perform some disk operation. The 8" controller monitors location 0040H, and the 5 1/4 controller
1176: FD3C                ; monitors location 0045H. These are called their disk control bytes.
1177: FD3C                ; If the most significant bit of  disk control byte is set, the controller will look at the word
1178: FD3C                ; following the respective control bytes. This word must contain the address of  valid disk control
1179: FD3C                ; table that specifies the exact disk operation to be performed.
1180: FD3C                ;                   
1181: FD3C                ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1182: FD3C                ; This indicates completion to the disk driver code.
1183: FD3C                ;                   
1184: FD3C                ;  The controller also sets a return code in a disk status block -both controllers use the SAME location
1185: FD3C                ; for this, 0043H. If the first byte of this status block is less than 80H. then a disk error
1186: FD3C                ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1187: FD3C                ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1188: FD3C                ; ten times before the controller returns an error
1189: FD3C                ;                   
1190: FD3C                ;  The disk control table layout is shown below. Note that the controllers have the capability
1191: FD3C                ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1192: FD3C                ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1193: FD3C                ; in the disk control tables be pointed back to the main control bytes in order to indicate
1194: FD3C                ; the end of the chain
1195: FD3C                ;**************************************************************************************************
1196: FD3C                                    
1197: FD3C                DiskControl8				EQU	040H	; 8" control byte
1198: FD3C                CommandBlock8				EQU	041H	; Control Table Pointer
1199: FD3C                                    
1200: FD3C                DiskStatusBlock				EQU	043H	; 8" and 5 1/4" status block
1201: FD3C                                    
1202: FD3C                DiskControl5				EQU	045H	; 8" control byte
1203: FD3C                CommandBlock5				EQU	046H	; Control Table Pointer
1204: FD3C                                    
1205: FD3C                DiskReadCode				EQU	01H		; Code for Read
1206: FD3C                DiskWriteCode				EQU	02H		; Code for Write
1207: FD3C                ;***************************************************************************
1208: FD3C                ;					Disk Control tables
1209: FD3C                ;***************************************************************************
1210: FD3C                DiskControlTable:   
1211: FD3C     00         DCTCommand:				DB	00H		; Command
1212: FD3D     00         DCTUnit:					DB	00H		; unit (drive) number = 0 or 1
1213: FD3E     00         DCTHead:					DB	00H		; head number = 0 or 1
1214: FD3F     00         DCTTrack:				DB	00H		; track number
1215: FD40     00         DCTSector:				DB	00H		; sector number
1216: FD41     0000       DCTByteCount:			DW	0000H	; number of bytes to read/write
1217: FD43     0000       DCTDMAAddress:			DW	0000H	; transfer address
1218: FD45     0000       DCTNextStatusBlock:		DW	0000H	; pointer to next status block
1219: FD47     0000       DCTNextControlLocation:	DW	0000H	; pointer to next control byte
1220: FD49                                    
1221: FD49                ; Write contents of disk buffer to correct sector
1222: FD49                WriteNoDeblock:     
1223: FD49     3E02       	MVI		A,DiskWriteCode	; get write function code
1224: FD4B     C350FD     	JMP		CommonNoDeblock
1225: FD4E                ;Read previously selected sector into disk buffer
1226: FD4E                ReadNoDeblock:      
1227: FD4E     3E01       	MVI		A,DiskReadCode	; get read function code
1228: FD50                CommonNoDeblock:    
1229: FD50     323CFD     	STA		DCTCommand		; set the correct command code
1230: FD53     218000     	LXI		H,128				; bytes per sector
1231: FD56     2241FD     	SHLD	DCTByteCount  
1232: FD59     AF         	XRA		A					; 8" has only head 0
1233: FD5A     323EFD     	STA		DCTHead       
1234: FD5D                	                   
1235: FD5D     3AEAFB     	LDA		SelectedDisk		; insure only disk 0 or 1
1236: FD60     E601       	ANI		01H           
1237: FD62     323DFD     	STA		DCTUnit			; set the unit number
1238: FD65                	                   
1239: FD65     3AEBFB     	LDA		SelectedTrack 
1240: FD68     323FFD     	STA		DCTTrack			; set track number
1241: FD6B                	                   
1242: FD6B     3AEDFB     	LDA		SelectedSector
1243: FD6E     3240FD     	STA		DCTSector		; set sector
1244: FD71                	                   
1245: FD71     2A63FB     	LHLD	DMAAddress    
1246: FD74     2243FD     	SHLD	DCTDMAAddress	; set transfer address
1247: FD77                	                   
1248: FD77                ;  The disk controller can accept chained disk control tables, but in this case
1249: FD77                ; they are not used. so the "Next" pointers must be pointed back at the initial
1250: FD77                ; control bytes in the base page. 
1251: FD77     214300     	LXI		H,DiskStatusBlock
1252: FD7A     2245FD     	SHLD	DCTNextStatusBlock	; set pointer back to start
1253: FD7D     214000     	LXI		H,DiskControl8
1254: FD80     2247FD     	SHLD	DCTNextControlLocation	; set pointer back to start
1255: FD83     213CFD     	LXI		H,DCTCommand  
1256: FD86     224100     	SHLD	CommandBlock8 
1257: FD89                	                   
1258: FD89     214000     	LXI		H,DiskControl8
1259: FD8C     3680       	MVI		M,080H				; activate the controller to perform operation
1260: FD8E     C3F3FD     	JMP		WaitForDiskComplete
1261: FD91                	                   
1262: FD91                ;Write contents of disk buffer to correct sector
1263: FD91                WritePhysical:      
1264: FD91     3E02       	MVI		A,DiskWriteCode	; get write function
1265: FD93     C398FD     	JMP		CommonPhysical
1266: FD96                ReadPhysical:       
1267: FD96     3E01       	MVI		A,DiskReadCode	; get read function
1268: FD98                CommonPhysical:     
1269: FD98     323CFD     	STA		DCTCommand		; set the command
1270: FD9B                	                   
1271: FD9B     3AFAFB     	LDA		DiskType      
1272: FD9E     FE01       	CPI		Floppy5				; is it 5 1/4 ?
1273: FDA0     CAA9FD     	JZ		CorrectDisktype		; yes
1274: FDA3     3E01       	MVI		A,1           
1275: FDA5     3205FE     	STA		DiskError			; no set error and exit
1276: FDA8     C9         	RET                
1277: FDA9                CorrectDisktype:    
1278: FDA9     3AE4FB     	LDA		InBufferDisk  
1279: FDAC     E601       	ANI		01H					; only units 0 or 1
1280: FDAE     323DFD     	STA		DCTUnit			; set disk
1281: FDB1     2AE5FB     	LHLD	InBufferTrack 
1282: FDB4     7D         	MOV		A,L					; for this controller it is a byte value
1283: FDB5     323FFD     	STA		DCTTrack			; set track
1284: FDB8                ;  The sector must be converted into a head number and sector number.
1285: FDB8                ; Sectors 0 - 8 are head 0, 9 - 17 , are head 1 
1286: FDB8     0600       	MVI		B,0					; assume head 0
1287: FDBA     3AE7FB     	LDA		InBufferSector
1288: FDBD     4F         	MOV		C,A					; save copy
1289: FDBE     FE09       	CPI		09H           
1290: FDC0     DAC7FD     	JC		Head0          
1291: FDC3     D609       	SUI		09H					; Modulo sector
1292: FDC5     4F         	MOV		C,A           
1293: FDC6     04         	INR		B					; set head to 1
1294: FDC7                Head0:              
1295: FDC7     78         	MOV		A,B           
1296: FDC8     323EFD     	STA		DCTHead			; set head number
1297: FDCB     79         	MOV		A,C           
1298: FDCC     3C         	INR		A					; physical sectors start at 1
1299: FDCD     3240FD     	STA		DCTSector		; set sector
1300: FDD0     210002     	LXI		H,PhysicalSectorSize
1301: FDD3     2241FD     	SHLD	DCTByteCount		; set byte count
1302: FDD6     2133F6     	LXI		H,DiskBuffer  
1303: FDD9     2243FD     	SHLD	DCTDMAAddress	; set transfer address
1304: FDDC                ;	As only one control table is in use, close the status and busy chain pointers
1305: FDDC                ;  back to the main control bytes
1306: FDDC     214300     	LXI		H,DiskStatusBlock
1307: FDDF     2245FD     	SHLD	DCTNextStatusBlock
1308: FDE2     214500     	LXI		H,DiskControl5
1309: FDE5     2247FD     	SHLD	DCTNextControlLocation
1310: FDE8     213CFD     	LXI		H,DCTCommand  
1311: FDEB     224600     	SHLD	CommandBlock5 
1312: FDEE                	                   
1313: FDEE     214500     	LXI		H,DiskControl5		; activate 5 1/4" disk controller
1314: FDF1     3680       	MVI		M,080H        
1315: FDF3                                    
1316: FDF3                ;Wait until Disk Status Block indicates , operation complete, then check 
1317: FDF3                ; if any errors occurred. ,On entry HL -> disk control byte	
1318: FDF3                WaitForDiskComplete:
1319: FDF3     7E         	MOV		A,M				; get control bytes
1320: FDF4     B7         	ORA		A             
1321: FDF5     C2F3FD     	JNZ		WaitForDiskComplete	; operation not done
1322: FDF8                	                   
1323: FDF8     3A4300     	LDA		DiskStatusBlock		; done , so now check status
1324: FDFB     FE80       	CPI		080H          
1325: FDFD     DA05FE     	JC		DiskError      
1326: FE00     AF         	XRA		A             
1327: FE01     32F6FB     	STA		DiskErrorFlag		; clear the flag
1328: FE04     C9         	RET                
1329: FE05                	                   
1330: FE05                DiskError:          
1331: FE05     3E01       	MVI		A,1           
1332: FE07     32F6FB     	STA		DiskErrorFlag		; set the error flag
1333: FE0A     C9         	RET                
1334: FE0B                	                   
1335: FE0B                ;**********************************************************************************
1336: FE0B                ;		Disk Control table image for warm boot
1337: FE0B                ;**********************************************************************************
1338: FE0B                BootControlPart1:   
1339: FE0B     01         	DB	01H				; Read function
1340: FE0C     00         	DB	00H				; unit number
1341: FE0D     00         	DB	00H				; head number
1342: FE0E     00         	DB	00H				; track number
1343: FE0F     02         	DB	02H				; Starting sector number
1344: FE10     0010       	DW	8 * 512			; Number of bytes to read
1345: FE12     00E0       	DW	CCPEntry		; read into this address
1346: FE14     4300       	DW	DiskStatusBlock	; pointer to next block
1347: FE16     4500       	DW	DiskControl5	; pointer to next table
1348: FE18                BootControlPart2:   
1349: FE18     01         	DB	01H				; Read function
1350: FE19     00         	DB	00H				; unit number
1351: FE1A     01         	DB	01H				; head number
1352: FE1B     00         	DB	00H				; track number
1353: FE1C     01         	DB	01H				; Starting sector number
1354: FE1D     0006       	DW	3 * 512			; Number of bytes to read
1355: FE1F     00F0       	DW	CCPEntry + ( 8 * 512)		; read into this address
1356: FE21     4300       	DW	DiskStatusBlock	; pointer to next block
1357: FE23     4500       	DW	DiskControl5	; pointer to next table
1358: FE25                                    
1359: FE25                ;**********************************************************************************	
1360: FE25                ;						Warm Boot    
1361: FE25                ;  On warm boot. the CCP and BDOS must be reloaded into memory.
1362: FE25                ; In this BIOS. only the 5 1/4" diskettes will be used.
1363: FE25                ; Therefore this code is hardware specific to the controller.
1364: FE25                ; Two prefabricated control tables are used.
1365: FE25                ;**********************************************************************************	
1366: FE25                WBOOT:              
1367: FE25     318000     	LXI		SP,DefaultDiskBuffer
1368: FE28     110BFE     	LXI		D,BootControlPart1
1369: FE2B     CD37FE     	CALL	WarmBootRead  
1370: FE2E                	                   
1371: FE2E     1118FE     	LXi		D,BootControlPart2
1372: FE31     CD37FE     	CALL	WarmBootRead  
1373: FE34     C340F8     	JMP		EnterCPM      
1374: FE37                	                   
1375: FE37                WarmBootRead:       
1376: FE37     213CFD     	LXI		H,DiskControlTable			; get pointer to the Floppy's Device Control Table
1377: FE3A     224600     	SHLD	CommandBlock5		; put it into the Command block for drive A:
1378: FE3D     0E0D       	MVI		C,13				; set byte count for move
1379: FE3F                WarmByteMove:       
1380: FE3F     1A         	LDAX	D					; Move the coded Control block into the Command Block
1381: FE40     77         	MOV		M,A           
1382: FE41     23         	INX		H             
1383: FE42     13         	INX		D             
1384: FE43     0D         	DCR		C             
1385: FE44     C23FFE     	JNZ		WarmByteMove  
1386: FE47                	                   
1387: FE47     214500     	LXI		H,DiskControl5
1388: FE4A     3680       	MVI		M,080H				; activate the controller 
1389: FE4C                	                   
1390: FE4C                WaitForBootComplete:
1391: FE4C     7E         	MOV		A,M					; Get the control byte
1392: FE4D     B7         	ORA		A					; Reset to 0 (Completed operation) ?
1393: FE4E     C24CFE     	JNZ		WaitForBootComplete	; if not try again
1394: FE51                	                   
1395: FE51     3A4300     	LDA		DiskStatusBlock		; after operation what's the status?
1396: FE54     FE80       	CPI		080H				; any errors ?
1397: FE56     DA5AFE     	JC		WarmBootError		; Yup
1398: FE59     C9         	RET							; else we are done!
1399: FE5A                                    
1400: FE5A                WarmBootError:      
1401: FE5A     2163FE     	LXI		H,WarmBootErroMessage	; point at error message
1402: FE5D     CD33F8     	CALL	DisplayMessage			; sent it. and
1403: FE60     C325FE     	JMP		WBOOT					; try again.
1404: FE63                	                   
1405: FE63                WarmBootErroMessage:
1406: FE63     0D0A       	DB		0DH,0AH        
1407: FE65     5761726D20 	DB		057H,061H,072H,06DH,020H				; Warm
1408: FE6A     426F6F7420 	DB		042H,06FH,06FH,074H,020H				; Boot
1409: FE6F     7265744879696E67 	DB		072H,065H,074H,072,079H,069H,06EH,067H	;retrying
1410: FE77     2E2E2E0D0A 	DB		02EH,02EH,02EH,0DH,0AH
1411: FE7C     00         	DB		00H            
1412: FE7D                CodeEnd:            
1413: FE7D                End:                
1414: FE7D                                    
1415: FE7D                                    
1416: FE7D                	                   
1417: FE7D                                    
1418: FE7D                                    
1419: FE7D                	                   




                                    Xref


0000	0000	$                             		

0083	F833	AFTERDISKBUFFER               		  0189,
0833	0800	ALLOCATIONBLOCKSIZE           		  0950,

0029	E806	BDOSENTRY                     		  0040,  0213,
0019	0E00	BDOSLENGTH                    		  0022,  0023,  0030,
0030	F600	BIOSENTRY                     		  0057,
0020	0A00	BIOSLENGTH                    		  0022,  0023,
0146	F6F9	BOOT                          		  0061,
1338	FE0B	BOOTCONTROLPART1              		  1368,
1348	FE18	BOOTCONTROLPART2              		  1371,
1078	FCE6	BUFFERMOVE                    		  1071,  1120,

0027	E000	CCPENTRY                      		  0029,  0030,  0222,  1345,  1355,
0018	0800	CCPLENGTH                     		  0022,  0023,  0029,  0030,
0958	FC37	CHECKUNALLOCATEDBLOCK         		  0947,
1412	FE7D	CODEEND                       		
0058	F600	CODESTART                     		
1203	0046	COMMANDBLOCK5                 		  1311,  1377,
1198	0041	COMMANDBLOCK8                 		  1256,
1228	FD50	COMMONNODEBLOCK               		  1224,
1268	FD98	COMMONPHYSICAL                		  1265,
0371	00DF	COMMUNICATIONBAUDMODE         		  0105,
0372	00DE	COMMUNICATIONBAUDRATE         		  0109,
0367	00EC	COMMUNICATIONDATAPORT         		  0386,
0427	F92F	COMMUNICATIONINPUT            		  0259,
0369	0002	COMMUNICATIONINPUTREADY       		  0388,
0399	F902	COMMUNICATIONINSTATUS         		  0244,
0440	F944	COMMUNICATIONOUTPUT           		  0271,  0305,  0318,  0329,
0368	0001	COMMUNICATIONOUTPUTREADY      		  0387,
0412	F917	COMMUNICATIONOUTSTATUS        		  0293,
0366	00ED	COMMUNICATIONSTATUSPORT       		  0385,
0384	F8F2	COMMUNICATIONTABLE            		  0400,  0413,  0428,  0441,
1141	FD20	COMPAREDKTRK                  		  1010,
1144	FD25	COMPAREDKTRKSEC               		  0967,
1146	FD27	COMPAREDKTRKSECLOOP           		  1143,  1154,
0247	F878	CONIN                         		  0065,
0262	F886	CONOUT                        		  0066,  0200,
0232	F862	CONST                         		  0064,
1277	FDA9	CORRECTDISKTYPE               		  1273,
0835	0004	CPMSECPERPHYSICAL             		  0836,  0837,
0836	0048	CPMSECPERTRACK                		  0973,
0117	000D	CR                            		  0130,  0132,  0133,  0135,  0136,  0137,  0138,

0860	FBE8	DATAINDISKBUFFER              		  0815,  1000,
0013	3235	DAY                           		  0127,
1216	FD41	DCTBYTECOUNT                  		  1231,  1301,
1211	FD3C	DCTCOMMAND                    		  1229,  1255,  1269,  1310,
1217	FD43	DCTDMAADDRESS                 		  1246,  1303,
1213	FD3E	DCTHEAD                       		  1233,  1296,
1219	FD47	DCTNEXTCONTROLLOCATION        		  1254,  1309,
1218	FD45	DCTNEXTSTATUSBLOCK            		  1252,  1307,
1215	FD40	DCTSECTOR                     		  1243,  1299,
1214	FD3F	DCTTRACK                      		  1240,  1283,
1212	FD3D	DCTUNIT                       		  1237,  1280,
0894	FBF9	DEBLOCKINGREQUIRED            		  0712,  0908,  0938,
0038	0004	DEFAULTDISK                   		  0182,  0220,
0051	0080	DEFAULTDISKBUFFER             		  0216,  1367,
0597	F9C1	DIRECTORYBUFFER               		  0562,  0572,  0582,  0592,
0663	FAC1	DISKAALLOCATIONVECTOR         		  0565,
0650	FA61	DISKAWORKAREA                 		  0564,
0664	FAD7	DISKBALLOCATIONVECTOR         		  0575,
0081	F633	DISKBUFFER                    		  0085,  1056,  1302,
0651	FA81	DISKBWORKAREA                 		  0574,
0666	FAED	DISKCALLOCATIONVECTOR         		  0585,
1202	0045	DISKCONTROL5                  		  1308,  1313,  1347,  1357,  1387,
1197	0040	DISKCONTROL8                  		  1253,  1258,
1210	FD3C	DISKCONTROLTABLE              		  1376,
0652	FAA1	DISKCWORKAREA                 		  0584,
0667	FB0C	DISKDALLOCATIONVECTOR         		  0595,
0653	FAB1	DISKDWORKAREA                 		  0594,
1330	FE05	DISKERROR                     		  1275,  1325,
0887	FBF6	DISKERRORFLAG                 		  0994,  1125,  1134,  1327,  1332,
0555	F981	DISKPARAMETERHEADERS          		  0694,
1205	0001	DISKREADCODE                  		  1227,  1267,
1200	0043	DISKSTATUSBLOCK               		  1251,  1306,  1323,  1346,  1356,  1395,
0895	FBFA	DISKTYPE                      		  0709,  1271,
1206	0002	DISKWRITECODE                 		  1223,  1264,
0193	F833	DISPLAYMESSAGE                		  0179,  0203,  1402,
0739	FB63	DMAADDRESS                    		  0743,  1059,  1245,
0430	F935	DUMMYINPUT                    		  0260,
0402	F908	DUMMYINSTATUS                 		  0245,
0443	F94A	DUMMYOUTPUT                   		  0272,  0306,  0317,  0328,
0415	F91D	DUMMYOUTSTATUS                		  0294,

1413	FE7D	END                           		
0205	F840	ENTERCPM                      		  0185,  1373,

0047	005C	FCB                           		
0600	0001	FLOPPY5                       		  0612,  1272,
0614	FA42	FLOPPY5PARAMETERBLOCK         		  0563,  0573,
0757	FB6B	FLOPPY5SKEWTABLE              		  0558,  0568,  0588,
0601	0002	FLOPPY8                       		  0629,
0632	FA52	FLOPPY8PARAMETERBLOCK         		  0583,  0593,
0781	FBB3	FLOPPY8SKEWTABLE              		  0578,

0239	F86A	GETCONSOLESTATUS              		  0233,
0286	F89C	GETLISTSTATUS                 		  0280,

1294	FDC7	HEAD0                         		  1290,
0811	FBD3	HOME                          		  0070,
0816	FBDD	HOMENOWRITE                   		  0814,

0856	FBE4	INBUFFERDISK                  		  1026,  1278,
0855	FBE4	INBUFFERDKTRKSEC              		  1008,
0858	FBE7	INBUFFERSECTOR                		  1013,  1030,  1287,
0857	FBE5	INBUFFERTRACK                 		  1028,  1281,
0175	F713	INITIALIZECOMPLETE            		  0158,
0155	F6FD	INITIALIZELOOP                		  0172,
0163	F707	INITIALIZENEXTBYTE            		  0170,
0167	F70A	INITIALIZEPORT                		  0160,
0087	F633	INITIALIZESTREAM              		  0154,
0004	00DB	INOPCODE                      		  0453,  0465,  0481,
0473	F960	INPUTDATA                     		  0421,  0424,  0429,  0477,
0482	F96E	INPUTDATAPORT                 		  0480,
0450	F94B	INPUTSTATUS                   		  0395,  0398,  0401,  0475,
0454	F950	INPUTSTATUSPORT               		  0452,
0036	0003	IOBYTE                        		  0177,  0240,  0254,  0266,  0287,  0299,  0311,  0324,

0023	2000	LENGTHINBYTES                 		
0022	0009	LENGTHINK                     		
0118	000A	LF                            		  0130,  0132,  0133,  0135,  0136,  0137,  0138,
0296	F8AC	LIST                          		  0067,
0274	F894	LISTST                        		  0077,

0016	0040	MEMORYSIZE                    		
0012	3038	MONTH                         		  0125,
1159	FD31	MOVEDKTRKSEC                  		  0954,
1161	FD33	MOVEDKTRKSECLOOP              		  1168,
0862	FBE9	MUSTWRITEBUFFER               		  0812,  1019,  1040,  1074,  1132,

0604	0080	NEEDDEBLOCKING                		  0612,  0711,
0979	FC5F	NOTRACKCHANGE                 		  0974,
0669	0004	NUMBEROFLOGICALDISKS          		  0682,

0005	00D3	OUTOPCODE                     		  0166,  0495,
0486	F970	OUTPUTDATA                    		  0436,  0439,  0442,  0490,
0496	F97F	OUTPUTDATAPORT                		  0493,
0462	F956	OUTPUTSTATUS                  		  0408,  0411,  0414,  0488,
0466	F95B	OUTPUTSTATUSPORT              		  0464,

0034	0000	PAGEZERO                      		
0992	FC6E	PERFORMREADWRITE              		  0921,  0982,
0834	0012	PHYSICALSECPERTRACK           		  0836,
0080	0200	PHYSICALSECTORSIZE            		  0082,  0835,  1300,
0890	FBF7	PREREADSECTORFLAG             		  0918,  0981,  0988,  1032,
0308	F8BC	PUNCH                         		  0068,

0049	007D	RANDOMRECORDPOSITION          		
0907	FBFB	READ                          		  0075,
0321	F8CD	READER                        		  0069,
0893	FBF8	READFLAG                      		  0917,  0943,  1069,
1226	FD4E	READNODEBLOCK                 		  0910,
1266	FD96	READPHYSICAL                  		  1034,
1023	FCA3	READSECTORINTOBUFFER          		  1004,
0984	FC66	REQUESTPREREAD                		  0961,  0968,

0838	0002	SECTORBITSHIFT                		
1044	FCC0	SECTORINBUFFER                		  1016,
0837	0003	SECTORMASK                    		  1046,
1018	FC9C	SECTORNOTINBUFFER             		  1011,
0797	FBCD	SECTRAN                       		  0078,
0679	FB2B	SELDSK                        		  0071,
0868	FBEA	SELECTEDDISK                  		  0685,  1025,  1235,
0877	FBF0	SELECTEDDISKDEBLOCK           		
0876	FBEF	SELECTEDDISKTYPE              		
0867	FBEA	SELECTEDDKTRKSEC              		  0952,  0965,  1009,
0874	FBEE	SELECTEDPHYSICALSECTOR        		  0999,  1014,  1029,
0870	FBED	SELECTEDSECTOR                		  0732,  0995,  1045,  1242,
0869	FBEB	SELECTEDTRACK                 		  0723,  1027,  1239,
0332	F8DC	SELECTROUTINE                 		  0241,  0255,  0267,  0290,  0302,  0315,  0326,
0340	F8DD	SELECTROUTINE21               		
0740	FB65	SETDMA                        		  0074,  0217,
0730	FB5E	SETSEC                        		  0073,
0720	FB58	SETTRK                        		  0072,  0818,
0120	F643	SIGNONMESSAGE                 		  0178,
0007	002F	SLASH                         		  0126,  0128,
0006	0020	SPACE                         		  0124,

0362	0001	TERMINALDATAPORT              		  0381,
0422	F926	TERMINALINPUT                 		  0258,
0364	007F	TERMINALINPUTREADY            		  0383,
0396	F8FC	TERMINALINSTATUS              		  0243,
0437	F93E	TERMINALOUTPUT                		  0270,  0304,  0319,  0330,
0363	0080	TERMINALOUTPUTREADY           		  0382,
0409	F911	TERMINALOUTSTATUS             		  0292,
0361	0002	TERMINALSTATUSPORT            		  0380,
0379	F8EE	TERMINALTABLE                 		  0397,  0410,  0423,  0438,
0357	00EC	TTYDATAPORT                   		  0376,
0419	F920	TTYINPUT                      		  0257,
0359	0002	TTYINPUTREADY                 		  0378,
0393	F8F6	TTYINSTATUS                   		  0242,
0434	F938	TTYOUTPUT                     		  0269,  0303,  0316,  0327,
0358	0001	TTYOUTPUTREADY                		  0377,
0406	F90B	TTYOUTSTATUS                  		  0291,
0356	00ED	TTYSTATUSPORT                 		  0375,
0374	F8EA	TTYTABLE                      		  0394,  0407,  0420,  0435,

0882	FBF1	UNALLOCATEDDISK               		
0881	FBF1	UNALLOCATEDDKTRKSEC           		  0953,  0966,
0884	FBF4	UNALLOCATEDSECTOR             		
0883	FBF2	UNALLOCATEDTRACK              		  0976,  0978,
0885	FBF5	UNALOCATEDLRECORDCOUNT        		  0915,  0951,  0959,  0963,  0986,

0011	3041	VERSION                       		  0123,

1390	FE4C	WAITFORBOOTCOMPLETE           		  1393,
1318	FDF3	WAITFORDISKCOMPLETE           		  1260,  1321,
0062	F603	WARMBOOTENTRY                 		  0035,  0210,
1405	FE63	WARMBOOTERROMESSAGE           		  1401,
1400	FE5A	WARMBOOTERROR                 		  1397,
1375	FE37	WARMBOOTREAD                  		  1369,  1372,
1379	FE3F	WARMBYTEMOVE                  		  1385,
1366	FE25	WBOOT                         		  0063,  1403,
0937	FC15	WRITE                         		  0076,
0847	0000	WRITEALLOCATED                		
0848	0001	WRITEDIRECTORY                		  1124,
1222	FD49	WRITENODEBLOCK                		  0940,
1263	FD91	WRITEPHYSICAL                 		  1021,  1133,
0851	FBE3	WRITETYPE                     		  0920,  0945,  1123,
0849	0002	WRITEUNALLOCATED              		  0919,  0946,

0014	3435	YEAR                          		  0129,
