0001: 0000                                    
0002: 0000                ;**************************************************************
0003: 0000                ;*                  
0004: 0000                ;*             C P / M   version   2 . 2
0005: 0000                ;*                    Sourced from:
0006: 0000                ;*  Reconstructed from memory image on February 27, 1981
0007: 0000                ;*                by Clark A. Calkins
0008: 0000                ;*                  
0009: 0000                ;**************************************************************
0010: 0000                ;                   
0011: 0000                                    
0012: 0000                ;                   
0013: 0000                MEM			EQU		64			;for a 64k system 
0014: 0000                ;                   
0015: 0000                IOBYTE		EQU		3			;i/o definition byte.
0016: 0000                TDRIVE		EQU		4			;current drive name and user number.
0017: 0000                ENTRY		EQU		5			;entry point for the cp/m bdos.
0018: 0000                TFCB		EQU		5CH			;default file control block.
0019: 0000                Pg0Buffer	EQU		80H			;i/o buffer and command line storage.
0020: 0000                TBASE		EQU		100H		;transiant program storage area.
0021: 0000                ;                   
0022: 0000                ;   Set control character equates.
0023: 0000                ;                   
0024: 0000                CNTRLC		EQU		03H			;control-c
0025: 0000                CNTRLE		EQU		05H			;control-e
0026: 0000                BS			EQU		08H			;backspace
0027: 0000                TAB			EQU		09H			;tab
0028: 0000                LF			EQU		0AH			;line feed
0029: 0000                FF			EQU		0CH			;form feed
0030: 0000                CR			EQU		0DH			;carriage return
0031: 0000                CNTRLP		EQU		10H			;control-p
0032: 0000                CNTRLR		EQU		12H			;control-r
0033: 0000                CNTRLS		EQU		13H			;control-s
0034: 0000                CNTRLU		EQU		15H			;control-u
0035: 0000                CNTRLX		EQU		18H			;control-x
0036: 0000                CNTRLZ		EQU		1AH			;control-z (end-of-file mark)
0037: 0000                DEL			EQU		7FH			;rubout
0038: 0000                ;                   
0039: 0000                BLANK		EQU		020H		; Space/Blank
0040: 0000                BRACKETLEFT		EQU	07BH		; {
0041: 0000                BRACKETRIGHT	EQU	07DH		; }
0042: 0000                QMARK		EQU		03FH		; ?
0043: 0000                EQUALS		EQU		03DH		; =
0044: 0000                USCORE		EQU		05FH		; _
0045: 0000                PERIOD		EQU		02EH		; .
0046: 0000                COLON		EQU		03AH		; :
0047: 0000                SEMIC		EQU		03BH		; ;
0048: 0000                LESSTH		EQU		03CH		; <
0049: 0000                GRTTHAN		EQU		03EH		; >
0050: 0000                ASTRK		EQU		02AH		; *
0051: 0000                CARET		EQU		05EH		; ^
0052: 0000                ATSIGN		EQU		040H		; @
0053: 0000                POUNDSN		EQU		023H		; #
0054: 0000                DOLLAR		EQU		024H		; $
0055: 0000                                    
0056: 0000                ;                   
0057: 0000                ;   Set origin for CP/M
0058: 0000                ;                   
0059: 0000                	ORG	(MEM-8)*1024   
0060: E000                CodeStart:          
0061: E000                ;                   
0062: E000                CBASE:              
0063: E000     C32FE3     		JMP		COMMAND		;execute command processor (ccp).
0064: E003     C32BE3     		JMP		CLEARBUF	;entry to empty input buffer before starting ccp.
0065: E006                                    
0066: E006                ;                   
0067: E006                ;   Standard cp/m ccp input buffer. Format is (max length),
0068: E006                ; (actual length), (char #1), (char #2), (char #3), etc.
0069: E006                ;                   
0070: E006                InBuffStart:        
0071: E006                InBuffSize:					;length of input buffer.
0072: E006     7F         		DB		InBuffEnd - InBuffStart		
0073: E007                InBuffCount:			;current Count of contents.
0074: E007     00         		DB		0             
0075: E008                InBuff:             
0076: E008     434F5059524947485420 		DB		'Copyright '  
0077: E012     313937392028432920425920 		DB		'1979 (c) by '
0078: E01E     4449474954414C205245534541524348 		DB		'Digital Research'
0079: E02E     00         		DB		00            
0080: E02F                		DS		86			         
0081: E085                InBuffEnd:          
0082: E085                		                  
0083: E085                INPOINT:            
0084: E085     08E0       		DW		InBuff		;input line pointer
0085: E087                NAMEPNT:            
0086: E087     0000       		DW		0			;input line pointer used for error message. Points to
0087: E089                ;			;start of name in error.
0088: E089                ;                   
0089: E089                ;   Routine to print (A) on the console. All registers used.
0090: E089                ;                   
0091: E089                PRINT:              
0092: E089     5F         	MOV		E,A			;setup bdos call.
0093: E08A     0E02       	MVI		C,2           
0094: E08C     C30500     	JMP		ENTRY         
0095: E08F                ;                   
0096: E08F                ;   Routine to print (A) on the console and to save (BC).
0097: E08F                ;                   
0098: E08F                PRINTB:             
0099: E08F     C5         	PUSH	B             
0100: E090     CD89E0     	CALL	PRINT         
0101: E093     C1         	POP		B             
0102: E094     C9         	RET                
0103: E095                ;                   
0104: E095                ;   Routine to send a carriage return, line feed combination
0105: E095                ; to the console.   
0106: E095                ;                   
0107: E095                CRLF:               
0108: E095     3E0D       	MVI		A,CR          
0109: E097     CD8FE0     	CALL	PRINTB        
0110: E09A     3E0A       	MVI		A,LF          
0111: E09C     C38FE0     	JMP		PRINTB        
0112: E09F                ;                   
0113: E09F                ;   Routine to send one space to the console and save (BC).
0114: E09F                ;                   
0115: E09F                SPACE:              
0116: E09F     3E20       	MVI		A,BLANK		; blank/Space
0117: E0A1     C38FE0     	JMP		PRINTB        
0118: E0A4                ;                   
0119: E0A4                ;   Routine to print character string pointed to be (BC) on the
0120: E0A4                ; console. It must terminate with a null byte.
0121: E0A4                ;                   
0122: E0A4                PLINE:              
0123: E0A4     C5         	PUSH	B             
0124: E0A5     CD95E0     	CALL	CRLF          
0125: E0A8     E1         	POP		H             
0126: E0A9                PLINE2:             
0127: E0A9     7E         	MOV		A,M           
0128: E0AA     B7         	ORA		A             
0129: E0AB     C8         	RZ                 
0130: E0AC     23         	INX		H             
0131: E0AD     E5         	PUSH	H             
0132: E0AE     CD89E0     	CALL	PRINT         
0133: E0B1     E1         	POP		H             
0134: E0B2     C3A9E0     	JMP		PLINE2        
0135: E0B5                ;                   
0136: E0B5                ;   Routine to reset the disk system.
0137: E0B5                ;                   
0138: E0B5                RESDSK:             
0139: E0B5     0E0D       	MVI		C,13          
0140: E0B7     C30500     	JMP		ENTRY         
0141: E0BA                ;                   
0142: E0BA                ;   Routine to select disk (A).
0143: E0BA                ;                   
0144: E0BA                DSKSEL:             
0145: E0BA     5F         	MOV		E,A           
0146: E0BB     0E0E       	MVI		C,14          
0147: E0BD     C30500     	JMP		ENTRY         
0148: E0C0                ;                   
0149: E0C0                ;   Routine to call bdos and save the return code. The zero
0150: E0C0                ; flag is set on a return of 0ffh.
0151: E0C0                ;                   
0152: E0C0                ENTRY1:             
0153: E0C0     CD0500     	CALL	ENTRY         
0154: E0C3     32BEE7     	STA		RTNCODE		;save return code.
0155: E0C6     3C         	INR		A			;set zero if 0ffh returned.
0156: E0C7     C9         	RET                
0157: E0C8                ;                   
0158: E0C8                ;   Routine to open a file. (DE) must point to the FCB.
0159: E0C8                ;                   
0160: E0C8                OPEN:               
0161: E0C8     0E0F       	MVI		C,15          
0162: E0CA     C3C0E0     	JMP		ENTRY1        
0163: E0CD                ;                   
0164: E0CD                ;   Routine to open file at (FCB).
0165: E0CD                ;                   
0166: E0CD                OPENFCB:            
0167: E0CD     AF         	XRA		A		;clear the record number byte at fcb+32
0168: E0CE     32BDE7     	STA		FCB+32        
0169: E0D1     119DE7     	LXI		D,FCB         
0170: E0D4     C3C8E0     	JMP		OPEN          
0171: E0D7                ;                   
0172: E0D7                ;   Routine to close a file. (DE) points to FCB.
0173: E0D7                ;                   
0174: E0D7                CLOSE:              
0175: E0D7     0E10       	MVI		C,16          
0176: E0D9     C3C0E0     	JMP		ENTRY1        
0177: E0DC                ;                   
0178: E0DC                ;   Routine to search for the first file with ambigueous name
0179: E0DC                ; (DE).             
0180: E0DC                ;                   
0181: E0DC                SRCHFST:            
0182: E0DC     0E11       	MVI		C,17          
0183: E0DE     C3C0E0     	JMP		ENTRY1        
0184: E0E1                ;                   
0185: E0E1                ;   Search for the next ambigeous file name.
0186: E0E1                ;                   
0187: E0E1                SRCHNXT:            
0188: E0E1     0E12       	MVI		C,18          
0189: E0E3     C3C0E0     	JMP		ENTRY1        
0190: E0E6                ;                   
0191: E0E6                ;   Search for file at (FCB).
0192: E0E6                ;                   
0193: E0E6                SRCHFCB:            
0194: E0E6     119DE7     	LXI		D,FCB         
0195: E0E9     C3DCE0     	JMP		SRCHFST       
0196: E0EC                ;                   
0197: E0EC                ;   Routine to delete a file pointed to by (DE).
0198: E0EC                ;                   
0199: E0EC                DELETE:             
0200: E0EC     0E13       	MVI		C,19          
0201: E0EE     C30500     	JMP		ENTRY         
0202: E0F1                ;                   
0203: E0F1                ;   Routine to call the bdos and set the zero flag if a zero
0204: E0F1                ; status is returned.
0205: E0F1                ;                   
0206: E0F1                ENTRY2:             
0207: E0F1     CD0500     	CALL	ENTRY         
0208: E0F4     B7         	ORA		A		;set zero flag if appropriate.
0209: E0F5     C9         	RET                
0210: E0F6                ;                   
0211: E0F6                ;   Routine to read the next record from a sequential file.
0212: E0F6                ; (DE) points to the FCB.
0213: E0F6                ;                   
0214: E0F6                RDREC:              
0215: E0F6     0E14       	MVI		C,20          
0216: E0F8     C3F1E0     	JMP		ENTRY2        
0217: E0FB                ;                   
0218: E0FB                ;   Routine to read file at (FCB).
0219: E0FB                ;                   
0220: E0FB                READFCB:            
0221: E0FB     119DE7     	LXI		D,FCB         
0222: E0FE     C3F6E0     	JMP		RDREC         
0223: E101                ;                   
0224: E101                ;   Routine to write the next record of a sequential file.
0225: E101                ; (DE) points to the FCB.
0226: E101                ;                   
0227: E101                WRTREC:             
0228: E101     0E15       	MVI		C,21          
0229: E103     C3F1E0     	JMP		ENTRY2        
0230: E106                ;                   
0231: E106                ;   Routine to create the file pointed to by (DE).
0232: E106                ;                   
0233: E106                CREATE:             
0234: E106     0E16       	MVI		C,22          
0235: E108     C3C0E0     	JMP		ENTRY1        
0236: E10B                ;                   
0237: E10B                ;   Routine to rename the file pointed to by (DE). Note that
0238: E10B                ; the new name starts at (DE+16).
0239: E10B                ;                   
0240: E10B                RENAM:              
0241: E10B     0E17       	MVI		C,23          
0242: E10D     C30500     	JMP		ENTRY         
0243: E110                ;                   
0244: E110                ;   Get the current user code.
0245: E110                ;                   
0246: E110                GETUSR:             
0247: E110     1EFF       	MVI		E,0FFH			; make it get
0248: E112                ;                   
0249: E112                ;   Routine to get or set the current user code.
0250: E112                ; If (E) is FF then this is a GET, else it is a SET.
0251: E112                ;                   
0252: E112                GETSETUC:           
0253: E112     0E20       	MVI		C,32			; BDOS vector
0254: E114     C30500     	JMP		ENTRY         
0255: E117                ;                   
0256: E117                ;   Routine to set the current drive byte at (TDRIVE).
0257: E117                ;                   
0258: E117                SETCDRV:            
0259: E117     CD10E1     	CALL	GETUSR			;get user number
0260: E11A     87         	ADD		A				;and shift into the upper 4 bits.
0261: E11B     87         	ADD		A             
0262: E11C     87         	ADD		A             
0263: E11D     87         	ADD		A             
0264: E11E     21BFE7     	LXI		H,CDRIVE		;now add in the current drive number.
0265: E121     B6         	ORA		M             
0266: E122     320400     	STA		TDRIVE			;and save.
0267: E125     C9         	RET                
0268: E126                ;                   
0269: E126                ;   Move currently active drive down to (TDRIVE).
0270: E126                ;                   
0271: E126                MOVECD:             
0272: E126     3ABFE7     	LDA		CDRIVE        
0273: E129     320400     	STA		TDRIVE        
0274: E12C     C9         	RET                
0275: E12D                ;                   
0276: E12D                ;   Routine to convert (A) into upper case ascii. Only letters
0277: E12D                ; are affected.     
0278: E12D                ;                   
0279: E12D                UPPER:              
0280: E12D     FE61       	CPI		061H			; 'a'	;check for letters in the range of 'a' to 'z'.
0281: E12F     D8         	RC                 
0282: E130     FE7B       	CPI		BRACKETLEFT		;'{'
0283: E132     D0         	RNC                
0284: E133     E65F       	ANI		5FH				;convert it if found.
0285: E135     C9         	RET                
0286: E136                ;                   
0287: E136                ;   Routine to get a line of input. We must check to see if the
0288: E136                ; user is in (BATCH) mode. If so, then read the input from file
0289: E136                ; ($$$.SUB). At the end, reset to console input.
0290: E136                ;                   
0291: E136                GETINP:             
0292: E136     3A7BE7     	LDA		BATCH			;if =0, then use console input.
0293: E139     B7         	ORA		A             
0294: E13A     CA93E1     	JZ		GETINP1        
0295: E13D                ;                   
0296: E13D                ;   Use the submit file ($$$.sub) which is prepared by a
0297: E13D                ; SUBMIT run. It must be on drive (A) and it will be deleted
0298: E13D                ; if and error occures (like eof).
0299: E13D                ;                   
0300: E13D     3ABFE7     	LDA		CDRIVE		;select drive 0 if need be.
0301: E140     B7         	ORA		A             
0302: E141     3E00       	MVI		A,0			;always use drive A for submit.
0303: E143     C4BAE0     	CNZ		DSKSEL		;select it if required.
0304: E146     117CE7     	LXI		D,BATCHFCB    
0305: E149     CDC8E0     	CALL	OPEN		;look for it.
0306: E14C     CA93E1     	JZ		GETINP1		;if not there, use normal input.
0307: E14F     3A8BE7     	LDA		BATCHFCB+15	;get last record number+1.
0308: E152     3D         	DCR		A             
0309: E153     329CE7     	STA		BATCHFCB+32   
0310: E156     117CE7     	LXI		D,BATCHFCB    
0311: E159     CDF6E0     	CALL	RDREC		;read last record.
0312: E15C     C293E1     	JNZ		GETINP1		;quit on end of file.
0313: E15F                ;                   
0314: E15F                ;   Move this record into input buffer.
0315: E15F                ;                   
0316: E15F     1107E0     	LXI		D,InBuffCount 
0317: E162     218000     	LXI		H,Pg0Buffer	;data was read into buffer here.
0318: E165     0680       	MVI		B,128		;all 128 characters may be used.
0319: E167     CD15E4     	CALL	HL2DE		;(HL) to (DE), (B) bytes.
0320: E16A     218AE7     	LXI		H,BATCHFCB+14 
0321: E16D     3600       	MVI		M,0			;zero out the 's2' byte.
0322: E16F     23         	INX		H			;and decrement the record count.
0323: E170     35         	DCR		M             
0324: E171     117CE7     	LXI		D,BATCHFCB	;close the batch file now.
0325: E174     CDD7E0     	CALL	CLOSE         
0326: E177     CA93E1     	JZ		GETINP1		;quit on an error.
0327: E17A     3ABFE7     	LDA		CDRIVE		;re-select previous drive if need be.
0328: E17D     B7         	ORA		A             
0329: E17E     C4BAE0     	CNZ		DSKSEL		;don't do needless selects.
0330: E181                ;                   
0331: E181                ;   Print line just read on console.
0332: E181                ;                   
0333: E181     2108E0     	LXI		H,InBuff      
0334: E184     CDA9E0     	CALL	PLINE2        
0335: E187     CDBFE1     	CALL	CHKCON		;check console, quit on a key.
0336: E18A     CAA4E1     	JZ		GETINP2		;jump if no key is pressed.
0337: E18D                ;                   
0338: E18D                ;   Terminate the submit job on any keyboard input. Delete this
0339: E18D                ; file such that it is not re-started and jump to normal keyboard
0340: E18D                ; input section.    
0341: E18D                ;                   
0342: E18D     CDDAE1     	CALL	DELBATCH	;delete the batch file.
0343: E190     C355E3     	JMP		CMMND1		;and restart command input.
0344: E193                ;                   
0345: E193                ;   Get here for normal keyboard input. Delete the submit file
0346: E193                ; incase there was one.
0347: E193                ;                   
0348: E193                GETINP1:            
0349: E193     CDDAE1     	CALL	DELBATCH	;delete file ($$$.sub).
0350: E196     CD17E1     	CALL	SETCDRV		;reset active disk.
0351: E199     0E0A       	MVI		C,10		;get line from console device.
0352: E19B     1106E0     	LXI		D,InBuffStart	; point at the Inbuff construct (Size, Pos, Buffer)
0353: E19E     CD0500     	CALL	ENTRY         
0354: E1A1     CD26E1     	CALL	MOVECD		;reset current drive (again).
0355: E1A4                ;                   
0356: E1A4                ;   Convert input line to upper case.
0357: E1A4                ;                   
0358: E1A4                GETINP2:            
0359: E1A4     2107E0     	LXI		H,InBuffCount 
0360: E1A7     46         	MOV		B,M			;(B)=character counter.
0361: E1A8                GETINP3:            
0362: E1A8     23         	INX		H             
0363: E1A9     78         	MOV		A,B			;end of the line?
0364: E1AA     B7         	ORA		A             
0365: E1AB     CAB7E1     	JZ		GETINP4        
0366: E1AE     7E         	MOV		A,M			;convert to upper case.
0367: E1AF     CD2DE1     	CALL	UPPER         
0368: E1B2     77         	MOV		M,A           
0369: E1B3     05         	DCR		B			;adjust character count.
0370: E1B4     C3A8E1     	JMP		GETINP3       
0371: E1B7                GETINP4:            
0372: E1B7     77         	MOV		M,A			;add trailing null.
0373: E1B8     2108E0     	LXI		H,InBuff      
0374: E1BB     2285E0     	SHLD	INPOINT		;reset input line pointer.
0375: E1BE     C9         	RET                
0376: E1BF                ;                   
0377: E1BF                ;   Routine to check the console for a key pressed. The zero
0378: E1BF                ; flag is set is none, else the character is returned in (A).
0379: E1BF                ;                   
0380: E1BF                CHKCON:             
0381: E1BF     0E0B       	MVI		C,11		;check console.
0382: E1C1     CD0500     	CALL	ENTRY         
0383: E1C4     B7         	ORA		A             
0384: E1C5     C8         	RZ					;return if nothing.
0385: E1C6     0E01       	MVI		C,1			;else get character.
0386: E1C8     CD0500     	CALL	ENTRY         
0387: E1CB     B7         	ORA		A			;clear zero flag and return.
0388: E1CC     C9         	RET                
0389: E1CD                ;                   
0390: E1CD                ;   Routine to get the currently active drive number.
0391: E1CD                ;                   
0392: E1CD                GETDSK:             
0393: E1CD     0E19       	MVI		C,25          
0394: E1CF     C30500     	JMP		ENTRY         
0395: E1D2                ;                   
0396: E1D2                ;   Set the stabdard dma address.
0397: E1D2                ;                   
0398: E1D2                STDDMA:             
0399: E1D2     118000     	LXI		D,Pg0Buffer   
0400: E1D5                ;                   
0401: E1D5                ;   Routine to set the dma address to (DE).
0402: E1D5                ;                   
0403: E1D5                DMASET:             
0404: E1D5     0E1A       	MVI		C,26          
0405: E1D7     C30500     	JMP		ENTRY         
0406: E1DA                ;                   
0407: E1DA                ;  Delete the batch file created by SUBMIT.
0408: E1DA                ;                   
0409: E1DA                DELBATCH:           
0410: E1DA     217BE7     	LXI		H,BATCH			;is batch active?
0411: E1DD     7E         	MOV		A,M           
0412: E1DE     B7         	ORA		A             
0413: E1DF     C8         	RZ                 
0414: E1E0     3600       	MVI		M,0				;yes, de-activate it.
0415: E1E2     AF         	XRA		A             
0416: E1E3     CDBAE0     	CALL	DSKSEL			;select drive 0 for sure.
0417: E1E6     117CE7     	LXI		D,BATCHFCB		;and delete this file.
0418: E1E9     CDECE0     	CALL	DELETE        
0419: E1EC     3ABFE7     	LDA		CDRIVE			;reset current drive.
0420: E1EF     C3BAE0     	JMP		DSKSEL        
0421: E1F2                ;                   
0422: E1F2                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0423: E1F2                ; the same or we halt....
0424: E1F2                ;                   
0425: E1F2                ;VERIFY:            
0426: E1F2                ;	LXI		D,PATTRN1		;these are the serial number bytes.
0427: E1F2                ;	LXI		H,PATTRN2		;ditto, but how could they be different?
0428: E1F2                ;	MVI		B,6				;6 bytes each.
0429: E1F2                ;VERIFY1:           
0430: E1F2                ;	LDAX	D            
0431: E1F2                ;	CMP		M            
0432: E1F2                ;	JNZ		HALT			;jump to halt routine.
0433: E1F2                ;	INX		D            
0434: E1F2                ;	INX		H            
0435: E1F2                ;	DCR		B            
0436: E1F2                ;	JNZ		VERIFY1      
0437: E1F2                ;	RET               
0438: E1F2                ;                   
0439: E1F2                ;   Print back file name with a '?' to indicate a syntax error.
0440: E1F2                ;                   
0441: E1F2                SYNERR:             
0442: E1F2     CD95E0     	CALL	CRLF	;end current line.
0443: E1F5     2A87E0     	LHLD	NAMEPNT	;this points to name in error.
0444: E1F8                SYNERR1:            
0445: E1F8     7E         	MOV	A,M	;print it until a space or null is found.
0446: E1F9     FE20       	CPI	BLANK		; Space 
0447: E1FB     CA0BE2     	JZ	SYNERR2         
0448: E1FE     B7         	ORA	A              
0449: E1FF     CA0BE2     	JZ	SYNERR2         
0450: E202     E5         	PUSH	H             
0451: E203     CD89E0     	CALL	PRINT         
0452: E206     E1         	POP	H              
0453: E207     23         	INX	H              
0454: E208     C3F8E1     	JMP	SYNERR1        
0455: E20B                SYNERR2:            
0456: E20B     3E3F       	MVI	A,QMARK		;add trailing '?'.
0457: E20D     CD89E0     	CALL	PRINT         
0458: E210     CD95E0     	CALL	CRLF          
0459: E213     CDDAE1     	CALL	DELBATCH;delete any batch file.
0460: E216     C355E3     	JMP	CMMND1	;and restart from console input.
0461: E219                ;                   
0462: E219                ;   Check character at (DE) for legal command input. Note that the
0463: E219                ; zero flag is set if the character is a delimiter.
0464: E219                ;                   
0465: E219                CHECK:              
0466: E219     1A         	LDAX	D			; Grab the character
0467: E21A     B7         	ORA		A             
0468: E21B     C8         	RZ					; Exit, its a Null (00)
0469: E21C                	                   
0470: E21C     FE20       	CPI		BLANK		; Is  less than 020H - controls character
0471: E21E     DAF2E1     	JC		SYNERR		; Yes,  Syntax error - exit CCP
0472: E221     C8         	RZ					; Exit because Space is valid delimiter.
0473: E222                	                   
0474: E222     FE3D       	CPI	EQUALS			; '=' 
0475: E224     C8         	RZ                 
0476: E225     FE5F       	CPI	USCORE			; '_' 
0477: E227     C8         	RZ                 
0478: E228     FE2E       	CPI	PERIOD			; '.' 
0479: E22A     C8         	RZ                 
0480: E22B     FE3A       	CPI	COLON			; ':'  
0481: E22D     C8         	RZ                 
0482: E22E     FE3B       	CPI	SEMIC			; ';'  
0483: E230     C8         	RZ                 
0484: E231     FE3C       	CPI	LESSTH			; '<' 
0485: E233     C8         	RZ                 
0486: E234     FE3E       	CPI	GRTTHAN			; '>'
0487: E236     C8         	RZ                 
0488: E237     C9         	RET					; Character is legal, but not a delimiter
0489: E238                ;                   
0490: E238                ;   Get the next non-blank character from (DE).
0491: E238                ;                   
0492: E238                NONBLANK:           
0493: E238     1A         	LDAX	D			; get the next character
0494: E239     B7         	ORA		A			;Since string ends with a null.
0495: E23A     C8         	RZ					; we return here if its 00
0496: E23B     FE20       	CPI		BLANK		; Is it a space?
0497: E23D     C0         	RNZ					; No, then we have the next non-space char
0498: E23E                	                   
0499: E23E     13         	INX		D			; since it a space we need to look at the next character
0500: E23F     C338E2     	JMP		NONBLANK      
0501: E242                ;                   
0502: E242                ;   Add (HL)=(HL)+(A)
0503: E242                ;                   
0504: E242                ADDHL:              
0505: E242     85         	ADD		L             
0506: E243     6F         	MOV		L,A           
0507: E244     D0         	RNC					;take care of any carry.
0508: E245     24         	INR		H             
0509: E246     C9         	RET                
0510: E247                ;                   
0511: E247                ;   Convert the first name in (FCB).
0512: E247                ;                   
0513: E247                CONVFST:            
0514: E247     3E00       	MVI	A,0		; set up index for first filename
0515: E249                ;                   
0516: E249                ;   Format a file name (convert * to '?', etc.). On return,
0517: E249                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0518: E249                ; the position within the fcb for the name (either 0 or 16).
0519: E249                ;                   
0520: E249                CONVERT:            
0521: E249     219DE7     	LXI		H,FCB		; point at FCB setup by CCP
0522: E24C     CD42E2     	CALL	ADDHL		; now pointing at correct FCB
0523: E24F     E5         	PUSH	H			; save    
0524: E250     E5         	PUSH	H             
0525: E251     AF         	XRA		A             
0526: E252     32C0E7     	STA		CHGDRV		; initialize drive change flag - no change.
0527: E255     2A85E0     	LHLD	INPOINT		; set (HL) as pointer into input line.
0528: E258     EB         	XCHG				; put line pointer in DE for call
0529: E259     CD38E2     	CALL	NONBLANK	; return the next non-blank character in A
0530: E25C     EB         	XCHG				; put line buffer pointer in HL for now
0531: E25D     2287E0     	SHLD	NAMEPNT		; save pointer here for any error message.
0532: E260     EB         	XCHG				; put line buffer pointer back in DE
0533: E261     E1         	POP		H			; retreive the CCP created FCB
0534: E262     1A         	LDAX	D			; get first character.
0535: E263     B7         	ORA		A			; is it a null 00 ?
0536: E264     CA72E2     	JZ		CONVRT1		; Yes, this FCB is empty (no argument)
0537: E267                	                   
0538: E267     DE40       	SBI		040H		; 'A'-1	;might be a drive name, convert to binary.
0539: E269     47         	MOV		B,A			; and save in case its a drive specifier.
0540: E26A     13         	INX		D			; get the next character 
0541: E26B     1A         	LDAX	D             
0542: E26C     FE3A       	CPI		COLON		; is it ':'
0543: E26E     CA79E2     	JZ		CONVRT2		; Yes, then we have a drive specification
0544: E271     1B         	DCX		D			; No, move pointer back to the start of the line.
0545: E272                CONVRT1:            
0546: E272     3ABFE7     	LDA		CDRIVE		; get current drive
0547: E275     77         	MOV		M,A			; put into the CCP FCB
0548: E276     C37FE2     	JMP		CONVRT3       
0549: E279                CONVRT2:            
0550: E279     78         	MOV		A,B			; get the saved drive number
0551: E27A     32C0E7     	STA		CHGDRV		; set change in drives flag.
0552: E27D     70         	MOV		M,B			; put new drive number in FCB
0553: E27E     13         	INX		D			; point past drive number
0554: E27F                ;                   
0555: E27F                ;   Convert the basic file name.
0556: E27F                ;                   
0557: E27F                CONVRT3:            
0558: E27F     0608       	MVI		B,08H		; File name size
0559: E281                CONVRT4:            
0560: E281     CDC9E2     	CALL	DECODENAME	; Expand all 8 characters in name
0561: E284                ;	CALL	CHECK		; Legal input character ?
0562: E284                ;	JZ		PADNAME		; its a delimiter, skip the rest of the filename
0563: E284                ;	INX		H            
0564: E284                ;	CPI		ASTRK		; '*'	;note that an '*' will fill the remaining
0565: E284                ;	JNZ		CONVRT5		; otherwise move to the next character and process.
0566: E284                ;	                  
0567: E284                ;	MVI		M,QMARK		; '?'
0568: E284                ;	JMP		CONVRT6      
0569: E284                ;CONVRT5:				; move on to the next character
0570: E284                ;	MOV		M,A			; put character in FCB
0571: E284                ;	INX		D			; move to next character in input line buffer
0572: E284                ;CONVRT6:           
0573: E284                ;	DCR		B			; decrement counter
0574: E284                ;	JNZ		CONVRT4		; loop if not done with fileName
0575: E284                CONVRT7:            
0576: E284     CD19E2     	CALL	CHECK		; Do we have a delimiter ?.
0577: E287     CA8EE2     	JZ		GETEXT		; Yes, process the extension
0578: E28A     13         	INX		D			; No, point a the next character
0579: E28B     C384E2     	JMP		CONVRT7		; and see if its a demiliter
0580: E28E                ;PADNAME:           
0581: E28E                ;	INX		H			; blank fill the remaining file name.
0582: E28E                ;	MVI		M,BLANK		; store the blank
0583: E28E                ;	DCR		B			; keep count
0584: E28E                ;	JNZ		PADNAME		; loop till done
0585: E28E                ;                   
0586: E28E                ;   Get the extension and convert it.
0587: E28E                ;                   
0588: E28E                GETEXT:             
0589: E28E     0603       	MVI		B,03H		; file extension size
0590: E290     FE2E       	CPI		PERIOD		; do we have the Period '.'
0591: E292                ;	JNZ		PADEXT		; No, Pad fill the extension
0592: E292     CA9BE2     	JZ		GETEXT1		; yes, process the extension
0593: E295     CDE1E2     	CALL	PADFIELD	; No, Pad fill the extension
0594: E298     C3A9E2     	JMP		CLEAREXTENT	; process the stuff after the extension
0595: E29B                GETEXT1:            
0596: E29B     13         	INX		D			; get past the period
0597: E29C                :                   
0598: E29C     CDC9E2     	CALL	DECODENAME	; Expand all 3 characters in extension
0599: E29F                ;	CALL	CHECK		; Legal input character ?		
0600: E29F                ;	JZ		PADEXT		; its a delimiter, so pad the rest of the extension
0601: E29F                ;	INX		H			; point at next spot in the CCP FCB
0602: E29F                ;	CPI		ASTRK		; ; '*'	;note that an '*' will fill the remaining
0603: E29F                ;	JNZ		GETEXT2		; otherwise move to the next character and process.
0604: E29F                ;	                  
0605: E29F                ;	MVI		M,QMARK		;'?'
0606: E29F                ;	JMP		GETEXT3      
0607: E29F                ;GETEXT2:				; move on to the next character
0608: E29F                ;	MOV		M,A			; put character in FCB
0609: E29F                ;	INX		D			; move to next character in input line buffer
0610: E29F                ;GETEXT3:           
0611: E29F                ;	DCR		B			; decrement counter
0612: E29F                ;	JNZ		GETEXT1		; loop if not done with file extension
0613: E29F                GETEXT4:            
0614: E29F     CD19E2     	CALL	CHECK		; Do we have a delimiter ?.
0615: E2A2     CAA9E2     	JZ		CLEAREXTENT	; Yes, Clear the EX, S1 & S2
0616: E2A5     13         	INX		D			; No, point a the next character
0617: E2A6     C39FE2     	JMP		GETEXT4		; and see if its a demiliter
0618: E2A9                	                   
0619: E2A9                ;PADEXT:            
0620: E2A9                ;	INX		H			; blank fill the remaining extension.
0621: E2A9                ;	MVI		M,BLANK		; store the blank
0622: E2A9                ;	DCR		B			; keep count
0623: E2A9                ;	JNZ		PADEXT		; loop till done
0624: E2A9                	                   
0625: E2A9                CLEAREXTENT:        
0626: E2A9     0603       	MVI		B,03H		; set count for clearing EX, S1 & S2
0627: E2AB                CLEAREXTENT1:       
0628: E2AB     23         	INX		H			; point at location in the CCP FCB
0629: E2AC     3600       	MVI		M,0			; initialize it
0630: E2AE     05         	DCR		B			; keep count
0631: E2AF     C2ABE2     	JNZ		CLEAREXTENT1	; loop til done
0632: E2B2     EB         	XCHG               
0633: E2B3     2285E0     	SHLD	INPOINT		; save current input line pointer.
0634: E2B6     E1         	POP		H			; point at correct CCP FCB
0635: E2B7                ;                   
0636: E2B7                ;   Check to see if this is an ambigeous file name specification.
0637: E2B7                ; Set the (A) register to non zero if it is.
0638: E2B7                ;                   
0639: E2B7                ;AFN - Ambiguous File Name
0640: E2B7     010B00     	LXI		B,11		; set name & Extension length .
0641: E2BA                AFN:                
0642: E2BA     23         	INX		H             
0643: E2BB     7E         	MOV		A,M           
0644: E2BC     FE3F       	CPI		QMARK		; '?'	;any question marks?
0645: E2BE     C2C2E2     	JNZ		AFN1          
0646: E2C1     04         	INR		B			; increment count
0647: E2C2                AFN1:               
0648: E2C2     0D         	DCR		C             
0649: E2C3     C2BAE2     	JNZ		AFN			; loop if not done
0650: E2C6     78         	MOV		A,B			; B has the question mark count 
0651: E2C7     B7         	ORA		A			; set the Z flag for calling routine
0652: E2C8     C9         	RET                
0653: E2C9                	                   
0654: E2C9                ;                   
0655: E2C9                ; DECODENAME -	expands the name/ext to all 8/3 characters by either padding with SPACES
0656: E2C9                ;				or, replaceing *'s with ?s for the remainder of the name/ext
0657: E2C9                ;                   
0658: E2C9                DECODENAME:         
0659: E2C9     CD19E2     	CALL	CHECK		; Legal input character ?
0660: E2CC     CAE1E2     	JZ		PADFIELD	; its a delimiter, skip the rest of the name/ext 
0661: E2CF     23         	INX		HL            
0662: E2D0     FE2A       	CPI		ASTRK		; '*'	;note that an '*' will fill the remaining
0663: E2D2     C2DAE2     	JNZ		DECODENAME1	; otherwise move to the next character and process.
0664: E2D5     363F       	MVI		M,QMARK		; '?'
0665: E2D7     C3DCE2     	JMP		DECODENAME2   
0666: E2DA                DECODENAME1:        
0667: E2DA     77         	MOV		M,A			; put character in FCB
0668: E2DB     13         	INX		D			; move to next character in input line buffer
0669: E2DC                DECODENAME2:        
0670: E2DC     05         	DCR		B			; decrement counter
0671: E2DD     C2C9E2     	JNZ		DECODENAME	; loop if not done with fileName
0672: E2E0     C9         	RET					; exit when done!
0673: E2E1                	                   
0674: E2E1                PADFIELD:            
0675: E2E1     23         	INX		H			; blank fill the remaining file name.
0676: E2E2     3620       	MVI		M,BLANK		; store the blank
0677: E2E4     05         	DCR		B			; keep count
0678: E2E5     C2E1E2     	JNZ		PADFIELD		; loop till done
0679: E2E8     C9         	RET					; exit when done!
0680: E2E9                		                  
0681: E2E9                ;                   
0682: E2E9                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0683: E2E9                ;                   
0684: E2E9                NUMCMDS	EQU	6	;number of commands
0685: E2E9                CMDTBL:             
0686: E2E9     44495220   	DB	'DIR '		; 0     
0687: E2ED     45524120   	DB	'ERA '		; 1     
0688: E2F1     54595045   	DB	'TYPE'		; 2     
0689: E2F5     53415645   	DB	'SAVE'		; 3     
0690: E2F9     52454E20   	DB	'REN '		; 4     
0691: E2FD     55534552   	DB	'USER'		; 5     
0692: E301                	;Unknown		; 6      
0693: E301                ;                   
0694: E301                ;   The following six bytes must agree with those at (PATTRN2)
0695: E301                ; or cp/m will HALT. Why?
0696: E301                ;                   
0697: E301                ;PATTRN1:           
0698: E301                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
0699: E301                ;                   
0700: E301                ;   Search the command table for a match with what has just
0701: E301                ; been entered. If a match is found, then we jump to the
0702: E301                ; proper section. Else jump to (UNKNOWN).
0703: E301                ; On return, the (C) register is set to the command number
0704: E301                ; that matched (or NUMCMDS+1 if no match).
0705: E301                ;                   
0706: E301                SEARCH:             
0707: E301     21E9E2     	LXI	H,CMDTBL       
0708: E304     0E00       	MVI	C,0            
0709: E306                SEARCH1:            
0710: E306     79         	MOV	A,C            
0711: E307     FE06       	CPI	NUMCMDS	;this commands exists.
0712: E309     D0         	RNC                
0713: E30A     119EE7     	LXI	D,FCB+1	;check this one.
0714: E30D     0604       	MVI	B,4	;max command length.
0715: E30F                SEARCH2:            
0716: E30F     1A         	LDAX	D             
0717: E310     BE         	CMP	M              
0718: E311     C222E3     	JNZ	SEARCH3	;not a match.
0719: E314     13         	INX	D              
0720: E315     23         	INX	H              
0721: E316     05         	DCR	B              
0722: E317     C20FE3     	JNZ	SEARCH2        
0723: E31A     1A         	LDAX	D	;allow a 3 character command to match.
0724: E31B     FE20       	CPI	BLANK          
0725: E31D     C227E3     	JNZ	SEARCH4        
0726: E320     79         	MOV	A,C	;set return register for this command.
0727: E321     C9         	RET                
0728: E322                SEARCH3:            
0729: E322     23         	INX	H              
0730: E323     05         	DCR	B              
0731: E324     C222E3     	JNZ	SEARCH3        
0732: E327                SEARCH4:            
0733: E327     0C         	INR	C              
0734: E328     C306E3     	JMP	SEARCH1        
0735: E32B                ;                   
0736: E32B                ;   Set the input buffer to empty and then start the command
0737: E32B                ; processor (ccp).  
0738: E32B                ;                   
0739: E32B                CLEARBUF:           
0740: E32B     AF         XRA	A               
0741: E32C     3207E0     	STA	InBuffCount			;second byte is actual length.
0742: E32F                ;                   
0743: E32F                ;**************************************************************
0744: E32F                ;*                  
0745: E32F                ;*                  
0746: E32F                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0747: E32F                ;*                  
0748: E32F                ;                   
0749: E32F                ;   On entry (C) points at Current disk & user (defaultDisk 0004)
0750: E32F                ;**************************************************************
0751: E32F                ;*                  
0752: E32F                COMMAND:            
0753: E32F     317BE7     	LXI			SP,CCPStack				; Use dedicated stack space.
0754: E332     C5         	PUSH		B						; (C) should be equal to currentDisk where:
0755: E333     79         	MOV			A,C						; (uuuudddd) where 'uuuu' is the user number
0756: E334     1F         	RAR									; and 'dddd' is the drive number.
0757: E335     1F         	RAR                
0758: E336     1F         	RAR                
0759: E337     1F         	RAR                
0760: E338     E60F       	ANI			0FH						; isolate the user number.
0761: E33A     5F         	MOV			E,A						; put into E for call
0762: E33B     CD12E1     	CALL	GETSETUC					; to the current user
0763: E33E     CDB5E0     	CALL	RESDSK						;reset the disk system.
0764: E341     327BE7     	STA	BATCH	;clear batch mode flag.
0765: E344     C1         	POP	B              
0766: E345     79         	MOV	A,C            
0767: E346     E60F       	ANI	0FH	;isolate the drive number.
0768: E348     32BFE7     	STA	CDRIVE	;and save.
0769: E34B     CDBAE0     	CALL	DSKSEL	;...and select.
0770: E34E     3A07E0     	LDA	InBuffCount    
0771: E351     B7         	ORA	A	;anything in input buffer already?
0772: E352     C26BE3     	JNZ	CMMND2	;yes, we just process it.
0773: E355                ;                   
0774: E355                ;   Entry point to get a command line from the console.
0775: E355                ;                   
0776: E355                CMMND1:             
0777: E355     317BE7     	LXI	SP,CCPStack;set stack straight.
0778: E358     CD95E0     	CALL	CRLF	;start a new line on the screen.
0779: E35B     CDCDE1     	CALL	GETDSK	;get current drive.
0780: E35E     C661       	ADI	061H		; 'a'    
0781: E360     CD89E0     	CALL	PRINT	;print current drive.
0782: E363     3E3E       	MVI	A,GRTTHAN	; '>'
0783: E365     CD89E0     	CALL	PRINT	;and add prompt.
0784: E368     CD36E1     	CALL	GETINP	;get line from user.
0785: E36B                ;                   
0786: E36B                ;   Process command line here.
0787: E36B                ;                   
0788: E36B                CMMND2:             
0789: E36B     118000     	LXI	D,Pg0Buffer    
0790: E36E     CDD5E1     	CALL	DMASET	;set standard dma address.
0791: E371     CDCDE1     	CALL	GETDSK        
0792: E374     32BFE7     	STA	CDRIVE	;set current drive.
0793: E377     CD47E2     	CALL	CONVFST	;convert name typed in.
0794: E37A     C4F2E1     	CNZ	SYNERR	;wild cards are not allowed.
0795: E37D     3AC0E7     	LDA	CHGDRV	;if a change in drives was indicated,
0796: E380     B7         	ORA	A	;then treat this as an unknown command
0797: E381     C278E6     	JNZ	UNKNOWN	;which gets executed.
0798: E384     CD01E3     	CALL	SEARCH	;else search command table for a match.
0799: E387                ;                   
0800: E387                ;   Note that an unknown command returns
0801: E387                ; with (A) pointing to the last address
0802: E387                ; in our table which is (UNKNOWN).
0803: E387                ;                   
0804: E387     2194E3     	LXI	H,CMDADR;now, look thru our address table for command (A).
0805: E38A     5F         	MOV	E,A	;set (DE) to command number.
0806: E38B     1600       	MVI	D,0            
0807: E38D     19         	DAD	D              
0808: E38E     19         	DAD	D	;(HL)=(CMDADR)+2*(command number).
0809: E38F     7E         	MOV	A,M	;now pick out this address.
0810: E390     23         	INX	H              
0811: E391     66         	MOV	H,M            
0812: E392     6F         	MOV	L,A            
0813: E393     E9         	PCHL		;now execute it.
0814: E394                ;                   
0815: E394                ;   CP/M command address table.
0816: E394                ;                   
0817: E394                CMDADR:             
0818: E394     4AE4       	DW	DIRECT		; 0     
0819: E396     F2E4       	DW	ERASE		; 1      
0820: E398     30E5       	DW	TYPE		; 2       
0821: E39A     80E5       	DW	SAVE		; 3       
0822: E39C     E3E5       	DW	RENAME		; 4     
0823: E39E     61E6       	DW	USER		; 5       
0824: E3A0     78E6       	DW	UNKNOWN		; 6    
0825: E3A2                ;                   
0826: E3A2                ;   Halt the system. Reason for this is unknown at present.
0827: E3A2                ;                   
0828: E3A2                HALT:               
0829: E3A2     21F376     	LXI	H,76F3H	;'DI HLT' instructions.
0830: E3A5     2200E0     	SHLD	CBASE         
0831: E3A8     2100E0     	LXI	H,CBASE        
0832: E3AB     E9         	PCHL               
0833: E3AC                ;                   
0834: E3AC                ;   Read error while TYPEing a file.
0835: E3AC                ;                   
0836: E3AC                RDERROR:            
0837: E3AC     01B2E3     	LXI	B,RDERR        
0838: E3AF     C3A4E0     	JMP	PLINE          
0839: E3B2                RDERR:              
0840: E3B2     52454144204552524F5200 	DB	'Read error',0  
0841: E3BD                ;                   
0842: E3BD                ;   Required file was not located.
0843: E3BD                ;                   
0844: E3BD                                    
0845: E3BD                NONE:               
0846: E3BD     01C3E3     	LXI	B,NOFILE       
0847: E3C0     C3A4E0     	JMP	PLINE          
0848: E3C3                NOFILE:             
0849: E3C3     4E4F2046494C4500 	DB	'No file',0     
0850: E3CB                ;                   
0851: E3CB                ;   Decode a command of the form 'A>filename number{ filename}.
0852: E3CB                ; Note that a drive specifier is not allowed on the first file
0853: E3CB                ; name. On return, the number is in register (A). Any error
0854: E3CB                ; causes 'filename?' to be printed and the command is aborted.
0855: E3CB                ;                   
0856: E3CB                DECODE:             
0857: E3CB     CD47E2     	CALL	CONVFST		;convert first filename.
0858: E3CE     3AC0E7     	LDA		CHGDRV		;do not allow a drive to be specified.
0859: E3D1     B7         	ORA		A             
0860: E3D2     C2F2E1     	JNZ		SYNERR		; exit with a syntax error
0861: E3D5     219EE7     	LXI		H,FCB+1		;convert number now.
0862: E3D8     010B00     	LXI		B,11		;(B)=sum register, (C)=max digit count.
0863: E3DB                DECODE1:            
0864: E3DB     7E         	MOV		A,M			; get the caracter from the CCP FCB
0865: E3DC     FE20       	CPI		BLANK		; a space terminates the numeral.
0866: E3DE     CA06E4     	JZ		PADNUMBER	; skip, the rest must be blanks
0867: E3E1     23         	INX		H			; bump pointer
0868: E3E2     D630       	SUI		030H  		; '0'	make binary from ascii. ZERO ????
0869: E3E4     FE0A       	CPI		10			; legal digit?
0870: E3E6     D2F2E1     	JNC		SYNERR		; exit with syntax error
0871: E3E9     57         	MOV		D,A			; yes, save the number in (D).
0872: E3EA                	;                  
0873: E3EA     78         	MOV		A,B			; compute (B)=(B)*10 and check for overflow.
0874: E3EB     E6E0       	ANI		0E0H          
0875: E3ED     C2F2E1     	JNZ		SYNERR		; Exit with math overflow error??
0876: E3F0     78         	MOV		A,B           
0877: E3F1     07         	RLC                
0878: E3F2     07         	RLC                
0879: E3F3     07         	RLC					;(A)=(B)*8 
0880: E3F4     80         	ADD		B			;.......*9
0881: E3F5     DAF2E1     	JC		SYNERR		; Exit with math overflow error??	
0882: E3F8     80         	ADD		B			;.......*10
0883: E3F9     DAF2E1     	JC		SYNERR		; Exit with math overflow error??
0884: E3FC     82         	ADD		D			;	add in new digit now.
0885: E3FD     DAF2E1     	JC		SYNERR		; Exit with math overflow error??
0886: E400     47         	MOV		B,A			;	and save result in B (subtotal)
0887: E401     0D         	DCR		C			;	only look at 11 digits.
0888: E402     C2DBE3     	JNZ		DECODE1       
0889: E405     C9         	RET					; return with value in (A)
0890: E406                PADNUMBER:          
0891: E406     7E         	MOV		A,M			; spaces must follow (why?).
0892: E407     FE20       	CPI		BLANK		; is it a blank
0893: E409     C2F2E1     	JNZ		SYNERR		; exit with syntax error
0894: E40C     23         	INX		H			; point at next
0895: E40D     0D         	DCR		C             
0896: E40E     C206E4     	JNZ		PADNUMBER	; loop till done
0897: E411     78         	MOV		A,B			;set (A)=the numeric value entered.
0898: E412     C9         	RET                
0899: E413                ;                   
0900: E413                ;   Move 3 bytes from (HL) to (DE). Note that there is only
0901: E413                ; one reference to this at (A2D5h).
0902: E413                ;                   
0903: E413                MOVE3:              
0904: E413     0603       	MVI	B,3            
0905: E415                ;                   
0906: E415                ;   Move (B) bytes from (HL) to (DE).
0907: E415                ;                   
0908: E415                HL2DE:              
0909: E415     7E         	MOV	A,M            
0910: E416     12         	STAX	D             
0911: E417     23         	INX	H              
0912: E418     13         	INX	D              
0913: E419     05         	DCR	B              
0914: E41A     C215E4     	JNZ	HL2DE          
0915: E41D     C9         	RET                
0916: E41E                ;                   
0917: E41E                ;   Compute (HL)=(Pg0Buffer)+(A)+(C) and get the byte that's here.
0918: E41E                ;                   
0919: E41E                EXTRACT:            
0920: E41E     218000     	LXI	H,Pg0Buffer    
0921: E421     81         	ADD	C              
0922: E422     CD42E2     	CALL	ADDHL         
0923: E425     7E         	MOV	A,M            
0924: E426     C9         	RET                
0925: E427                ;                   
0926: E427                ;  Check drive specified. If it means a change, then the new
0927: E427                ; drive will be selected. In any case, the drive byte of the
0928: E427                ; fcb will be set to null (means use current drive).
0929: E427                ;                   
0930: E427                DSELECT:            
0931: E427     AF         	XRA		A             
0932: E428     329DE7     	STA		FCB				; null out first byte of fcb.
0933: E42B     3AC0E7     	LDA		CHGDRV			; is a drive change indicated?
0934: E42E     B7         	ORA		A             
0935: E42F     C8         	RZ						; No, drive OK
0936: E430     3D         	DCR		A				; yes, is it the same as the current drive?
0937: E431     21BFE7     	LXI		H,CDRIVE      
0938: E434     BE         	CMP		M				; FCB drive number same as this?
0939: E435     C8         	RZ						; Yes, return 					
0940: E436     C3BAE0     	JMP		DSKSEL			;	no. Select it then.
0941: E439                ;                   
0942: E439                ;   Check the drive selection and reset it to the previous
0943: E439                ; drive if it was changed for the preceeding command.
0944: E439                ;                   
0945: E439                RESETDR:            
0946: E439     3AC0E7     	LDA	CHGDRV	;drive change indicated?
0947: E43C     B7         	ORA	A              
0948: E43D     C8         	RZ                 
0949: E43E     3D         	DCR	A	;yes, was it a different drive?
0950: E43F     21BFE7     	LXI	H,CDRIVE       
0951: E442     BE         	CMP	M              
0952: E443     C8         	RZ                 
0953: E444     3ABFE7     	LDA	CDRIVE	;yes, re-select our old drive.
0954: E447     C3BAE0     	JMP	DSKSEL         
0955: E44A                ;                   
0956: E44A                ;**************************************************************
0957: E44A                ;*                  
0958: E44A                ;*           D I R E C T O R Y   C O M M A N D
0959: E44A                ;*                  
0960: E44A                ;**************************************************************
0961: E44A                ;                   
0962: E44A                DIRECT:             
0963: E44A     CD47E2     	CALL	CONVFST	;convert file name.
0964: E44D     CD27E4     	CALL	DSELECT	;select indicated drive.
0965: E450     219EE7     	LXI	H,FCB+1	;was any file indicated?
0966: E453     7E         	MOV	A,M            
0967: E454     FE20       	CPI	BLANK          
0968: E456     C262E4     	JNZ	DIRECT2        
0969: E459     060B       	MVI	B,11	;no. Fill field with '?' - same as *.*.
0970: E45B                DIRECT1:            
0971: E45B     363F       	MVI	M,QMARK		; '?' 
0972: E45D     23         	INX	H              
0973: E45E     05         	DCR	B              
0974: E45F     C25BE4     	JNZ	DIRECT1        
0975: E462                DIRECT2:            
0976: E462     1E00       	MVI	E,0	;set initial cursor position.
0977: E464     D5         	PUSH	D             
0978: E465     CDE6E0     	CALL	SRCHFCB	;get first file name.
0979: E468     CCBDE3     	CZ	NONE	;none found at all?
0980: E46B                DIRECT3:            
0981: E46B     CAEEE4     	JZ	DIRECT9	;terminate if no more names.
0982: E46E     3ABEE7     	LDA	RTNCODE	;get file's position in segment (0-3).
0983: E471     0F         	RRC                
0984: E472     0F         	RRC                
0985: E473     0F         	RRC                
0986: E474     E660       	ANI	60H	;(A)=position*32
0987: E476     4F         	MOV	C,A            
0988: E477     3E0A       	MVI	A,10           
0989: E479     CD1EE4     	CALL	EXTRACT	;extract the tenth entry in fcb.
0990: E47C     17         	RAL		;check system file status bit.
0991: E47D     DAE2E4     	JC	DIRECT8	;we don't list them.
0992: E480     D1         	POP	D              
0993: E481     7B         	MOV	A,E	;bump name count.
0994: E482     1C         	INR	E              
0995: E483     D5         	PUSH	D             
0996: E484     E603       	ANI	03H	;at end of line?
0997: E486     F5         	PUSH	PSW           
0998: E487     C29FE4     	JNZ	DIRECT4        
0999: E48A     CD95E0     	CALL	CRLF	;yes, end this line and start another.
1000: E48D     C5         	PUSH	B             
1001: E48E     CDCDE1     	CALL	GETDSK	;start line with ('A:').
1002: E491     C1         	POP	B              
1003: E492     C641       	ADI	041H	; 'A'     
1004: E494     CD8FE0     	CALL	PRINTB        
1005: E497     3E3A       	MVI	A, COLON		; ':'
1006: E499     CD8FE0     	CALL	PRINTB        
1007: E49C     C3A7E4     	JMP	DIRECT5        
1008: E49F                DIRECT4:            
1009: E49F     CD9FE0     	CALL	SPACE	;add seperator between file names.
1010: E4A2     3E3A       	MVI	A, COLON	;':'  
1011: E4A4     CD8FE0     	CALL	PRINTB        
1012: E4A7                DIRECT5:            
1013: E4A7     CD9FE0     	CALL	SPACE         
1014: E4AA     0601       	MVI	B,1	;'extract' each file name character at a time.
1015: E4AC                DIRECT6:            
1016: E4AC     78         	MOV	A,B            
1017: E4AD     CD1EE4     	CALL	EXTRACT       
1018: E4B0     E67F       	ANI	7FH	;strip bit 7 (status bit).
1019: E4B2     FE20       	CPI	BLANK	;are we at the end of the name?
1020: E4B4     C2CCE4     	JNZ	DRECT65        
1021: E4B7     F1         	POP	PSW	;yes, don't print spaces at the end of a line.
1022: E4B8     F5         	PUSH	PSW           
1023: E4B9     FE03       	CPI	3              
1024: E4BB     C2CAE4     	JNZ	DRECT63        
1025: E4BE     3E09       	MVI	A,9	;first check for no extension.
1026: E4C0     CD1EE4     	CALL	EXTRACT       
1027: E4C3     E67F       	ANI	7FH            
1028: E4C5     FE20       	CPI	BLANK          
1029: E4C7     CAE1E4     	JZ	DIRECT7	;don't print spaces.
1030: E4CA                DRECT63:            
1031: E4CA     3E20       	MVI	A,BLANK	;else print them.
1032: E4CC                DRECT65:            
1033: E4CC     CD8FE0     	CALL	PRINTB        
1034: E4CF     04         	INR	B	;bump to next character psoition.
1035: E4D0     78         	MOV	A,B            
1036: E4D1     FE0C       	CPI	12	;end of the name?
1037: E4D3     D2E1E4     	JNC	DIRECT7        
1038: E4D6     FE09       	CPI	9	;nope, starting extension?
1039: E4D8     C2ACE4     	JNZ	DIRECT6        
1040: E4DB     CD9FE0     	CALL	SPACE	;yes, add seperating space.
1041: E4DE     C3ACE4     	JMP	DIRECT6        
1042: E4E1                DIRECT7:            
1043: E4E1     F1         	POP	PSW	;get the next file name.
1044: E4E2                DIRECT8:            
1045: E4E2     CDBFE1     	CALL	CHKCON	;first check console, quit on anything.
1046: E4E5     C2EEE4     	JNZ	DIRECT9        
1047: E4E8     CDE1E0     	CALL	SRCHNXT	;get next name.
1048: E4EB     C36BE4     	JMP	DIRECT3	;and continue with our list.
1049: E4EE                DIRECT9:            
1050: E4EE     D1         	POP	D	;restore the stack and return to command level.
1051: E4EF     C356E7     	JMP	GETBACK        
1052: E4F2                ;                   
1053: E4F2                ;**************************************************************
1054: E4F2                ;*                  
1055: E4F2                ;*                E R A S E   C O M M A N D
1056: E4F2                ;*                  
1057: E4F2                ;**************************************************************
1058: E4F2                ;                   
1059: E4F2                ERASE:              
1060: E4F2     CD47E2     	CALL	CONVFST	;convert file name.
1061: E4F5     FE0B       	CPI	11	;was '*.*' entered?
1062: E4F7     C215E5     	JNZ	ERASE1         
1063: E4FA     0125E5     	LXI	B,YESNO	;yes, ask for confirmation.
1064: E4FD     CDA4E0     	CALL	PLINE         
1065: E500     CD36E1     	CALL	GETINP        
1066: E503     2107E0     	LXI	H,InBuffCount  
1067: E506     35         	DCR	M	;must be exactly 'y'.
1068: E507     C255E3     	JNZ	CMMND1         
1069: E50A     23         	INX	H              
1070: E50B     7E         	MOV	A,M            
1071: E50C     FE59       	CPI	059H	; 'Y'     
1072: E50E     C255E3     	JNZ	CMMND1         
1073: E511     23         	INX	H              
1074: E512     2285E0     	SHLD	INPOINT	;save input line pointer.
1075: E515                ERASE1:             
1076: E515     CD27E4     	CALL	DSELECT	;select desired disk.
1077: E518     119DE7     	LXI	D,FCB          
1078: E51B     CDECE0     	CALL	DELETE	;delete the file.
1079: E51E     3C         	INR	A              
1080: E51F     CCBDE3     	CZ	NONE	;not there?
1081: E522     C356E7     	JMP	GETBACK	;return to command level now.
1082: E525                YESNO:              
1083: E525     414C4C2028592F4E293F00 	DB	'All (y/n)?',0  
1084: E530                ;                   
1085: E530                ;**************************************************************
1086: E530                ;*                  
1087: E530                ;*            T Y P E   C O M M A N D
1088: E530                ;*                  
1089: E530                ;**************************************************************
1090: E530                ;                   
1091: E530                TYPE:               
1092: E530     CD47E2     	CALL	CONVFST	;convert file name.
1093: E533     C2F2E1     	JNZ	SYNERR	;wild cards not allowed.
1094: E536     CD27E4     	CALL	DSELECT	;select indicated drive.
1095: E539     CDCDE0     	CALL	OPENFCB	;open the file.
1096: E53C     CA7AE5     	JZ	TYPE5	;not there?
1097: E53F     CD95E0     	CALL	CRLF	;ok, start a new line on the screen.
1098: E542     21C1E7     	LXI	H,NBYTES;initialize byte counter.
1099: E545     36FF       	MVI	M,0FFH	;set to read first sector.
1100: E547                TYPE1:              
1101: E547     21C1E7     	LXI	H,NBYTES       
1102: E54A                TYPE2:              
1103: E54A     7E         	MOV	A,M	;have we written the entire sector?
1104: E54B     FE80       	CPI	128            
1105: E54D     DA5AE5     	JC	TYPE3           
1106: E550     E5         	PUSH	H	;yes, read in the next one.
1107: E551     CDFBE0     	CALL	READFCB       
1108: E554     E1         	POP	H              
1109: E555     C273E5     	JNZ	TYPE4	;end or error?
1110: E558     AF         	XRA	A	;ok, clear byte counter.
1111: E559     77         	MOV	M,A            
1112: E55A                TYPE3:              
1113: E55A     34         	INR	M	;count this byte.
1114: E55B     218000     	LXI	H,Pg0Buffer	;and get the (A)th one from the buffer (Pg0Buffer).
1115: E55E     CD42E2     	CALL	ADDHL         
1116: E561     7E         	MOV	A,M            
1117: E562     FE1A       	CPI	CNTRLZ	;end of file mark?
1118: E564     CA56E7     	JZ	GETBACK         
1119: E567     CD89E0     	CALL	PRINT	;no, print it.
1120: E56A     CDBFE1     	CALL	CHKCON	;check console, quit if anything ready.
1121: E56D     C256E7     	JNZ	GETBACK        
1122: E570     C347E5     	JMP	TYPE1          
1123: E573                ;                   
1124: E573                ;   Get here on an end of file or read error.
1125: E573                ;                   
1126: E573                TYPE4:              
1127: E573     3D         	DCR	A	;read error? 
1128: E574     CA56E7     	JZ	GETBACK         
1129: E577     CDACE3     	CALL	RDERROR	;yes, print message.
1130: E57A                TYPE5:              
1131: E57A     CD39E4     	CALL	RESETDR	;and reset proper drive
1132: E57D     C3F2E1     	JMP	SYNERR	;now print file name with problem.
1133: E580                ;                   
1134: E580                ;**************************************************************
1135: E580                ;*                  
1136: E580                ;*            S A V E   C O M M A N D
1137: E580                ;*                  
1138: E580                ;**************************************************************
1139: E580                ;                   
1140: E580                SAVE:               
1141: E580     CDCBE3     	CALL	DECODE		; get numeric number that follows SAVE.
1142: E583     F5         	PUSH	PSW			; save number of pages to write.
1143: E584     CD47E2     	CALL	CONVFST		; convert file name linepointer past the number.
1144: E587     C2F2E1     	JNZ		SYNERR		; exit with syntax error -wild cards not allowed.
1145: E58A     CD27E4     	CALL	DSELECT		; select specified drive.
1146: E58D     119DE7     	LXI		D,FCB		; now delete this file.
1147: E590     D5         	PUSH	D			; save the fcb
1148: E591     CDECE0     	CALL	DELETE        
1149: E594     D1         	POP		D             
1150: E595     CD06E1     	CALL	CREATE		;and create it again.
1151: E598     CACEE5     	JZ		SAVE3		;can't create?
1152: E59B     AF         	XRA		A			;clear record number byte.
1153: E59C     32BDE7     	STA		FCB+32        
1154: E59F     F1         	POP		PSW			;convert pages to sectors.
1155: E5A0     6F         	MOV		L,A           
1156: E5A1     2600       	MVI		H,0           
1157: E5A3     29         	DAD		H			;(HL)=number of sectors to write.
1158: E5A4     110001     	LXI		D,TBASE		;and we start from here.
1159: E5A7                SAVE1:              
1160: E5A7     7C         	MOV		A,H			;done yet?
1161: E5A8     B5         	ORA		L             
1162: E5A9     CAC4E5     	JZ		SAVE2          
1163: E5AC     2B         	DCX		H			;nope, count this and compute the start
1164: E5AD     E5         	PUSH	H			;of the next 128 byte sector.
1165: E5AE     218000     	LXI		H,128         
1166: E5B1     19         	DAD		D             
1167: E5B2     E5         	PUSH	H			;save it and set the transfer address.
1168: E5B3     CDD5E1     	CALL	DMASET        
1169: E5B6     119DE7     	LXI		D,FCB		;write out this sector now.
1170: E5B9     CD01E1     	CALL	WRTREC        
1171: E5BC     D1         	POP		D			;reset (DE) to the start of the last sector.
1172: E5BD     E1         	POP		H			;restore sector count.
1173: E5BE     C2CEE5     	JNZ		SAVE3		;write error?
1174: E5C1     C3A7E5     	JMP		SAVE1         
1175: E5C4                ;                   
1176: E5C4                ;   Get here after writing all of the file.
1177: E5C4                ;                   
1178: E5C4                SAVE2:              
1179: E5C4     119DE7     	LXI		D,FCB		;now close the file.
1180: E5C7     CDD7E0     	CALL	CLOSE         
1181: E5CA     3C         	INR		A			;did it close ok?
1182: E5CB     C2D4E5     	JNZ		SAVE4         
1183: E5CE                ;                   
1184: E5CE                ;   Print out error message (no space).
1185: E5CE                ;                   
1186: E5CE                SAVE3:              
1187: E5CE     01DAE5     	LXI		B,NOSPACE     
1188: E5D1     CDA4E0     	CALL	PLINE         
1189: E5D4                SAVE4:              
1190: E5D4     CDD2E1     	CALL	STDDMA		;reset the standard dma address.
1191: E5D7     C356E7     	JMP		GETBACK       
1192: E5DA                NOSPACE:            
1193: E5DA     4E4F20535041434500 	DB	'No space',0    
1194: E5E3                ;                   
1195: E5E3                ;**************************************************************
1196: E5E3                ;*                  
1197: E5E3                ;*           R E N A M E   C O M M A N D
1198: E5E3                ;*                  
1199: E5E3                ;**************************************************************
1200: E5E3                ;                   
1201: E5E3                RENAME:             
1202: E5E3     CD47E2     	CALL	CONVFST	;convert first file name.
1203: E5E6     C2F2E1     	JNZ	SYNERR	;wild cards not allowed.
1204: E5E9     3AC0E7     	LDA	CHGDRV	;remember any change in drives specified.
1205: E5EC     F5         	PUSH	PSW           
1206: E5ED     CD27E4     	CALL	DSELECT	;and select this drive.
1207: E5F0     CDE6E0     	CALL	SRCHFCB	;is this file present?
1208: E5F3     C24CE6     	JNZ	RENAME6	;yes, print error message.
1209: E5F6     219DE7     	LXI	H,FCB	;yes, move this name into second slot.
1210: E5F9     11ADE7     	LXI	D,FCB+16       
1211: E5FC     0610       	MVI	B,16           
1212: E5FE     CD15E4     	CALL	HL2DE         
1213: E601     2A85E0     	LHLD	INPOINT	;get input pointer.
1214: E604     EB         	XCHG               
1215: E605     CD38E2     	CALL	NONBLANK;get next non blank character.
1216: E608     FE3D       	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1217: E60A     CA12E6     	JZ	RENAME1         
1218: E60D     FE5F       	CPI	USCORE		; '_'  
1219: E60F     C246E6     	JNZ	RENAME5        
1220: E612                RENAME1:            
1221: E612     EB         	XCHG               
1222: E613     23         	INX	H	;ok, skip seperator.
1223: E614     2285E0     	SHLD	INPOINT	;save input line pointer.
1224: E617     CD47E2     	CALL	CONVFST	;convert this second file name now.
1225: E61A     C246E6     	JNZ	RENAME5	;again, no wild cards.
1226: E61D     F1         	POP	PSW	;if a drive was specified, then it
1227: E61E     47         	MOV	B,A	;must be the same as before.
1228: E61F     21C0E7     	LXI	H,CHGDRV       
1229: E622     7E         	MOV	A,M            
1230: E623     B7         	ORA	A              
1231: E624     CA2CE6     	JZ	RENAME2         
1232: E627     B8         	CMP	B              
1233: E628     70         	MOV	M,B            
1234: E629     C246E6     	JNZ	RENAME5	;they were different, error.
1235: E62C                RENAME2:            
1236: E62C     70         	MOV	M,B;	reset as per the first file specification.
1237: E62D     AF         	XRA	A              
1238: E62E     329DE7     	STA	FCB	;clear the drive byte of the fcb.
1239: E631                RENAME3:            
1240: E631     CDE6E0     	CALL	SRCHFCB	;and go look for second file.
1241: E634     CA40E6     	JZ	RENAME4	;doesn't exist?
1242: E637     119DE7     	LXI	D,FCB          
1243: E63A     CD0BE1     	CALL	RENAM	;ok, rename the file.
1244: E63D     C356E7     	JMP	GETBACK        
1245: E640                ;                   
1246: E640                ;   Process rename errors here.
1247: E640                ;                   
1248: E640                RENAME4:            
1249: E640     CDBDE3     	CALL	NONE	;file not there.
1250: E643     C356E7     	JMP	GETBACK        
1251: E646                RENAME5:            
1252: E646     CD39E4     	CALL	RESETDR	;bad command format.
1253: E649     C3F2E1     	JMP	SYNERR         
1254: E64C                RENAME6:            
1255: E64C     0155E6     	LXI	B,EXISTS;destination file already exists.
1256: E64F     CDA4E0     	CALL	PLINE         
1257: E652     C356E7     	JMP	GETBACK        
1258: E655                EXISTS:             
1259: E655     46494C452045584953545300 	DB	'File exists',0 
1260: E661                ;                   
1261: E661                ;**************************************************************
1262: E661                ;*                  
1263: E661                ;*             U S E R   C O M M A N D
1264: E661                ;*                  
1265: E661                ;**************************************************************
1266: E661                ;                   
1267: E661                USER:               
1268: E661     CDCBE3     	CALL	DECODE	;get numeric value following command.
1269: E664     FE10       	CPI	16	;legal user number?
1270: E666     D2F2E1     	JNC	SYNERR         
1271: E669     5F         	MOV	E,A	;yes but is there anything else?
1272: E66A     3A9EE7     	LDA	FCB+1          
1273: E66D     FE20       	CPI	BLANK          
1274: E66F     CAF2E1     	JZ	SYNERR	;yes, that is not allowed.
1275: E672     CD12E1     	CALL	GETSETUC;ok, set user code.
1276: E675     C359E7     	JMP	GETBACK1       
1277: E678                ;                   
1278: E678                ;**************************************************************
1279: E678                ;*                  
1280: E678                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1281: E678                ;*                  
1282: E678                ;**************************************************************
1283: E678                ;                   
1284: E678                UNKNOWN:            
1285: E678                ;e68b	CALL	VERIFY	;check for valid system (why?).
1286: E678     3A9EE7     	LDA		FCB+1		;anything to execute?
1287: E67B     FE20       	CPI		BLANK		; is it a Space?
1288: E67D     C294E6     	JNZ		UNKWN1        
1289: E680     3AC0E7     	LDA		CHGDRV		; No, only a drive change?
1290: E683     B7         	ORA		A			; Is itEmpty (00)
1291: E684     CA59E7     	JZ		GETBACK1	; Yes, get otta here?
1292: E687     3D         	DCR		A             
1293: E688     32BFE7     	STA	CDRIVE	;ok, store new drive.
1294: E68B     CD26E1     	CALL	MOVECD	;set (TDRIVE) also.
1295: E68E     CDBAE0     	CALL	DSKSEL	;and select this drive.
1296: E691     C359E7     	JMP	GETBACK1;then return.
1297: E694                ;                   
1298: E694                ;   Here a file name was typed. Prepare to execute it.
1299: E694                ;                   
1300: E694                UNKWN1:             
1301: E694     11A6E7     	LXI	D,FCB+9	;an extension specified?
1302: E697     1A         	LDAX	D             
1303: E698     FE20       	CPI	BLANK          
1304: E69A     C2F2E1     	JNZ	SYNERR	;yes, not allowed.
1305: E69D                UNKWN2:             
1306: E69D     D5         	PUSH	D             
1307: E69E     CD27E4     	CALL	DSELECT	;select specified drive.
1308: E6A1     D1         	POP	D              
1309: E6A2     2153E7     	LXI	H,COMFILE	;set the extension to 'COM'.
1310: E6A5     CD13E4     	CALL	MOVE3         
1311: E6A8     CDCDE0     	CALL	OPENFCB	;and open this file.
1312: E6AB     CA3BE7     	JZ	UNKWN9	;not present?
1313: E6AE                ;                   
1314: E6AE                ;   Load in the program.
1315: E6AE                ;                   
1316: E6AE     210001     	LXI	H,TBASE	;store the program starting here.
1317: E6B1                UNKWN3:             
1318: E6B1     E5         	PUSH	H             
1319: E6B2     EB         	XCHG               
1320: E6B3     CDD5E1     	CALL	DMASET	;set transfer address.
1321: E6B6     119DE7     	LXI	D,FCB	;and read the next record.
1322: E6B9     CDF6E0     	CALL	RDREC         
1323: E6BC     C2D1E6     	JNZ	UNKWN4	;end of file or read error?
1324: E6BF     E1         	POP	H	;nope, bump pointer for next sector.
1325: E6C0     118000     	LXI	D,128          
1326: E6C3     19         	DAD	D              
1327: E6C4     1100E0     	LXI	D,CBASE	;enough room for the whole file?
1328: E6C7     7D         	MOV	A,L            
1329: E6C8     93         	SUB	E              
1330: E6C9     7C         	MOV	A,H            
1331: E6CA     9A         	SBB	D              
1332: E6CB     D241E7     	JNC	UNKWN0	;no, it can't fit.
1333: E6CE     C3B1E6     	JMP	UNKWN3         
1334: E6D1                ;                   
1335: E6D1                ;   Get here after finished reading.
1336: E6D1                ;                   
1337: E6D1                UNKWN4:             
1338: E6D1     E1         	POP	H              
1339: E6D2     3D         	DCR	A	;normal end of file?
1340: E6D3     C241E7     	JNZ	UNKWN0         
1341: E6D6     CD39E4     	CALL	RESETDR	;yes, reset previous drive.
1342: E6D9     CD47E2     	CALL	CONVFST	;convert the first file name that follows
1343: E6DC     21C0E7     	LXI	H,CHGDRV;command name.
1344: E6DF     E5         	PUSH	H             
1345: E6E0     7E         	MOV	A,M	;set drive code in default fcb.
1346: E6E1     329DE7     	STA	FCB            
1347: E6E4     3E10       	MVI	A,16	;put second name 16 bytes later.
1348: E6E6     CD49E2     	CALL	CONVERT	;convert second file name.
1349: E6E9     E1         	POP	H              
1350: E6EA     7E         	MOV	A,M	;and set the drive for this second file.
1351: E6EB     32ADE7     	STA	FCB+16         
1352: E6EE     AF         	XRA	A	;clear record byte in fcb.
1353: E6EF     32BDE7     	STA	FCB+32         
1354: E6F2     115C00     	LXI	D,TFCB	;move it into place at(005Ch).
1355: E6F5     219DE7     	LXI	H,FCB          
1356: E6F8     0621       	MVI	B,33           
1357: E6FA     CD15E4     	CALL	HL2DE         
1358: E6FD     2108E0     	LXI	H,InBuff			;now move the remainder of the input
1359: E700                UNKWN5:             
1360: E700     7E         	MOV	A,M	;line down to (0080h). Look for a non blank.
1361: E701     B7         	ORA	A	;or a null.  
1362: E702     CA0EE7     	JZ	UNKWN6          
1363: E705     FE20       	CPI	BLANK          
1364: E707     CA0EE7     	JZ	UNKWN6          
1365: E70A     23         	INX	H              
1366: E70B     C300E7     	JMP	UNKWN5         
1367: E70E                ;                   
1368: E70E                ;   Do the line move now. It ends in a null byte.
1369: E70E                ;                   
1370: E70E                UNKWN6:             
1371: E70E     0600       	MVI	B,0	;keep a character count.
1372: E710     118100     	LXI	D,Pg0Buffer+1;data gets put here.
1373: E713                UNKWN7:             
1374: E713     7E         	MOV	A,M	;move it now.
1375: E714     12         	STAX	D             
1376: E715     B7         	ORA	A              
1377: E716     CA1FE7     	JZ	UNKWN8          
1378: E719     04         	INR	B              
1379: E71A     23         	INX	H              
1380: E71B     13         	INX	D              
1381: E71C     C313E7     	JMP	UNKWN7         
1382: E71F                UNKWN8:             
1383: E71F     78         	MOV	A,B	;now store the character count.
1384: E720     328000     	STA	Pg0Buffer      
1385: E723     CD95E0     	CALL	CRLF	;clean up the screen.
1386: E726     CDD2E1     	CALL	STDDMA	;set standard transfer address.
1387: E729     CD17E1     	CALL	SETCDRV	;reset current drive.
1388: E72C     CD0001     	CALL	TBASE	;and execute the program.
1389: E72F                ;                   
1390: E72F                ;   Transiant programs return here (or reboot).
1391: E72F                ;                   
1392: E72F     317BE7     	LXI	SP,BATCH	;set stack first off.
1393: E732     CD26E1     	CALL	MOVECD	;move current drive into place (TDRIVE).
1394: E735     CDBAE0     	CALL	DSKSEL	;and reselect it.
1395: E738     C355E3     	JMP	CMMND1	;back to comand mode.
1396: E73B                ;                   
1397: E73B                ;   Get here if some error occured.
1398: E73B                ;                   
1399: E73B                UNKWN9:             
1400: E73B     CD39E4     	CALL	RESETDR	;inproper format.
1401: E73E     C3F2E1     	JMP	SYNERR         
1402: E741                UNKWN0:             
1403: E741     014AE7     	LXI	B,BADLOAD;read error or won't fit.
1404: E744     CDA4E0     	CALL	PLINE         
1405: E747     C356E7     	JMP	GETBACK        
1406: E74A                BADLOAD:            
1407: E74A     424144204C4F414400 	DB	'Bad load',0    
1408: E753                COMFILE:            
1409: E753     434F4D     	DB	'COM'	;command file extension.
1410: E756                ;                   
1411: E756                ;   Get here to return to command level. We will reset the
1412: E756                ; previous active drive and then either return to command
1413: E756                ; level directly or print error message and then return.
1414: E756                ;                   
1415: E756                GETBACK:            
1416: E756     CD39E4     	CALL	RESETDR	;reset previous drive.
1417: E759                GETBACK1:           
1418: E759     CD47E2     	CALL	CONVFST	;convert first name in (FCB).
1419: E75C     3A9EE7     	LDA	FCB+1	;if this was just a drive change request,
1420: E75F     D620       	SUI	BLANK	;make sure it was valid.
1421: E761     21C0E7     	LXI	H,CHGDRV       
1422: E764     B6         	ORA	M              
1423: E765     C2F2E1     	JNZ	SYNERR         
1424: E768     C355E3     	JMP	CMMND1	;ok, return to command level.
1425: E76B                ;                   
1426: E76B                ;   ccp stack area. 
1427: E76B                ;                   
1428: E76B     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1429: E77B                CCPStack	EQU	$	;end of ccp stack area.
1430: E77B                ;                   
1431: E77B                ;   Batch (or SUBMIT) processing information storage.
1432: E77B                ;                   
1433: E77B                BATCH:              
1434: E77B     00         	DB	0	;batch mode flag (0=not active).
1435: E77C                BATCHFCB:           
1436: E77C     002424242020202020535542000000000000000000000000000000000000000000 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1437: E79D                ;                   
1438: E79D                ;   File control block setup by the CCP.
1439: E79D                ;                   
1440: E79D                FCB:                
1441: E79D     002020202020202020202020000000000020202020202020202020200000000000 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1442: E7BE                RTNCODE:            
1443: E7BE     00         	DB	0	;status returned from bdos call.
1444: E7BF                CDRIVE:             
1445: E7BF     00         	DB	0	;currently active drive.
1446: E7C0                CHGDRV:             
1447: E7C0     00         	DB	0	;change in drives flag (0=no change).
1448: E7C1                NBYTES:             
1449: E7C1     0000       	DW	0	;byte counter used by TYPE.
1450: E7C3                ;                   
1451: E7C3                ;   Room for expansion?
1452: E7C3                ;                   
1453: E7C3     00000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1454: E7D0                ;                   
1455: E7D0                ;   Note that the following six bytes must match those at
1456: E7D0                ; (PATTRN1) or cp/m will HALT. Why?
1457: E7D0                ;                   
1458: E7D0                ;PATTRN2:           
1459: E7D0                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
1460: E7D0                ;                   
1461: E7D0                ;**************************************************************
1462: E7D0                ;*                  
1463: E7D0                ;*                    B D O S   E N T R Y
1464: E7D0                ;*                  
1465: E7D0                ;**************************************************************
1466: E7D0                ;                   
1467: E7D0                ;   Entry into bdos.
1468: E7D0                ;			Parameters: (DE) or (E) are the parameters passed. The
1469: E7D0                ;						(C) - function number
1470: E7D0                ;	The user's stack is saved (UserStack) 
1471: E7D0                ;	BDOS uses its own stack  (BDOSstack)
1472: E7D0                ;	The Function number is checked
1473: E7D0                ;	The corect routine is calcualted using the FunctionVector and (C)
1474: E7D0                ;                   
1475: E7D0                	ORG  0E806H					; forces - see start of bios fix later
1476: E806                BDOSEntry:          
1477: E806                ;	JMP	BDOSSetup     
1478: E806                ;BDOSSetup:         
1479: E806     EB         	XCHG						; Swap  (DE) and (HL). **23**
1480: E807     223CE8     	SHLD	ParamsDE			; Save (DE)
1481: E80A     EB         	XCHG						; Restore (DE) and (HL) to original values
1482: E80B     7B         	MOV		A,E	          
1483: E80C     323EE8     	STA		ParamE				; Save register (E) in particular.
1484: E80F     210000     	LXI		H,0           
1485: E812     223FE8     	SHLD	StatusBDOSReturn	;clear return status.
1486: E815     39         	DAD		SP            
1487: E816     2241E8     	SHLD	UserStack			; ave users stack pointer.
1488: E819     3173E8     	LXI		SP,BDOSstack		; nd set our own.
1489: E81C     AF         	XRA		A					; lear A for flags resets
1490: E81D     32DCF5     	STA		AutoSelectFlag		; lear auto select storage Flag
1491: E820     32DAF5     	STA		AutoSelectActive	; lear auto select Active Flag
1492: E823     2173E8     	LXI		H,BDOSExit			; et return address to BDOSExit routine
1493: E826     E5         	PUSH	H					; ut it on the stack
1494: E827     79         	MOV		A,C					; get function number and put into A.
1495: E828     FE29       	CPI		FunctionCount + 1	; valid function number?
1496: E82A     D0         	RNC							; Exit if not valid
1497: E82B     4B         	MOV		C,E					; keep single register function value in C.
1498: E82C     219AE8     	LXI		H,FunctionVector	; now look thru the function table.
1499: E82F     5F         	MOV		E,A           
1500: E830     1600       	MVI		D,0					;(DE)=function number.
1501: E832     19         	DAD		D             
1502: E833     19         	DAD		D					;(HL)=(start of table)+2*(function number).
1503: E834     5E         	MOV		E,M           
1504: E835     23         	INX		H             
1505: E836     56         	MOV		D,M					; now (DE)=address for this function.
1506: E837     2A3CE8     	LHLD	ParamsDE			; retrieve parameters.
1507: E83A     EB         	XCHG						;now (DE) has the original parameters.
1508: E83B     E9         	PCHL						;execute desired function.
1509: E83C                ;----------------------------------
1510: E83C     0000       ParamsDE:			DW	0	;(DE) parameters saved here on entry to BDOS.
1511: E83E     00         ParamE:				DB	0	;storage for register (E) on entry to bdos.
1512: E83F     0000       StatusBDOSReturn:	DW	0	;status returned from bdos function.
1513: E841     0000       UserStack:			DW	0	;save users stack pointer here.
1514: E843                ;                   
1515: E843                ;   Stack area for BDOS calls.
1516: E843                ;                   
1517: E843                					DS	030H        
1518: E873                BDOSstack	EQU	$	;end of stack area.
1519: E873                ;----------------------------------
1520: E873                BDOSExit:           
1521: E873     3ADAF5     	LDA	AutoSelectActive	;was auto select activated?
1522: E876     B7         	ORA	A              
1523: E877     CA90E8     	JZ	BDOSExit1       
1524: E87A     2A3CE8     	LHLD	ParamsDE	;yes, but was a change made?
1525: E87D     3600       	MVI	M,0	;(* reset first byte of fcb *)
1526: E87F     3ADCF5     	LDA	AutoSelectFlag 
1527: E882     B7         	ORA	A              
1528: E883     CA90E8     	JZ	BDOSExit1       
1529: E886     77         	MOV	M,A	;yes, reset first byte properly.
1530: E887     3ADBF5     	LDA	OLDDRV	;and get the old drive and select it.
1531: E88A     323EE8     	STA	ParamE         
1532: E88D     CD66F4     	CALL	SETDSK        
1533: E890                BDOSExit1:          
1534: E890     2A41E8     	LHLD		UserStack			;Get  the users stack pointer.
1535: E893     F9         	SPHL		             
1536: E894     2A3FE8     	LHLD		StatusBDOSReturn	;get return status.
1537: E897     7D         	MOV	A,L							;force version 1.4 compatability.
1538: E898     44         	MOV	B,H            
1539: E899     C9         	RET			;and go back to user.
1540: E89A                                    
1541: E89A                	                   
1542: E89A                	                   
1543: E89A                ;                   
1544: E89A                ;   BDOS function jump table.
1545: E89A                ;                   
1546: E89A                ;NFUNCTS	EQU	41	;number of functions in followin table.
1547: E89A                ;                   
1548: E89A                FunctionVector:     
1549: E89A     03F6       	DW	WBOOT	;0		Overall system and BDOS reset
1550: E89C     23EB       	DW	GETCON	;1		Read a byte from the console keyboard
1551: E89E     EBE9       	DW	OUTCON	;2		Write a byte to the console screen
1552: E8A0     29EB       	DW	GETRDR	;3		Read a byte from the logical reader device
1553: E8A2     12F6       	DW	PUNCH	;4		Write a byte to the logical punch device
1554: E8A4     0FF6       	DW	LIST	;5		Write a byte to the logical list device
1555: E8A6     2FEB       	DW	DIRCIO	;6		Direct console I/O (no CCP-style editing)
1556: E8A8     48EB       	DW	GETIOB	;7		Read the current setting of the IOBYTE
1557: E8AA     4EEB       	DW	SETIOB	;8		Set a new value of the IOBYTE
1558: E8AC     53EB       	DW	PRTSTR	;9		Send a "$"-terminated string to the console
1559: E8AE     3CEA       	DW	RDBUFF	;10		Read a string from the console into a buffer
1560: E8B0     59EB       	DW	GETCSTS	;11		Check if a console key is waiting to be read
1561: E8B2     9FF4       	DW	GETVER	;12		Return the CP/M version number
1562: E8B4                	                   
1563: E8B4     A4F4       	DW	RSTDSK		;13		Reset disk system
1564: E8B6     66F4       	DW	SETDSK		;14		Select specified logical disk drive
1565: E8B8     BDF4       	DW	OPENFIL		;15		Open specified file for reading/writing
1566: E8BA     C6F4       	DW	CLOSEFIL	;16		Close specified file after reading/writing
1567: E8BC     CCF4       	DW	GETFST		;17		Search file directory for first match with filename
1568: E8BE     E9F4       	DW	GETNXT		;18		Search file directory for next match with filename
1569: E8C0     F8F4       	DW	DELFILE		;19		Delete (erase) file
1570: E8C2     01F5       	DW	READSEQ		;20		Read the next "record" sequentially
1571: E8C4     07F5       	DW	WRTSEQ		;21		Write the next "record" sequentially
1572: E8C6     0DF5       	DW	FCREATE		;22		Create a new file with the specified name
1573: E8C8     16F5       	DW	RENFILE		;23		Rename a file to a new name
1574: E8CA     1FF5       	DW	GETLOG		;24		Indicate which logical disks are active
1575: E8CC     25F5       	DW	GETCRNT		;25		Return the current default disk drive number
1576: E8CE     2BF5       	DW	PUTDMA		;26		Set the DMA address (read/write address)
1577: E8D0     32F5       	DW	GETALOC		;27		Return the address of an allocation vector
1578: E8D2     35ED       	DW	WRTPRTD		;28		Return the address of an allocation vector
1579: E8D4     38F5       	DW	GETROV		;29		Indicate which disks are currently Read-Only status
1580: E8D6     3EF5       	DW	SETATTR		;30		Set specified file to System or Read-Only status
1581: E8D8     47F5       	DW	GETPARM		;31		Return address of disk parameter block (DPB)
1582: E8DA     4EF5       	DW	GETUSER		;32		Set/Get the current user number
1583: E8DC     62F5       	DW	RDRANDOM	;33		Set/Get the current user number
1584: E8DE     68F5       	DW	WTRANDOM	;34		Write a "record" randomly
1585: E8E0     6EF5       	DW	FILESIZE	;35		Return logical file size (even for random files)
1586: E8E2     BBF3       	DW	SETRAN		;36		Set record number for the next random read/write
1587: E8E4     74F5       	DW	LOGOFF		;37     
1588: E8E6     5FEB       	DW	Return			;38		Simple Return
1589: E8E8     5FEB       	DW	Return			;39		Simple Return
1590: E8EA     95F5       	DW	WTSPECL		;40		Write a "record" randomly with zero fill
1591: E8EC                	                   
1592: E8EC                FunctionCount	EQU	 ($ -FunctionVector)/2
1593: E8EC                                    
1594: E8EC                ;                   
1595: E8EC                ;   Bdos error table.
1596: E8EC                ;                   
1597: E8EC     F4E8       BADSCTR:	DW	ERROR1	;bad sector on read or write.
1598: E8EE     00E9       BADSLCT:	DW	ERROR2	;bad disk select.
1599: E8F0     06E9       RODISK:		DW	ERROR3	;disk is read only.
1600: E8F2     0CE9       ROFILE:		DW	ERROR4	;file is read only.
1601: E8F4                ;                   
1602: E8F4                ;                   
1603: E8F4                ;   Bdos error message section.
1604: E8F4                ;                   
1605: E8F4                ERROR1:             
1606: E8F4     2125E9     	LXI	H,BADSEC	;bad sector message.
1607: E8F7     CD40E9     	CALL	PRTERR	;print it and get a 1 char responce.
1608: E8FA     FE03       	CPI	CNTRLC	;re-boot request (control-c)?
1609: E8FC     CA0000     	JZ	0	;yes.         
1610: E8FF     C9         	RET		;no, return to retry i/o function.
1611: E900                ;                   
1612: E900                ERROR2:             
1613: E900     2130E9     	LXI	H,BADSEL	;bad drive selected.
1614: E903     C30FE9     	JMP	ERROR5         
1615: E906                ;                   
1616: E906                ERROR3:             
1617: E906     213CE9     	LXI	H,DISKRO	;disk is read only.
1618: E909     C30FE9     	JMP	ERROR5         
1619: E90C                ;                   
1620: E90C                ERROR4:             
1621: E90C     2137E9     	LXI	H,FILERO	;file is read only.
1622: E90F                ;                   
1623: E90F                ERROR5:             
1624: E90F     CD40E9     	CALL	PRTERR        
1625: E912     C30000     	JMP	0	;always reboot on these errors.
1626: E915                ;                   
1627: E915     42444F5320455252204F4E20 BDOSERR:	DB	'Bdos Err On '
1628: E921     203A2024   BDOSDRV:	DB	' : $'  
1629: E925     42414420534543544F5224 BADSEC:		DB	'Bad Sector$'
1630: E930     53454C45435424 BADSEL:		DB	'Select$'
1631: E937     46494C4520 FILERO:		DB	'File ' 
1632: E93C     522F4F24   DISKRO:		DB	'R/O$'  
1633: E940                ;                   
1634: E940                ;   Print bdos error message.
1635: E940                ;                   
1636: E940                PRTERR:             
1637: E940     E5         	PUSH	H	;save second message pointer.
1638: E941     CD24EA     	CALL	OUTCRLF	;send (cr)(lf).
1639: E944     3AA7F5     	LDA	CurrentDrive	;get Current Drive drive.
1640: E947     C641       	ADI	041H	; 'A'	;make ascii.
1641: E949     3221E9     	STA	BDOSDRV	;and put in message.
1642: E94C     0115E9     	LXI	B,BDOSERR;and print it.
1643: E94F     CD2EEA     	CALL	PRTMESG       
1644: E952     C1         	POP	B	;print second message line now.
1645: E953     CD2EEA     	CALL	PRTMESG       
1646: E956                ;                   
1647: E956                ;   Get an input character. We will check our 1 character
1648: E956                ; buffer first. This may be set by the console status routine.
1649: E956                ;                   
1650: E956                GETCHAR:            
1651: E956     2169EB     	LXI	H,CHARBUF;check character buffer.
1652: E959     7E         	MOV	A,M	;anything present already?
1653: E95A     3600       	MVI	M,0	;...either case clear it.
1654: E95C     B7         	ORA	A              
1655: E95D     C0         	RNZ		;yes, use it. 
1656: E95E     C309F6     	JMP	CONIN	;nope, go get a character responce.
1657: E961                ;                   
1658: E961                ;   Input and echo a character.
1659: E961                ;                   
1660: E961                GETECHO:            
1661: E961     CD56E9     	CALL	GETCHAR	;input a character.
1662: E964     CD6FE9     	CALL	CHKCHAR	;carriage control?
1663: E967     D8         	RC		;no, a regular control char so don't echo.
1664: E968     F5         	PUSH	PSW	;ok, save character now.
1665: E969     4F         	MOV	C,A            
1666: E96A     CDEBE9     	CALL	OUTCON	;and echo it.
1667: E96D     F1         	POP	PSW	;get character and return.
1668: E96E     C9         	RET                
1669: E96F                ;                   
1670: E96F                ;   Check character in (A). Set the zero flag on a carriage
1671: E96F                ; control character and the carry flag on any other control
1672: E96F                ; character.        
1673: E96F                ;                   
1674: E96F                CHKCHAR:            
1675: E96F     FE0D       	CPI	CR	;check for carriage return, line feed, backspace,
1676: E971     C8         	RZ		;or a tab.     
1677: E972     FE0A       	CPI	LF             
1678: E974     C8         	RZ                 
1679: E975     FE09       	CPI	TAB            
1680: E977     C8         	RZ                 
1681: E978     FE08       	CPI	BS             
1682: E97A     C8         	RZ                 
1683: E97B     FE20       	CPI	BLANK	;other control char? Set carry flag.
1684: E97D     C9         	RET                
1685: E97E                ;                   
1686: E97E                ;   Check the console during output. Halt on a control-s, then
1687: E97E                ; reboot on a control-c. If anything else is ready, clear the
1688: E97E                ; zero flag and return (the calling routine may want to do
1689: E97E                ; something).       
1690: E97E                ;                   
1691: E97E                CKCONSOL:           
1692: E97E     3A69EB     	LDA	CHARBUF	;check buffer.
1693: E981     B7         	ORA	A	;if anything, just return without checking.
1694: E982     C2A0E9     	JNZ	CKCON2         
1695: E985     CD06F6     	CALL	CONST	;nothing in buffer. Check console.
1696: E988     E601       	ANI	01H	;look at bit 0.
1697: E98A     C8         	RZ		;return if nothing.
1698: E98B     CD09F6     	CALL	CONIN	;ok, get it.
1699: E98E     FE13       	CPI	CNTRLS	;if not control-s, return with zero cleared.
1700: E990     C29DE9     	JNZ	CKCON1         
1701: E993     CD09F6     	CALL	CONIN	;halt processing until another char
1702: E996     FE03       	CPI	CNTRLC	;is typed. Control-c?
1703: E998     CA0000     	JZ	0	;yes, reboot now.
1704: E99B     AF         	XRA	A	;no, just pretend nothing was ever ready.
1705: E99C     C9         	RET                
1706: E99D                CKCON1:             
1707: E99D     3269EB     	STA	CHARBUF	;save character in buffer for later processing.
1708: E9A0                CKCON2:             
1709: E9A0     3E01       	MVI	A,1	;set (A) to non zero to mean something is ready.
1710: E9A2     C9         	RET                
1711: E9A3                ;                   
1712: E9A3                ;   Output (C) to the screen. If the printer flip-flop flag
1713: E9A3                ; is set, we will send character to printer also. The console
1714: E9A3                ; will be checked in the process.
1715: E9A3                ;                   
1716: E9A3                OUTCHAR:            
1717: E9A3     3A65EB     	LDA	OUTFLAG	;check output flag.
1718: E9A6     B7         	ORA	A	;anything and we won't generate output.
1719: E9A7     C2BDE9     	JNZ	OUTCHR1        
1720: E9AA     C5         	PUSH	B             
1721: E9AB     CD7EE9     	CALL	CKCONSOL;check console (we don't care whats there).
1722: E9AE     C1         	POP	B              
1723: E9AF     C5         	PUSH	B             
1724: E9B0     CD0CF6     	CALL	CONOUT	;output (C) to the screen.
1725: E9B3     C1         	POP	B              
1726: E9B4     C5         	PUSH	B             
1727: E9B5     3A68EB     	LDA	PRTFLAG	;check printer flip-flop flag.
1728: E9B8     B7         	ORA	A              
1729: E9B9     C40FF6     	CNZ	LIST	;print it also if non-zero.
1730: E9BC     C1         	POP	B              
1731: E9BD                OUTCHR1:            
1732: E9BD     79         	MOV	A,C	;update cursors position.
1733: E9BE     2167EB     	LXI	H,CURPOS       
1734: E9C1     FE7F       	CPI	DEL	;rubouts don't do anything here.
1735: E9C3     C8         	RZ                 
1736: E9C4     34         	INR	M	;bump line pointer.
1737: E9C5     FE20       	CPI	BLANK	;and return if a normal character.
1738: E9C7     D0         	RNC                
1739: E9C8     35         	DCR	M	;restore and check for the start of the line.
1740: E9C9     7E         	MOV	A,M            
1741: E9CA     B7         	ORA	A              
1742: E9CB     C8         	RZ		;ingnore control characters at the start of the line.
1743: E9CC     79         	MOV	A,C            
1744: E9CD     FE08       	CPI	BS	;is it a backspace?
1745: E9CF     C2D4E9     	JNZ	OUTCHR2        
1746: E9D2     35         	DCR	M	;yes, backup pointer.
1747: E9D3     C9         	RET                
1748: E9D4                OUTCHR2:            
1749: E9D4     FE0A       	CPI	LF	;is it a line feed?
1750: E9D6     C0         	RNZ		;ignore anything else.
1751: E9D7     3600       	MVI	M,0	;reset pointer to start of line.
1752: E9D9     C9         	RET                
1753: E9DA                ;                   
1754: E9DA                ;   Output (A) to the screen. If it is a control character
1755: E9DA                ; (other than carriage control), use ^x format.
1756: E9DA                ;                   
1757: E9DA                SHOWIT:             
1758: E9DA     79         	MOV	A,C            
1759: E9DB     CD6FE9     	CALL	CHKCHAR	;check character.
1760: E9DE     D2EBE9     	JNC	OUTCON	;not a control, use normal output.
1761: E9E1     F5         	PUSH	PSW           
1762: E9E2     0E5E       	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1763: E9E4     CDA3E9     	CALL	OUTCHAR       
1764: E9E7     F1         	POP	PSW            
1765: E9E8     F640       	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1766: E9EA     4F         	MOV	C,A            
1767: E9EB                ;                   
1768: E9EB                ;   Function to output (C) to the console device and expand tabs
1769: E9EB                ; if necessary.     
1770: E9EB                ;                   
1771: E9EB                OUTCON:             
1772: E9EB     79         	MOV	A,C            
1773: E9EC     FE09       	CPI	TAB	;is it a tab?
1774: E9EE     C2A3E9     	JNZ	OUTCHAR	;use regular output.
1775: E9F1                OUTCON1:            
1776: E9F1     0E20       	MVI	C,BLANK	;yes it is, use spaces instead.
1777: E9F3     CDA3E9     	CALL	OUTCHAR       
1778: E9F6     3A67EB     	LDA	CURPOS	;go until the cursor is at a multiple of 8
1779: E9F9                                    
1780: E9F9     E607       	ANI	07H	;position. 
1781: E9FB     C2F1E9     	JNZ	OUTCON1        
1782: E9FE     C9         	RET                
1783: E9FF                ;                   
1784: E9FF                ;   Echo a backspace character. Erase the prevoius character
1785: E9FF                ; on the screen.    
1786: E9FF                ;                   
1787: E9FF                BACKUP:             
1788: E9FF     CD07EA     	CALL	BACKUP1	;backup the screen 1 place.
1789: EA02     0E20       	MVI	C,BLANK	;then blank that character.
1790: EA04     CD0CF6     	CALL	CONOUT        
1791: EA07                BACKUP1:            
1792: EA07     0E08       	MVI	C,BS	;then back space once more.
1793: EA09     C30CF6     	JMP	CONOUT         
1794: EA0C                ;                   
1795: EA0C                ;   Signal a deleted line. Print a '#' at the end and start
1796: EA0C                ; over.             
1797: EA0C                ;                   
1798: EA0C                NEWLINE:            
1799: EA0C     0E23       	MVI	C, POUNDSN		; '#'
1800: EA0E     CDA3E9     	CALL	OUTCHAR	;print this.
1801: EA11     CD24EA     	CALL	OUTCRLF	;start new line.
1802: EA14                NEWLN1:             
1803: EA14     3A67EB     	LDA	CURPOS	;move the cursor to the starting position.
1804: EA17     2166EB     	LXI	H,STARTING     
1805: EA1A     BE         	CMP	M              
1806: EA1B     D0         	RNC		;there yet?   
1807: EA1C     0E20       	MVI	C,BLANK        
1808: EA1E     CDA3E9     	CALL	OUTCHAR	;nope, keep going.
1809: EA21     C314EA     	JMP	NEWLN1         
1810: EA24                ;                   
1811: EA24                ;   Output a (cr) (lf) to the console device (screen).
1812: EA24                ;                   
1813: EA24                OUTCRLF:            
1814: EA24     0E0D       	MVI	C,CR           
1815: EA26     CDA3E9     	CALL	OUTCHAR       
1816: EA29     0E0A       	MVI	C,LF           
1817: EA2B     C3A3E9     	JMP	OUTCHAR        
1818: EA2E                ;                   
1819: EA2E                ;   Print message pointed to by (BC). It will end with a '$'.
1820: EA2E                ;                   
1821: EA2E                PRTMESG:            
1822: EA2E     0A         	LDAX	B	;check for terminating character.
1823: EA2F     FE24       	CPI	DOLLAR		; '$'  
1824: EA31     C8         	RZ                 
1825: EA32     03         	INX	B              
1826: EA33     C5         	PUSH	B	;otherwise, bump pointer and print it.
1827: EA34     4F         	MOV	C,A            
1828: EA35     CDEBE9     	CALL	OUTCON        
1829: EA38     C1         	POP	B              
1830: EA39     C32EEA     	JMP	PRTMESG        
1831: EA3C                ;                   
1832: EA3C                ;   Function to execute a buffered read.
1833: EA3C                ;                   
1834: EA3C                RDBUFF:             
1835: EA3C     3A67EB     	LDA	CURPOS	;use present location as starting one.
1836: EA3F     3266EB     	STA	STARTING       
1837: EA42     2A3CE8     	LHLD	ParamsDE	;get the maximum buffer space.
1838: EA45     4E         	MOV	C,M            
1839: EA46     23         	INX	H	;point to first available space.
1840: EA47     E5         	PUSH	H	;and save.  
1841: EA48     0600       	MVI	B,0	;keep a character count.
1842: EA4A                RDBUF1:             
1843: EA4A     C5         	PUSH	B             
1844: EA4B     E5         	PUSH	H             
1845: EA4C                RDBUF2:             
1846: EA4C     CD56E9     	CALL	GETCHAR	;get the next input character.
1847: EA4F     E67F       	ANI	7FH	;strip bit 7.
1848: EA51     E1         	POP	H	;reset registers.
1849: EA52     C1         	POP	B              
1850: EA53     FE0D       	CPI	CR	;en of the line?
1851: EA55     CA1CEB     	JZ	RDBUF17         
1852: EA58     FE0A       	CPI	LF             
1853: EA5A     CA1CEB     	JZ	RDBUF17         
1854: EA5D     FE08       	CPI	BS	;how about a backspace?
1855: EA5F     C271EA     	JNZ	RDBUF3         
1856: EA62     78         	MOV	A,B	;yes, but ignore at the beginning of the line.
1857: EA63     B7         	ORA	A              
1858: EA64     CA4AEA     	JZ	RDBUF1          
1859: EA67     05         	DCR	B	;ok, update counter.
1860: EA68     3A67EB     	LDA	CURPOS	;if we backspace to the start of the line,
1861: EA6B     3265EB     	STA	OUTFLAG	;treat as a cancel (control-x).
1862: EA6E     C3CBEA     	JMP	RDBUF10        
1863: EA71                RDBUF3:             
1864: EA71     FE7F       	CPI	DEL	;user typed a rubout?
1865: EA73     C281EA     	JNZ	RDBUF4         
1866: EA76     78         	MOV	A,B	;ignore at the start of the line.
1867: EA77     B7         	ORA	A              
1868: EA78     CA4AEA     	JZ	RDBUF1          
1869: EA7B     7E         	MOV	A,M	;ok, echo the prevoius character.
1870: EA7C     05         	DCR	B	;and reset pointers (counters).
1871: EA7D     2B         	DCX	H              
1872: EA7E     C304EB     	JMP	RDBUF15        
1873: EA81                RDBUF4:             
1874: EA81     FE05       	CPI	CNTRLE	;physical end of line?
1875: EA83     C292EA     	JNZ	RDBUF5         
1876: EA86     C5         	PUSH	B	;yes, do it.
1877: EA87     E5         	PUSH	H             
1878: EA88     CD24EA     	CALL	OUTCRLF       
1879: EA8B     AF         	XRA	A	;and update starting position.
1880: EA8C     3266EB     	STA	STARTING       
1881: EA8F     C34CEA     	JMP	RDBUF2         
1882: EA92                RDBUF5:             
1883: EA92     FE10       	CPI	CNTRLP	;control-p?
1884: EA94     C2A3EA     	JNZ	RDBUF6         
1885: EA97     E5         	PUSH	H	;yes, flip the print flag filp-flop byte.
1886: EA98     2168EB     	LXI	H,PRTFLAG      
1887: EA9B     3E01       	MVI	A,1	;PRTFLAG=1-PRTFLAG
1888: EA9D     96         	SUB	M              
1889: EA9E     77         	MOV	M,A            
1890: EA9F     E1         	POP	H              
1891: EAA0     C34AEA     	JMP	RDBUF1         
1892: EAA3                RDBUF6:             
1893: EAA3     FE18       	CPI	CNTRLX	;control-x (cancel)?
1894: EAA5     C2BAEA     	JNZ	RDBUF8         
1895: EAA8     E1         	POP	H              
1896: EAA9                RDBUF7:             
1897: EAA9     3A66EB     	LDA	STARTING;yes, backup the cursor to here.
1898: EAAC     2167EB     	LXI	H,CURPOS       
1899: EAAF     BE         	CMP	M              
1900: EAB0     D23CEA     	JNC	RDBUFF	;done yet?
1901: EAB3     35         	DCR	M	;no, decrement pointer and output back up one space.
1902: EAB4     CDFFE9     	CALL	BACKUP        
1903: EAB7     C3A9EA     	JMP	RDBUF7         
1904: EABA                RDBUF8:             
1905: EABA     FE15       	CPI	CNTRLU	;cntrol-u (cancel line)?
1906: EABC     C2C6EA     	JNZ	RDBUF9         
1907: EABF     CD0CEA     	CALL	NEWLINE	;start a new line.
1908: EAC2     E1         	POP	H              
1909: EAC3     C33CEA     	JMP	RDBUFF         
1910: EAC6                RDBUF9:             
1911: EAC6     FE12       	CPI	CNTRLR	;control-r?
1912: EAC8     C201EB     	JNZ	RDBUF14        
1913: EACB                RDBUF10:            
1914: EACB     C5         	PUSH	B	;yes, start a new line and retype the old one.
1915: EACC     CD0CEA     	CALL	NEWLINE       
1916: EACF     C1         	POP	B              
1917: EAD0     E1         	POP	H              
1918: EAD1     E5         	PUSH	H             
1919: EAD2     C5         	PUSH	B             
1920: EAD3                RDBUF11:            
1921: EAD3     78         	MOV	A,B	;done whole line yet?
1922: EAD4     B7         	ORA	A              
1923: EAD5     CAE5EA     	JZ	RDBUF12         
1924: EAD8     23         	INX	H	;nope, get next character.
1925: EAD9     4E         	MOV	C,M            
1926: EADA     05         	DCR	B	;count it.   
1927: EADB     C5         	PUSH	B             
1928: EADC     E5         	PUSH	H             
1929: EADD     CDDAE9     	CALL	SHOWIT	;and display it.
1930: EAE0     E1         	POP	H              
1931: EAE1     C1         	POP	B              
1932: EAE2     C3D3EA     	JMP	RDBUF11        
1933: EAE5                RDBUF12:            
1934: EAE5     E5         	PUSH	H	;done with line. If we were displaying
1935: EAE6     3A65EB     	LDA	OUTFLAG	;then update cursor position.
1936: EAE9     B7         	ORA	A              
1937: EAEA     CA4CEA     	JZ	RDBUF2          
1938: EAED     2167EB     	LXI	H,CURPOS;because this line is shorter, we must
1939: EAF0     96         	SUB	M	;back up the cursor (not the screen however)
1940: EAF1     3265EB     	STA	OUTFLAG	;some number of positions.
1941: EAF4                RDBUF13:            
1942: EAF4     CDFFE9     	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1943: EAF7     2165EB     	LXI	H,OUTFLAG;zero, the screen will not be changed.
1944: EAFA     35         	DCR	M              
1945: EAFB     C2F4EA     	JNZ	RDBUF13        
1946: EAFE     C34CEA     	JMP	RDBUF2	;now just get the next character.
1947: EB01                ;                   
1948: EB01                ;   Just a normal character, put this in our buffer and echo.
1949: EB01                ;                   
1950: EB01                RDBUF14:            
1951: EB01     23         	INX	H              
1952: EB02     77         	MOV	M,A	;store character.
1953: EB03     04         	INR	B	;and count it.
1954: EB04                RDBUF15:            
1955: EB04     C5         	PUSH	B             
1956: EB05     E5         	PUSH	H             
1957: EB06     4F         	MOV	C,A	;echo it now.
1958: EB07     CDDAE9     	CALL	SHOWIT        
1959: EB0A     E1         	POP	H              
1960: EB0B     C1         	POP	B              
1961: EB0C     7E         	MOV	A,M	;was it an abort request?
1962: EB0D     FE03       	CPI	CNTRLC	;control-c abort?
1963: EB0F     78         	MOV	A,B            
1964: EB10     C218EB     	JNZ	RDBUF16        
1965: EB13     FE01       	CPI	1	;only if at start of line.
1966: EB15     CA0000     	JZ	0               
1967: EB18                RDBUF16:            
1968: EB18     B9         	CMP	C	;nope, have we filled the buffer?
1969: EB19     DA4AEA     	JC	RDBUF1          
1970: EB1C                RDBUF17:            
1971: EB1C     E1         	POP	H	;yes end the line and return.
1972: EB1D     70         	MOV	M,B            
1973: EB1E     0E0D       	MVI	C,CR           
1974: EB20     C3A3E9     	JMP	OUTCHAR	;output (cr) and return.
1975: EB23                ;                   
1976: EB23                ;   Function to get a character from the console device.
1977: EB23                ;                   
1978: EB23                GETCON:             
1979: EB23     CD61E9     	CALL	GETECHO	;get and echo.
1980: EB26     C35CEB     	JMP	SETSTAT	;save status and return.
1981: EB29                ;                   
1982: EB29                ;   Function to get a character from the tape reader device.
1983: EB29                ;                   
1984: EB29                GETRDR:             
1985: EB29     CD15F6     	CALL	READER	;get a character from reader, set status and return.
1986: EB2C     C35CEB     	JMP	SETSTAT        
1987: EB2F                ;                   
1988: EB2F                ;  Function to perform direct console i/o. If (C) contains (FF)
1989: EB2F                ; then this is an input request. If (C) contains (FE) then
1990: EB2F                ; this is a status request. Otherwise we are to output (C).
1991: EB2F                ;                   
1992: EB2F                DIRCIO:             
1993: EB2F     79         	MOV	A,C	;test for (FF).
1994: EB30     3C         	INR	A              
1995: EB31     CA3BEB     	JZ	DIRC1           
1996: EB34     3C         	INR	A	;test for (FE).
1997: EB35     CA06F6     	JZ	CONST           
1998: EB38     C30CF6     	JMP	CONOUT	;just output (C).
1999: EB3B                DIRC1:              
2000: EB3B     CD06F6     	CALL	CONST	;this is an input request.
2001: EB3E     B7         	ORA	A              
2002: EB3F     CA90E8     	JZ	BDOSExit1	;not ready? Just return (directly).
2003: EB42     CD09F6     	CALL	CONIN	;yes, get character.
2004: EB45     C35CEB     	JMP	SETSTAT	;set status and return.
2005: EB48                ;                   
2006: EB48                ;   Function to return the i/o byte.
2007: EB48                ;                   
2008: EB48                GETIOB:             
2009: EB48     3A0300     	LDA	IOBYTE         
2010: EB4B     C35CEB     	JMP	SETSTAT        
2011: EB4E                ;                   
2012: EB4E                ;   Function to set the i/o byte.
2013: EB4E                ;                   
2014: EB4E                SETIOB:             
2015: EB4E     210300     	LXI	H,IOBYTE       
2016: EB51     71         	MOV	M,C            
2017: EB52     C9         	RET                
2018: EB53                ;                   
2019: EB53                ;   Function to print the character string pointed to by (DE)
2020: EB53                ; on the console device. The string ends with a '$'.
2021: EB53                ;                   
2022: EB53                PRTSTR:             
2023: EB53     EB         	XCHG               
2024: EB54     4D         	MOV	C,L            
2025: EB55     44         	MOV	B,H	;now (BC) points to it.
2026: EB56     C32EEA     	JMP	PRTMESG        
2027: EB59                ;                   
2028: EB59                ;   Function to interigate the console device.
2029: EB59                ;                   
2030: EB59                GETCSTS:            
2031: EB59     CD7EE9     	CALL	CKCONSOL      
2032: EB5C                ;                   
2033: EB5C                ;   Get here to set the status and return to the cleanup
2034: EB5C                ; section. Then back to the user.
2035: EB5C                ;                   
2036: EB5C                SETSTAT:            
2037: EB5C     323FE8     	STA	StatusBDOSReturn
2038: EB5F                Return:             
2039: EB5F     C9         	RET                
2040: EB60                ;                   
2041: EB60                ;   Set the status to 1 (read or write error code).
2042: EB60                ;                   
2043: EB60                IOERR1:             
2044: EB60     3E01       	MVI	A,1            
2045: EB62     C35CEB     	JMP	SETSTAT        
2046: EB65                ;                   
2047: EB65     00         OUTFLAG:	DB	0	;output flag (non zero means no output).
2048: EB66     02         STARTING:	DB	2	;starting position for cursor.
2049: EB67     00         CURPOS:		DB	0	;cursor position (0=start of line).
2050: EB68     00         PRTFLAG:	DB	0	;printer flag (control-p toggle). List if non zero.
2051: EB69     00         CHARBUF:	DB	0	;single input character buffer.
2052: EB6A                ;                   
2053: EB6A                ;   Stack area for BDOS calls.
2054: EB6A                ;                   
2055: EB6A                                    
2056: EB6A                ;                   
2057: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2058: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2059: EB6A                ;BDOSstack	EQU	$	;end of stack area.
2060: EB6A                ;                   
2061: EB6A                ;                   
2062: EB6A                ;   Select error occured, jump to error routine.
2063: EB6A                ;                   
2064: EB6A                SLCTERR:            
2065: EB6A     21EEE8     	LXI	H,BADSLCT      
2066: EB6D                ;                   
2067: EB6D                ;   Jump to (HL) indirectly.
2068: EB6D                ;                   
2069: EB6D                JUMPHL:             
2070: EB6D     5E         	MOV	E,M            
2071: EB6E     23         	INX	H              
2072: EB6F     56         	MOV	D,M	;now (DE) contain the desired address.
2073: EB70     EB         	XCHG               
2074: EB71     E9         	PCHL               
2075: EB72                ;                   
2076: EB72                ;   Block move. (DE) to (HL), (C) bytes total.
2077: EB72                ;                   
2078: EB72                DE2HL:              
2079: EB72     0C         	INR		C			; manage counter
2080: EB73                DE2HL1:             
2081: EB73     0D         	DCR		C			; decrement counter
2082: EB74     C8         	RZ					; Return if done
2083: EB75                	                   
2084: EB75     1A         	LDAX	D			; move a byte.
2085: EB76     77         	MOV		M,A           
2086: EB77     13         	INX		D             
2087: EB78     23         	INX		H             
2088: EB79     C373EB     	JMP		DE2HL1		;	and repeat.
2089: EB7C                ;                   
2090: EB7C                ;   Select the desired drive.
2091: EB7C                ; it will set up all the disk parameters blocks 
2092: EB7C                ;                   
2093: EB7C                SelectDisk:         
2094: EB7C     3AA7F5     	LDA		CurrentDrive		; get active disk.
2095: EB7F     4F         	MOV		C,A					; set up for Bios call, put disk in (C)
2096: EB80     CD1BF6     	CALL	SELDSK				; BIOS CALL )select it.
2097: EB83     7C         	MOV		A,H					; HL = 0000 if invalid
2098: EB84     B5         	ORA		L					; otherwise it points to the correct Disk Parameter Block
2099: EB85     C8         	RZ							; so, return if HL = 0000
2100: EB86                ;                   
2101: EB86                ;   Here, the BIOS returned the address of the parameter block
2102: EB86                ; in (HL). We will extract the necessary pointers and save them.
2103: EB86                ;                   
2104: EB86     5E         	MOV		E,M					; first word of DPB points to the drive's skew table
2105: EB87     23         	INX		H             
2106: EB88     56         	MOV		D,M					; Get it and put it into (DE)
2107: EB89     23         	INX		H             
2108: EB8A                						;save pointers to BDOS scratch areas
2109: EB8A     22B0F5     	SHLD	FilePosInDir		; save Relative position for file		.
2110: EB8D     23         	INX		H             
2111: EB8E     23         	INX		H             
2112: EB8F     22B2F5     	SHLD	LastTrackNumber		; save last track referenced			
2113: EB92     23         	INX		H             
2114: EB93     23         	INX		H             
2115: EB94     22B4F5     	SHLD	LastSectorNumber	; save last sector referenced	
2116: EB97     23         	INX		H             
2117: EB98     23         	INX		H					; get directory buffer
2118: EB99     EB         	XCHG						; been holding the translation table address in DE, now in HL
2119: EB9A                								; Moved Directory buffer pointer into DE (from HL
2120: EB9A     22CDF5     	SHLD	XLATE				; save skew table address				
2121: EB9D     21B6F5     	LXI		H,DIRBUF			; get address of the directory buffer vector
2122: EBA0     0E08       	MVI		C,8					; they consist of the directory buffer
2123: EBA2     CD72EB     	CALL	DE2HL				; pointer, parameter block pointer,check and allocation vectors.
2124: EBA5     2AB8F5     	LHLD	DISKPB				;  * DISK PARAMTER BLOCK POINTER
2125: EBA8     EB         	XCHG						; put into DE
2126: EBA9     21BEF5     	LXI		H,SECTORS			; point at  Sectors per Block
2127: EBAC     0E0F       	MVI		C,15				; it is 15 bytes long. 
2128: EBAE     CD72EB     	CALL	DE2HL				; move disk parameter block from BIOS to BDOS for current disk
2129: EBB1     2AC3F5     	LHLD	DSKSIZE				; check disk size.
2130: EBB4     7C         	MOV		A,H					; more than 256 blocks on this?
2131: EBB5     21D9F5     	LXI		H,BIGDISK			; should be called SmallDisk [ if BIGDISK =0 then > 256 block long])
2132: EBB8     36FF       	MVI		M,0FFH				; set to small.
2133: EBBA     B7         	ORA		A             
2134: EBBB     CAC0EB     	JZ		SelectDisk1    
2135: EBBE     3600       	MVI		M,0					; wrong, set to large.
2136: EBC0                SelectDisk1:        
2137: EBC0     3EFF       	MVI		A,0FFH				; clear the zero flag.
2138: EBC2     B7         	ORA		A             
2139: EBC3     C9         	RET                
2140: EBC4                ;                   
2141: EBC4                ;   Routine to home the disk track head and clear pointers.
2142: EBC4                ;                   
2143: EBC4                HOMEDRV:            
2144: EBC4     CD18F6     	CALL	HOME	;home the head.
2145: EBC7     AF         	XRA	A              
2146: EBC8     2AB2F5     	LHLD	LastTrackNumber;set our track pointer also.
2147: EBCB     77         	MOV	M,A            
2148: EBCC     23         	INX	H              
2149: EBCD     77         	MOV	M,A            
2150: EBCE     2AB4F5     	LHLD	LastSectorNumber;and our sector pointer.
2151: EBD1     77         	MOV	M,A            
2152: EBD2     23         	INX	H              
2153: EBD3     77         	MOV	M,A            
2154: EBD4     C9         	RET                
2155: EBD5                ;                   
2156: EBD5                ;   Do the actual disk read and check the error return status.
2157: EBD5                ;                   
2158: EBD5                DOREAD:             
2159: EBD5     CD27F6     	CALL	READ          
2160: EBD8     C3DEEB     	JMP	IORET          
2161: EBDB                ;                   
2162: EBDB                ;   Do the actual disk write and handle any bios error.
2163: EBDB                ;                   
2164: EBDB                DOWRITE:            
2165: EBDB     CD2AF6     	CALL	WRITE         
2166: EBDE                IORET:              
2167: EBDE     B7         	ORA	A              
2168: EBDF     C8         	RZ		;return unless an error occured.
2169: EBE0     21ECE8     	LXI	H,BADSCTR;bad read/write on this sector.
2170: EBE3     C36DEB     	JMP	JUMPHL         
2171: EBE6                ;                   
2172: EBE6                ;   Routine to select the track and sector that the desired
2173: EBE6                ; block number falls in.
2174: EBE6                ;                   
2175: EBE6                TRKSEC:             
2176: EBE6     2AE6F5     	LHLD	FILEPOS			; get position of last accessed file
2177: EBE9     0E02       	MVI		C,2				; in directory and compute sector #.
2178: EBEB     CD0DED     	CALL	HLrightC			; sector #=file-position/4.
2179: EBEE     22E1F5     	SHLD	BLKNMBR			; save this as the block number of interest.
2180: EBF1     22E8F5     	SHLD	CKSUMTBL		; what's it doing here too?
2181: EBF4                ;                   
2182: EBF4                ;   if the sector number has already been set (BLKNMBR), enter
2183: EBF4                ; at this point.    
2184: EBF4                ;                   
2185: EBF4                TRKSEC1:            
2186: EBF4                		;move Desired sector number into (BC).
2187: EBF4     21E1F5     	LXI		H,BLKNMBR     
2188: EBF7     4E         	MOV		C,M				       
2189: EBF8     23         	INX		H             
2190: EBF9     46         	MOV		B,M           
2191: EBFA                		;move Last sector number into (DE).
2192: EBFA     2AB4F5     	LHLD	LastSectorNumber
2193: EBFD     5E         	MOV		E,M	          
2194: EBFE     23         	INX		H             
2195: EBFF     56         	MOV		D,M           
2196: EC00                		;move current track number into (HL).
2197: EC00     2AB2F5     	LHLD	LastTrackNumber
2198: EC03     7E         	MOV		A,M           
2199: EC04     23         	INX		H             
2200: EC05     66         	MOV		H,M           
2201: EC06     6F         	MOV		L,A           
2202: EC07                	                   
2203: EC07                TRKSEC2:            
2204: EC07     79         	MOV		A,C			;is desired sector before current one?
2205: EC08     93         	SUB		E             
2206: EC09     78         	MOV		A,B           
2207: EC0A     9A         	SBB		D             
2208: EC0B     D21DEC     	JNC		TRKSEC3       
2209: EC0E     E5         	PUSH	H			;yes, decrement sectors by one track.
2210: EC0F     2ABEF5     	LHLD	SECTORS		;get sectors per track.
2211: EC12     7B         	MOV		A,E           
2212: EC13     95         	SUB		L             
2213: EC14     5F         	MOV		E,A           
2214: EC15     7A         	MOV		A,D           
2215: EC16     9C         	SBB		H             
2216: EC17     57         	MOV		D,A			;now we have backed up one full track.
2217: EC18     E1         	POP		H             
2218: EC19     2B         	DCX		H			;adjust track counter.
2219: EC1A     C307EC     	JMP		TRKSEC2       
2220: EC1D                TRKSEC3:            
2221: EC1D     E5         	PUSH	H			;desired sector is after current one.
2222: EC1E     2ABEF5     	LHLD	SECTORS		;get sectors per track.
2223: EC21     19         	DAD	D				;bump sector pointer to next track.
2224: EC22     DA32EC     	JC		TRKSEC4        
2225: EC25     79         	MOV		A,C			;is desired sector now before current one?
2226: EC26     95         	SUB		L             
2227: EC27     78         	MOV		A,B           
2228: EC28     9C         	SBB		H             
2229: EC29     DA32EC     	JC		TRKSEC4        
2230: EC2C     EB         	XCHG				;not yes, increment track counter
2231: EC2D     E1         	POP		H			;and continue until it is.
2232: EC2E     23         	INX		H             
2233: EC2F     C31DEC     	JMP		TRKSEC3       
2234: EC32                ;                   
2235: EC32                ;   here we have determined the track number that contains the
2236: EC32                ; desired sector.   
2237: EC32                ;                   
2238: EC32                TRKSEC4:            
2239: EC32     E1         	POP		H			;get track number (HL).
2240: EC33     C5         	PUSH	B             
2241: EC34     D5         	PUSH	D             
2242: EC35     E5         	PUSH	H             
2243: EC36     EB         	XCHG               
2244: EC37     2ACBF5     	LHLD	OFFSET		;adjust for first track offset.
2245: EC3A     19         	DAD		D             
2246: EC3B     44         	MOV		B,H           
2247: EC3C     4D         	MOV		C,L           
2248: EC3D     CD1EF6     	CALL	SETTRK		;select this track.
2249: EC40     D1         	POP		D			;reset current track pointer.
2250: EC41     2AB2F5     	LHLD	LastTrackNumber
2251: EC44     73         	MOV		M,E           
2252: EC45     23         	INX		H             
2253: EC46     72         	MOV		M,D           
2254: EC47     D1         	POP		D             
2255: EC48     2AB4F5     	LHLD	LastSectorNumber	;reset the first sector on this track.
2256: EC4B     73         	MOV		M,E           
2257: EC4C     23         	INX		H             
2258: EC4D     72         	MOV		M,D           
2259: EC4E     C1         	POP		B             
2260: EC4F     79         	MOV		A,C			;now subtract the desired one.
2261: EC50     93         	SUB		E			;to make it relative (1-# sectors/track).
2262: EC51     4F         	MOV		C,A           
2263: EC52     78         	MOV		A,B           
2264: EC53     9A         	SBB		D             
2265: EC54     47         	MOV		B,A           
2266: EC55     2ACDF5     	LHLD	XLATE		;translate this sector according to this table.
2267: EC58     EB         	XCHG               
2268: EC59     CD30F6     	CALL	SECTRN		;let the bios translate it.
2269: EC5C     4D         	MOV		C,L           
2270: EC5D     44         	MOV		B,H           
2271: EC5E     C321F6     	JMP		SETSEC		;and select it.
2272: EC61                ;                   
2273: EC61                ;   Compute block number from record number (SAVNREC) and
2274: EC61                ; extent number (SAVEXT).
2275: EC61                ;                   
2276: EC61                GETBLOCK:           
2277: EC61     21C0F5     	LXI	H,BLKSHFT;get logical to physical conversion.
2278: EC64     4E         	MOV	C,M	;note that this is base 2 log of ratio.
2279: EC65     3ADFF5     	LDA	SAVNREC	;get record number.
2280: EC68                GETBLK1:            
2281: EC68     B7         	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2282: EC69     1F         	RAR                
2283: EC6A     0D         	DCR	C              
2284: EC6B     C268EC     	JNZ	GETBLK1        
2285: EC6E     47         	MOV	B,A	;save result in (B).
2286: EC6F     3E08       	MVI	A,8            
2287: EC71     96         	SUB	M              
2288: EC72     4F         	MOV	C,A	;compute (C)=8-BLKSHFT.
2289: EC73     3ADEF5     	LDA	SAVEXT         
2290: EC76                GETBLK2:            
2291: EC76     0D         	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2292: EC77     CA7FEC     	JZ	GETBLK3         
2293: EC7A     B7         	ORA	A              
2294: EC7B     17         	RAL                
2295: EC7C     C376EC     	JMP	GETBLK2        
2296: EC7F                GETBLK3:            
2297: EC7F     80         	ADD	B              
2298: EC80     C9         	RET                
2299: EC81                ;                   
2300: EC81                ;   Routine to extract the (BC) block byte from the fcb pointed
2301: EC81                ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2302: EC81                ; block numbers, else they are 8 bit numbers.
2303: EC81                ; Number is returned in (HL).
2304: EC81                ;                   
2305: EC81                EXTBLK:             
2306: EC81     2A3CE8     	LHLD	ParamsDE	;get fcb address.
2307: EC84     111000     	LXI	D,16	;block numbers start 16 bytes into fcb.
2308: EC87     19         	DAD	D              
2309: EC88     09         	DAD	B              
2310: EC89     3AD9F5     	LDA	BIGDISK	;are we using a big-disk?
2311: EC8C     B7         	ORA	A              
2312: EC8D     CA94EC     	JZ	EXTBLK1         
2313: EC90     6E         	MOV	L,M	;no, extract an 8 bit number from the fcb.
2314: EC91     2600       	MVI	H,0            
2315: EC93     C9         	RET                
2316: EC94                EXTBLK1:            
2317: EC94     09         	DAD	B	;yes, extract a 16 bit number.
2318: EC95     5E         	MOV	E,M            
2319: EC96     23         	INX	H              
2320: EC97     56         	MOV	D,M            
2321: EC98     EB         	XCHG		;return in (HL).
2322: EC99     C9         	RET                
2323: EC9A                ;                   
2324: EC9A                ;   Compute block number.
2325: EC9A                ;                   
2326: EC9A                COMBLK:             
2327: EC9A     CD61EC     	CALL	GETBLOCK      
2328: EC9D     4F         	MOV	C,A            
2329: EC9E     0600       	MVI	B,0            
2330: ECA0     CD81EC     	CALL	EXTBLK        
2331: ECA3     22E1F5     	SHLD	BLKNMBR       
2332: ECA6     C9         	RET                
2333: ECA7                ;                   
2334: ECA7                ;   Check for a zero block number (unused).
2335: ECA7                ;                   
2336: ECA7                CHKBLK:             
2337: ECA7     2AE1F5     	LHLD	BLKNMBR       
2338: ECAA     7D         	MOV	A,L	;is it zero?
2339: ECAB     B4         	ORA	H              
2340: ECAC     C9         	RET                
2341: ECAD                ;                   
2342: ECAD                ;   Adjust physical block (BLKNMBR) and convert to logical
2343: ECAD                ; sector (LOGSECT). This is the starting sector of this block.
2344: ECAD                ; The actual sector of interest is then added to this and the
2345: ECAD                ; resulting sector number is stored back in (BLKNMBR). This
2346: ECAD                ; will still have to be adjusted for the track number.
2347: ECAD                ;                   
2348: ECAD                LOGICAL:            
2349: ECAD     3AC0F5     	LDA	BLKSHFT	;get log2(physical/logical sectors).
2350: ECB0     2AE1F5     	LHLD	BLKNMBR	;get physical sector desired.
2351: ECB3                LOGICL1:            
2352: ECB3     29         	DAD	H	;compute logical sector number.
2353: ECB4     3D         	DCR	A	;note logical sectors are 128 bytes long.
2354: ECB5     C2B3EC     	JNZ	LOGICL1        
2355: ECB8     22E3F5     	SHLD	LOGSECT	;save logical sector.
2356: ECBB     3AC1F5     	LDA	BLKMASK	;get block mask.
2357: ECBE     4F         	MOV	C,A            
2358: ECBF     3ADFF5     	LDA	SAVNREC	;get next sector to access.
2359: ECC2     A1         	ANA	C	;extract the relative position within physical block.
2360: ECC3     B5         	ORA	L	;and add it too logical sector.
2361: ECC4     6F         	MOV	L,A            
2362: ECC5     22E1F5     	SHLD	BLKNMBR	;and store.
2363: ECC8     C9         	RET                
2364: ECC9                ;                   
2365: ECC9                ;   Set (HL) to point to extent byte in fcb.
2366: ECC9                ;                   
2367: ECC9                SETEXT:             
2368: ECC9     2A3CE8     	LHLD	ParamsDE      
2369: ECCC     110C00     	LXI	D,12	;it is the twelth byte.
2370: ECCF     19         	DAD	D              
2371: ECD0     C9         	RET                
2372: ECD1                ;                   
2373: ECD1                ;   Set (HL) to point to record count byte in fcb and (DE) to
2374: ECD1                ; next record number byte.
2375: ECD1                ;                   
2376: ECD1                SETHLDE:            
2377: ECD1     2A3CE8     	LHLD	ParamsDE      
2378: ECD4     110F00     	LXI	D,15	;record count byte (#15).
2379: ECD7     19         	DAD	D              
2380: ECD8     EB         	XCHG               
2381: ECD9     211100     	LXI	H,17	;next record number (#32).
2382: ECDC     19         	DAD	D              
2383: ECDD     C9         	RET                
2384: ECDE                ;                   
2385: ECDE                ;   Save current file data from fcb.
2386: ECDE                ;                   
2387: ECDE                STRDATA:            
2388: ECDE     CDD1EC     	CALL	SETHLDE       
2389: ECE1     7E         	MOV	A,M	;get and store record count byte.
2390: ECE2     32DFF5     	STA	SAVNREC        
2391: ECE5     EB         	XCHG               
2392: ECE6     7E         	MOV	A,M	;get and store next record number byte.
2393: ECE7     32DDF5     	STA	SAVNXT         
2394: ECEA     CDC9EC     	CALL	SETEXT	;point to extent byte.
2395: ECED     3AC2F5     	LDA	EXTMASK	;get extent mask.
2396: ECF0     A6         	ANA	M              
2397: ECF1     32DEF5     	STA	SAVEXT	;and save extent here.
2398: ECF4     C9         	RET                
2399: ECF5                ;                   
2400: ECF5                ;   Set the next record to access. If (MODE) is set to 2, then
2401: ECF5                ; the last record byte (SAVNREC) has the correct number to access.
2402: ECF5                ; For sequential access, (MODE) will be equal to 1.
2403: ECF5                ;                   
2404: ECF5                SETNREC:            
2405: ECF5     CDD1EC     	CALL	SETHLDE       
2406: ECF8     3AD2F5     	LDA	MODE	;get sequential flag (=1).
2407: ECFB     FE02       	CPI	2	;a 2 indicates that no adder is needed.
2408: ECFD     C201ED     	JNZ	STNREC1        
2409: ED00     AF         	XRA	A	;clear adder (random access?).
2410: ED01                STNREC1:            
2411: ED01     4F         	MOV	C,A            
2412: ED02     3ADFF5     	LDA	SAVNREC	;get last record number.
2413: ED05     81         	ADD	C	;increment record count.
2414: ED06     77         	MOV	M,A	;and set fcb's next record byte.
2415: ED07     EB         	XCHG               
2416: ED08     3ADDF5     	LDA	SAVNXT	;get next record byte from storage.
2417: ED0B     77         	MOV	M,A	;and put this into fcb as number of records used.
2418: ED0C     C9         	RET                
2419: ED0D                ;                   
2420: ED0D                ;   Shift HL right (C) bits.
2421: ED0D                ;                   
2422: ED0D                HLrightC:           
2423: ED0D     0C         	INR		C			; minor adjustment
2424: ED0E                HLrightC1:          
2425: ED0E     0D         	DCR		C			; count down
2426: ED0F     C8         	RZ					; exit if done
2427: ED10     7C         	MOV		A,H			; get the hi byte
2428: ED11     B7         	ORA		A			; reset carry bit
2429: ED12     1F         	RAR					; rotate right thru carry
2430: ED13     67         	MOV		H,A			; return new hi byte
2431: ED14     7D         	MOV		A,L			; get lo byte
2432: ED15     1F         	RAR					; rotate right thru carry
2433: ED16     6F         	MOV		L,A			; return new lo byte
2434: ED17     C30EED     	JMP		HLrightC1		; keep doing it
2435: ED1A                ;                   
2436: ED1A                ;   Compute the check-sum for the directory buffer. Return
2437: ED1A                ; integer sum in (A).
2438: ED1A                ;                   
2439: ED1A                CHECKSUM:           
2440: ED1A     0E80       	MVI	C,128	;length of buffer.
2441: ED1C     2AB6F5     	LHLD	DIRBUF	;get its location.
2442: ED1F     AF         	XRA	A	;clear summation byte.
2443: ED20                CHKSUM1:            
2444: ED20     86         	ADD	M	;and compute sum ignoring carries.
2445: ED21     23         	INX	H              
2446: ED22     0D         	DCR	C              
2447: ED23     C220ED     	JNZ	CHKSUM1        
2448: ED26     C9         	RET                
2449: ED27                                    
2450: ED27                ;                   
2451: ED27                ;   Extract the write protect status bit for the current drive.
2452: ED27                ; The result is returned in (A), bit 0.
2453: ED27                ;                   
2454: ED27                GETWPRT:            
2455: ED27     2AAAF5     	LHLD	ROBitMap		;get Read Only Bit Map
2456: ED2A     3AA7F5     	LDA		CurrentDrive	;which drive is current?
2457: ED2D     4F         	MOV		C,A           
2458: ED2E     CD0DED     	CALL	HLrightC			;shift status such that bit 0 is the
2459: ED31     7D         	MOV		A,L				;one of interest for this drive.
2460: ED32     E601       	ANI		01H				;and isolate it.
2461: ED34     C9         	RET						; Zero if not write protected
2462: ED35                ;                   
2463: ED35                ;   Function to write protect the current disk.
2464: ED35                ;                   
2465: ED35                WRTPRTD:            
2466: ED35     21AAF5     	LXI	H,ROBitMap	;point to Read Only Bit Map
2467: ED38     4E         	MOV	C,M	;set (BC) equal to the status.
2468: ED39     23         	INX	H              
2469: ED3A     46         	MOV	B,M            
2470: ED3B     CD50F4     	CALL	SetBit	;and set this bit according to current drive.
2471: ED3E     22AAF5     	SHLD	ROBitMap	;then save.
2472: ED41     2AC5F5     	LHLD	DIRSIZE	;now save directory size limit.
2473: ED44     23         	INX	H	;remember the last one.
2474: ED45     EB         	XCHG               
2475: ED46     2AB0F5     	LHLD	FilePosInDir;and store it here.
2476: ED49     73         	MOV	M,E	;put low byte.
2477: ED4A     23         	INX	H              
2478: ED4B     72         	MOV	M,D	;then high byte.
2479: ED4C     C9         	RET                
2480: ED4D                ;                   
2481: ED4D                ;   Check for a read only file.
2482: ED4D                ;                   
2483: ED4D                CHKROFL:            
2484: ED4D     CD67ED     	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2485: ED50                CKROF1:             
2486: ED50     110900     	LXI	D,9	;look at bit 7 of the ninth byte.
2487: ED53     19         	DAD	D              
2488: ED54     7E         	MOV	A,M            
2489: ED55     17         	RAL                
2490: ED56     D0         	RNC		;return if ok.
2491: ED57     21F2E8     	LXI	H,ROFILE;else, print error message and terminate.
2492: ED5A     C36DEB     	JMP	JUMPHL         
2493: ED5D                ;                   
2494: ED5D                ;   Check the write protect status of the active disk.
2495: ED5D                ;                   
2496: ED5D                CHKWPRT:            
2497: ED5D     CD27ED     	CALL	GETWPRT			; is it write protected ?
2498: ED60     C8         	RZ						; NO, return.
2499: ED61     21F0E8     	LXI		H,RODISK      
2500: ED64     C36DEB     	JMP	JUMPHL		; else print message and terminate.
2501: ED67                ;                   
2502: ED67                ;   Routine to set (HL) pointing to the proper entry in the
2503: ED67                ; directory buffer. 
2504: ED67                ;                   
2505: ED67                FCB2HL:             
2506: ED67     2AB6F5     	LHLD	DIRBUF		;get address of buffer.
2507: ED6A     3AE5F5     	LDA		FCBPOS		;relative position of file.
2508: ED6D                ;                   
2509: ED6D                ;   Routine to add (A) to (HL).
2510: ED6D                ;                   
2511: ED6D                ADDA2HL:            
2512: ED6D     85         	ADD		L             
2513: ED6E     6F         	MOV		L,A           
2514: ED6F     D0         	RNC	               
2515: ED70     24         	INR		H			;take care of any carry.
2516: ED71     C9         	RET                
2517: ED72                ;                   
2518: ED72                ;   Routine to get the 's2' byte(Extent Count) from the fcb supplied in
2519: ED72                ; the initial parameter specification.
2520: ED72                ;                   
2521: ED72                GETS2:              
2522: ED72     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
2523: ED75     110E00     	LXI		D,14		;relative position of 's2'.
2524: ED78     19         	DAD		D             
2525: ED79     7E         	MOV		A,M			;extract this byte.
2526: ED7A     C9         	RET                
2527: ED7B                ;                   
2528: ED7B                ;   Clear the 's2' byte in the fcb.
2529: ED7B                ;                   
2530: ED7B                CLEARS2:            
2531: ED7B     CD72ED     	CALL	GETS2		;this sets (HL) pointing to it.
2532: ED7E     3600       	MVI		M,0			;now clear it.
2533: ED80     C9         	RET                
2534: ED81                ;                   
2535: ED81                ;   Set bit 7 in the 's2' byte of the fcb.
2536: ED81                ;                   
2537: ED81                SETS2B7:            
2538: ED81     CD72ED     	CALL	GETS2		;get the byte.
2539: ED84     F680       	ORI		80H			;and set bit 7.
2540: ED86     77         	MOV		M,A			;then store.
2541: ED87     C9         	RET                
2542: ED88                ;                   
2543: ED88                ;   Compare (FILEPOS) with (FilePosInDir) and set flags based on
2544: ED88                ; the difference. This checks to see if there are more file
2545: ED88                ; names in the directory. We are at (FILEPOS) and there are
2546: ED88                ; (FilePosInDir) of them to check.
2547: ED88                ;                   
2548: ED88                MOREFLS:            
2549: ED88     2AE6F5     	LHLD	FILEPOS			;we are here.
2550: ED8B     EB         	XCHG               
2551: ED8C     2AB0F5     	LHLD	FilePosInDir	;and don't go past here.
2552: ED8F     7B         	MOV		A,E				;compute difference but don't keep.
2553: ED90     96         	SUB		M             
2554: ED91     23         	INX		H             
2555: ED92     7A         	MOV		A,D           
2556: ED93     9E         	SBB		M				;set carry if no more names.
2557: ED94     C9         	RET                
2558: ED95                ;                   
2559: ED95                ;   Call this routine to prevent (FilePosInDir) from being greater
2560: ED95                ; than (FILEPOS).   
2561: ED95                ;                   
2562: ED95                CHKNMBR:            
2563: ED95     CD88ED     	CALL	MOREFLS		;FilePosInDir too big?
2564: ED98     D8         	RC                 
2565: ED99     13         	INX		D		;yes, reset it to (FILEPOS).
2566: ED9A     72         	MOV		M,D           
2567: ED9B     2B         	DCX		H             
2568: ED9C     73         	MOV		M,E           
2569: ED9D     C9         	RET                
2570: ED9E                ;                   
2571: ED9E                ;   Compute (HL)=(DE)-(HL)
2572: ED9E                ;                   
2573: ED9E                SUBHL:              
2574: ED9E     7B         	MOV		A,E		;compute difference.
2575: ED9F     95         	SUB		L             
2576: EDA0     6F         	MOV		L,A		;store low byte.
2577: EDA1     7A         	MOV		A,D           
2578: EDA2     9C         	SBB		H             
2579: EDA3     67         	MOV		H,A		;and then high byte.
2580: EDA4     C9         	RET                
2581: EDA5                ;                   
2582: EDA5                ;   Set the directory checksum byte.
2583: EDA5                ;                   
2584: EDA5                SETDIR:             
2585: EDA5     0EFF       	MVI	C,0FFH         
2586: EDA7                ;                   
2587: EDA7                ;   Routine to set or compare the directory checksum byte. If
2588: EDA7                ; (C)=0ffh, then this will set the checksum byte. Else the byte
2589: EDA7                ; will be checked. If the check fails (the disk has been changed),
2590: EDA7                ; then this disk will be write protected.
2591: EDA7                ;                   
2592: EDA7                CHECKDIR:           
2593: EDA7     2AE8F5     	LHLD	CKSUMTBL      
2594: EDAA     EB         	XCHG               
2595: EDAB     2AC9F5     	LHLD	ALLOC1        
2596: EDAE     CD9EED     	CALL	SUBHL         
2597: EDB1     D0         	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2598: EDB2     C5         	PUSH	B             
2599: EDB3     CD1AED     	CALL	CHECKSUM;else compute checksum.
2600: EDB6     2ABAF5     	LHLD	CHKVECT	;get address of checksum table.
2601: EDB9     EB         	XCHG               
2602: EDBA     2AE8F5     	LHLD	CKSUMTBL      
2603: EDBD     19         	DAD	D	;set (HL) to point to byte for this drive.
2604: EDBE     C1         	POP	B              
2605: EDBF     0C         	INR	C	;set or check ?
2606: EDC0     CACDED     	JZ	CHKDIR1         
2607: EDC3     BE         	CMP	M	;check them. 
2608: EDC4     C8         	RZ		;return if they are the same.
2609: EDC5     CD88ED     	CALL	MOREFLS	;not the same, do we care?
2610: EDC8     D0         	RNC                
2611: EDC9     CD35ED     	CALL	WRTPRTD	;yes, mark this as write protected.
2612: EDCC     C9         	RET                
2613: EDCD                CHKDIR1:            
2614: EDCD     77         	MOV	M,A	;just set the byte.
2615: EDCE     C9         	RET                
2616: EDCF                ;                   
2617: EDCF                ;   Do a write to the directory of the current disk.
2618: EDCF                ;                   
2619: EDCF                DIRWRITE:           
2620: EDCF     CDA5ED     	CALL	SETDIR			;set checksum byte.
2621: EDD2     CDE9ED     	CALL	SetDirDMA		;set directory dma address.
2622: EDD5     0E01       	MVI		C,1				;tell the bios to actually write.
2623: EDD7     CDDBEB     	CALL	DOWRITE			;then do the write.
2624: EDDA     C3E3ED     	JMP		Set2UsersDMA  
2625: EDDD                ;                   
2626: EDDD                ;   Read from the directory.
2627: EDDD                ;                   
2628: EDDD                DIRREAD:            
2629: EDDD     CDE9ED     	CALL	SetDirDMA	;set the directory dma address.
2630: EDE0     CDD5EB     	CALL	DOREAD	;and read it.
2631: EDE3                ;                   
2632: EDE3                ;   Routine to set the dma address to the users choice.
2633: EDE3                ;                   
2634: EDE3                Set2UsersDMA:       
2635: EDE3     21AEF5     	LXI		H,UsersDMA		;reset the default dma address and return.
2636: EDE6     C3ECED     	JMP		SetDMA0       
2637: EDE9                ;                   
2638: EDE9                ;   Routine to set the dma address for directory work.
2639: EDE9                ;                   
2640: EDE9                SetDirDMA:          
2641: EDE9     21B6F5     	LXI		H,DIRBUF      
2642: EDEC                ;                   
2643: EDEC                ;   Set the dma address. On entry, (HL) points to
2644: EDEC                ; word containing the desired dma address.
2645: EDEC                ;                   
2646: EDEC                SetDMA0:            
2647: EDEC     4E         	MOV		C,M           
2648: EDED     23         	INX		H             
2649: EDEE     46         	MOV		B,M			;setup (BC) and go to the bios to set it.
2650: EDEF     C324F6     	JMP		SETDMA        
2651: EDF2                ;                   
2652: EDF2                ;   Move the directory buffer into user's dma space.
2653: EDF2                ;                   
2654: EDF2                MOVEDIR:            
2655: EDF2     2AB6F5     	LHLD	DIRBUF	;buffer is located here, and
2656: EDF5     EB         	XCHG               
2657: EDF6     2AAEF5     	LHLD	UsersDMA; put it here.
2658: EDF9     0E80       	MVI	C,128	;this is its length.
2659: EDFB     C372EB     	JMP	DE2HL	;move it now and return.
2660: EDFE                ;                   
2661: EDFE                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2662: EDFE                ;                   
2663: EDFE                CKFILPOS:           
2664: EDFE     21E6F5     	LXI	H,FILEPOS      
2665: EE01     7E         	MOV	A,M            
2666: EE02     23         	INX	H              
2667: EE03     BE         	CMP	M	;are both bytes the same?
2668: EE04     C0         	RNZ                
2669: EE05     3C         	INR	A	;yes, but are they each 0ffh?
2670: EE06     C9         	RET                
2671: EE07                ;                   
2672: EE07                ;   Set location (FILEPOS) to 0ffffh.
2673: EE07                ;                   
2674: EE07                STFILPOS:           
2675: EE07     21FFFF     	LXI	H,-1           
2676: EE0A     22E6F5     	SHLD	FILEPOS       
2677: EE0D     C9         	RET                
2678: EE0E                ;                   
2679: EE0E                ;   Move on to the next file position within the current
2680: EE0E                ; directory buffer. If no more exist, set pointer to 0ffffh
2681: EE0E                ; and the calling routine will check for this. Enter with (C)
2682: EE0E                ; equal to 0ffh to cause the checksum byte to be set, else we
2683: EE0E                ; will check this disk and set write protect if checksums are
2684: EE0E                ; not the same (applies only if another directory sector must
2685: EE0E                ; be read).         
2686: EE0E                ;                   
2687: EE0E                NXENTRY:            
2688: EE0E     2AC5F5     	LHLD	DIRSIZE		; Get directory entry size limit.
2689: EE11     EB         	XCHG               
2690: EE12     2AE6F5     	LHLD	FILEPOS		; Get index into directory.
2691: EE15     23         	INX		H			; Point at the next one
2692: EE16     22E6F5     	SHLD	FILEPOS		; Save it
2693: EE19     CD9EED     	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2694: EE1C     D222EE     	JNC		NXENTRY1	; Are there any more entries?
2695: EE1F     C307EE     	JMP		STFILPOS	; No. - Set this flag and return.
2696: EE22                	                   
2697: EE22                NXENTRY1:           
2698: EE22     3AE6F5     	LDA		FILEPOS		; Get current index for dirctory directory.
2699: EE25     E603       	ANI		03H			;only look within this sector (only 4 entries fit).
2700: EE27     0605       	MVI		B,5			;convert to relative position (32 bytes each).
2701: EE29                NXENTRY2:           
2702: EE29     87         	ADD		A			;note that this is not efficient code.
2703: EE2A     05         	DCR		B			;5 'ADD A's would be better.
2704: EE2B     C229EE     	JNZ		NXENTRY2      
2705: EE2E                	                   
2706: EE2E     32E5F5     	STA		FCBPOS		;save it as position of fcb.
2707: EE31     B7         	ORA		A             
2708: EE32     C0         	RNZ					;return if we are within buffer.
2709: EE33     C5         	PUSH	B             
2710: EE34     CDE6EB     	CALL	TRKSEC		;we need the next directory sector.
2711: EE37     CDDDED     	CALL	DIRREAD       
2712: EE3A     C1         	POP		B             
2713: EE3B     C3A7ED     	JMP		CHECKDIR      
2714: EE3E                ;                   
2715: EE3E                ;   Routine to to get a bit from the disk space allocation
2716: EE3E                ; map. It is returned in (A), bit position 0. On entry to here,
2717: EE3E                ; set (BC) to the block number on the disk to check.
2718: EE3E                ; On return, (D) will contain the original bit position for
2719: EE3E                ; this block number and (HL) will point to the address for it.
2720: EE3E                ; Bit is determined by Block Number Mod 8
2721: EE3E                ; Byte is determined by Block Number / 8
2722: EE3E                                    
2723: EE3E                CKBITMAP:           
2724: EE3E     79         	MOV		A,C			; Determine Bit  interest.
2725: EE3F     E607       	ANI		07H			; mod 8 
2726: EE41     3C         	INR		A			; add 1? and save
2727: EE42     5F         	MOV		E,A			; Save particular bit number.
2728: EE43     57         	MOV		D,A			; save it again
2729: EE44                ;                     
2730: EE44                ;   compute (BC)=(BC)/8.
2731: EE44                ;   to determin in which Allocation block the number resides
2732: EE44                ;                   
2733: EE44     79         	MOV		A,C			; get the block
2734: EE45     0F         	RRC					; now shift right 3 bits.
2735: EE46     0F         	RRC      	  		; to divide by 8
2736: EE47     0F         	RRC                
2737: EE48     E61F       	ANI		1FH			; and clear bits 7,6,5.
2738: EE4A     4F         	MOV		C,A			; put result in c           
2739: EE4B     78         	MOV		A,B			           
2740: EE4C     87         	ADD		A			; now shift
2741: EE4D     87         	ADD		A           ; hi byte's bits 0,1 & 2   
2742: EE4E     87         	ADD		A           ; int bit positions 6,7, & 8  
2743: EE4F     87         	ADD		A           ; so we can put continue the   
2744: EE50     87         	ADD		A           ; divide by 8 of the whole word  
2745: EE51     B1         	ORA		C			; combile with (C)(bits 0,1,2,3 & 4).
2746: EE52     4F         	MOV		C,A			; ok, (C), the low byte has been completed.
2747: EE53     78         	MOV		A,B			; Now to finish with
2748: EE54     0F         	RRC 	       		; the high order byte                
2749: EE55     0F         	RRC                
2750: EE56     0F         	RRC 	       		; divide by 8
2751: EE57     E61F       	ANI		1FH			; zero out bits 5,6 & 7           
2752: EE59     47         	MOV		B,A			;and now (B) is completed.
2753: EE5A                ;                     
2754: EE5A                ;   use this as an offset into the disk space allocation
2755: EE5A                ; table.            
2756: EE5A                ;                   
2757: EE5A     2ABCF5     	LHLD	ALOCVECT      
2758: EE5D     09         	DAD	B              
2759: EE5E     7E         	MOV	A,M				; we now have correct byte.
2760: EE5F                CKBMAP1:            
2761: EE5F     07         	RLC		;get correct bit into position 0.
2762: EE60     1D         	DCR	E              
2763: EE61     C25FEE     	JNZ	CKBMAP1        
2764: EE64     C9         	RET                
2765: EE65                ;                   
2766: EE65                ;   Set or clear the bit map such that block number (BC) will be marked
2767: EE65                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2768: EE65                ; 1 then it will be set (don't use anyother values).
2769: EE65                ;                   
2770: EE65                STBITMAP:           
2771: EE65                ;	PUSH	D				; Save Set/Clear indicator
2772: EE65     CD3EEE     	CALL	CKBITMAP		; Get the byte of interest.
2773: EE68     E6FE       	ANI		0FEH			; clear the affected bit.
2774: EE6A     4F         	MOV		C,A				; Save it in C
2775: EE6B     3AA8F5     	LDA		BitSetFlag		; get the flag
2776: EE6E     B1         	ORA		C				; and now set(01)/reset(01) acording to flag
2777: EE6F                ;	POP	B             
2778: EE6F                ;	ORA	C	;and now set it acording to (C).
2779: EE6F                ;                   
2780: EE6F                ;  entry to restore the original bit position and then store
2781: EE6F                ; in table. (A) contains the value, (D) contains the bit
2782: EE6F                ; position (1-8), and (HL) points to the address within the
2783: EE6F                ; space allocation table for this byte.
2784: EE6F                ;                   
2785: EE6F                STBMAP1:            
2786: EE6F     0F         	RRC		;restore original bit position.
2787: EE70     15         	DCR	D              
2788: EE71     C26FEE     	JNZ	STBMAP1        
2789: EE74     77         	MOV	M,A	;and stor byte in table.
2790: EE75     C9         	RET                
2791: EE76                ;                   
2792: EE76                ;   Set/clear space used bits in allocation map for this file.
2793: EE76                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2794: EE76                ;                   
2795: EE76                SETFILE:            
2796: EE76     CD67ED     	CALL	FCB2HL			; Get address of fcb
2797: EE79     111000     	LXI		D,16			; Offset to Block Pointers in Directory entry
2798: EE7C     19         	DAD		D				; Compute start to block number bytes. (A1..A10)
2799: EE7D                ;	PUSH	B				; Save Set/Clear indicator 
2800: EE7D     0E11       	MVI		C,17			; Check all 16 bytes (max) of table.
2801: EE7F                SETFL1:             
2802: EE7F                ;	POP		D				; Retreive Set/Clear indicator
2803: EE7F     0D         	DCR		C				; Counter
2804: EE80     C8         	RZ						; Done?, then return
2805: EE81                	                   
2806: EE81                ;	PUSH	D				; Save Set/Clear indicator
2807: EE81     3AD9F5     	LDA		BIGDISK			; check disk size .
2808: EE84     B7         	ORA		A             
2809: EE85     CA90EE     	JZ		SETFL2			; If it is a big disk, use 16 bits
2810: EE88                	                   
2811: EE88     C5         	PUSH	B				; Only 8 bit numbers. Save counter.
2812: EE89     E5         	PUSH	H				; Save pointer to current Allocation byte
2813: EE8A     4E         	MOV		C,M				; Get low byte from table, always
2814: EE8B     0600       	MVI		B,0				; Set high byte to zero.
2815: EE8D     C396EE     	JMP		SETFL3			; skip 16 bit number processing
2816: EE90                	                   
2817: EE90                SETFL2:             
2818: EE90     0D         	DCR		C				; Adjust counter for 16 bit block numbers,.
2819: EE91     C5         	PUSH	B				; Save Counter
2820: EE92     4E         	MOV		C,M				; Now get both the low and high bytes.
2821: EE93     23         	INX		H             
2822: EE94     46         	MOV		B,M           
2823: EE95     E5         	PUSH	H				; Save pointer to current Allocation byte
2824: EE96                SETFL3:             
2825: EE96     79         	MOV		A,C				; Block used? if both (b) and (c) are 00
2826: EE97     B0         	ORA		B				; the block is NOT used
2827: EE98     CAA5EE     	JZ		SETFL4			; NOT used move on			
2828: EE9B     2AC3F5     	LHLD	DSKSIZE			; Is this block number within the
2829: EE9E     7D         	MOV		A,L	          
2830: EE9F     91         	SUB		C             
2831: EEA0     7C         	MOV		A,H           
2832: EEA1     98         	SBB		B             
2833: EEA2     D465EE     	CNC		STBITMAP		; Yes, set the proper bit.
2834: EEA5                SETFL4:             
2835: EEA5     E1         	POP	H					; Point to next block number in fcb.
2836: EEA6     23         	INX	H              
2837: EEA7     C1         	POP	B					; Retreive the counter
2838: EEA8     C37FEE     	JMP	SETFL1         
2839: EEAB                                    
2840: EEAB                ;                   
2841: EEAB                ;   Set the status (StatusBDOSReturn) and return.
2842: EEAB                ;                   
2843: EEAB                STSTATUS:           
2844: EEAB     3AD1F5     	LDA	FNDSTAT        
2845: EEAE     C35CEB     	JMP	SETSTAT        
2846: EEB1                ;                   
2847: EEB1                ;   Check extents in (A) and (C). Set the zero flag if they
2848: EEB1                ; are the same. The number of 16k chunks of disk space that
2849: EEB1                ; the directory extent covers is expressad is (EXTMASK+1).
2850: EEB1                ; No registers are modified.
2851: EEB1                ;                   
2852: EEB1                SAMEXT:             
2853: EEB1     C5         	PUSH	B             
2854: EEB2     F5         	PUSH	PSW           
2855: EEB3     3AC2F5     	LDA	EXTMASK	;get extent mask and use it to
2856: EEB6     2F         	CMA		;to compare both extent numbers.
2857: EEB7     47         	MOV	B,A	;save resulting mask here.
2858: EEB8     79         	MOV	A,C	;mask first extent and save in (C).
2859: EEB9     A0         	ANA	B              
2860: EEBA     4F         	MOV	C,A            
2861: EEBB     F1         	POP	PSW	;now mask second extent and compare
2862: EEBC     A0         	ANA	B	;with the first one.
2863: EEBD     91         	SUB	C              
2864: EEBE     E61F       	ANI	1FH	;(* only check buts 0-4 *)
2865: EEC0     C1         	POP	B	;the zero flag is set if they are the same.
2866: EEC1     C9         	RET		;restore (BC) and return.
2867: EEC2                ;                   
2868: EEC2                ;   Search for the first occurence of a file name. On entry,
2869: EEC2                ; register (C) should contain the number of bytes of the fcb
2870: EEC2                ; that must match.  
2871: EEC2                ;                   
2872: EEC2                FINDFST:            
2873: EEC2     3EFF       	MVI		A,0FFH        
2874: EEC4     32D1F5     	STA		FNDSTAT			; set flag to not match found
2875: EEC7     21D4F5     	LXI		H,COUNTER		; point at character counter.
2876: EECA     71         	MOV		M,C				; put in number of bytes to match
2877: EECB     2A3CE8     	LHLD	ParamsDE		; get filename to match.
2878: EECE     22D5F5     	SHLD	SAVEFCB			; and save.
2879: EED1     CD07EE     	CALL	STFILPOS		; clear initial file position (set to 0ffffh).
2880: EED4     CDC4EB     	CALL	HOMEDRV			;home the drive.
2881: EED7                ;                   
2882: EED7                ;   Entry to locate the next occurence of a filename within the
2883: EED7                ; directory. The disk is not expected to have been changed. If
2884: EED7                ; it was, then it will be write protected.
2885: EED7                ;                   
2886: EED7                FINDNXT:            
2887: EED7     0E00       	MVI		C,0			;write protect the disk if changed.
2888: EED9     CD0EEE     	CALL	NXENTRY		;get next filename entry in directory.
2889: EEDC     CDFEED     	CALL	CKFILPOS;is file position = 0ffffh?
2890: EEDF     CA3EEF     	JZ	FNDNXT6	;yes, exit now then.
2891: EEE2     2AD5F5     	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2892: EEE5     EB         	XCHG               
2893: EEE6     1A         	LDAX	D             
2894: EEE7     FEE5       	CPI	0E5H	;empty directory entry?
2895: EEE9     CAF4EE     	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2896: EEEC     D5         	PUSH	D             
2897: EEED     CD88ED     	CALL	MOREFLS	;more files in directory?
2898: EEF0     D1         	POP	D              
2899: EEF1     D23EEF     	JNC	FNDNXT6	;no more. Exit now.
2900: EEF4                FNDNXT1:            
2901: EEF4     CD67ED     	CALL	FCB2HL	;get address of this fcb in directory.
2902: EEF7     3AD4F5     	LDA	COUNTER	;get number of bytes (characters) to check.
2903: EEFA     4F         	MOV	C,A            
2904: EEFB     0600       	MVI	B,0	;initialize byte position counter.
2905: EEFD                FNDNXT2:            
2906: EEFD     79         	MOV	A,C	;are we done with the compare?
2907: EEFE     B7         	ORA	A              
2908: EEFF     CA2DEF     	JZ	FNDNXT5         
2909: EF02     1A         	LDAX	D	;no, check next byte.
2910: EF03     FE3F       	CPI	QMARK		; '?'	;don't care about this character?
2911: EF05     CA26EF     	JZ	FNDNXT4         
2912: EF08     78         	MOV	A,B	;get bytes position in fcb.
2913: EF09     FE0D       	CPI	13	;don't care about the thirteenth byte either.
2914: EF0B     CA26EF     	JZ	FNDNXT4         
2915: EF0E     FE0C       	CPI	12	;extent byte?
2916: EF10     1A         	LDAX	D             
2917: EF11     CA1DEF     	JZ	FNDNXT3         
2918: EF14     96         	SUB	M	;otherwise compare characters.
2919: EF15     E67F       	ANI	7FH            
2920: EF17     C2D7EE     	JNZ	FINDNXT	;not the same, check next entry.
2921: EF1A     C326EF     	JMP	FNDNXT4	;so far so good, keep checking.
2922: EF1D                FNDNXT3:            
2923: EF1D     C5         	PUSH	B	;check the extent byte here.
2924: EF1E     4E         	MOV	C,M            
2925: EF1F     CDB1EE     	CALL	SAMEXT        
2926: EF22     C1         	POP	B              
2927: EF23     C2D7EE     	JNZ	FINDNXT	;not the same, look some more.
2928: EF26                ;                   
2929: EF26                ;   So far the names compare. Bump pointers to the next byte
2930: EF26                ; and continue until all (C) characters have been checked.
2931: EF26                ;                   
2932: EF26                FNDNXT4:            
2933: EF26     13         	INX	D	;bump pointers.
2934: EF27     23         	INX	H              
2935: EF28     04         	INR	B              
2936: EF29     0D         	DCR	C	;adjust character counter.
2937: EF2A     C3FDEE     	JMP	FNDNXT2        
2938: EF2D                FNDNXT5:            
2939: EF2D     3AE6F5     	LDA	FILEPOS	;return the position of this entry.
2940: EF30     E603       	ANI	03H            
2941: EF32     323FE8     	STA	StatusBDOSReturn
2942: EF35     21D1F5     	LXI	H,FNDSTAT      
2943: EF38     7E         	MOV	A,M            
2944: EF39     17         	RAL                
2945: EF3A     D0         	RNC                
2946: EF3B     AF         	XRA	A              
2947: EF3C     77         	MOV	M,A            
2948: EF3D     C9         	RET                
2949: EF3E                ;                   
2950: EF3E                ;   Filename was not found. Set appropriate status.
2951: EF3E                ;                   
2952: EF3E                FNDNXT6:            
2953: EF3E     CD07EE     	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2954: EF41     3EFF       	MVI	A,0FFH	;say not located.
2955: EF43     C35CEB     	JMP	SETSTAT        
2956: EF46                ;                   
2957: EF46                ;   Erase files from the directory. Only the first byte of the
2958: EF46                ; fcb will be affected. It is set to (E5).
2959: EF46                ;                   
2960: EF46                ERAFILE:            
2961: EF46     CD5DED     	CALL	CHKWPRT		;is disk write protected?
2962: EF49     0E0C       	MVI		C,12		;only compare file names.
2963: EF4B     CDC2EE     	CALL	FINDFST		;get first file name.
2964: EF4E                ERAFIL1:            
2965: EF4E     CDFEED     	CALL	CKFILPOS	;any found?
2966: EF51     C8         	RZ					;nope, we must be done.
2967: EF52     CD4DED     	CALL	CHKROFL	;is file read only?
2968: EF55     CD67ED     	CALL	FCB2HL	;nope, get address of fcb and
2969: EF58     36E5       	MVI	M,0E5H	;set first byte to 'empty'.
2970: EF5A                ;	MVI	C,0	;clear the space from the bit map.
2971: EF5A     3E00       	MVI		A,00H		; want to clear the bit
2972: EF5C     32A8F5     	STA		BitSetFlag	; Flag = 00, clear bit
2973: EF5F     CD76EE     	CALL	SETFILE       
2974: EF62     CDCFED     	CALL	DIRWRITE;now write the directory sector back out.
2975: EF65     CDD7EE     	CALL	FINDNXT	;find the next file name.
2976: EF68     C34EEF     	JMP	ERAFIL1	;and repeat process.
2977: EF6B                ;                   
2978: EF6B                ;   Look through the space allocation map (bit map) for the
2979: EF6B                ; next available block. Start searching at block number (BC-1).
2980: EF6B                ; The search procedure is to look for an empty block that is
2981: EF6B                ; before the starting block. If not empty, look at a later
2982: EF6B                ; block number. In this way, we return the closest empty block
2983: EF6B                ; on either side of the 'target' block number. This will speed
2984: EF6B                ; access on random devices. For serial devices, this should be
2985: EF6B                ; changed to look in the forward direction first and then start
2986: EF6B                ; at the front and search some more.
2987: EF6B                ;                   
2988: EF6B                ;   On return, (DE)= block number that is empty and (HL) =0
2989: EF6B                ; if no empry block was found.
2990: EF6B                ;                   
2991: EF6B                FNDSPACE:           
2992: EF6B     50         	MOV	D,B	;set (DE) as the block that is checked.
2993: EF6C     59         	MOV	E,C            
2994: EF6D                ;                   
2995: EF6D                ;   Look before target block. Registers (BC) are used as the lower
2996: EF6D                ; pointer and (DE) as the upper pointer.
2997: EF6D                ;                   
2998: EF6D                FNDSPA1:            
2999: EF6D     79         	MOV	A,C	;is block 0 specified?
3000: EF6E     B0         	ORA	B              
3001: EF6F     CA7EEF     	JZ	FNDSPA2         
3002: EF72     0B         	DCX	B	;nope, check previous block.
3003: EF73     D5         	PUSH	D             
3004: EF74     C5         	PUSH	B             
3005: EF75     CD3EEE     	CALL	CKBITMAP      
3006: EF78     1F         	RAR		;is this block empty?
3007: EF79     D299EF     	JNC	FNDSPA3	;yes. use this.
3008: EF7C                ;                   
3009: EF7C                ;   Note that the above logic gets the first block that it finds
3010: EF7C                ; that is empty. Thus a file could be written 'backward' making
3011: EF7C                ; it very slow to access. This could be changed to look for the
3012: EF7C                ; first empty block and then continue until the start of this
3013: EF7C                ; empty space is located and then used that starting block.
3014: EF7C                ; This should help speed up access to some files especially on
3015: EF7C                ; a well used disk with lots of fairly small 'holes'.
3016: EF7C                ;                   
3017: EF7C     C1         	POP	B	;nope, check some more.
3018: EF7D     D1         	POP	D              
3019: EF7E                ;                   
3020: EF7E                ;   Now look after target block.
3021: EF7E                ;                   
3022: EF7E                FNDSPA2:            
3023: EF7E     2AC3F5     	LHLD	DSKSIZE	;is block (DE) within disk limits?
3024: EF81     7B         	MOV	A,E            
3025: EF82     95         	SUB	L              
3026: EF83     7A         	MOV	A,D            
3027: EF84     9C         	SBB	H              
3028: EF85     D2A1EF     	JNC	FNDSPA4        
3029: EF88     13         	INX	D	;yes, move on to next one.
3030: EF89     C5         	PUSH	B             
3031: EF8A     D5         	PUSH	D             
3032: EF8B     42         	MOV	B,D            
3033: EF8C     4B         	MOV	C,E            
3034: EF8D     CD3EEE     	CALL	CKBITMAP;check it.
3035: EF90     1F         	RAR		;empty?       
3036: EF91     D299EF     	JNC	FNDSPA3        
3037: EF94     D1         	POP	D	;nope, continue searching.
3038: EF95     C1         	POP	B              
3039: EF96     C36DEF     	JMP	FNDSPA1        
3040: EF99                ;                   
3041: EF99                ;   Empty block found. Set it as used and return with (HL)
3042: EF99                ; pointing to it (true?).
3043: EF99                ;                   
3044: EF99                FNDSPA3:            
3045: EF99     17         	RAL		;reset byte.  
3046: EF9A     3C         	INR	A	;and set bit 0.
3047: EF9B     CD6FEE     	CALL	STBMAP1	;update bit map.
3048: EF9E     E1         	POP	H	;set return registers.
3049: EF9F     D1         	POP	D              
3050: EFA0     C9         	RET                
3051: EFA1                ;                   
3052: EFA1                ;   Free block was not found. If (BC) is not zero, then we have
3053: EFA1                ; not checked all of the disk space.
3054: EFA1                ;                   
3055: EFA1                FNDSPA4:            
3056: EFA1     79         	MOV	A,C            
3057: EFA2     B0         	ORA	B              
3058: EFA3     C26DEF     	JNZ	FNDSPA1        
3059: EFA6     210000     	LXI	H,0	;set 'not found' status.
3060: EFA9     C9         	RET                
3061: EFAA                ;                   
3062: EFAA                ;   Move a complete fcb entry into the directory and write it.
3063: EFAA                ;                   
3064: EFAA                FCBSET:             
3065: EFAA     0E00       	MVI	C,0            
3066: EFAC     1E20       	MVI	E,32	;length of each entry.
3067: EFAE                ;                   
3068: EFAE                ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3069: EFAE                ; fcb in directory starting at relative byte (C). This updated
3070: EFAE                ; directory buffer is then written to the disk.
3071: EFAE                ;                   
3072: EFAE                UPDATE:             
3073: EFAE     D5         	PUSH	D             
3074: EFAF     0600       	MVI	B,0	;set (BC) to relative byte position.
3075: EFB1     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3076: EFB4     09         	DAD	B	;compute starting byte.
3077: EFB5     EB         	XCHG               
3078: EFB6     CD67ED     	CALL	FCB2HL	;get address of fcb to update in directory.
3079: EFB9     C1         	POP	B	;set (C) to number of bytes to change.
3080: EFBA     CD72EB     	CALL	DE2HL         
3081: EFBD                UPDATE1:            
3082: EFBD     CDE6EB     	CALL	TRKSEC	;determine the track and sector affected.
3083: EFC0     C3CFED     	JMP	DIRWRITE	;then write this sector out.
3084: EFC3                ;                   
3085: EFC3                ;   Routine to change the name of all files on the disk with a
3086: EFC3                ; specified name. The fcb contains the current name as the
3087: EFC3                ; first 12 characters and the new name 16 bytes into the fcb.
3088: EFC3                ;                   
3089: EFC3                CHGNAMES:           
3090: EFC3     CD5DED     	CALL	CHKWPRT	;check for a write protected disk.
3091: EFC6     0E0C       	MVI	C,12	;match first 12 bytes of fcb only.
3092: EFC8     CDC2EE     	CALL	FINDFST	;get first name.
3093: EFCB     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3094: EFCE     7E         	MOV	A,M	;get user number.
3095: EFCF     111000     	LXI	D,16	;move over to desired name.
3096: EFD2     19         	DAD	D              
3097: EFD3     77         	MOV	M,A	;keep same user number.
3098: EFD4                CHGNAM1:            
3099: EFD4     CDFEED     	CALL	CKFILPOS;any matching file found?
3100: EFD7     C8         	RZ		;no, we must be done.
3101: EFD8     CD4DED     	CALL	CHKROFL	;check for read only file.
3102: EFDB     0E10       	MVI	C,16	;start 16 bytes into fcb.
3103: EFDD     1E0C       	MVI	E,12	;and update the first 12 bytes of directory.
3104: EFDF     CDAEEF     	CALL	UPDATE        
3105: EFE2     CDD7EE     	CALL	FINDNXT	;get te next file name.
3106: EFE5     C3D4EF     	JMP	CHGNAM1	;and continue.
3107: EFE8                ;                   
3108: EFE8                ;   Update a files attributes. The procedure is to search for
3109: EFE8                ; every file with the same name as shown in fcb (ignoring bit 7)
3110: EFE8                ; and then to update it (which includes bit 7). No other changes
3111: EFE8                ; are made.         
3112: EFE8                ;                   
3113: EFE8                SAVEATTR:           
3114: EFE8     0E0C       	MVI	C,12	;match first 12 bytes.
3115: EFEA     CDC2EE     	CALL	FINDFST	;look for first filename.
3116: EFED                SAVATR1:            
3117: EFED     CDFEED     	CALL	CKFILPOS;was one found?
3118: EFF0     C8         	RZ		;nope, we must be done.
3119: EFF1     0E00       	MVI	C,0	;yes, update the first 12 bytes now.
3120: EFF3     1E0C       	MVI	E,12           
3121: EFF5     CDAEEF     	CALL	UPDATE	;update filename and write directory.
3122: EFF8     CDD7EE     	CALL	FINDNXT	;and get the next file.
3123: EFFB     C3EDEF     	JMP	SAVATR1	;then continue until done.
3124: EFFE                ;                   
3125: EFFE                ;  Open a file (name specified in fcb).
3126: EFFE                ;                   
3127: EFFE                OPENIT:             
3128: EFFE     0E0F       	MVI	C,15	;compare the first 15 bytes.
3129: F000     CDC2EE     	CALL	FINDFST	;get the first one in directory.
3130: F003     CDFEED     	CALL	CKFILPOS;any at all?
3131: F006     C8         	RZ                 
3132: F007                OPENIT1:            
3133: F007     CDC9EC     	CALL	SETEXT	;point to extent byte within users fcb.
3134: F00A     7E         	MOV	A,M	;and get it.
3135: F00B     F5         	PUSH	PSW	;save it and address.
3136: F00C     E5         	PUSH	H             
3137: F00D     CD67ED     	CALL	FCB2HL	;point to fcb in directory.
3138: F010     EB         	XCHG               
3139: F011     2A3CE8     	LHLD	ParamsDE	;this is the users copy.
3140: F014     0E20       	MVI	C,32	;move it into users space.
3141: F016     D5         	PUSH	D             
3142: F017     CD72EB     	CALL	DE2HL         
3143: F01A     CD81ED     	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
3144: F01D     D1         	POP	D	;now get the extent byte from this fcb.
3145: F01E     210C00     	LXI	H,12           
3146: F021     19         	DAD	D              
3147: F022     4E         	MOV	C,M	;into (C). 
3148: F023     210F00     	LXI	H,15	;now get the record count byte into (B).
3149: F026     19         	DAD	D              
3150: F027     46         	MOV	B,M            
3151: F028     E1         	POP	H	;keep the same extent as the user had originally.
3152: F029     F1         	POP	PSW            
3153: F02A     77         	MOV	M,A            
3154: F02B     79         	MOV	A,C	;is it the same as in the directory fcb?
3155: F02C     BE         	CMP	M              
3156: F02D     78         	MOV	A,B	;if yes, then use the same record count.
3157: F02E     CA38F0     	JZ	OPENIT2         
3158: F031     3E00       	MVI	A,0	;if the user specified an extent greater than
3159: F033     DA38F0     	JC	OPENIT2	;the one in the directory, then set record count to 0.
3160: F036     3E80       	MVI	A,128	;otherwise set to maximum.
3161: F038                OPENIT2:            
3162: F038     2A3CE8     	LHLD	ParamsDE	;set record count in users fcb to (A).
3163: F03B     110F00     	LXI	D,15           
3164: F03E     19         	DAD	D	;compute relative position.
3165: F03F     77         	MOV	M,A	;and set the record count.
3166: F040     C9         	RET                
3167: F041                ;                   
3168: F041                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3169: F041                ; point to a zero value (16 bit).
3170: F041                ;   Return with zero flag set it (DE) was moved. Registers (DE)
3171: F041                ; and (HL) are not changed. However (A) is.
3172: F041                ;                   
3173: F041                MOVEWORD:           
3174: F041     7E         	MOV	A,M	;check for a zero word.
3175: F042     23         	INX	H              
3176: F043     B6         	ORA	M	;both bytes zero?
3177: F044     2B         	DCX	H              
3178: F045     C0         	RNZ		;nope, just return.
3179: F046     1A         	LDAX	D	;yes, move two bytes from (DE) into
3180: F047     77         	MOV	M,A	;this zero space.
3181: F048     13         	INX	D              
3182: F049     23         	INX	H              
3183: F04A     1A         	LDAX	D             
3184: F04B     77         	MOV	M,A            
3185: F04C     1B         	DCX	D	;don't disturb these registers.
3186: F04D     2B         	DCX	H              
3187: F04E     C9         	RET                
3188: F04F                ;                   
3189: F04F                ;   Get here to close a file specified by (fcb).
3190: F04F                ;                   
3191: F04F                CLOSEIT:            
3192: F04F     AF         	XRA	A	;clear status and file position bytes.
3193: F050     323FE8     	STA	StatusBDOSReturn
3194: F053     32E6F5     	STA	FILEPOS        
3195: F056     32E7F5     	STA	FILEPOS+1      
3196: F059     CD27ED     	CALL	GETWPRT	;get write protect bit for this drive.
3197: F05C     C0         	RNZ		;just return if it is set.
3198: F05D     CD72ED     	CALL	GETS2	;else get the 's2' byte.
3199: F060     E680       	ANI	80H	;and look at bit 7 (file unmodified?).
3200: F062     C0         	RNZ		;just return if set.
3201: F063     0E0F       	MVI	C,15	;else look up this file in directory.
3202: F065     CDC2EE     	CALL	FINDFST       
3203: F068     CDFEED     	CALL	CKFILPOS;was it found?
3204: F06B     C8         	RZ		;just return if not.
3205: F06C     011000     	LXI	B,16	;set (HL) pointing to records used section.
3206: F06F     CD67ED     	CALL	FCB2HL        
3207: F072     09         	DAD	B              
3208: F073     EB         	XCHG               
3209: F074     2A3CE8     	LHLD	ParamsDE	;do the same for users specified fcb.
3210: F077     09         	DAD	B              
3211: F078     0E10       	MVI	C,16	;this many bytes are present in this extent.
3212: F07A                CLOSEIT1:           
3213: F07A     3AD9F5     	LDA	BIGDISK	;8 or 16 bit record numbers?
3214: F07D     B7         	ORA	A              
3215: F07E     CA95F0     	JZ	CLOSEIT4        
3216: F081     7E         	MOV	A,M	;just 8 bit. Get one from users fcb.
3217: F082     B7         	ORA	A              
3218: F083     1A         	LDAX	D	;now get one from directory fcb.
3219: F084     C288F0     	JNZ	CLOSEIT2       
3220: F087     77         	MOV	M,A	;users byte was zero. Update from directory.
3221: F088                CLOSEIT2:           
3222: F088     B7         	ORA	A              
3223: F089     C28EF0     	JNZ	CLOSEIT3       
3224: F08C     7E         	MOV	A,M	;directories byte was zero, update from users fcb.
3225: F08D     12         	STAX	D             
3226: F08E                CLOSEIT3:           
3227: F08E     BE         	CMP	M	;if neither one of these bytes were zero,
3228: F08F     C2CCF0     	JNZ	CLOSEIT7	;then close error if they are not the same.
3229: F092     C3AAF0     	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3230: F095                CLOSEIT4:           
3231: F095     CD41F0     	CALL	MOVEWORD;update users fcb if it is zero.
3232: F098     EB         	XCHG               
3233: F099     CD41F0     	CALL	MOVEWORD;update directories fcb if it is zero.
3234: F09C     EB         	XCHG               
3235: F09D     1A         	LDAX	D	;if these two values are no different,
3236: F09E     BE         	CMP	M	;then a close error occured.
3237: F09F     C2CCF0     	JNZ	CLOSEIT7       
3238: F0A2     13         	INX	D	;check second byte.
3239: F0A3     23         	INX	H              
3240: F0A4     1A         	LDAX	D             
3241: F0A5     BE         	CMP	M              
3242: F0A6     C2CCF0     	JNZ	CLOSEIT7       
3243: F0A9     0D         	DCR	C	;remember 16 bit values.
3244: F0AA                CLOSEIT5:           
3245: F0AA     13         	INX	D	;bump to next item in table.
3246: F0AB     23         	INX	H              
3247: F0AC     0D         	DCR	C	;there are 16 entries only.
3248: F0AD     C27AF0     	JNZ	CLOSEIT1;continue if more to do.
3249: F0B0     01ECFF     	LXI	B,0FFECH;backup 20 places (extent byte).
3250: F0B3     09         	DAD	B              
3251: F0B4     EB         	XCHG               
3252: F0B5     09         	DAD	B              
3253: F0B6     1A         	LDAX	D             
3254: F0B7     BE         	CMP	M	;directory's extent already greater than the
3255: F0B8     DAC4F0     	JC	CLOSEIT6	;users extent?
3256: F0BB     77         	MOV	M,A	;no, update directory extent.
3257: F0BC     010300     	LXI	B,3	;and update the record count byte in
3258: F0BF     09         	DAD	B	;directories fcb.
3259: F0C0     EB         	XCHG               
3260: F0C1     09         	DAD	B              
3261: F0C2     7E         	MOV	A,M	;get from user.
3262: F0C3     12         	STAX	D	;and put in directory.
3263: F0C4                CLOSEIT6:           
3264: F0C4     3EFF       	MVI	A,0FFH	;set 'was open and is now closed' byte.
3265: F0C6     32CFF5     	STA	CLOSEFLG       
3266: F0C9     C3BDEF     	JMP	UPDATE1	;update the directory now.
3267: F0CC                CLOSEIT7:           
3268: F0CC     213FE8     	LXI	H,StatusBDOSReturn;set return status and then return.
3269: F0CF     35         	DCR	M              
3270: F0D0     C9         	RET                
3271: F0D1                ;                   
3272: F0D1                ;   Routine to get the next empty space in the directory. It
3273: F0D1                ; will then be cleared for use.
3274: F0D1                ;                   
3275: F0D1                GETEMPTY:           
3276: F0D1     CD5DED     	CALL	CHKWPRT		;make sure disk is not write protected.
3277: F0D4     2A3CE8     	LHLD	ParamsDE	;save current parameters (fcb).
3278: F0D7     E5         	PUSH	H             
3279: F0D8     21A9F5     	LXI		H,EMPTYFCB	;use special one for empty space.
3280: F0DB     223CE8     	SHLD	ParamsDE      
3281: F0DE     0E01       	MVI	C,1	;search for first empty spot in directory.
3282: F0E0     CDC2EE     	CALL	FINDFST	;(* only check first byte *)
3283: F0E3     CDFEED     	CALL	CKFILPOS;none?
3284: F0E6     E1         	POP	H              
3285: F0E7     223CE8     	SHLD	ParamsDE	;restore original fcb address.
3286: F0EA     C8         	RZ		;return if no more space.
3287: F0EB     EB         	XCHG               
3288: F0EC     210F00     	LXI	H,15	;point to number of records for this file.
3289: F0EF     19         	DAD	D              
3290: F0F0     0E11       	MVI	C,17	;and clear all of this space.
3291: F0F2     AF         	XRA	A              
3292: F0F3                GETMT1:             
3293: F0F3     77         	MOV	M,A            
3294: F0F4     23         	INX	H              
3295: F0F5     0D         	DCR	C              
3296: F0F6     C2F3F0     	JNZ	GETMT1         
3297: F0F9     210D00     	LXI	H,13	;clear the 's1' byte also.
3298: F0FC     19         	DAD	D              
3299: F0FD     77         	MOV	M,A            
3300: F0FE     CD95ED     	CALL	CHKNMBR	;keep (FilePosInDir) within bounds.
3301: F101     CDAAEF     	CALL	FCBSET	;write out this fcb entry to directory.
3302: F104     C381ED     	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
3303: F107                ;                   
3304: F107                ;   Routine to close the current extent and open the next one
3305: F107                ; for reading.      
3306: F107                ;                   
3307: F107                GETNEXT:            
3308: F107     AF         	XRA	A              
3309: F108     32CFF5     	STA	CLOSEFLG;clear close flag.
3310: F10B     CD4FF0     	CALL	CLOSEIT	;close this extent.
3311: F10E     CDFEED     	CALL	CKFILPOS      
3312: F111     C8         	RZ		;not there???  
3313: F112     2A3CE8     	LHLD	ParamsDE	;get extent byte.
3314: F115     010C00     	LXI	B,12           
3315: F118     09         	DAD	B              
3316: F119     7E         	MOV	A,M	;and increment it.
3317: F11A     3C         	INR	A              
3318: F11B     E61F       	ANI	1FH	;keep within range 0-31.
3319: F11D     77         	MOV	M,A            
3320: F11E     CA30F1     	JZ	GTNEXT1	;overflow?
3321: F121     47         	MOV	B,A	;mask extent byte.
3322: F122     3AC2F5     	LDA	EXTMASK        
3323: F125     A0         	ANA	B              
3324: F126     21CFF5     	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3325: F129     A6         	ANA	M              
3326: F12A     CA3BF1     	JZ	GTNEXT2	;if zero, we must read in next extent.
3327: F12D     C359F1     	JMP	GTNEXT3	;else, it is already in memory.
3328: F130                GTNEXT1:            
3329: F130     010200     	LXI	B,2	;Point to the 's2' byte.
3330: F133     09         	DAD	B              
3331: F134     34         	INR	M	;and bump it.
3332: F135     7E         	MOV	A,M	;too many extents?
3333: F136     E60F       	ANI	0FH            
3334: F138     CA63F1     	JZ	GTNEXT5	;yes, set error code.
3335: F13B                ;                   
3336: F13B                ;   Get here to open the next extent.
3337: F13B                ;                   
3338: F13B                GTNEXT2:            
3339: F13B     0E0F       	MVI	C,15	;set to check first 15 bytes of fcb.
3340: F13D     CDC2EE     	CALL	FINDFST	;find the first one.
3341: F140     CDFEED     	CALL	CKFILPOS;none available?
3342: F143     C259F1     	JNZ	GTNEXT3        
3343: F146     3AD0F5     	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3344: F149     3C         	INR	A	;0ffh means reading (so not possible).
3345: F14A     CA63F1     	JZ	GTNEXT5	;or an error.
3346: F14D     CDD1F0     	CALL	GETEMPTY;we are writing, get an empty entry.
3347: F150     CDFEED     	CALL	CKFILPOS;none?
3348: F153     CA63F1     	JZ	GTNEXT5	;error if true.
3349: F156     C35CF1     	JMP	GTNEXT4	;else we are almost done.
3350: F159                GTNEXT3:            
3351: F159     CD07F0     	CALL	OPENIT1	;open this extent.
3352: F15C                GTNEXT4:            
3353: F15C     CDDEEC     	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3354: F15F     AF         	XRA	A	;clear status and return.
3355: F160     C35CEB     	JMP	SETSTAT        
3356: F163                ;                   
3357: F163                ;   Error in extending the file. Too many extents were needed
3358: F163                ; or not enough space on the disk.
3359: F163                ;                   
3360: F163                GTNEXT5:            
3361: F163     CD60EB     	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3362: F166     C381ED     	JMP	SETS2B7	;so this is not written on a close.
3363: F169                ;                   
3364: F169                ;   Read a sequential file.
3365: F169                ;                   
3366: F169                RDSEQ:              
3367: F169     3E01       	MVI	A,1	;set sequential access mode.
3368: F16B     32D2F5     	STA	MODE           
3369: F16E                RDSEQ1:             
3370: F16E     3EFF       	MVI	A,0FFH	;don't allow reading unwritten space.
3371: F170     32D0F5     	STA	RDWRTFLG       
3372: F173     CDDEEC     	CALL	STRDATA	;put rec# and ext# into fcb.
3373: F176     3ADFF5     	LDA	SAVNREC	;get next record to read.
3374: F179     21DDF5     	LXI	H,SAVNXT;get number of records in extent.
3375: F17C     BE         	CMP	M	;within this extent?
3376: F17D     DA93F1     	JC	RDSEQ2          
3377: F180     FE80       	CPI	128	;no. Is this extent fully used?
3378: F182     C2A8F1     	JNZ	RDSEQ3	;no. End-of-file.
3379: F185     CD07F1     	CALL	GETNEXT	;yes, open the next one.
3380: F188     AF         	XRA	A	;reset next record to read.
3381: F189     32DFF5     	STA	SAVNREC        
3382: F18C     3A3FE8     	LDA	StatusBDOSReturn	;check on open, successful?
3383: F18F     B7         	ORA	A              
3384: F190     C2A8F1     	JNZ	RDSEQ3	;no, error.
3385: F193                RDSEQ2:             
3386: F193     CD9AEC     	CALL	COMBLK	;ok. compute block number to read.
3387: F196     CDA7EC     	CALL	CHKBLK	;check it. Within bounds?
3388: F199     CAA8F1     	JZ	RDSEQ3	;no, error.
3389: F19C     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
3390: F19F     CDF4EB     	CALL	TRKSEC1	;set the track and sector for this block #.
3391: F1A2     CDD5EB     	CALL	DOREAD	;and read it.
3392: F1A5     C3F5EC     	JMP	SETNREC	;and set the next record to be accessed.
3393: F1A8                ;                   
3394: F1A8                ;   Read error occured. Set status and return.
3395: F1A8                ;                   
3396: F1A8                RDSEQ3:             
3397: F1A8     C360EB     	JMP	IOERR1         
3398: F1AB                ;                   
3399: F1AB                ;   Write the next sequential record.
3400: F1AB                ;                   
3401: F1AB                WTSEQ:              
3402: F1AB     3E01       	MVI	A,1	;set sequential access mode.
3403: F1AD     32D2F5     	STA	MODE           
3404: F1B0                WTSEQ1:             
3405: F1B0     3E00       	MVI	A,0	;allow an addition empty extent to be opened.
3406: F1B2     32D0F5     	STA	RDWRTFLG       
3407: F1B5     CD5DED     	CALL	CHKWPRT	;check write protect status.
3408: F1B8     2A3CE8     	LHLD	ParamsDE      
3409: F1BB     CD50ED     	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3410: F1BE     CDDEEC     	CALL	STRDATA	;put updated data into fcb.
3411: F1C1     3ADFF5     	LDA	SAVNREC	;get record number to write.
3412: F1C4     FE80       	CPI	128	;within range?
3413: F1C6     D260EB     	JNC	IOERR1	;no, error(?).
3414: F1C9     CD9AEC     	CALL	COMBLK	;compute block number.
3415: F1CC     CDA7EC     	CALL	CHKBLK	;check number.
3416: F1CF     0E00       	MVI	C,0	;is there one to write to?
3417: F1D1     C21BF2     	JNZ	WTSEQ6	;yes, go do it.
3418: F1D4     CD61EC     	CALL	GETBLOCK;get next block number within fcb to use.
3419: F1D7     32D3F5     	STA	RELBLOCK;and save.
3420: F1DA     010000     	LXI	B,0	;start looking for space from the start
3421: F1DD     B7         	ORA	A	;if none allocated as yet.
3422: F1DE     CAE8F1     	JZ	WTSEQ2          
3423: F1E1     4F         	MOV	C,A	;extract previous block number from fcb
3424: F1E2     0B         	DCX	B	;so we can be closest to it.
3425: F1E3     CD81EC     	CALL	EXTBLK        
3426: F1E6     44         	MOV	B,H            
3427: F1E7     4D         	MOV	C,L            
3428: F1E8                WTSEQ2:             
3429: F1E8     CD6BEF     	CALL	FNDSPACE;find the next empty block nearest number (BC).
3430: F1EB     7D         	MOV	A,L	;check for a zero number.
3431: F1EC     B4         	ORA	H              
3432: F1ED     C2F5F1     	JNZ	WTSEQ3         
3433: F1F0     3E02       	MVI	A,2	;no more space?
3434: F1F2     C35CEB     	JMP	SETSTAT        
3435: F1F5                WTSEQ3:             
3436: F1F5     22E1F5     	SHLD	BLKNMBR	;save block number to access.
3437: F1F8     EB         	XCHG		;put block number into (DE).
3438: F1F9     2A3CE8     	LHLD	ParamsDE	;now we must update the fcb for this
3439: F1FC     011000     	LXI	B,16	;newly allocated block.
3440: F1FF     09         	DAD	B              
3441: F200     3AD9F5     	LDA	BIGDISK	;8 or 16 bit block numbers?
3442: F203     B7         	ORA	A              
3443: F204     3AD3F5     	LDA	RELBLOCK	;(* update this entry *)
3444: F207     CA11F2     	JZ	WTSEQ4	;zero means 16 bit ones.
3445: F20A     CD6DED     	CALL	ADDA2HL	;(HL)=(HL)+(A)
3446: F20D     73         	MOV	M,E	;store new block number.
3447: F20E     C319F2     	JMP	WTSEQ5         
3448: F211                WTSEQ4:             
3449: F211     4F         	MOV	C,A	;compute spot in this 16 bit table.
3450: F212     0600       	MVI	B,0            
3451: F214     09         	DAD	B              
3452: F215     09         	DAD	B              
3453: F216     73         	MOV	M,E	;stuff block number (DE) there.
3454: F217     23         	INX	H              
3455: F218     72         	MOV	M,D            
3456: F219                WTSEQ5:             
3457: F219     0E02       	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3458: F21B                WTSEQ6:             
3459: F21B     3A3FE8     	LDA	StatusBDOSReturn	;are we ok so far?
3460: F21E     B7         	ORA	A              
3461: F21F     C0         	RNZ                
3462: F220     C5         	PUSH	B	;yes, save write flag for bios (register C).
3463: F221     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3464: F224     3AD2F5     	LDA	MODE	;get access mode flag (1=sequential,
3465: F227     3D         	DCR	A	;0=random, 2=special?).
3466: F228     3D         	DCR	A              
3467: F229     C268F2     	JNZ	WTSEQ9         
3468: F22C                ;                   
3469: F22C                ;   Special random i/o from function #40. Maybe for M/PM, but the
3470: F22C                ; current block, if it has not been written to, will be zeroed
3471: F22C                ; out and then written (reason?).
3472: F22C                ;                   
3473: F22C     C1         	POP	B              
3474: F22D     C5         	PUSH	B             
3475: F22E     79         	MOV	A,C	;get write status flag (2=writing unused space).
3476: F22F     3D         	DCR	A              
3477: F230     3D         	DCR	A              
3478: F231     C268F2     	JNZ	WTSEQ9         
3479: F234     E5         	PUSH	H             
3480: F235     2AB6F5     	LHLD	DIRBUF	;zero out the directory buffer.
3481: F238     57         	MOV	D,A	;note that (A) is zero here.
3482: F239                WTSEQ7:             
3483: F239     77         	MOV	M,A            
3484: F23A     23         	INX	H              
3485: F23B     14         	INR	D	;do 128 bytes.
3486: F23C     F239F2     	JP	WTSEQ7          
3487: F23F     CDE9ED     	CALL	SetDirDMA	;tell the bios the dma address for directory access.
3488: F242     2AE3F5     	LHLD	LOGSECT	;get sector that starts current block.
3489: F245     0E02       	MVI	C,2	;set 'writing to unused space' flag.
3490: F247                WTSEQ8:             
3491: F247     22E1F5     	SHLD	BLKNMBR	;save sector to write.
3492: F24A     C5         	PUSH	B             
3493: F24B     CDF4EB     	CALL	TRKSEC1	;determine its track and sector numbers.
3494: F24E     C1         	POP	B              
3495: F24F     CDDBEB     	CALL	DOWRITE	;now write out 128 bytes of zeros.
3496: F252     2AE1F5     	LHLD	BLKNMBR	;get sector number.
3497: F255     0E00       	MVI	C,0	;set normal write flag.
3498: F257     3AC1F5     	LDA	BLKMASK	;determine if we have written the entire
3499: F25A     47         	MOV	B,A	;physical block.
3500: F25B     A5         	ANA	L              
3501: F25C     B8         	CMP	B              
3502: F25D     23         	INX	H	;prepare for the next one.
3503: F25E     C247F2     	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3504: F261     E1         	POP	H	;reset next sector number.
3505: F262     22E1F5     	SHLD	BLKNMBR       
3506: F265     CDE3ED     	CALL	Set2UsersDMA	;and reset dma address.
3507: F268                ;                   
3508: F268                ;   Normal disk write. Set the desired track and sector then
3509: F268                ; do the actual write.
3510: F268                ;                   
3511: F268                WTSEQ9:             
3512: F268     CDF4EB     	CALL	TRKSEC1	;determine track and sector for this write.
3513: F26B     C1         	POP	B	;get write status flag.
3514: F26C     C5         	PUSH	B             
3515: F26D     CDDBEB     	CALL	DOWRITE	;and write this out.
3516: F270     C1         	POP	B              
3517: F271     3ADFF5     	LDA	SAVNREC	;get number of records in file.
3518: F274     21DDF5     	LXI	H,SAVNXT;get last record written.
3519: F277     BE         	CMP	M              
3520: F278     DA7FF2     	JC	WTSEQ10         
3521: F27B     77         	MOV	M,A	;we have to update record count.
3522: F27C     34         	INR	M              
3523: F27D     0E02       	MVI	C,2            
3524: F27F                ;                   
3525: F27F                ;*   This area has been patched to correct disk update problem
3526: F27F                ;* when using blocking and de-blocking in the BIOS.
3527: F27F                ;                   
3528: F27F                WTSEQ10:            
3529: F27F     00         	NOP		;was 'dcr c'  
3530: F280     00         	NOP		;was 'dcr c'  
3531: F281     210000     	LXI	H,0	;was 'jnz wtseq99'
3532: F284                ;                   
3533: F284                ; *   End of patch. 
3534: F284                ;                   
3535: F284     F5         	PUSH	PSW           
3536: F285     CD72ED     	CALL	GETS2	;set 'extent written to' flag.
3537: F288     E67F       	ANI	7FH	;(* clear bit 7 *)
3538: F28A     77         	MOV	M,A            
3539: F28B     F1         	POP	PSW	;get record count for this extent.
3540: F28C                WTSEQ99:            
3541: F28C     FE7F       	CPI	127	;is it full?
3542: F28E     C2ADF2     	JNZ	WTSEQ12        
3543: F291     3AD2F5     	LDA	MODE	;yes, are we in sequential mode?
3544: F294     FE01       	CPI	1              
3545: F296     C2ADF2     	JNZ	WTSEQ12        
3546: F299     CDF5EC     	CALL	SETNREC	;yes, set next record number.
3547: F29C     CD07F1     	CALL	GETNEXT	;and get next empty space in directory.
3548: F29F     213FE8     	LXI	H,StatusBDOSReturn;ok?
3549: F2A2     7E         	MOV	A,M            
3550: F2A3     B7         	ORA	A              
3551: F2A4     C2ABF2     	JNZ	WTSEQ11        
3552: F2A7     3D         	DCR	A	;yes, set record count to -1.
3553: F2A8     32DFF5     	STA	SAVNREC        
3554: F2AB                WTSEQ11:            
3555: F2AB     3600       	MVI	M,0	;clear status.
3556: F2AD                WTSEQ12:            
3557: F2AD     C3F5EC     	JMP	SETNREC	;set next record to access.
3558: F2B0                ;                   
3559: F2B0                ;   For random i/o, set the fcb for the desired record number
3560: F2B0                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3561: F2B0                ; used as follows:  
3562: F2B0                ;                   
3563: F2B0                ;       fcb+35            fcb+34            fcb+33
3564: F2B0                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3565: F2B0                ;  |7             0 | 7             0 | 7             0|
3566: F2B0                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3567: F2B0                ;  |    overflow   | | extra |  extent   |   record #  |
3568: F2B0                ;  | ______________| |_extent|__number___|_____________|
3569: F2B0                ;                     also 's2'
3570: F2B0                ;                   
3571: F2B0                ;   On entry, register (C) contains 0ffh if this is a read
3572: F2B0                ; and thus we can not access unwritten disk space. Otherwise,
3573: F2B0                ; another extent will be opened (for writing) if required.
3574: F2B0                ;                   
3575: F2B0                POSITION:           
3576: F2B0     AF         	XRA	A	;set random i/o flag.
3577: F2B1     32D2F5     	STA	MODE           
3578: F2B4                ;                   
3579: F2B4                ;   Special entry (function #40). M/PM ?
3580: F2B4                ;                   
3581: F2B4                POSITN1:            
3582: F2B4     C5         	PUSH	B	;save read/write flag.
3583: F2B5     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3584: F2B8     EB         	XCHG               
3585: F2B9     212100     	LXI	H,33	;now get byte 'r0'.
3586: F2BC     19         	DAD	D              
3587: F2BD     7E         	MOV	A,M            
3588: F2BE     E67F       	ANI	7FH	;keep bits 0-6 for the record number to access.
3589: F2C0     F5         	PUSH	PSW           
3590: F2C1     7E         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3591: F2C2     17         	RAL                
3592: F2C3     23         	INX	H              
3593: F2C4     7E         	MOV	A,M            
3594: F2C5     17         	RAL                
3595: F2C6     E61F       	ANI	1FH	;and save this in bits 0-4 of (C).
3596: F2C8     4F         	MOV	C,A	;this is the extent byte.
3597: F2C9     7E         	MOV	A,M	;now get the extra extent byte.
3598: F2CA     1F         	RAR                
3599: F2CB     1F         	RAR                
3600: F2CC     1F         	RAR                
3601: F2CD     1F         	RAR                
3602: F2CE     E60F       	ANI	0FH            
3603: F2D0     47         	MOV	B,A	;and save it in (B).
3604: F2D1     F1         	POP	PSW	;get record number back to (A).
3605: F2D2     23         	INX	H	;check overflow byte 'r2'.
3606: F2D3     6E         	MOV	L,M            
3607: F2D4     2C         	INR	L              
3608: F2D5     2D         	DCR	L              
3609: F2D6     2E06       	MVI	L,6	;prepare for error.
3610: F2D8     C238F3     	JNZ	POSITN5	;out of disk space error.
3611: F2DB     212000     	LXI	H,32	;store record number into fcb.
3612: F2DE     19         	DAD	D              
3613: F2DF     77         	MOV	M,A            
3614: F2E0     210C00     	LXI	H,12	;and now check the extent byte.
3615: F2E3     19         	DAD	D              
3616: F2E4     79         	MOV	A,C            
3617: F2E5     96         	SUB	M	;same extent as before?
3618: F2E6     C2F4F2     	JNZ	POSITN2        
3619: F2E9     210E00     	LXI	H,14	;yes, check extra extent byte 's2' also.
3620: F2EC     19         	DAD	D              
3621: F2ED     78         	MOV	A,B            
3622: F2EE     96         	SUB	M              
3623: F2EF     E67F       	ANI	7FH            
3624: F2F1     CA2CF3     	JZ	POSITN3;same, we are almost done then.
3625: F2F4                ;                   
3626: F2F4                ;  Get here when another extent is required.
3627: F2F4                ;                   
3628: F2F4                POSITN2:            
3629: F2F4     C5         	PUSH	B             
3630: F2F5     D5         	PUSH	D             
3631: F2F6     CD4FF0     	CALL	CLOSEIT	;close current extent.
3632: F2F9     D1         	POP	D              
3633: F2FA     C1         	POP	B              
3634: F2FB     2E03       	MVI	L,3	;prepare for error.
3635: F2FD     3A3FE8     	LDA	StatusBDOSReturn
3636: F300     3C         	INR	A              
3637: F301     CA31F3     	JZ	POSITN4	;close error.
3638: F304     210C00     	LXI	H,12	;put desired extent into fcb now.
3639: F307     19         	DAD	D              
3640: F308     71         	MOV	M,C            
3641: F309     210E00     	LXI	H,14	;and store extra extent byte 's2'.
3642: F30C     19         	DAD	D              
3643: F30D     70         	MOV	M,B            
3644: F30E     CDFEEF     	CALL	OPENIT	;try and get this extent.
3645: F311     3A3FE8     	LDA	StatusBDOSReturn	;was it there?
3646: F314     3C         	INR	A              
3647: F315     C22CF3     	JNZ	POSITN3        
3648: F318     C1         	POP	B	;no. can we create a new one (writing?).
3649: F319     C5         	PUSH	B             
3650: F31A     2E04       	MVI	L,4	;prepare for error.
3651: F31C     0C         	INR	C              
3652: F31D     CA31F3     	JZ	POSITN4	;nope, reading unwritten space error.
3653: F320     CDD1F0     	CALL	GETEMPTY;yes we can, try to find space.
3654: F323     2E05       	MVI	L,5	;prepare for error.
3655: F325     3A3FE8     	LDA	StatusBDOSReturn
3656: F328     3C         	INR	A              
3657: F329     CA31F3     	JZ	POSITN4	;out of space?
3658: F32C                ;                   
3659: F32C                ;   Normal return location. Clear error code and return.
3660: F32C                ;                   
3661: F32C                POSITN3:            
3662: F32C     C1         	POP	B	;restore stack.
3663: F32D     AF         	XRA	A	;and clear error code byte.
3664: F32E     C35CEB     	JMP	SETSTAT        
3665: F331                ;                   
3666: F331                ;   Error. Set the 's2' byte to indicate this (why?).
3667: F331                ;                   
3668: F331                POSITN4:            
3669: F331     E5         	PUSH	H             
3670: F332     CD72ED     	CALL	GETS2         
3671: F335     36C0       	MVI	M,0C0H         
3672: F337     E1         	POP	H              
3673: F338                ;                   
3674: F338                ;   Return with error code (presently in L).
3675: F338                ;                   
3676: F338                POSITN5:            
3677: F338     C1         	POP	B              
3678: F339     7D         	MOV	A,L	;get error code.
3679: F33A     323FE8     	STA	StatusBDOSReturn
3680: F33D     C381ED     	JMP	SETS2B7        
3681: F340                ;                   
3682: F340                ;   Read a random record.
3683: F340                ;                   
3684: F340                READRAN:            
3685: F340     0EFF       	MVI	C,0FFH	;set 'read' status.
3686: F342     CDB0F2     	CALL	POSITION;position the file to proper record.
3687: F345     CC6EF1     	CZ	RDSEQ1	;and read it as usual (if no errors).
3688: F348     C9         	RET                
3689: F349                ;                   
3690: F349                ;   Write to a random record.
3691: F349                ;                   
3692: F349                WRITERAN:           
3693: F349     0E00       	MVI	C,0	;set 'writing' flag.
3694: F34B     CDB0F2     	CALL	POSITION;position the file to proper record.
3695: F34E     CCB0F1     	CZ	WTSEQ1	;and write as usual (if no errors).
3696: F351     C9         	RET                
3697: F352                ;                   
3698: F352                ;   Compute the random record number. Enter with (HL) pointing
3699: F352                ; to a fcb an (DE) contains a relative location of a record
3700: F352                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3701: F352                ; byte, and (A) the 'r2' byte.
3702: F352                ;                   
3703: F352                ;   On return, the zero flag is set if the record is within
3704: F352                ; bounds. Otherwise, an overflow occured.
3705: F352                ;                   
3706: F352                COMPRAND:           
3707: F352     EB         	XCHG		;save fcb pointer in (DE).
3708: F353     19         	DAD	D	;compute relative position of record #.
3709: F354     4E         	MOV	C,M	;get record number into (BC).
3710: F355     0600       	MVI	B,0            
3711: F357     210C00     	LXI	H,12	;now get extent.
3712: F35A     19         	DAD	D              
3713: F35B     7E         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3714: F35C     0F         	RRC		;move lower bit into bit 7.
3715: F35D     E680       	ANI	80H	;and ignore all other bits.
3716: F35F     81         	ADD	C	;add to our record number.
3717: F360     4F         	MOV	C,A            
3718: F361     3E00       	MVI	A,0	;take care of any carry.
3719: F363     88         	ADC	B              
3720: F364     47         	MOV	B,A            
3721: F365     7E         	MOV	A,M	;now get the upper bits of extent into
3722: F366     0F         	RRC		;bit positions 0-3.
3723: F367     E60F       	ANI	0FH	;and ignore all others.
3724: F369     80         	ADD	B	;add this in to 'r1' byte.
3725: F36A     47         	MOV	B,A            
3726: F36B     210E00     	LXI	H,14	;get the 's2' byte (extra extent).
3727: F36E     19         	DAD	D              
3728: F36F     7E         	MOV	A,M            
3729: F370     87         	ADD	A	;and shift it left 4 bits (bits 4-7).
3730: F371     87         	ADD	A              
3731: F372     87         	ADD	A              
3732: F373     87         	ADD	A              
3733: F374     F5         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3734: F375     80         	ADD	B	;now add extra extent into 'r1'.
3735: F376     47         	MOV	B,A            
3736: F377     F5         	PUSH	PSW	;and save carry (overflow byte 'r2').
3737: F378     E1         	POP	H	;bit 0 of (L) is the overflow indicator.
3738: F379     7D         	MOV	A,L            
3739: F37A     E1         	POP	H	;and same for first carry flag.
3740: F37B     B5         	ORA	L	;either one of these set?
3741: F37C     E601       	ANI	01H	;only check the carry flags.
3742: F37E     C9         	RET                
3743: F37F                ;                   
3744: F37F                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3745: F37F                ; reflect the last record used for a random (or other) file.
3746: F37F                ; This reads the directory and looks at all extents computing
3747: F37F                ; the largerst record number for each and keeping the maximum
3748: F37F                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3749: F37F                ; maximum record number. This is used to compute the space used
3750: F37F                ; by a random file. 
3751: F37F                ;                   
3752: F37F                RANSIZE:            
3753: F37F     0E0C       	MVI	C,12	;look thru directory for first entry with
3754: F381     CDC2EE     	CALL	FINDFST	;this name.
3755: F384     2A3CE8     	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3756: F387     112100     	LXI	D,33           
3757: F38A     19         	DAD	D              
3758: F38B     E5         	PUSH	H             
3759: F38C     72         	MOV	M,D	;note that (D)=0.
3760: F38D     23         	INX	H              
3761: F38E     72         	MOV	M,D            
3762: F38F     23         	INX	H              
3763: F390     72         	MOV	M,D            
3764: F391                RANSIZ1:            
3765: F391     CDFEED     	CALL	CKFILPOS;is there an extent to process?
3766: F394     CAB9F3     	JZ	RANSIZ3	;no, we are done.
3767: F397     CD67ED     	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3768: F39A     110F00     	LXI	D,15	;point to last record in extent.
3769: F39D     CD52F3     	CALL	COMPRAND;and compute random parameters.
3770: F3A0     E1         	POP	H              
3771: F3A1     E5         	PUSH	H	;now check these values against those
3772: F3A2     5F         	MOV	E,A	;already in fcb.
3773: F3A3     79         	MOV	A,C	;the carry flag will be set if those
3774: F3A4     96         	SUB	M	;in the fcb represent a larger size than
3775: F3A5     23         	INX	H	;this extent does.
3776: F3A6     78         	MOV	A,B            
3777: F3A7     9E         	SBB	M              
3778: F3A8     23         	INX	H              
3779: F3A9     7B         	MOV	A,E            
3780: F3AA     9E         	SBB	M              
3781: F3AB     DAB3F3     	JC	RANSIZ2         
3782: F3AE     73         	MOV	M,E	;we found a larger (in size) extent.
3783: F3AF     2B         	DCX	H	;stuff these values into fcb.
3784: F3B0     70         	MOV	M,B            
3785: F3B1     2B         	DCX	H              
3786: F3B2     71         	MOV	M,C            
3787: F3B3                RANSIZ2:            
3788: F3B3     CDD7EE     	CALL	FINDNXT	;now get the next extent.
3789: F3B6     C391F3     	JMP	RANSIZ1	;continue til all done.
3790: F3B9                RANSIZ3:            
3791: F3B9     E1         	POP	H	;we are done, restore the stack and
3792: F3BA     C9         	RET		;return.      
3793: F3BB                ;                   
3794: F3BB                ;   Function to return the random record position of a given
3795: F3BB                ; file which has been read in sequential mode up to now.
3796: F3BB                ;                   
3797: F3BB                SETRAN:             
3798: F3BB     2A3CE8     	LHLD	ParamsDE	;point to fcb.
3799: F3BE     112000     	LXI	D,32	;and to last used record.
3800: F3C1     CD52F3     	CALL	COMPRAND;compute random position.
3801: F3C4     212100     	LXI	H,33	;now stuff these values into fcb.
3802: F3C7     19         	DAD	D              
3803: F3C8     71         	MOV	M,C	;move 'r0'.
3804: F3C9     23         	INX	H              
3805: F3CA     70         	MOV	M,B	;and 'r1'. 
3806: F3CB     23         	INX	H              
3807: F3CC     77         	MOV	M,A	;and lastly 'r2'.
3808: F3CD     C9         	RET                
3809: F3CE                ;                   
3810: F3CE                ; This routine selects the drive specified in (CurrentDrive) and
3811: F3CE                ; updates the login vector and bitmap table if this drive was
3812: F3CE                ; not already active.
3813: F3CE                ;                   
3814: F3CE                LoginDrive:         
3815: F3CE     3AA7F5     	LDA		CurrentDrive		; get the Subject Drive.
3816: F3D1     4F         	MOV		C,A					; Save current drive
3817: F3D2     2AACF5     	LHLD	LoggedBitMap		; point at the "logged In" Bitmap.
3818: F3D5     CD0DED     	CALL	HLrightC			; Return with CurrentDrive's bit in L's lsb (byte 0)
3819: F3D8     E5         	PUSH	H					; Save it, so we will know if it is already active
3820: F3D9     EB         	XCHG               
3821: F3DA     CD7CEB     	CALL	SelectDisk			; select this drive (in BIOS).
3822: F3DD     CA6AEB     	JZ		SLCTERR				; If not valid then error exit outta here
3823: F3E0     E1         	POP	H						; retreive original state of the drive
3824: F3E1     7D         	MOV	A,L						; and put it into (A) 
3825: F3E2     1F         	RAR							; move bit 0 into the carry flag if it is set		
3826: F3E3     D8         	RC							; then return, because this drive has already been activated
3827: F3E4                				;Else  update the logged Bitmap to reflect this drive.
3828: F3E4     2AACF5     	LHLD	LoggedBitMap		
3829: F3E7     4D         	MOV		C,L           
3830: F3E8     44         	MOV		B,H					; put the map into (BC)
3831: F3E9     CD50F4     	CALL	SetBit				; Set it in the LoggedBitMap
3832: F3EC     22ACF5     	SHLD	LoggedBitMap		; and save the Bit map.
3833: F3EF                ;	JMP	BITMAP	;now update the bitmap.
3834: F3EF                ;-----------------------------------------------------------
3835: F3EF                ;                   
3836: F3EF                ;   Construct the space used allocation bit map for the active
3837: F3EF                ; drive. If a file name starts with '$' and it is under the
3838: F3EF                ; current user number, then (StatusBDOSReturn) is set to minus 1. Otherwise
3839: F3EF                ; it is not set at all.
3840: F3EF                ;                   
3841: F3EF                BITMAP:             
3842: F3EF                								;compute size of allocation table.
3843: F3EF     2AC3F5     	LHLD		DSKSIZE		; get maximum  Allocation Block number
3844: F3F2     0E03       	MVI			C,3			; 2 raised to 3rd power = 8
3845: F3F4     CD0DED     	CALL		HLrightC		;(HL)=(HL)/8.
3846: F3F7     23         	INX			H			;at lease 1 byte.
3847: F3F8     44         	MOV			B,H          
3848: F3F9     4D         	MOV			C,L			;set (BC) to the allocation table length.
3849: F3FA                ;                   
3850: F3FA                ;   Initialize the bitmap for this drive. Right now, the first
3851: F3FA                ; two bytes are specified by the disk parameter block. However
3852: F3FA                ; a patch could be entered here if it were necessary to setup
3853: F3FA                ; this table in a special mannor. For example, the bios could
3854: F3FA                ; determine locations of 'bad blocks' and set them as already
3855: F3FA                ; 'used' in the map.
3856: F3FA                ;                   
3857: F3FA     2ABCF5     	LHLD		ALOCVECT	;now zero out the table now.
3858: F3FD                BITMAP1:            
3859: F3FD     3600       	MVI			M,0			; put zero in vector
3860: F3FF     23         	INX			H			; point at next locatio
3861: F400     0B         	DCX			B			; count down
3862: F401     78         	MOV			A,B          
3863: F402     B1         	ORA			C			; equals zero if both (B) and (B) are Zero
3864: F403     C2FDF3     	JNZ			BITMAP1		; loop for more
3865: F406                	; allocation vector is cleared
3866: F406     2AC7F5     	LHLD		ALLOC0		;get initial space used by directory.
3867: F409     EB         	XCHG               
3868: F40A     2ABCF5     	LHLD	ALOCVECT;and put this into map.
3869: F40D     73         	MOV	M,E            
3870: F40E     23         	INX	H              
3871: F40F     72         	MOV	M,D            
3872: F410                ;                   
3873: F410                ;   End of initialization portion.
3874: F410                ;                   
3875: F410     CDC4EB     	CALL	HOMEDRV	;now home the drive.
3876: F413     2AB0F5     	LHLD	FilePosInDir  
3877: F416     3603       	MVI	M,3	;force next directory request to read
3878: F418     23         	INX	H	;in a sector.
3879: F419     3600       	MVI	M,0            
3880: F41B     CD07EE     	CALL	STFILPOS;clear initial file position also.
3881: F41E                BITMAP2:            
3882: F41E     0EFF       	MVI		C,0FFH			; Read next file name in directory
3883: F420     CD0EEE     	CALL	NXENTRY			; And set checksum byte.
3884: F423     CDFEED     	CALL	CKFILPOS		; Is there another file?
3885: F426     C8         	RZ						; NO - return
3886: F427                	                   
3887: F427     CD67ED     	CALL	FCB2HL			; YES, get its address.
3888: F42A     3EE5       	MVI		A,0E5H        
3889: F42C     BE         	CMP		M				; Is it an empty file entry?
3890: F42D     CA1EF4     	JZ		BITMAP2			; YES - Go back for next entry
3891: F430                	                   
3892: F430     3AA6F5     	LDA		CurrentUser		; NO, Do we have the correct user number?
3893: F433     BE         	CMP		M             
3894: F434     C242F4     	JNZ		BITMAP3			; NO -			
3895: F437     23         	INX		H				; YES -skip to first character in file name
3896: F438     7E         	MOV		A,M				; Does name start with a '$'?
3897: F439     D624       	SUI		DOLLAR			; Clear acc(if =) and test for equality at the same time
3898: F43B     C242F4     	JNZ		BITMAP3       
3899: F43E     3D         	DCR		A				; Yes, set atatus to minus one.
3900: F43F     323FE8     	STA		StatusBDOSReturn	; set return status
3901: F442                BITMAP3:            
3902: F442                ;	MVI		C,1				;now set this file's space as used in bit map.
3903: F442     3E01       	MVI		A,01H		; want to set the bit
3904: F444     32A8F5     	STA		BitSetFlag	; Flag = 01, set the bit
3905: F447     CD76EE     	CALL	SETFILE       
3906: F44A     CD95ED     	CALL	CHKNMBR	;keep (FilePosInDir) in bounds.
3907: F44D     C31EF4     	JMP	BITMAP2        
3908: F450                ;-----------------------------------------------------------
3909: F450                ;                   
3910: F450                ;  Routine to set a bit in a 16 bit value contained in (BC).
3911: F450                ; The bit set depends on the current drive selection.
3912: F450                ;                   
3913: F450                SetBit:             
3914: F450     3AA7F5     	LDA		CurrentDrive		; get active drive.
3915: F453     210100     	LXI		H,1					; Need a bit to move
3916: F456     3C         	INR		A             
3917: F457                SetBit1:            
3918: F457     3D         	DCR		A             
3919: F458     CA5FF4     	JZ		SetBit2        
3920: F45B     29         	DAD		H             
3921: F45C     C357F4     	JMP		SetBit1       
3922: F45F                SetBit2:	           
3923: F45F     79         	MOV		A,C           
3924: F460     B5         	ORA		L             
3925: F461     6F         	MOV		L,A					;low byte done, do high byte.
3926: F462     78         	MOV		A,B           
3927: F463     B4         	ORA		H             
3928: F464     67         	MOV		H,A           
3929: F465     C9         	RET							; HL has the result
3930: F466                                    
3931: F466                ;                   
3932: F466                ;   Function to set the active disk number.
3933: F466                ;                   
3934: F466                SETDSK:             
3935: F466     3A3EE8     	LDA	ParamE				;get parameter passed and see if this
3936: F469     21A7F5     	LXI	H,CurrentDrive		;represents a change in drives.
3937: F46C     BE         	CMP	M              
3938: F46D     C8         	RZ						; return the drive is already selected
3939: F46E     77         	MOV	M,A					; It is a change in drives, so log it in.
3940: F46F     C3CEF3     	JMP	LoginDrive     
3941: F472                ;                   
3942: F472                ;   This is the 'auto disk select' routine. The firsst byte
3943: F472                ; of the fcb is examined for a drive specification. If non
3944: F472                ; zero then the drive will be selected and loged in.
3945: F472                ;                   
3946: F472                AUTOSEL:            
3947: F472     3EFF       	MVI		A,0FFH			;say 'auto-select activated'.
3948: F474     32DAF5     	STA		AutoSelectActive
3949: F477     2A3CE8     	LHLD	ParamsDE		;get drive specified.
3950: F47A     7E         	MOV		A,M           
3951: F47B     E61F       	ANI		1FH				;look at lower 5 bits.
3952: F47D     3D         	DCR		A				;adjust for (1=A, 2=B) etc.
3953: F47E     323EE8     	STA		ParamE			;and save for the select routine.
3954: F481     FE1E       	CPI		1EH				;check for 'no change' condition.
3955: F483     D296F4     	JNC		AUTOSL1			;yes, don't change.
3956: F486     3AA7F5     	LDA		CurrentDrive	;we must change, save currently active
3957: F489     32DBF5     	STA		OLDDRV			;drive.
3958: F48C     7E         	MOV		A,M				;and save first byte of fcb also.
3959: F48D     32DCF5     	STA		AutoSelectFlag	;this must be non-zero.
3960: F490     E6E0       	ANI		0E0H			;whats this for (bits 6,7 are used for
3961: F492     77         	MOV		M,A				;something)?
3962: F493     CD66F4     	CALL	SETDSK			;select and log in this drive.
3963: F496                AUTOSL1:            
3964: F496     3AA6F5     	LDA		CurrentUser		;move user number into fcb.
3965: F499     2A3CE8     	LHLD	ParamsDE		;(* upper half of first byte *)
3966: F49C     B6         	ORA		M             
3967: F49D     77         	MOV		M,A           
3968: F49E     C9         	RET		;and return (all done).
3969: F49F                ;                   
3970: F49F                ;   Function to return the current cp/m version number.
3971: F49F                ;                   
3972: F49F                GETVER:             
3973: F49F     3E22       	MVI	A,022h	;version 2.2
3974: F4A1     C35CEB     	JMP	SETSTAT        
3975: F4A4                ;                   
3976: F4A4                ;   Function (0D) to reset the disk system.
3977: F4A4                ;                   
3978: F4A4                RSTDSK:             
3979: F4A4     210000     	LXI		H,0				; clear write protect status and log
3980: F4A7     22AAF5     	SHLD	ROBitMap		; clear all Read Only Bits
3981: F4AA     22ACF5     	SHLD	LoggedBitMap	; clear all logged in drives
3982: F4AD     AF         	XRA		A             
3983: F4AE     32A7F5     	STA		CurrentDrive	;select drive 'A'.
3984: F4B1     218000     	LXI		H,Pg0Buffer		;setup default dma address.
3985: F4B4     22AEF5     	SHLD	UsersDMA      
3986: F4B7     CDE3ED     	CALL	Set2UsersDMA	; Call BIOS to set DMA
3987: F4BA     C3CEF3     	JMP		LoginDrive		;now log in drive 'A'.
3988: F4BD                ;                   
3989: F4BD                ;   Function to open a specified file.
3990: F4BD                ;                   
3991: F4BD                OPENFIL:            
3992: F4BD     CD7BED     	CALL	CLEARS2	;clear 's2' byte.
3993: F4C0     CD72F4     	CALL	AUTOSEL	;select proper disk.
3994: F4C3     C3FEEF     	JMP	OPENIT	;and open the file.
3995: F4C6                ;                   
3996: F4C6                ;   Function to close a specified file.
3997: F4C6                ;                   
3998: F4C6                CLOSEFIL:           
3999: F4C6     CD72F4     	CALL	AUTOSEL	;select proper disk.
4000: F4C9     C34FF0     	JMP	CLOSEIT	;and close the file.
4001: F4CC                ;                   
4002: F4CC                ;   Function to return the first occurence of a specified file
4003: F4CC                ; name. If the first byte of the fcb is '?' then the name will
4004: F4CC                ; not be checked (get the first entry no matter what).
4005: F4CC                ;                   
4006: F4CC                GETFST:             
4007: F4CC     0E00       	MVI	C,0	;prepare for special search.
4008: F4CE     EB         	XCHG               
4009: F4CF     7E         	MOV	A,M	;is first byte a '?'?
4010: F4D0     FE3F       	CPI	QMARK		;'?'    
4011: F4D2     CAE3F4     	JZ	GETFST1	;yes, just get very first entry (zero length match).
4012: F4D5     CDC9EC     	CALL	SETEXT	;get the extension byte from fcb.
4013: F4D8     7E         	MOV	A,M	;is it '?'? if yes, then we want
4014: F4D9     FE3F       	CPI	QMARK		; '?'	;an entry with a specific 's2' byte.
4015: F4DB     C47BED     	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
4016: F4DE     CD72F4     	CALL	AUTOSEL	;select proper drive.
4017: F4E1     0E0F       	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
4018: F4E3                GETFST1:            
4019: F4E3     CDC2EE     	CALL	FINDFST	;find an entry and then move it into
4020: F4E6     C3F2ED     	JMP	MOVEDIR	;the users dma space.
4021: F4E9                ;                   
4022: F4E9                ;   Function to return the next occurence of a file name.
4023: F4E9                ;                   
4024: F4E9                GETNXT:             
4025: F4E9     2AD5F5     	LHLD	SAVEFCB	;restore pointers. note that no
4026: F4EC     223CE8     	SHLD	ParamsDE	;other dbos calls are allowed.
4027: F4EF     CD72F4     	CALL	AUTOSEL	;no error will be returned, but the
4028: F4F2     CDD7EE     	CALL	FINDNXT	;results will be wrong.
4029: F4F5     C3F2ED     	JMP	MOVEDIR        
4030: F4F8                ;                   
4031: F4F8                ;   Function to delete a file by name.
4032: F4F8                ;                   
4033: F4F8                DELFILE:            
4034: F4F8     CD72F4     	CALL	AUTOSEL		;select proper drive.
4035: F4FB     CD46EF     	CALL	ERAFILE		;erase the file.
4036: F4FE     C3ABEE     	JMP		STSTATUS	;set status and return.
4037: F501                ;                   
4038: F501                ;   Function to execute a sequential read of the specified
4039: F501                ; record number.    
4040: F501                ;                   
4041: F501                READSEQ:            
4042: F501     CD72F4     	CALL	AUTOSEL	;select proper drive then read.
4043: F504     C369F1     	JMP	RDSEQ          
4044: F507                ;                   
4045: F507                ;   Function to write the net sequential record.
4046: F507                ;                   
4047: F507                WRTSEQ:             
4048: F507     CD72F4     	CALL	AUTOSEL	;select proper drive then write.
4049: F50A     C3ABF1     	JMP	WTSEQ          
4050: F50D                ;                   
4051: F50D                ;   Create a file function.
4052: F50D                ;                   
4053: F50D                FCREATE:            
4054: F50D     CD7BED     	CALL	CLEARS2	;clear the 's2' byte ( extents counter hi byte).
4055: F510     CD72F4     	CALL	AUTOSEL	;select proper drive and get the next
4056: F513     C3D1F0     	JMP		GETEMPTY;empty directory space.
4057: F516                ;                   
4058: F516                ;   Function to rename a file.
4059: F516                ;                   
4060: F516                RENFILE:            
4061: F516     CD72F4     	CALL	AUTOSEL	;select proper drive and then switch
4062: F519     CDC3EF     	CALL	CHGNAMES;file names.
4063: F51C     C3ABEE     	JMP	STSTATUS       
4064: F51F                ;                   
4065: F51F                ;   Function to return the logged in Bit map.
4066: F51F                ;                   
4067: F51F                GETLOG:             
4068: F51F     2AACF5     	LHLD	LoggedBitMap  
4069: F522     C34AF5     	JMP	GETPRM1        
4070: F525                ;                   
4071: F525                ;   Function to return the current disk assignment.
4072: F525                ;                   
4073: F525                GETCRNT:            
4074: F525     3AA7F5     	LDA	CurrentDrive   
4075: F528     C35CEB     	JMP	SETSTAT        
4076: F52B                ;                   
4077: F52B                ;   Function to set the dma address.
4078: F52B                ;                   
4079: F52B                PUTDMA:             
4080: F52B     EB         	XCHG               
4081: F52C     22AEF5     	SHLD	UsersDMA	;save in our space and then get to
4082: F52F     C3E3ED     	JMP	Set2UsersDMA	;the bios with this also.
4083: F532                ;                   
4084: F532                ;   Function to return the allocation vector.
4085: F532                ;                   
4086: F532                GETALOC:            
4087: F532     2ABCF5     	LHLD	ALOCVECT      
4088: F535     C34AF5     	JMP	GETPRM1        
4089: F538                ;                   
4090: F538                ;   Function to return the read-only status vector.
4091: F538                ;                   
4092: F538                GETROV:             
4093: F538     2AAAF5     	LHLD	ROBitMap      
4094: F53B     C34AF5     	JMP	GETPRM1        
4095: F53E                ;                   
4096: F53E                ;   Function to set the file attributes (read-only, system).
4097: F53E                ;                   
4098: F53E                SETATTR:            
4099: F53E     CD72F4     	CALL	AUTOSEL	;select proper drive then save attributes.
4100: F541     CDE8EF     	CALL	SAVEATTR      
4101: F544     C3ABEE     	JMP	STSTATUS       
4102: F547                ;                   
4103: F547                ;   Function to return the address of the disk parameter block
4104: F547                ; for the current drive.
4105: F547                ;                   
4106: F547                GETPARM:            
4107: F547     2AB8F5     	LHLD	DISKPB        
4108: F54A                GETPRM1:            
4109: F54A     223FE8     	SHLD	StatusBDOSReturn
4110: F54D     C9         	RET                
4111: F54E                ;                   
4112: F54E                ;   Function to get or set the user number. If (E) was (FF)
4113: F54E                ; then this is a request to return the current user number.
4114: F54E                ; Else set the user number from (E).
4115: F54E                ;                   
4116: F54E                GETUSER:            
4117: F54E     3A3EE8     	LDA			ParamE			; get parameter.
4118: F551     FEFF       	CPI			0FFH			; want to get user number?
4119: F553     C25CF5     	JNZ			SETUSER			; No, then set it
4120: F556     3AA6F5     	LDA			CurrentUser		;yes, just return it in A
4121: F559     C35CEB     	JMP			SETSTAT			; exit while setting return status
4122: F55C                	                   
4123: F55C                SETUSER:            
4124: F55C     E61F       	ANI			1FH				;no,just keep the low bits (000X XXXX)
4125: F55E     32A6F5     	STA			CurrentUser		;and save in Current user
4126: F561     C9         	RET                
4127: F562                ;                   
4128: F562                ;   Function to read a random record from a file.
4129: F562                ;                   
4130: F562                RDRANDOM:           
4131: F562     CD72F4     	CALL	AUTOSEL	;select proper drive and read.
4132: F565     C340F3     	JMP	READRAN        
4133: F568                ;                   
4134: F568                ;   Function to compute the file size for random files.
4135: F568                ;                   
4136: F568                WTRANDOM:           
4137: F568     CD72F4     	CALL	AUTOSEL	;select proper drive and write.
4138: F56B     C349F3     	JMP	WRITERAN       
4139: F56E                ;                   
4140: F56E                ;   Function to compute the size of a random file.
4141: F56E                ;                   
4142: F56E                FILESIZE:           
4143: F56E     CD72F4     	CALL	AUTOSEL	;select proper drive and check file length
4144: F571     C37FF3     	JMP	RANSIZE        
4145: F574                ;                   
4146: F574                ;   Function #37. This allows a program to log off any drives.
4147: F574                ; On entry, set (DE) to contain a word with bits set for those
4148: F574                ; drives that are to be logged off. The log-in vector and the
4149: F574                ; write protect vector will be updated. This must be a M/PM
4150: F574                ; special function. 
4151: F574                ;                   
4152: F574                LOGOFF:             
4153: F574     2A3CE8     	LHLD	ParamsDE	;get drives to log off.
4154: F577     7D         	MOV	A,L	;for each bit that is set, we want
4155: F578     2F         	CMA		;to clear that bit in (LoggedBitMap)
4156: F579     5F         	MOV	E,A	;and (ROBitMap).
4157: F57A     7C         	MOV	A,H            
4158: F57B     2F         	CMA                
4159: F57C     2AACF5     	LHLD	LoggedBitMap	;reset the login Bit map.
4160: F57F     A4         	ANA	H              
4161: F580     57         	MOV	D,A            
4162: F581     7D         	MOV	A,L            
4163: F582     A3         	ANA	E              
4164: F583     5F         	MOV	E,A            
4165: F584     2AAAF5     	LHLD	ROBitMap      
4166: F587     EB         	XCHG               
4167: F588     22ACF5     	SHLD	LoggedBitMap	;and save.
4168: F58B     7D         	MOV	A,L	;now do the write protect vector.
4169: F58C     A3         	ANA	E              
4170: F58D     6F         	MOV	L,A            
4171: F58E     7C         	MOV	A,H            
4172: F58F     A2         	ANA	D              
4173: F590     67         	MOV	H,A            
4174: F591     22AAF5     	SHLD	ROBitMap	;and save. all done.
4175: F594     C9         	RET                
4176: F595                ;                   
4177: F595                ;   Get here to return to the user.
4178: F595                ;                   
4179: F595                                    
4180: F595                ;                   
4181: F595                ;   Function #40. This is a special entry to do random i/o.
4182: F595                ; For the case where we are writing to unused disk space, this
4183: F595                ; space will be zeroed out first. This must be a M/PM special
4184: F595                ; purpose function, because why would any normal program even
4185: F595                ; care about the previous contents of a sector about to be
4186: F595                ; written over.     
4187: F595                ;                   
4188: F595                WTSPECL:            
4189: F595     CD72F4     	CALL	AUTOSEL	;select proper drive.
4190: F598     3E02       	MVI	A,2	;use special write mode.
4191: F59A     32D2F5     	STA	MODE           
4192: F59D     0E00       	MVI	C,0	;set write indicator.
4193: F59F     CDB4F2     	CALL	POSITN1	;position the file.
4194: F5A2     CCB0F1     	CZ	WTSEQ1	;and write (if no errors).
4195: F5A5     C9         	RET                
4196: F5A6                                    
4197: F5A6                ;**************************************************************
4198: F5A6                ;*                  
4199: F5A6                ;*     BDOS data storage pool.
4200: F5A6                ;*                  
4201: F5A6                ;**************************************************************
4202: F5A6                                    
4203: F5A6     00         CurrentUser:			DB	0	;current user number.
4204: F5A7     00         CurrentDrive:			DB	0	;currently active drive.
4205: F5A8     00         BitSetFlag:				DB	0	; Flag to set(01) or reset(00) bit in disk allocation table
4206: F5A9                                    
4207: F5A9                ;                   
4208: F5A9     E5         EMPTYFCB:				DB	0E5H	;empty directory segment indicator.
4209: F5AA     0000       ROBitMap:				DW	0	;write protect status for all 16 drives.
4210: F5AC     0000       LoggedBitMap:			DW	0	;drive active word (1 bit per drive).
4211: F5AE     8000       UsersDMA:				DW	080H	;user's dma address (defaults to 80h).
4212: F5B0                ;                   
4213: F5B0                ;   Scratch areas from parameter block.
4214: F5B0                ;                   
4215: F5B0     0000       FilePosInDir:			DW	0	;relative position within dir segment for file (0-3).
4216: F5B2     0000       LastTrackNumber:		DW	0	;last selected track number.
4217: F5B4     0000       LastSectorNumber:		DW	0	;last selected sector number.
4218: F5B6                ;                   
4219: F5B6                ;   Disk storage areas from parameter block.
4220: F5B6                ;                   
4221: F5B6     0000       DIRBUF:					DW	0	;address of directory buffer to use.
4222: F5B8     0000       DISKPB:					DW	0	;contains address of disk parameter block.
4223: F5BA     0000       CHKVECT:				DW	0	;address of check vector.
4224: F5BC     0000       ALOCVECT:				DW	0	;address of allocation vector (bit map).
4225: F5BE                ;                   
4226: F5BE                ;   Parameter block returned from the bios.
4227: F5BE                ;                   
4228: F5BE     0000       SECTORS:				DW	0	;sectors per track from bios.
4229: F5C0     00         BLKSHFT:				DB	0	;block shift.
4230: F5C1     00         BLKMASK:				DB	0	;block mask.
4231: F5C2     00         EXTMASK:				DB	0	;extent mask.
4232: F5C3     0000       DSKSIZE:				DW	0	;disk size from bios (number of blocks-1).
4233: F5C5     0000       DIRSIZE:				DW	0	;directory size.
4234: F5C7     0000       ALLOC0:					DW	0	;storage for first bytes of bit map (dir space used).
4235: F5C9     0000       ALLOC1:					DW	0    
4236: F5CB     0000       OFFSET:					DW	0	;first usable track number.
4237: F5CD     0000       XLATE:					DW	0	;sector translation table address.
4238: F5CF                ;                   
4239: F5CF                ;                   
4240: F5CF     00         CLOSEFLG:				DB	0	;close flag (=0ffh is extent written ok).
4241: F5D0     00         RDWRTFLG:				DB	0	;read/write flag (0ffh=read, 0=write).
4242: F5D1     00         FNDSTAT:				DB	0	;filename found status (0=found first entry).
4243: F5D2     00         MODE:					DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4244: F5D3     00         RELBLOCK:				DB	0	;relative position within fcb of block number written.
4245: F5D4     00         COUNTER:				DB	0	;byte counter for directory name searches.
4246: F5D5     00000000   SAVEFCB:				DW	0,0	;save space for address of fcb (for directory searches).
4247: F5D9     00         BIGDISK:				DB	0	;if =0 then disk is > 256 blocks long.
4248: F5DA     00         AutoSelectActive:		DB	0	;if non-zero, then auto select activated.
4249: F5DB     00         OLDDRV:					DB	0	;on auto select, storage for previous drive.
4250: F5DC     00         AutoSelectFlag:			DB	0	;if non-zero, then auto select changed drives.
4251: F5DD     00         SAVNXT:					DB	0	;storage for next record number to access.
4252: F5DE     00         SAVEXT:					DB	0	;storage for extent number of file.
4253: F5DF     0000       SAVNREC:				DW	0	;storage for number of records in file.
4254: F5E1     0000       BLKNMBR:				DW	0	;block number (physical sector) used within a file or logical sector.
4255: F5E3     0000       LOGSECT:				DW	0	;starting logical (128 byte) sector of block (physical sector).
4256: F5E5     00         FCBPOS:					DB	0	;relative position within buffer for fcb of file of interest.
4257: F5E6     0000       FILEPOS:				DW	0	;files position within directory (0 to max entries -1).
4258: F5E8                ;                   
4259: F5E8                ;   Disk directory buffer checksum bytes. One for each of the
4260: F5E8                ; 16 possible drives.
4261: F5E8                ;                   
4262: F5E8                CKSUMTBL:           
4263: F5E8     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4264: F5F8                ;                   
4265: F5F8                ;   Extra space ?   
4266: F5F8                ;                   
4267: F5F8     00000000   	DB	0,0,0,0         
4268: F5FC                ;                   
4269: F5FC                ;**************************************************************
4270: F5FC                ;*                  
4271: F5FC                ;*        B I O S   J U M P   T A B L E
4272: F5FC                ;*                  
4273: F5FC                ;**************************************************************
4274: F5FC                ;                   
4275: F5FC                BIOSEntry	Equ	0F600H		; start of bios
4276: F5FC                                    
4277: F5FC                BOOT	EQU		BIOSEntry + 000H	
4278: F5FC                WBOOT	EQU		BIOSEntry + 003H
4279: F5FC                CONST	EQU		BIOSEntry + 006H
4280: F5FC                CONIN	EQU		BIOSEntry + 009H
4281: F5FC                CONOUT	EQU		BIOSEntry + 00CH
4282: F5FC                LIST	EQU		BIOSEntry + 00FH
4283: F5FC                PUNCH	EQU		BIOSEntry + 012H
4284: F5FC                READER	EQU		BIOSEntry + 015H
4285: F5FC                HOME	EQU		BIOSEntry + 018H
4286: F5FC                SELDSK	EQU		BIOSEntry + 01BH
4287: F5FC                SETTRK	EQU		BIOSEntry + 01EH
4288: F5FC                SETSEC	EQU		BIOSEntry + 021H
4289: F5FC                SETDMA	EQU		BIOSEntry + 024H
4290: F5FC                READ	EQU		BIOSEntry + 027H
4291: F5FC                WRITE	EQU		BIOSEntry + 02AH
4292: F5FC                PRSTAT	EQU		BIOSEntry + 02DH
4293: F5FC                SECTRN	EQU		BIOSEntry + 030H
4294: F5FC                                    
4295: F5FC                ;*                  
4296: F5FC                ;******************   E N D   O F   C P / M   *****************
4297: F5FC                ;*                  
4298: F5FC                CodeEnd:            
4299: F5FC                		END               




                                    Xref


0000	0000	$                             		  1592,

2511	ED6D	ADDA2HL                       		  3445,
0504	E242	ADDHL                         		  0522,  0922,  1115,
0641	E2BA	AFN                           		  0649,
0647	E2C2	AFN1                          		  0645,
4234	F5C7	ALLOC0                        		  3866,
4235	F5C9	ALLOC1                        		  2595,
4224	F5BC	ALOCVECT                      		  2757,  3857,  3868,  4087,
0050	002A	ASTRK                         		  0662,
0052	0040	ATSIGN                        		  1765,
3946	F472	AUTOSEL                       		  3993,  3999,  4016,  4027,  4034,  4042,  4048,  4055,  4061,  4099,  4131,  4137,  4143,  4189,
4248	F5DA	AUTOSELECTACTIVE              		  1491,  1521,  3948,
4250	F5DC	AUTOSELECTFLAG                		  1490,  1526,  3959,
3963	F496	AUTOSL1                       		  3955,

1787	E9FF	BACKUP                        		  1902,  1942,
1791	EA07	BACKUP1                       		  1788,
1406	E74A	BADLOAD                       		  1403,
1597	E8EC	BADSCTR                       		  2169,
1629	E925	BADSEC                        		  1606,
1630	E930	BADSEL                        		  1613,
1598	E8EE	BADSLCT                       		  2065,
1433	E77B	BATCH                         		  0292,  0410,  0764,  1392,
1435	E77C	BATCHFCB                      		  0304,  0307,  0309,  0310,  0320,  0324,  0417,
1628	E921	BDOSDRV                       		  1641,
1476	E806	BDOSENTRY                     		
1627	E915	BDOSERR                       		  1642,
1520	E873	BDOSEXIT                      		  1492,
1533	E890	BDOSEXIT1                     		  1523,  1528,  2002,
1518	E873	BDOSSTACK                     		  1488,
4247	F5D9	BIGDISK                       		  2131,  2310,  2807,  3213,  3441,
4275	F600	BIOSENTRY                     		  4277,  4278,  4279,  4280,  4281,  4282,  4283,  4284,  4285,  4286,  4287,  4288,  4289,  4290,  4291,  4292,  4293,
3841	F3EF	BITMAP                        		
3858	F3FD	BITMAP1                       		  3864,
3881	F41E	BITMAP2                       		  3890,  3907,
3901	F442	BITMAP3                       		  3894,  3898,
4205	F5A8	BITSETFLAG                    		  2775,  2972,  3904,
0039	0020	BLANK                         		  0116,  0446,  0470,  0496,  0676,  0724,  0865,  0892,  0967,  1019,  1028,  1031,  1273,  1287,  1303,  1363,  1420,  1683,  1737,  1776,  1789,  1807,
4230	F5C1	BLKMASK                       		  2356,  3498,
4254	F5E1	BLKNMBR                       		  2179,  2187,  2331,  2337,  2350,  2362,  3436,  3491,  3496,  3505,
4229	F5C0	BLKSHFT                       		  2277,  2349,
4277	F600	BOOT                          		
0040	007B	BRACKETLEFT                   		  0282,
0041	007D	BRACKETRIGHT                  		
0026	0008	BS                            		  1681,  1744,  1792,  1854,

0051	005E	CARET                         		  1762,
0062	E000	CBASE                         		  0830,  0831,  1327,
1429	E77B	CCPSTACK                      		  0753,  0777,
1444	E7BF	CDRIVE                        		  0264,  0272,  0300,  0327,  0419,  0546,  0768,  0792,  0937,  0950,  0953,  1293,
2051	EB69	CHARBUF                       		  1651,  1692,  1707,
0465	E219	CHECK                         		  0576,  0614,  0659,
2592	EDA7	CHECKDIR                      		  2713,
2439	ED1A	CHECKSUM                      		  2599,
1446	E7C0	CHGDRV                        		  0526,  0551,  0795,  0858,  0933,  0946,  1204,  1228,  1289,  1343,  1421,
3098	EFD4	CHGNAM1                       		  3106,
3089	EFC3	CHGNAMES                      		  4062,
2336	ECA7	CHKBLK                        		  3387,  3415,
1674	E96F	CHKCHAR                       		  1662,  1759,
0380	E1BF	CHKCON                        		  0335,  1045,  1120,
2613	EDCD	CHKDIR1                       		  2606,
2562	ED95	CHKNMBR                       		  3300,  3906,
2483	ED4D	CHKROFL                       		  2967,  3101,
2443	ED20	CHKSUM1                       		  2447,
4223	F5BA	CHKVECT                       		  2600,
2496	ED5D	CHKWPRT                       		  2961,  3090,  3276,  3407,
2723	EE3E	CKBITMAP                      		  2772,  3005,  3034,
2760	EE5F	CKBMAP1                       		  2763,
1706	E99D	CKCON1                        		  1700,
1708	E9A0	CKCON2                        		  1694,
1691	E97E	CKCONSOL                      		  1721,  2031,
2663	EDFE	CKFILPOS                      		  2889,  2965,  3099,  3117,  3130,  3203,  3283,  3311,  3341,  3347,  3765,  3884,
2485	ED50	CKROF1                        		  3409,
4262	F5E8	CKSUMTBL                      		  2180,  2593,  2602,
0739	E32B	CLEARBUF                      		  0064,
0625	E2A9	CLEAREXTENT                   		  0594,  0615,
0627	E2AB	CLEAREXTENT1                  		  0631,
2530	ED7B	CLEARS2                       		  3992,  4015,  4054,
0174	E0D7	CLOSE                         		  0325,  1180,
3998	F4C6	CLOSEFIL                      		  1566,
4240	F5CF	CLOSEFLG                      		  3265,  3309,  3324,
3191	F04F	CLOSEIT                       		  3310,  3631,  4000,
3212	F07A	CLOSEIT1                      		  3248,
3221	F088	CLOSEIT2                      		  3219,
3226	F08E	CLOSEIT3                      		  3223,
3230	F095	CLOSEIT4                      		  3215,
3244	F0AA	CLOSEIT5                      		  3229,
3263	F0C4	CLOSEIT6                      		  3255,
3267	F0CC	CLOSEIT7                      		  3228,  3237,  3242,
0817	E394	CMDADR                        		  0804,
0685	E2E9	CMDTBL                        		  0707,
0776	E355	CMMND1                        		  0343,  0460,  1068,  1072,  1395,  1424,
0788	E36B	CMMND2                        		  0772,
0024	0003	CNTRLC                        		  1608,  1702,  1962,
0025	0005	CNTRLE                        		  1874,
0031	0010	CNTRLP                        		  1883,
0032	0012	CNTRLR                        		  1911,
0033	0013	CNTRLS                        		  1699,
0034	0015	CNTRLU                        		  1905,
0035	0018	CNTRLX                        		  1893,
0036	001A	CNTRLZ                        		  1117,
4298	F5FC	CODEEND                       		
0060	E000	CODESTART                     		
0046	003A	COLON                         		  0480,  0542,  1005,  1010,
2326	EC9A	COMBLK                        		  3386,  3414,
1408	E753	COMFILE                       		  1309,
0752	E32F	COMMAND                       		  0063,
3706	F352	COMPRAND                      		  3769,  3800,
4280	F609	CONIN                         		  1656,  1698,  1701,  2003,
4281	F60C	CONOUT                        		  1724,  1790,  1793,  1998,
4279	F606	CONST                         		  1695,  1997,  2000,
0520	E249	CONVERT                       		  1348,
0513	E247	CONVFST                       		  0793,  0857,  0963,  1060,  1092,  1143,  1202,  1224,  1342,  1418,
0545	E272	CONVRT1                       		  0536,
0549	E279	CONVRT2                       		  0543,
0557	E27F	CONVRT3                       		  0548,
0559	E281	CONVRT4                       		
0575	E284	CONVRT7                       		  0579,
4245	F5D4	COUNTER                       		  2875,  2902,
0030	000D	CR                            		  0108,  1675,  1814,  1850,  1973,
0233	E106	CREATE                        		  1150,
0107	E095	CRLF                          		  0124,  0442,  0458,  0778,  0999,  1097,  1385,
2049	EB67	CURPOS                        		  1733,  1778,  1803,  1835,  1860,  1898,  1938,
4204	F5A7	CURRENTDRIVE                  		  1639,  2094,  2456,  3815,  3914,  3936,  3956,  3983,  4074,
4203	F5A6	CURRENTUSER                   		  3892,  3964,  4120,  4125,

2078	EB72	DE2HL                         		  2123,  2128,  2659,  3080,  3142,
2080	EB73	DE2HL1                        		  2088,
0856	E3CB	DECODE                        		  1141,  1268,
0863	E3DB	DECODE1                       		  0888,
0658	E2C9	DECODENAME                    		  0560,  0598,  0671,
0666	E2DA	DECODENAME1                   		  0663,
0669	E2DC	DECODENAME2                   		  0665,
0037	007F	DEL                           		  1734,  1864,
0409	E1DA	DELBATCH                      		  0342,  0349,  0459,
0199	E0EC	DELETE                        		  0418,  1078,  1148,
4033	F4F8	DELFILE                       		  1569,
4221	F5B6	DIRBUF                        		  2121,  2441,  2506,  2641,  2655,  3480,
1999	EB3B	DIRC1                         		  1995,
1992	EB2F	DIRCIO                        		  1555,
0962	E44A	DIRECT                        		  0818,
0970	E45B	DIRECT1                       		  0974,
0975	E462	DIRECT2                       		  0968,
0980	E46B	DIRECT3                       		  1048,
1008	E49F	DIRECT4                       		  0998,
1012	E4A7	DIRECT5                       		  1007,
1015	E4AC	DIRECT6                       		  1039,  1041,
1042	E4E1	DIRECT7                       		  1029,  1037,
1044	E4E2	DIRECT8                       		  0991,
1049	E4EE	DIRECT9                       		  0981,  1046,
2628	EDDD	DIRREAD                       		  2711,
4233	F5C5	DIRSIZE                       		  2472,  2688,
2619	EDCF	DIRWRITE                      		  2974,  3083,
4222	F5B8	DISKPB                        		  2124,  4107,
1632	E93C	DISKRO                        		  1617,
0403	E1D5	DMASET                        		  0790,  1168,  1320,
0054	0024	DOLLAR                        		  1823,  3897,
2158	EBD5	DOREAD                        		  2630,  3391,
2164	EBDB	DOWRITE                       		  2623,  3495,  3515,
1030	E4CA	DRECT63                       		  1024,
1032	E4CC	DRECT65                       		  1020,
0930	E427	DSELECT                       		  0964,  1076,  1094,  1145,  1206,  1307,
0144	E0BA	DSKSEL                        		  0303,  0329,  0416,  0420,  0769,  0940,  0954,  1295,  1394,
4232	F5C3	DSKSIZE                       		  2129,  2828,  3023,  3843,

4208	F5A9	EMPTYFCB                      		  3279,
0017	0005	ENTRY                         		  0094,  0140,  0147,  0153,  0201,  0207,  0242,  0254,  0353,  0382,  0386,  0394,  0405,
0152	E0C0	ENTRY1                        		  0162,  0176,  0183,  0189,  0235,
0206	E0F1	ENTRY2                        		  0216,  0229,
0043	003D	EQUALS                        		  0474,  1216,
2964	EF4E	ERAFIL1                       		  2976,
2960	EF46	ERAFILE                       		  4035,
1059	E4F2	ERASE                         		  0819,
1075	E515	ERASE1                        		  1062,
1605	E8F4	ERROR1                        		  1597,
1612	E900	ERROR2                        		  1598,
1616	E906	ERROR3                        		  1599,
1620	E90C	ERROR4                        		  1600,
1623	E90F	ERROR5                        		  1614,  1618,
1258	E655	EXISTS                        		  1255,
2305	EC81	EXTBLK                        		  2330,  3425,
2316	EC94	EXTBLK1                       		  2312,
4231	F5C2	EXTMASK                       		  2395,  2855,  3322,
0919	E41E	EXTRACT                       		  0989,  1017,  1026,

1440	E79D	FCB                           		  0168,  0169,  0194,  0221,  0521,  0713,  0861,  0932,  0965,  1077,  1146,  1153,  1169,  1179,  1209,  1210,  1238,  1242,  1272,  1286,  1301,  1321,  1346,  1351,  1353,  1355,  1419,
2505	ED67	FCB2HL                        		  2484,  2796,  2901,  2968,  3078,  3137,  3206,  3767,  3887,
4256	F5E5	FCBPOS                        		  2507,  2706,
3064	EFAA	FCBSET                        		  3301,
4053	F50D	FCREATE                       		  1572,
0029	000C	FF                            		
4257	F5E6	FILEPOS                       		  2176,  2549,  2664,  2676,  2690,  2692,  2698,  2939,  3194,  3195,
4215	F5B0	FILEPOSINDIR                  		  2109,  2475,  2551,  3876,
1631	E937	FILERO                        		  1621,
4142	F56E	FILESIZE                      		  1585,
2872	EEC2	FINDFST                       		  2963,  3092,  3115,  3129,  3202,  3282,  3340,  3754,  4019,
2886	EED7	FINDNXT                       		  2920,  2927,  2975,  3105,  3122,  3788,  4028,
2900	EEF4	FNDNXT1                       		  2895,
2905	EEFD	FNDNXT2                       		  2937,
2922	EF1D	FNDNXT3                       		  2917,
2932	EF26	FNDNXT4                       		  2911,  2914,  2921,
2938	EF2D	FNDNXT5                       		  2908,
2952	EF3E	FNDNXT6                       		  2890,  2899,
2998	EF6D	FNDSPA1                       		  3039,  3058,
3022	EF7E	FNDSPA2                       		  3001,
3044	EF99	FNDSPA3                       		  3007,  3036,
3055	EFA1	FNDSPA4                       		  3028,
2991	EF6B	FNDSPACE                      		  3429,
4242	F5D1	FNDSTAT                       		  2844,  2874,  2942,
1592	0028	FUNCTIONCOUNT                 		  1495,
1548	E89A	FUNCTIONVECTOR                		  1592,  1498,

4086	F532	GETALOC                       		  1577,
1415	E756	GETBACK                       		  1051,  1081,  1118,  1121,  1128,  1191,  1244,  1250,  1257,  1405,
1417	E759	GETBACK1                      		  1276,  1291,  1296,
2280	EC68	GETBLK1                       		  2284,
2290	EC76	GETBLK2                       		  2295,
2296	EC7F	GETBLK3                       		  2292,
2276	EC61	GETBLOCK                      		  2327,  3418,
1650	E956	GETCHAR                       		  1661,  1846,
1978	EB23	GETCON                        		  1550,
4073	F525	GETCRNT                       		  1575,
2030	EB59	GETCSTS                       		  1560,
0392	E1CD	GETDSK                        		  0779,  0791,  1001,
1660	E961	GETECHO                       		  1979,
3275	F0D1	GETEMPTY                      		  3346,  3653,  4056,
0588	E28E	GETEXT                        		  0577,
0595	E29B	GETEXT1                       		  0592,
0613	E29F	GETEXT4                       		  0617,
4006	F4CC	GETFST                        		  1567,
4018	F4E3	GETFST1                       		  4011,
0291	E136	GETINP                        		  0784,  1065,
0348	E193	GETINP1                       		  0294,  0306,  0312,  0326,
0358	E1A4	GETINP2                       		  0336,
0361	E1A8	GETINP3                       		  0370,
0371	E1B7	GETINP4                       		  0365,
2008	EB48	GETIOB                        		  1556,
4067	F51F	GETLOG                        		  1574,
3292	F0F3	GETMT1                        		  3296,
3307	F107	GETNEXT                       		  3379,  3547,
4024	F4E9	GETNXT                        		  1568,
4106	F547	GETPARM                       		  1581,
4108	F54A	GETPRM1                       		  4069,  4088,  4094,
1984	EB29	GETRDR                        		  1552,
4092	F538	GETROV                        		  1579,
2521	ED72	GETS2                         		  2531,  2538,  3198,  3536,  3670,
0252	E112	GETSETUC                      		  0762,  1275,
4116	F54E	GETUSER                       		  1582,
0246	E110	GETUSR                        		  0259,
3972	F49F	GETVER                        		  1561,
2454	ED27	GETWPRT                       		  2497,  3196,
0049	003E	GRTTHAN                       		  0486,  0782,
3328	F130	GTNEXT1                       		  3320,
3338	F13B	GTNEXT2                       		  3326,
3350	F159	GTNEXT3                       		  3327,  3342,
3352	F15C	GTNEXT4                       		  3349,
3360	F163	GTNEXT5                       		  3334,  3345,  3348,

0828	E3A2	HALT                          		
0908	E415	HL2DE                         		  0319,  0914,  1212,  1357,
2422	ED0D	HLRIGHTC                      		  2178,  2458,  3818,  3845,
2424	ED0E	HLRIGHTC1                     		  2434,
4285	F618	HOME                          		  2144,
2143	EBC4	HOMEDRV                       		  2880,  3875,

0075	E008	INBUFF                        		  0084,  0333,  0373,  1358,
0073	E007	INBUFFCOUNT                   		  0316,  0359,  0741,  0770,  1066,
0081	E085	INBUFFEND                     		  0072,
0071	E006	INBUFFSIZE                    		
0070	E006	INBUFFSTART                   		  0072,  0352,
0083	E085	INPOINT                       		  0374,  0527,  0633,  1074,  1213,  1223,
0015	0003	IOBYTE                        		  2009,  2015,
2043	EB60	IOERR1                        		  3361,  3397,  3413,
2166	EBDE	IORET                         		  2160,

2069	EB6D	JUMPHL                        		  2170,  2492,  2500,

4217	F5B4	LASTSECTORNUMBER              		  2115,  2150,  2192,  2255,
4216	F5B2	LASTTRACKNUMBER               		  2112,  2146,  2197,  2250,
0048	003C	LESSTH                        		  0484,
0028	000A	LF                            		  0110,  1677,  1749,  1816,  1852,
4282	F60F	LIST                          		  1554,  1729,
4210	F5AC	LOGGEDBITMAP                  		  3817,  3828,  3832,  3981,  4068,  4159,  4167,
2348	ECAD	LOGICAL                       		  3389,  3463,
2351	ECB3	LOGICL1                       		  2354,
3814	F3CE	LOGINDRIVE                    		  3940,  3987,
4152	F574	LOGOFF                        		  1587,
4255	F5E3	LOGSECT                       		  2355,  3488,

0013	0040	MEM                           		  0059,
4243	F5D2	MODE                          		  2406,  3368,  3403,  3464,  3543,  3577,  4191,
2548	ED88	MOREFLS                       		  2563,  2609,  2897,
0903	E413	MOVE3                         		  1310,
0271	E126	MOVECD                        		  0354,  1294,  1393,
2654	EDF2	MOVEDIR                       		  4020,  4029,
3173	F041	MOVEWORD                      		  3231,  3233,

0085	E087	NAMEPNT                       		  0443,  0531,
1448	E7C1	NBYTES                        		  1098,  1101,
1798	EA0C	NEWLINE                       		  1907,  1915,
1802	EA14	NEWLN1                        		  1809,
0848	E3C3	NOFILE                        		  0846,
0492	E238	NONBLANK                      		  0500,  0529,  1215,
0845	E3BD	NONE                          		  0979,  1080,  1249,
1192	E5DA	NOSPACE                       		  1187,
0684	0006	NUMCMDS                       		  0711,
2687	EE0E	NXENTRY                       		  2888,  3883,
2697	EE22	NXENTRY1                      		  2694,
2701	EE29	NXENTRY2                      		  2704,

4236	F5CB	OFFSET                        		  2244,
4249	F5DB	OLDDRV                        		  1530,  3957,
0160	E0C8	OPEN                          		  0170,  0305,
0166	E0CD	OPENFCB                       		  1095,  1311,
3991	F4BD	OPENFIL                       		  1565,
3127	EFFE	OPENIT                        		  3644,  3994,
3132	F007	OPENIT1                       		  3351,
3161	F038	OPENIT2                       		  3157,  3159,
1716	E9A3	OUTCHAR                       		  1763,  1774,  1777,  1800,  1808,  1815,  1817,  1974,
1731	E9BD	OUTCHR1                       		  1719,
1748	E9D4	OUTCHR2                       		  1745,
1771	E9EB	OUTCON                        		  1551,  1666,  1760,  1828,
1775	E9F1	OUTCON1                       		  1781,
1813	EA24	OUTCRLF                       		  1638,  1801,  1878,
2047	EB65	OUTFLAG                       		  1717,  1861,  1935,  1940,  1943,

0674	E2E1	PADFIELD                      		  0593,  0660,  0678,
0890	E406	PADNUMBER                     		  0866,  0896,
1511	E83E	PARAME                        		  1483,  1531,  3935,  3953,  4117,
1510	E83C	PARAMSDE                      		  1480,  1506,  1524,  1837,  2306,  2368,  2377,  2522,  2877,  3075,  3093,  3139,  3162,  3209,  3277,  3280,  3285,  3313,  3408,  3438,  3583,  3755,  3798,  3949,  3965,  4026,  4153,
0045	002E	PERIOD                        		  0478,  0590,
0019	0080	PG0BUFFER                     		  0317,  0399,  0789,  0920,  1114,  1372,  1384,  3984,
0122	E0A4	PLINE                         		  0838,  0847,  1064,  1188,  1256,  1404,
0126	E0A9	PLINE2                        		  0134,  0334,
3575	F2B0	POSITION                      		  3686,  3694,
3581	F2B4	POSITN1                       		  4193,
3628	F2F4	POSITN2                       		  3618,
3661	F32C	POSITN3                       		  3624,  3647,
3668	F331	POSITN4                       		  3637,  3652,  3657,
3676	F338	POSITN5                       		  3610,
0053	0023	POUNDSN                       		  1799,
0091	E089	PRINT                         		  0100,  0132,  0451,  0457,  0781,  0783,  1119,
0098	E08F	PRINTB                        		  0109,  0111,  0117,  1004,  1006,  1011,  1033,
4292	F62D	PRSTAT                        		
1636	E940	PRTERR                        		  1607,  1624,
2050	EB68	PRTFLAG                       		  1727,  1886,
1821	EA2E	PRTMESG                       		  1643,  1645,  1830,  2026,
2022	EB53	PRTSTR                        		  1558,
4283	F612	PUNCH                         		  1553,
4079	F52B	PUTDMA                        		  1576,

0042	003F	QMARK                         		  0456,  0644,  0664,  0971,  2910,  4010,  4014,

3764	F391	RANSIZ1                       		  3789,
3787	F3B3	RANSIZ2                       		  3781,
3790	F3B9	RANSIZ3                       		  3766,
3752	F37F	RANSIZE                       		  4144,
1842	EA4A	RDBUF1                        		  1858,  1868,  1891,  1969,
1913	EACB	RDBUF10                       		  1862,
1920	EAD3	RDBUF11                       		  1932,
1933	EAE5	RDBUF12                       		  1923,
1941	EAF4	RDBUF13                       		  1945,
1950	EB01	RDBUF14                       		  1912,
1954	EB04	RDBUF15                       		  1872,
1967	EB18	RDBUF16                       		  1964,
1970	EB1C	RDBUF17                       		  1851,  1853,
1845	EA4C	RDBUF2                        		  1881,  1937,  1946,
1863	EA71	RDBUF3                        		  1855,
1873	EA81	RDBUF4                        		  1865,
1882	EA92	RDBUF5                        		  1875,
1892	EAA3	RDBUF6                        		  1884,
1896	EAA9	RDBUF7                        		  1903,
1904	EABA	RDBUF8                        		  1894,
1910	EAC6	RDBUF9                        		  1906,
1834	EA3C	RDBUFF                        		  1559,  1900,  1909,
0839	E3B2	RDERR                         		  0837,
0836	E3AC	RDERROR                       		  1129,
4130	F562	RDRANDOM                      		  1583,
0214	E0F6	RDREC                         		  0222,  0311,  1322,
3366	F169	RDSEQ                         		  4043,
3369	F16E	RDSEQ1                        		  3687,
3385	F193	RDSEQ2                        		  3376,
3396	F1A8	RDSEQ3                        		  3378,  3384,  3388,
4241	F5D0	RDWRTFLG                      		  3343,  3371,  3406,
4290	F627	READ                          		  2159,
4284	F615	READER                        		  1985,
0220	E0FB	READFCB                       		  1107,
3684	F340	READRAN                       		  4132,
4041	F501	READSEQ                       		  1570,
4244	F5D3	RELBLOCK                      		  3419,  3443,
0240	E10B	RENAM                         		  1243,
1201	E5E3	RENAME                        		  0822,
1220	E612	RENAME1                       		  1217,
1235	E62C	RENAME2                       		  1231,
1239	E631	RENAME3                       		
1248	E640	RENAME4                       		  1241,
1251	E646	RENAME5                       		  1219,  1225,  1234,
1254	E64C	RENAME6                       		  1208,
4060	F516	RENFILE                       		  1573,
0138	E0B5	RESDSK                        		  0763,
0945	E439	RESETDR                       		  1131,  1252,  1341,  1400,  1416,
2038	EB5F	RETURN                        		  1588,  1589,
4209	F5AA	ROBITMAP                      		  2455,  2466,  2471,  3980,  4093,  4165,  4174,
1599	E8F0	RODISK                        		  2499,
1600	E8F2	ROFILE                        		  2491,
3978	F4A4	RSTDSK                        		  1563,
1442	E7BE	RTNCODE                       		  0154,  0982,

2852	EEB1	SAMEXT                        		  2925,
3116	EFED	SAVATR1                       		  3123,
1140	E580	SAVE                          		  0821,
1159	E5A7	SAVE1                         		  1174,
1178	E5C4	SAVE2                         		  1162,
1186	E5CE	SAVE3                         		  1151,  1173,
1189	E5D4	SAVE4                         		  1182,
3113	EFE8	SAVEATTR                      		  4100,
4246	F5D5	SAVEFCB                       		  2878,  2891,  4025,
4252	F5DE	SAVEXT                        		  2289,  2397,
4253	F5DF	SAVNREC                       		  2279,  2358,  2390,  2412,  3373,  3381,  3411,  3517,  3553,
4251	F5DD	SAVNXT                        		  2393,  2416,  3374,  3518,
0706	E301	SEARCH                        		  0798,
0709	E306	SEARCH1                       		  0734,
0715	E30F	SEARCH2                       		  0722,
0728	E322	SEARCH3                       		  0718,  0731,
0732	E327	SEARCH4                       		  0725,
4228	F5BE	SECTORS                       		  2126,  2210,  2222,
4293	F630	SECTRN                        		  2268,
4286	F61B	SELDSK                        		  2096,
2093	EB7C	SELECTDISK                    		  3821,
2136	EBC0	SELECTDISK1                   		  2134,
0047	003B	SEMIC                         		  0482,
2634	EDE3	SET2USERSDMA                  		  2624,  3506,  3986,  4082,
4098	F53E	SETATTR                       		  1580,
3913	F450	SETBIT                        		  2470,  3831,
3917	F457	SETBIT1                       		  3921,
3922	F45F	SETBIT2                       		  3919,
0258	E117	SETCDRV                       		  0350,  1387,
2584	EDA5	SETDIR                        		  2620,
2640	EDE9	SETDIRDMA                     		  2621,  2629,  3487,
4289	F624	SETDMA                        		  2650,
2646	EDEC	SETDMA0                       		  2636,
3934	F466	SETDSK                        		  1532,  1564,  3962,
2367	ECC9	SETEXT                        		  2394,  3133,  4012,
2795	EE76	SETFILE                       		  2973,  3905,
2801	EE7F	SETFL1                        		  2838,
2817	EE90	SETFL2                        		  2809,
2824	EE96	SETFL3                        		  2815,
2834	EEA5	SETFL4                        		  2827,
2376	ECD1	SETHLDE                       		  2388,  2405,
2014	EB4E	SETIOB                        		  1557,
2404	ECF5	SETNREC                       		  3392,  3546,  3557,
3797	F3BB	SETRAN                        		  1586,
2537	ED81	SETS2B7                       		  3143,  3302,  3362,  3680,
4288	F621	SETSEC                        		  2271,
2036	EB5C	SETSTAT                       		  1980,  1986,  2004,  2010,  2045,  2845,  2955,  3355,  3434,  3664,  3974,  4075,  4121,
4287	F61E	SETTRK                        		  2248,
4123	F55C	SETUSER                       		  4119,
1757	E9DA	SHOWIT                        		  1929,  1958,
2064	EB6A	SLCTERR                       		  3822,
0115	E09F	SPACE                         		  1009,  1013,  1040,
0193	E0E6	SRCHFCB                       		  0978,  1207,  1240,
0181	E0DC	SRCHFST                       		  0195,
0187	E0E1	SRCHNXT                       		  1047,
2048	EB66	STARTING                      		  1804,  1836,  1880,  1897,
1512	E83F	STATUSBDOSRETURN              		  1485,  1536,  2037,  2941,  3193,  3268,  3382,  3459,  3548,  3635,  3645,  3655,  3679,  3900,  4109,
2770	EE65	STBITMAP                      		  2833,
2785	EE6F	STBMAP1                       		  2788,  3047,
0398	E1D2	STDDMA                        		  1190,  1386,
2674	EE07	STFILPOS                      		  2695,  2879,  2953,  3880,
2410	ED01	STNREC1                       		  2408,
2387	ECDE	STRDATA                       		  3353,  3372,  3410,
2843	EEAB	STSTATUS                      		  4036,  4063,  4101,
2573	ED9E	SUBHL                         		  2596,  2693,
0441	E1F2	SYNERR                        		  0471,  0794,  0860,  0870,  0875,  0881,  0883,  0885,  0893,  1093,  1132,  1144,  1203,  1253,  1270,  1274,  1304,  1401,  1423,
0444	E1F8	SYNERR1                       		  0454,
0455	E20B	SYNERR2                       		  0447,  0449,

0027	0009	TAB                           		  1679,  1773,
0020	0100	TBASE                         		  1158,  1316,  1388,
0016	0004	TDRIVE                        		  0266,  0273,
0018	005C	TFCB                          		  1354,
2175	EBE6	TRKSEC                        		  2710,  3082,
2185	EBF4	TRKSEC1                       		  3390,  3493,  3512,
2203	EC07	TRKSEC2                       		  2219,
2220	EC1D	TRKSEC3                       		  2208,  2233,
2238	EC32	TRKSEC4                       		  2224,  2229,
1091	E530	TYPE                          		  0820,
1100	E547	TYPE1                         		  1122,
1102	E54A	TYPE2                         		
1112	E55A	TYPE3                         		  1105,
1126	E573	TYPE4                         		  1109,
1130	E57A	TYPE5                         		  1096,

1284	E678	UNKNOWN                       		  0797,  0824,
1402	E741	UNKWN0                        		  1332,  1340,
1300	E694	UNKWN1                        		  1288,
1305	E69D	UNKWN2                        		
1317	E6B1	UNKWN3                        		  1333,
1337	E6D1	UNKWN4                        		  1323,
1359	E700	UNKWN5                        		  1366,
1370	E70E	UNKWN6                        		  1362,  1364,
1373	E713	UNKWN7                        		  1381,
1382	E71F	UNKWN8                        		  1377,
1399	E73B	UNKWN9                        		  1312,
3072	EFAE	UPDATE                        		  3104,  3121,
3081	EFBD	UPDATE1                       		  3266,
0279	E12D	UPPER                         		  0367,
0044	005F	USCORE                        		  0476,  1218,
1267	E661	USER                          		  0823,
4211	F5AE	USERSDMA                      		  2635,  2657,  3985,  4081,
1513	E841	USERSTACK                     		  1487,  1534,

4278	F603	WBOOT                         		  1549,
4291	F62A	WRITE                         		  2165,
3692	F349	WRITERAN                      		  4138,
2465	ED35	WRTPRTD                       		  1578,  2611,
0227	E101	WRTREC                        		  1170,
4047	F507	WRTSEQ                        		  1571,
4136	F568	WTRANDOM                      		  1584,
3401	F1AB	WTSEQ                         		  4049,
3404	F1B0	WTSEQ1                        		  3695,  4194,
3528	F27F	WTSEQ10                       		  3520,
3554	F2AB	WTSEQ11                       		  3551,
3556	F2AD	WTSEQ12                       		  3542,  3545,
3428	F1E8	WTSEQ2                        		  3422,
3435	F1F5	WTSEQ3                        		  3432,
3448	F211	WTSEQ4                        		  3444,
3456	F219	WTSEQ5                        		  3447,
3458	F21B	WTSEQ6                        		  3417,
3482	F239	WTSEQ7                        		  3486,
3490	F247	WTSEQ8                        		  3503,
3511	F268	WTSEQ9                        		  3467,  3478,
3540	F28C	WTSEQ99                       		
4188	F595	WTSPECL                       		  1590,

4237	F5CD	XLATE                         		  2120,  2266,

1082	E525	YESNO                         		  1063,
