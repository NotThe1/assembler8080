0001: 0000                                    
0002: 0000                ;**************************************************************
0003: 0000                ;*                  
0004: 0000                ;*             C P / M   version   2 . 2
0005: 0000                ;*                    Sourced from:
0006: 0000                ;*  Reconstructed from memory image on February 27, 1981
0007: 0000                ;*                by Clark A. Calkins
0008: 0000                ;*                  
0009: 0000                ;**************************************************************
0010: 0000                ;                   
0011: 0000                                    
0012: 0000                ;                   
0013: 0000                MEM			EQU		64			;for a 64k system 
0014: 0000                ;                   
0015: 0000                IOBYTE		EQU		3			;i/o definition byte.
0016: 0000                TDRIVE		EQU		4			;current drive name and user number.
0017: 0000                ENTRY		EQU		5			;entry point for the cp/m bdos.
0018: 0000                DefaultFCB	EQU		5CH			;default file control block.
0019: 0000                Pg0Buffer	EQU		80H			;i/o buffer and command line storage.
0020: 0000                TBASE		EQU		100H		;transiant program storage area.
0021: 0000                ;                   
0022: 0000                ;   Set control character equates.
0023: 0000                ;                   
0024: 0000                CNTRLC		EQU		03H			;control-c
0025: 0000                CNTRLE		EQU		05H			;control-e
0026: 0000                BS			EQU		08H			;backspace
0027: 0000                TAB			EQU		09H			;tab
0028: 0000                LF			EQU		0AH			;line feed
0029: 0000                FF			EQU		0CH			;form feed
0030: 0000                CR			EQU		0DH			;carriage return
0031: 0000                CNTRLP		EQU		10H			;control-p
0032: 0000                CNTRLR		EQU		12H			;control-r
0033: 0000                CNTRLS		EQU		13H			;control-s
0034: 0000                CNTRLU		EQU		15H			;control-u
0035: 0000                CNTRLX		EQU		18H			;control-x
0036: 0000                CNTRLZ		EQU		1AH			;control-z (end-of-file mark)
0037: 0000                DEL			EQU		7FH			;rubout
0038: 0000                ;                   
0039: 0000                BLANK		EQU		020H		; Space/Blank
0040: 0000                BRACKETLEFT		EQU	07BH		; {
0041: 0000                BRACKETRIGHT	EQU	07DH		; }
0042: 0000                QMARK		EQU		03FH		; ?
0043: 0000                EQUALS		EQU		03DH		; =
0044: 0000                USCORE		EQU		05FH		; _
0045: 0000                PERIOD		EQU		02EH		; .
0046: 0000                COLON		EQU		03AH		; :
0047: 0000                SEMIC		EQU		03BH		; ;
0048: 0000                LESSTH		EQU		03CH		; <
0049: 0000                GRTTHAN		EQU		03EH		; >
0050: 0000                ASTRK		EQU		02AH		; *
0051: 0000                CARET		EQU		05EH		; ^
0052: 0000                ATSIGN		EQU		040H		; @
0053: 0000                POUNDSN		EQU		023H		; #
0054: 0000                DOLLAR		EQU		024H		; $
0055: 0000                                    
0056: 0000                EndOfMessage	EQU	00H
0057: 0000                EmptyFileFlag	EQU	0E5H		; empty file slot in dorectory
0058: 0000                ;                   
0059: 0000                ;   Set origin for CP/M
0060: 0000                ;                   
0061: 0000                	ORG	(MEM-8)*1024   
0062: E000                CodeStart:          
0063: E000                ;                   
0064: E000                CBASE:              
0065: E000     C32FE3     		JMP		COMMAND		;execute command processor (ccp).
0066: E003     C32BE3     		JMP		CLEARBUF	;entry to empty input buffer before starting ccp.
0067: E006                                    
0068: E006                ;                   
0069: E006                ;   Standard cp/m ccp input buffer. Format is (max length),
0070: E006                ; (actual length), (char #1), (char #2), (char #3), etc.
0071: E006                ;                   
0072: E006                InBuffStart:        
0073: E006                InBuffSize:					;length of input buffer.
0074: E006     7F         		DB		InBuffEnd - InBuffStart		
0075: E007                InBuffCount:			;current Count of contents.
0076: E007     00         		DB		0             
0077: E008                InBuff:             
0078: E008     434F5059524947485420 		DB		'Copyright '  
0079: E012     313937392028432920425920 		DB		'1979 (c) by '
0080: E01E     4449474954414C205245534541524348 		DB		'Digital Research'
0081: E02E     00         		DB		00            
0082: E02F                		DS		86			         
0083: E085                InBuffEnd:          
0084: E085                		                  
0085: E085                InBuffAddress:      
0086: E085     08E0       		DW		InBuff		;input line pointer
0087: E087                ErrorMsgPointer:    
0088: E087     0000       		DW		0			; input line pointer used for error message. Points to
0089: E089                							; start of name in error.
0090: E089                ;                   
0091: E089                ;   Routine to print (A) on the console. All registers used.
0092: E089                ;                   
0093: E089                PRINT:              
0094: E089     5F         	MOV		E,A			;setup bdos call.
0095: E08A     0E02       	MVI		C,2           
0096: E08C     C30500     	JMP		ENTRY         
0097: E08F                ;                   
0098: E08F                ;   Routine to print (A) on the console and to save (BC).
0099: E08F                ;                   
0100: E08F                PRINTB:             
0101: E08F     C5         	PUSH	B             
0102: E090     CD89E0     	CALL	PRINT         
0103: E093     C1         	POP		B             
0104: E094     C9         	RET                
0105: E095                ;                   
0106: E095                ;   Routine to send a carriage return, line feed combination
0107: E095                ; to the console.   
0108: E095                ;                   
0109: E095                SendEndOfLine:      
0110: E095     3E0D       	MVI		A,CR          
0111: E097     CD8FE0     	CALL	PRINTB        
0112: E09A     3E0A       	MVI		A,LF          
0113: E09C     C38FE0     	JMP		PRINTB        
0114: E09F                ;                   
0115: E09F                ;   Routine to send one space to the console and save (BC).
0116: E09F                ;                   
0117: E09F                SpaceToConsole:     
0118: E09F     3E20       	MVI		A,BLANK		; blank/Space
0119: E0A1     C38FE0     	JMP		PRINTB        
0120: E0A4                ;                   
0121: E0A4                ;   Routine to print character string pointed to be (BC) on the
0122: E0A4                ; console. It must terminate with a null byte.
0123: E0A4                ;                   
0124: E0A4                PLINE:              
0125: E0A4     C5         	PUSH	B             
0126: E0A5     CD95E0     	CALL	SendEndOfLine 
0127: E0A8     E1         	POP		H             
0128: E0A9                PLINE2:             
0129: E0A9     7E         	MOV		A,M           
0130: E0AA     B7         	ORA		A             
0131: E0AB     C8         	RZ                 
0132: E0AC     23         	INX		H             
0133: E0AD     E5         	PUSH	H             
0134: E0AE     CD89E0     	CALL	PRINT         
0135: E0B1     E1         	POP		H             
0136: E0B2     C3A9E0     	JMP		PLINE2        
0137: E0B5                ;                   
0138: E0B5                ;   Routine to reset the disk system.
0139: E0B5                ;                   
0140: E0B5                ResetDiskSystem:    
0141: E0B5     0E0D       	MVI		C,13          
0142: E0B7     C30500     	JMP		ENTRY         
0143: E0BA                ;                   
0144: E0BA                ;   Routine to select disk (A).
0145: E0BA                ;                   
0146: E0BA                DiskSelect:         
0147: E0BA     5F         	MOV		E,A           
0148: E0BB     0E0E       	MVI		C,14          
0149: E0BD     C30500     	JMP		ENTRY         
0150: E0C0                ;                   
0151: E0C0                ;   Routine to call bdos and save the return code. The zero
0152: E0C0                ; flag is set on a return of 0ffh.
0153: E0C0                ;                   
0154: E0C0                ENTRY1:             
0155: E0C0     CD0500     	CALL	ENTRY         
0156: E0C3     32B9E7     	STA		RTNCODE		;save return code.
0157: E0C6     3C         	INR		A			;set zero if 0ffh returned.
0158: E0C7     C9         	RET                
0159: E0C8                ;                   
0160: E0C8                ;   Routine to open a file. (DE) must point to the FCB.
0161: E0C8                ;                   
0162: E0C8                OPEN:               
0163: E0C8     0E0F       	MVI		C,15          
0164: E0CA     C3C0E0     	JMP		ENTRY1        
0165: E0CD                ;                   
0166: E0CD                ;   Routine to open file at (FCB).
0167: E0CD                ;                   
0168: E0CD                OPENFCB:            
0169: E0CD     AF         	XRA		A		;clear the record number byte at fcb+32
0170: E0CE     32B8E7     	STA		FCBfromCCP+32 
0171: E0D1     1198E7     	LXI		D,FCBfromCCP  
0172: E0D4     C3C8E0     	JMP		OPEN          
0173: E0D7                ;                   
0174: E0D7                ;   Routine to close a file. (DE) points to FCB.
0175: E0D7                ;                   
0176: E0D7                CLOSE:              
0177: E0D7     0E10       	MVI		C,16          
0178: E0D9     C3C0E0     	JMP		ENTRY1        
0179: E0DC                ;                   
0180: E0DC                ;   Routine to search for the first file with ambigueous name
0181: E0DC                ; (DE).             
0182: E0DC                ;                   
0183: E0DC                SearchForFirst:     
0184: E0DC     0E11       	MVI		C,17          
0185: E0DE     C3C0E0     	JMP		ENTRY1        
0186: E0E1                ;                   
0187: E0E1                ;   Search for the next ambigeous file name.
0188: E0E1                ;                   
0189: E0E1                SearchForNext:      
0190: E0E1     0E12       	MVI		C,18          
0191: E0E3     C3C0E0     	JMP		ENTRY1        
0192: E0E6                ;                   
0193: E0E6                ;   Search for file at (FCB).
0194: E0E6                ;                   
0195: E0E6                SRCHFCB:            
0196: E0E6     1198E7     	LXI		D,FCBfromCCP  
0197: E0E9     C3DCE0     	JMP		SearchForFirst
0198: E0EC                ;                   
0199: E0EC                ;   Routine to delete a file pointed to by (DE).
0200: E0EC                ;                   
0201: E0EC                DeleteFile:         
0202: E0EC     0E13       	MVI		C,19          
0203: E0EE     C30500     	JMP		ENTRY         
0204: E0F1                ;                   
0205: E0F1                ;   Routine to call the bdos and set the zero flag if a zero
0206: E0F1                ; status is returned.
0207: E0F1                ;                   
0208: E0F1                ENTRY2:             
0209: E0F1     CD0500     	CALL	ENTRY         
0210: E0F4     B7         	ORA		A		;set zero flag if appropriate.
0211: E0F5     C9         	RET                
0212: E0F6                ;                   
0213: E0F6                ;   Routine to read the next record from a sequential file.
0214: E0F6                ; (DE) points to the FCB.
0215: E0F6                ;                   
0216: E0F6                RDREC:              
0217: E0F6     0E14       	MVI		C,20          
0218: E0F8     C3F1E0     	JMP		ENTRY2        
0219: E0FB                ;                   
0220: E0FB                ;   Routine to read file at (FCB).
0221: E0FB                ;                   
0222: E0FB                READFCB:            
0223: E0FB     1198E7     	LXI		D,FCBfromCCP  
0224: E0FE     C3F6E0     	JMP		RDREC         
0225: E101                ;                   
0226: E101                ;   Routine to write the next record of a sequential file.
0227: E101                ; (DE) points to the FCB.
0228: E101                ;                   
0229: E101                WRTREC:             
0230: E101     0E15       	MVI		C,21          
0231: E103     C3F1E0     	JMP		ENTRY2        
0232: E106                ;                   
0233: E106                ;   Routine to create the file pointed to by (DE).
0234: E106                ;                   
0235: E106                CREATE:             
0236: E106     0E16       	MVI		C,22          
0237: E108     C3C0E0     	JMP		ENTRY1        
0238: E10B                ;                   
0239: E10B                ;   Routine to rename the file pointed to by (DE). Note that
0240: E10B                ; the new name starts at (DE+16).
0241: E10B                ;                   
0242: E10B                RENAM:              
0243: E10B     0E17       	MVI		C,23          
0244: E10D     C30500     	JMP		ENTRY         
0245: E110                ;                   
0246: E110                ;   Get the current user code.
0247: E110                ;                   
0248: E110                GETUSR:             
0249: E110     1EFF       	MVI		E,0FFH			; make it get
0250: E112                ;                   
0251: E112                ;   Routine to get or set the current user code.
0252: E112                ; If (E) is FF then this is a GET, else it is a SET.
0253: E112                ;                   
0254: E112                GetSetCurrentUser:  
0255: E112     0E20       	MVI		C,32			; BDOS vector
0256: E114     C30500     	JMP		ENTRY         
0257: E117                ;                   
0258: E117                ;   Routine to set the current drive byte at (TDRIVE).
0259: E117                ;                   
0260: E117                SetCurrentDrive:    
0261: E117     CD10E1     	CALL	GETUSR			;get user number
0262: E11A     87         	ADD		A				;and shift into the upper 4 bits.
0263: E11B     87         	ADD		A             
0264: E11C     87         	ADD		A             
0265: E11D     87         	ADD		A             
0266: E11E     21BAE7     	LXI		H,CDRIVE		;now add in the current drive number.
0267: E121     B6         	ORA		M             
0268: E122     320400     	STA		TDRIVE			;and save.
0269: E125     C9         	RET                
0270: E126                ;                   
0271: E126                ;   Move currently active drive down to (TDRIVE).
0272: E126                ;                   
0273: E126                MOVECD:             
0274: E126     3ABAE7     	LDA		CDRIVE        
0275: E129     320400     	STA		TDRIVE        
0276: E12C     C9         	RET                
0277: E12D                ;                   
0278: E12D                ;   Routine to convert (A) into upper case ascii. Only letters
0279: E12D                ; are affected.     
0280: E12D                ;                   
0281: E12D                UPPER:              
0282: E12D     FE61       	CPI		061H			; 'a'	;check for letters in the range of 'a' to 'z'.
0283: E12F     D8         	RC                 
0284: E130     FE7B       	CPI		BRACKETLEFT		;'{'
0285: E132     D0         	RNC                
0286: E133     E65F       	ANI		5FH				;convert it if found.
0287: E135     C9         	RET                
0288: E136                ;                   
0289: E136                ;   Routine to get a line of input. We must check to see if the
0290: E136                ; user is in (BatchFlag) mode. If so, then read the input from file
0291: E136                ; ($$$.SUB). At the end, reset to console input.
0292: E136                ;                   
0293: E136                InputLine:          
0294: E136     3A76E7     	LDA		BatchFlag			;if =0, then use console input.
0295: E139     B7         	ORA		A             
0296: E13A     CA93E1     	JZ		InputLineConsole
0297: E13D                ;                   
0298: E13D                ;   Use the submit file ($$$.sub) which is prepared by a
0299: E13D                ; SUBMIT run. It must be on drive (A) and it will be deleted
0300: E13D                ; if and error occures (like eof).
0301: E13D                ;                   
0302: E13D     3ABAE7     	LDA		CDRIVE		;select drive 0 if need be.
0303: E140     B7         	ORA		A             
0304: E141     3E00       	MVI		A,0			;always use drive A for submit.
0305: E143     C4BAE0     	CNZ		DiskSelect		;select it if required.
0306: E146     1177E7     	LXI		D,BATCHFCB    
0307: E149     CDC8E0     	CALL	OPEN		;look for it.
0308: E14C     CA93E1     	JZ		InputLineConsole		;if not there, use normal input.
0309: E14F     3A86E7     	LDA		BATCHFCB+15	;get last record number+1.
0310: E152     3D         	DCR		A             
0311: E153     3297E7     	STA		BATCHFCB+32   
0312: E156     1177E7     	LXI		D,BATCHFCB    
0313: E159     CDF6E0     	CALL	RDREC		;read last record.
0314: E15C     C293E1     	JNZ		InputLineConsole		;quit on end of file.
0315: E15F                ;                   
0316: E15F                ;   Move this record into input buffer.
0317: E15F                ;                   
0318: E15F     1107E0     	LXI		D,InBuffCount 
0319: E162     218000     	LXI		H,Pg0Buffer	;data was read into buffer here.
0320: E165     06E006     	MVI		B,InBuffSize		;all 128 characters may be used.
0321: E167     CD13E4     	CALL	HL2DE		;(HL) to (DE), (B) bytes.
0322: E16A     2185E7     	LXI		H,BATCHFCB+14 
0323: E16D     3600       	MVI		M,0			;zero out the 's2' byte.
0324: E16F     23         	INX		H			;and decrement the record count.
0325: E170     35         	DCR		M             
0326: E171     1177E7     	LXI		D,BATCHFCB	;close the batch file now.
0327: E174     CDD7E0     	CALL	CLOSE         
0328: E177     CA93E1     	JZ		InputLineConsole		;quit on an error.
0329: E17A     3ABAE7     	LDA		CDRIVE		;re-select previous drive if need be.
0330: E17D     B7         	ORA		A             
0331: E17E     C4BAE0     	CNZ		DiskSelect		;don't do needless selects.
0332: E181                ;                   
0333: E181                ;   Print line just read on console.
0334: E181                ;                   
0335: E181     2108E0     	LXI		H,InBuff      
0336: E184     CDA9E0     	CALL	PLINE2        
0337: E187     CDBFE1     	CALL	CHKCON		;check console, quit on a key.
0338: E18A     CAA4E1     	JZ		InputLineConsole1		;jump if no key is pressed.
0339: E18D                ;                   
0340: E18D                ;   Terminate the submit job on any keyboard input. Delete this
0341: E18D                ; file such that it is not re-started and jump to normal keyboard
0342: E18D                ; input section.    
0343: E18D                ;                   
0344: E18D     CDDAE1     	CALL	DeleteBatchFile	;delete the batch file.
0345: E190     C353E3     	JMP		CMMND1		;and restart command input.
0346: E193                ;                   
0347: E193                ;   Get here for normal keyboard input. Delete the submit file
0348: E193                ; incase there was one.
0349: E193                ;                   
0350: E193                InputLineConsole:   
0351: E193     CDDAE1     	CALL	DeleteBatchFile		; delete file ($$$.sub).
0352: E196     CD17E1     	CALL	SetCurrentDrive		; reset active disk.
0353: E199     0E0A       	MVI		C,10				; get line from console device.
0354: E19B     1106E0     	LXI		D,InBuffStart		; point at the Inbuff construct (Size, Pos, Buffer)
0355: E19E     CD0500     	CALL	ENTRY				; call BDOS fcConsoleStringIn
0356: E1A1     CD26E1     	CALL	MOVECD		;reset current drive (again).
0357: E1A4                ;                   
0358: E1A4                ;   Convert input line to upper case.
0359: E1A4                ;                   
0360: E1A4                InputLineConsole1:  
0361: E1A4     2107E0     	LXI		H,InBuffCount 
0362: E1A7     46         	MOV		B,M			;(B)=character counter.
0363: E1A8                InputLineConsole2:  
0364: E1A8     23         	INX		H             
0365: E1A9     78         	MOV		A,B			;end of the line?
0366: E1AA     B7         	ORA		A             
0367: E1AB     CAB7E1     	JZ		InputLineConsole3
0368: E1AE     7E         	MOV		A,M			;convert to upper case.
0369: E1AF     CD2DE1     	CALL	UPPER         
0370: E1B2     77         	MOV		M,A           
0371: E1B3     05         	DCR		B			;adjust character count.
0372: E1B4     C3A8E1     	JMP		InputLineConsole2
0373: E1B7                InputLineConsole3:  
0374: E1B7     77         	MOV		M,A			;add trailing null.
0375: E1B8     2108E0     	LXI		H,InBuff      
0376: E1BB     2285E0     	SHLD	InBuffAddress		;reset input line pointer.
0377: E1BE     C9         	RET                
0378: E1BF                ;                   
0379: E1BF                ;   Routine to check the console for a key pressed. The zero
0380: E1BF                ; flag is set is none, else the character is returned in (A).
0381: E1BF                ;                   
0382: E1BF                CHKCON:             
0383: E1BF     0E0B       	MVI		C,11		;check console.
0384: E1C1     CD0500     	CALL	ENTRY         
0385: E1C4     B7         	ORA		A             
0386: E1C5     C8         	RZ					;return if nothing.
0387: E1C6     0E01       	MVI		C,1			;else get character.
0388: E1C8     CD0500     	CALL	ENTRY         
0389: E1CB     B7         	ORA		A			;clear zero flag and return.
0390: E1CC     C9         	RET                
0391: E1CD                ;                   
0392: E1CD                ;   Routine to get the currently active drive number.
0393: E1CD                ;                   
0394: E1CD                GetCurrentDisk:     
0395: E1CD     0E19       	MVI		C,25          
0396: E1CF     C30500     	JMP		ENTRY         
0397: E1D2                ;                   
0398: E1D2                ;   Set the stabdard dma address.
0399: E1D2                ;                   
0400: E1D2                STDDMA:             
0401: E1D2     118000     	LXI		D,Pg0Buffer   
0402: E1D5                ;                   
0403: E1D5                ;   Routine to set the dma address to (DE).
0404: E1D5                ;                   
0405: E1D5                setDMA:             
0406: E1D5     0E1A       	MVI		C,26          
0407: E1D7     C30500     	JMP		ENTRY         
0408: E1DA                ;                   
0409: E1DA                ;  Delete the batch file created by SUBMIT.
0410: E1DA                ;                   
0411: E1DA                DeleteBatchFile:    
0412: E1DA     2176E7     	LXI		H,BatchFlag			;is batch active?
0413: E1DD     7E         	MOV		A,M           
0414: E1DE     B7         	ORA		A             
0415: E1DF     C8         	RZ                 
0416: E1E0     3600       	MVI		M,0				;yes, de-activate it.
0417: E1E2     AF         	XRA		A             
0418: E1E3     CDBAE0     	CALL	DiskSelect			;select drive 0 for sure.
0419: E1E6     1177E7     	LXI		D,BATCHFCB		;and delete this file.
0420: E1E9     CDECE0     	CALL	DeleteFile    
0421: E1EC     3ABAE7     	LDA		CDRIVE			;reset current drive.
0422: E1EF     C3BAE0     	JMP		DiskSelect    
0423: E1F2                ;                   
0424: E1F2                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0425: E1F2                ; the same or we halt....
0426: E1F2                ;                   
0427: E1F2                ;VERIFY:            
0428: E1F2                ;	LXI		D,PATTRN1		;these are the serial number bytes.
0429: E1F2                ;	LXI		H,PATTRN2		;ditto, but how could they be different?
0430: E1F2                ;	MVI		B,6				;6 bytes each.
0431: E1F2                ;VERIFY1:           
0432: E1F2                ;	LDAX	D            
0433: E1F2                ;	CMP		M            
0434: E1F2                ;	JNZ		HALT			;jump to halt routine.
0435: E1F2                ;	INX		D            
0436: E1F2                ;	INX		H            
0437: E1F2                ;	DCR		B            
0438: E1F2                ;	JNZ		VERIFY1      
0439: E1F2                ;	RET               
0440: E1F2                ;                   
0441: E1F2                ;   Print back file name with a '?' to indicate a syntax error.
0442: E1F2                ;                   
0443: E1F2                SYNERR:             
0444: E1F2     CD95E0     	CALL	SendEndOfLine	;end current line.
0445: E1F5     2A87E0     	LHLD	ErrorMsgPointer	;this points to name in error.
0446: E1F8                SYNERR1:            
0447: E1F8     7E         	MOV	A,M	;print it until a space or null is found.
0448: E1F9     FE20       	CPI	BLANK		; Space 
0449: E1FB     CA0BE2     	JZ	SYNERR2         
0450: E1FE     B7         	ORA	A              
0451: E1FF     CA0BE2     	JZ	SYNERR2         
0452: E202     E5         	PUSH	H             
0453: E203     CD89E0     	CALL	PRINT         
0454: E206     E1         	POP	H              
0455: E207     23         	INX	H              
0456: E208     C3F8E1     	JMP	SYNERR1        
0457: E20B                SYNERR2:            
0458: E20B     3E3F       	MVI	A,QMARK		;add trailing '?'.
0459: E20D     CD89E0     	CALL	PRINT         
0460: E210     CD95E0     	CALL	SendEndOfLine 
0461: E213     CDDAE1     	CALL	DeleteBatchFile;delete any batch file.
0462: E216     C353E3     	JMP	CMMND1	;and restart from console input.
0463: E219                ;                   
0464: E219                ;   Check character at (DE) for legal command input. Note that the
0465: E219                ; zero flag is set if the character is a delimiter.
0466: E219                ;                   
0467: E219                IsItValidCharacter: 
0468: E219     1A         	LDAX	D			; Grab the character
0469: E21A     B7         	ORA		A             
0470: E21B     C8         	RZ					; Exit, its a Null (00)
0471: E21C                	                   
0472: E21C     FE20       	CPI		BLANK		; Is  less than 020H - controls character
0473: E21E     DAF2E1     	JC		SYNERR		; Yes,  Syntax error - exit CCP
0474: E221     C8         	RZ					; Exit because Space is valid delimiter.
0475: E222                	                   
0476: E222     FE3D       	CPI	EQUALS			; '=' 
0477: E224     C8         	RZ                 
0478: E225     FE5F       	CPI	USCORE			; '_' 
0479: E227     C8         	RZ                 
0480: E228     FE2E       	CPI	PERIOD			; '.' 
0481: E22A     C8         	RZ                 
0482: E22B     FE3A       	CPI	COLON			; ':'  
0483: E22D     C8         	RZ                 
0484: E22E     FE3B       	CPI	SEMIC			; ';'  
0485: E230     C8         	RZ                 
0486: E231     FE3C       	CPI	LESSTH			; '<' 
0487: E233     C8         	RZ                 
0488: E234     FE3E       	CPI	GRTTHAN			; '>'
0489: E236     C8         	RZ                 
0490: E237     C9         	RET					; Character is legal, but not a delimiter
0491: E238                ;                   
0492: E238                ;   Get the next non-blank character from (DE).
0493: E238                ;                   
0494: E238                NextNonBlankChar:   
0495: E238     1A         	LDAX	D			; get the next character
0496: E239     B7         	ORA		A			; since string ends with a null.
0497: E23A     C8         	RZ					; we return here if its 00
0498: E23B     FE20       	CPI		BLANK		; is it a space?
0499: E23D     C0         	RNZ					; No, then we have the next non-space char
0500: E23E                	                   
0501: E23E     13         	INX		D			; point at the next character and keep going
0502: E23F     C338E2     	JMP		NextNonBlankChar
0503: E242                ;                   
0504: E242                ;   Add (HL)=(HL)+(A)
0505: E242                ;                   
0506: E242                AddAtoHL:           
0507: E242     85         	ADD		L             
0508: E243     6F         	MOV		L,A           
0509: E244     D0         	RNC					;take care of any carry.
0510: E245     24         	INR		H             
0511: E246     C9         	RET                
0512: E247                ;                   
0513: E247                ;   Convert the first name in (FCB).
0514: E247                ;                   
0515: E247                ConvertFirstName:   
0516: E247     3E00       	MVI	A,0		; set up index for first filename
0517: E249                ;                   
0518: E249                ;   Format a file name (convert * to '?', etc.). On return,
0519: E249                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0520: E249                ; the position within the fcb for the name (either 0 or 16).
0521: E249                ;                   
0522: E249                ConvertFileName:    
0523: E249     2198E7     	LXI		H,FCBfromCCP		; point at FCB setup by CCP
0524: E24C     CD42E2     	CALL	AddAtoHL			; now pointing at correct FCB
0525: E24F     E5         	PUSH	H					; save correct FCBfromCCP
0526: E250     E5         	PUSH	H					; save correct FCBfromCCP
0527: E251     AF         	XRA		A					; clear the Acc.
0528: E252     32BBE7     	STA		ChangeDriveFlag		; initialize drive change flag - no change.
0529: E255     2A85E0     	LHLD	InBuffAddress		; set (HL) as pointer into input line.
0530: E258     EB         	XCHG						; put line pointer in DE for call
0531: E259     CD38E2     	CALL	NextNonBlankChar	; return the next non-blank character in A
0532: E25C     EB         	XCHG						; put line buffer pointer in HL for now
0533: E25D     2287E0     	SHLD	ErrorMsgPointer		; save pointer here for any error message.
0534: E260     EB         	XCHG						; put line buffer pointer back in DE
0535: E261     E1         	POP		H					; retreive the CCP created FCB
0536: E262     1A         	LDAX	D					; get first character.
0537: E263     B7         	ORA		A					; is it a null 00 ?
0538: E264     CA72E2     	JZ		CONVRT1				; Yes, this FCB is empty (no argument)
0539: E267                	                   
0540: E267     DE40       	SBI		040H				; 'A'-1	;might be a drive name, convert to binary.
0541: E269     47         	MOV		B,A					; and save in case its a drive specifier.
0542: E26A     13         	INX		D					; get the next character 
0543: E26B     1A         	LDAX	D             
0544: E26C     FE3A       	CPI		COLON				; is it ':'
0545: E26E     CA79E2     	JZ		CONVRT2				; Yes, then we have a drive specification here
0546: E271     1B         	DCX		D					; No, move pointer back to the start of the line.
0547: E272                CONVRT1:            
0548: E272     3ABAE7     	LDA		CDRIVE				; get current drive
0549: E275     77         	MOV		M,A					; put into the correst FCBfromCCP
0550: E276     C37FE2     	JMP		CONVRT3       
0551: E279                	                   
0552: E279                CONVRT2:            
0553: E279     78         	MOV		A,B					; get the saved drive number
0554: E27A     32BBE7     	STA		ChangeDriveFlag		; set change in drives flag.
0555: E27D     70         	MOV		M,B					; put new drive number in FCB
0556: E27E     13         	INX		D					; point past drive number
0557: E27F                ;                   
0558: E27F                ;   Convert the basic file name.
0559: E27F                ;                   
0560: E27F                CONVRT3:            
0561: E27F     0608       	MVI		B,08H				; File name size
0562: E281                CONVRT4:            
0563: E281     CDC9E2     	CALL	ExpandName			; Expand all 8 characters in name
0564: E284                                    
0565: E284                CONVRT7:            
0566: E284     CD19E2     	CALL	IsItValidCharacter	; Do we have a delimiter ?.
0567: E287     CA8EE2     	JZ		GetExtension		; Yes, process the extension
0568: E28A     13         	INX		D					; No, point a the next character
0569: E28B     C384E2     	JMP		CONVRT7				; and see if its a demiliter
0570: E28E                                    
0571: E28E                GetExtension:       
0572: E28E     0603       	MVI		B,03H				; file extension size
0573: E290     FE2E       	CPI		PERIOD				; do we have the Period '.'
0574: E292                ;	JNZ		PADEXT				; No, Pad fill the extension
0575: E292     CA9BE2     	JZ		GetExtension1		; yes, process the extension
0576: E295     CDE1E2     	CALL	PadField			; No, Pad fill the extension
0577: E298     C3A9E2     	JMP		ClearS1S2EX			; process the stuff after the extension
0578: E29B                GetExtension1:      
0579: E29B     13         	INX		D					; get past the period
0580: E29C     CDC9E2     	CALL	ExpandName			; Expand all 3 characters in extension
0581: E29F                                    
0582: E29F                GetExtension4:      
0583: E29F     CD19E2     	CALL	IsItValidCharacter	; Do we have a delimiter ?.
0584: E2A2     CAA9E2     	JZ		ClearS1S2EX			; Yes, Clear the EX, S1 & S2
0585: E2A5     13         	INX		D					; No, point a the next character
0586: E2A6     C39FE2     	JMP		GetExtension4		; and see if its a demiliter
0587: E2A9                	                   
0588: E2A9                ClearS1S2EX:        
0589: E2A9     0603       	MVI		B,03H				; set count for clearing EX, S1 & S2
0590: E2AB                ClearS1S2EX1:       
0591: E2AB     23         	INX		H					; point at location in the CCP FCB
0592: E2AC     3600       	MVI		M,0					; initialize it
0593: E2AE     05         	DCR		B					; keep count
0594: E2AF     C2ABE2     	JNZ		ClearS1S2EX1		; loop til done
0595: E2B2     EB         	XCHG               
0596: E2B3     2285E0     	SHLD	InBuffAddress		; save current input line pointer.
0597: E2B6     E1         	POP		H					; point at correct CCP FCB
0598: E2B7                ;                   
0599: E2B7                ;   Check to see if this is an ambigeous file name specification.
0600: E2B7                ; Set the (A) register to non zero if it is.
0601: E2B7                ;                   
0602: E2B7                ;AFN - Ambiguous File Name
0603: E2B7     010B00     	LXI		B,11				; set name & Extension length .
0604: E2BA                AFN:                
0605: E2BA     23         	INX		H             
0606: E2BB     7E         	MOV		A,M           
0607: E2BC     FE3F       	CPI		QMARK				; '?'	;any question marks?
0608: E2BE     C2C2E2     	JNZ		AFN1          
0609: E2C1     04         	INR		B					; increment count
0610: E2C2                AFN1:               
0611: E2C2     0D         	DCR		C             
0612: E2C3     C2BAE2     	JNZ		AFN					; loop if not done
0613: E2C6     78         	MOV		A,B					; B has the question mark count 
0614: E2C7     B7         	ORA		A					; set the Z flag for calling routine
0615: E2C8     C9         	RET                
0616: E2C9                	                   
0617: E2C9                ;                   
0618: E2C9                ; ExpandName -	expands the name/ext to all 8/3 characters by either padding with SPACES
0619: E2C9                ;				or, replaceing *'s with ?s for the remainder of the name/ext
0620: E2C9                ;               Original input is in DE (InBuFF)
0621: E2C9                ;				Expanded result is put in HL (FCBfromCCP)
0622: E2C9                ;                   
0623: E2C9                ExpandName:         
0624: E2C9     CD19E2     	CALL	IsItValidCharacter	; Legal input character ?
0625: E2CC     CAE1E2     	JZ		PadField			; its a delimiter, skip the rest of the name/ext 
0626: E2CF     23         	INX		HL            
0627: E2D0     FE2A       	CPI		ASTRK				; '*'	;note that an '*' will fill the remaining
0628: E2D2     C2DAE2     	JNZ		ExpandName1			; with question marks
0629: E2D5     363F       	MVI		M,QMARK				; '?'
0630: E2D7     C3DCE2     	JMP		ExpandName2   
0631: E2DA                	                   
0632: E2DA                ExpandName1:        
0633: E2DA     77         	MOV		M,A			; put character in FCB
0634: E2DB     13         	INX		D			; move to next character in input line buffer
0635: E2DC                ExpandName2:        
0636: E2DC     05         	DCR		B			; decrement counter
0637: E2DD     C2C9E2     	JNZ		ExpandName	; loop if not done with fileName
0638: E2E0     C9         	RET					; exit when done!
0639: E2E1                	                   
0640: E2E1                PadField:            
0641: E2E1     23         	INX		H			; blank fill the remaining file name.
0642: E2E2     3620       	MVI		M,BLANK		; store the blank
0643: E2E4     05         	DCR		B			; keep count
0644: E2E5     C2E1E2     	JNZ		PadField	; loop till done
0645: E2E8     C9         	RET					; exit when done!
0646: E2E9                		                  
0647: E2E9                ;                   
0648: E2E9                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0649: E2E9                ;                   
0650: E2E9                                    
0651: E2E9                CommandSize		EQU	04 
0652: E2E9                CommandList:        
0653: E2E9     44495220   	DB	'DIR '		; 0     
0654: E2ED     45524120   	DB	'ERA '		; 1     
0655: E2F1     54595045   	DB	'TYPE'		; 2     
0656: E2F5     53415645   	DB	'SAVE'		; 3     
0657: E2F9     52454E20   	DB	'REN '		; 4     
0658: E2FD     55534552   	DB	'USER'		; 5     
0659: E301                	;Unknown		; 6      
0660: E301                CommandListEnd:     
0661: E301                CommandCount	EQU	(CommandListEnd-CommandList)/CommandSize
0662: E301                ;                   
0663: E301                ;   The following six bytes must agree with those at (PATTRN2)
0664: E301                ; or cp/m will HALT. Why?
0665: E301                ;                   
0666: E301                ;PATTRN1:           
0667: E301                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
0668: E301                ;                   
0669: E301                ;   Search the command table for a match with what has just
0670: E301                ; been entered. If a match is found, then we jump to the
0671: E301                ; proper section. Else jump to (UNKNOWN).
0672: E301                ; On return, the (C) register is set to the command number
0673: E301                ; that matched (or CommandCount+1 if no match).
0674: E301                ;                   
0675: E301                FindDOSCommand:     
0676: E301     21E9E2     	LXI		H,CommandList		; point at the CP/M Command List
0677: E304     0E00       	MVI		C,0					; index into CommandList
0678: E306                FindDOSCommand1:    
0679: E306     79         	MOV		A,C           
0680: E307     FE06       	CPI		CommandCount		; Are we still in the list?
0681: E309     D0         	RNC							; no, the command is UNKNOWN, get out
0682: E30A     1199E7     	LXI		D,FCBfromCCP+1		; check this one.
0683: E30D     0604       	MVI		B,CommandSize		; max command Size.
0684: E30F                FindDOSCommand2:    
0685: E30F     1A         	LDAX	D					; get next character
0686: E310     BE         	CMP		M					; do we have a match?
0687: E311     C222E3     	JNZ		FindDOSCommand3		; if not a match, try the next command
0688: E314     13         	INX		D             
0689: E315     23         	INX		H             
0690: E316     05         	DCR		B					; keep count of characters matched
0691: E317     C20FE3     	JNZ		FindDOSCommand2		; loop until 4 character match
0692: E31A                	                   
0693: E31A     1A         	LDAX	D					; allow a 3 character command to match.
0694: E31B     FE20       	CPI		BLANK         
0695: E31D     C227E3     	JNZ		FindDOSCommand4
0696: E320     79         	MOV		A,C					;s et return register for this command.
0697: E321     C9         	RET                
0698: E322                FindDOSCommand3:    
0699: E322     23         	INX		H					; move pointer to the next command in the table
0700: E323     05         	DCR		B					; insures correct poisting
0701: E324     C222E3     	JNZ		FindDOSCommand3		; keep going til you reach the next command    
0702: E327                FindDOSCommand4:    
0703: E327     0C         	INR		C					; increment the index into CommandList
0704: E328     C306E3     	JMP		FindDOSCommand1		; try again
0705: E32B                ;                   
0706: E32B                ;   Set the input buffer to empty and then start the command
0707: E32B                ; processor (ccp).  
0708: E32B                ;                   
0709: E32B                CLEARBUF:           
0710: E32B     AF         XRA	A               
0711: E32C     3207E0     	STA	InBuffCount			;second byte is actual length.
0712: E32F                ;                   
0713: E32F                ;**************************************************************
0714: E32F                ;*                  
0715: E32F                ;*                  
0716: E32F                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0717: E32F                ;*                  
0718: E32F                ;                   
0719: E32F                ;   On entry (C) points at Current disk & user (defaultDisk 0004)
0720: E32F                ;**************************************************************
0721: E32F                ;*                  
0722: E32F                COMMAND:            
0723: E32F     3176E7     	LXI			SP,CCPStack				; Use dedicated stack space.
0724: E332     C5         	PUSH		B						; (C) should be equal to currentDisk where:
0725: E333     79         	MOV			A,C						; (uuuudddd) where 'uuuu' is the user number
0726: E334     1F         	RAR									; and 'dddd' is the drive number.
0727: E335     1F         	RAR                
0728: E336     1F         	RAR                
0729: E337     1F         	RAR                
0730: E338     E60F       	ANI			0FH						; isolate the user number.
0731: E33A     5F         	MOV			E,A						; and put into E for call
0732: E33B     CD12E1     	CALL		GetSetCurrentUser		; to set the current user
0733: E33E     CDB5E0     	CALL		ResetDiskSystem			; reset the disk system.
0734: E341     3276E7     	STA			BatchFlag				; clear batch mode flag.
0735: E344     C1         	POP			B						; Current disk
0736: E345     79         	MOV			A,C						; move current disk to acc
0737: E346                	AN			0FH						; isolate the drive number.
0738: E346     32BAE7     	STA			CDRIVE					;	and save.
0739: E349     CDBAE0     	CALL		DiskSelect					; ...and select.
0740: E34C     3A07E0     	LDA			InBuffCount  
0741: E34F     B7         	ORA			A						; anything in input buffer already?
0742: E350     C269E3     	JNZ			CMMND2					; yes, then just process it.
0743: E353                ;                   
0744: E353                ;   Entry point to get a command line from the console.
0745: E353                ;                   
0746: E353                CMMND1:             
0747: E353     3176E7     	LXI			SP,CCPStack			; set stack straight.
0748: E356     CD95E0     	CALL		SendEndOfLine				; start a new line on the screen.
0749: E359     CDCDE1     	CALL		GetCurrentDisk		; get current drive.
0750: E35C     C641       	ADI			041H				; 'A' make it printable
0751: E35E     CD89E0     	CALL		PRINT				; print current drive.
0752: E361     3E3E       	MVI			A,GRTTHAN			; '>'
0753: E363     CD89E0     	CALL		PRINT				; and add prompt.
0754: E366     CD36E1     	CALL		InputLine				; get line from user.
0755: E369                ;                   
0756: E369                ;   Process command line here.
0757: E369                ;                   
0758: E369                CMMND2:             
0759: E369     118000     	LXI			D,Pg0Buffer			; set up command storage
0760: E36C     CDD5E1     	CALL		setDMA				; set standard dma address.
0761: E36F     CDCDE1     	CALL		GetCurrentDisk
0762: E372     32BAE7     	STA			CDRIVE				; set current drive.
0763: E375     CD47E2     	CALL		ConvertFirstName				; convert name typed in.
0764: E378     C4F2E1     	CNZ			SYNERR				; wild cards are not allowed. report error
0765: E37B     3ABBE7     	LDA			ChangeDriveFlag		; if a change in drives was indicated,
0766: E37E     B7         	ORA			A					; then treat this as an unknown command
0767: E37F     C273E6     	JNZ			UNKNOWN				; which gets executed.
0768: E382     CD01E3     	CALL		FindDOSCommand				; else search command table for a match.
0769: E385                ;                   
0770: E385                ;   Note that an unknown command returns
0771: E385                ; with (A) pointing to the last address
0772: E385                ; in our table which is (UNKNOWN).
0773: E385                ;                   
0774: E385     2192E3     	LXI			H,CommandVector		; now, look thru our address table for command (A).
0775: E388     5F         	MOV			E,A					; set (DE) to command number.
0776: E389     1600       	MVI			D,0          
0777: E38B     19         	DAD			D            
0778: E38C     19         	DAD			D					; (HL)=(CommandVector)+2*(command number).
0779: E38D     7E         	MOV			A,M					; now pick out this address.
0780: E38E     23         	INX			H            
0781: E38F     66         	MOV			H,M          
0782: E390     6F         	MOV			L,A					; HL now has the address of the command to execute
0783: E391     E9         	PCHL		;now execute it.
0784: E392                ;                   
0785: E392                ;   CP/M command address table.
0786: E392                ;                   
0787: E392                CommandVector:      
0788: E392     48E4       	DW	DIRECT		; 0     
0789: E394     EDE4       	DW	ERASE		; 1      
0790: E396     2BE5       	DW	TYPE		; 2       
0791: E398     7BE5       	DW	SAVE		; 3       
0792: E39A     DEE5       	DW	RENAME		; 4     
0793: E39C     5CE6       	DW	USER		; 5       
0794: E39E     73E6       	DW	UNKNOWN		; 6    
0795: E3A0                ;                   
0796: E3A0                ;   Halt the system. Reason for this is unknown at present.
0797: E3A0                ;                   
0798: E3A0                HALT:               
0799: E3A0     21F376     	LXI	H,76F3H	;'DI HLT' instructions.
0800: E3A3     2200E0     	SHLD	CBASE         
0801: E3A6     2100E0     	LXI	H,CBASE        
0802: E3A9     E9         	PCHL               
0803: E3AA                ;                   
0804: E3AA                ;   Read error while TYPEing a file.
0805: E3AA                ;                   
0806: E3AA                RDERROR:            
0807: E3AA     01B0E3     	LXI	B,RDERR        
0808: E3AD     C3A4E0     	JMP	PLINE          
0809: E3B0                RDERR:              
0810: E3B0     52454144204552524F5200 	DB	'Read error',0  
0811: E3BB                ;                   
0812: E3BB                ;   Required file was not located.
0813: E3BB                ;                   
0814: E3BB                                    
0815: E3BB                FileNotFound:       
0816: E3BB     01C1E3     	LXI	B,NOFILE       
0817: E3BE     C3A4E0     	JMP	PLINE          
0818: E3C1                NOFILE:             
0819: E3C1     4E4F2046494C4500 	DB	'No file',EndOfMessage
0820: E3C9                ;                   
0821: E3C9                ;   Decode a command of the form 'A>filename number{ filename}.
0822: E3C9                ; Note that a drive specifier is not allowed on the first file
0823: E3C9                ; name. On return, the number is in register (A). Any error
0824: E3C9                ; causes 'filename?' to be printed and the command is aborted.
0825: E3C9                ;                   
0826: E3C9                GetCmdNumber:       
0827: E3C9     CD47E2     	CALL	ConvertFirstName				; convert first filename.
0828: E3CC     3ABBE7     	LDA		ChangeDriveFlag		; do not allow a drive to be specified.
0829: E3CF     B7         	ORA		A             
0830: E3D0     C2F2E1     	JNZ		SYNERR				; exit with a syntax error
0831: E3D3     2199E7     	LXI		H,FCBfromCCP+1		; convert number now.
0832: E3D6     010B00     	LXI		B,11				;(B)=sum register, (C)=max digit count.
0833: E3D9                GetCmdNumber1:      
0834: E3D9     7E         	MOV		A,M					; get the caracter from the CCP FCB
0835: E3DA     FE20       	CPI		BLANK				; a space terminates the numeral.
0836: E3DC     CA04E4     	JZ		PadNumber			; skip, the rest must be blanks
0837: E3DF     23         	INX		H					; bump pointer
0838: E3E0     D630       	SUI		030H  				; '0'	make binary from ascii. ZERO ????
0839: E3E2     FE0A       	CPI		10					; legal digit?
0840: E3E4     D2F2E1     	JNC		SYNERR				; exit with syntax error
0841: E3E7     57         	MOV		D,A					; yes, save the number in (D).
0842: E3E8                	;                  
0843: E3E8     78         	MOV		A,B					; compute (B)=(B)*10 and check for overflow.
0844: E3E9     E6E0       	ANI		0E0H          
0845: E3EB     C2F2E1     	JNZ		SYNERR				; Exit with math overflow error??
0846: E3EE     78         	MOV		A,B           
0847: E3EF     07         	RLC                
0848: E3F0     07         	RLC                
0849: E3F1     07         	RLC							;(A)=(B)*8
0850: E3F2     80         	ADD		B					;.......*9
0851: E3F3     DAF2E1     	JC		SYNERR				; Exit with math overflow error??	
0852: E3F6     80         	ADD		B					;.......*10
0853: E3F7     DAF2E1     	JC		SYNERR				; Exit with math overflow error??
0854: E3FA     82         	ADD		D					; add in new digit now.
0855: E3FB     DAF2E1     	JC		SYNERR				; Exit with math overflow error??
0856: E3FE     47         	MOV		B,A					; and save result in B (subtotal)
0857: E3FF     0D         	DCR		C					; only look at 11 digits.
0858: E400     C2D9E3     	JNZ		GetCmdNumber1 
0859: E403     C9         	RET							; return with value in (A)
0860: E404                PadNumber:          
0861: E404     7E         	MOV		A,M					; spaces must follow (why?).
0862: E405     FE20       	CPI		BLANK				; is it a blank
0863: E407     C2F2E1     	JNZ		SYNERR				; exit with syntax error
0864: E40A     23         	INX		H					; point at next
0865: E40B     0D         	DCR		C             
0866: E40C     C204E4     	JNZ		PadNumber			; loop till done
0867: E40F     78         	MOV		A,B					; set (A)=the numeric value entered.
0868: E410     C9         	RET                
0869: E411                ;                   
0870: E411                ;   Move 3 bytes from (HL) to (DE). Note that there is only
0871: E411                ; one reference to this at (A2D5h).
0872: E411                ;                   
0873: E411                MOVE3:              
0874: E411     0603       	MVI	B,3            
0875: E413                ;                   
0876: E413                ;   Move (B) bytes from (HL) to (DE).
0877: E413                ;                   
0878: E413                HL2DE:              
0879: E413     7E         	MOV	A,M            
0880: E414     12         	STAX	D             
0881: E415     23         	INX	H              
0882: E416     13         	INX	D              
0883: E417     05         	DCR	B              
0884: E418     C213E4     	JNZ	HL2DE          
0885: E41B     C9         	RET                
0886: E41C                ;                   
0887: E41C                ;   Compute (HL)=(Pg0Buffer)+(A)+(C) and get the byte that's here.
0888: E41C                ;                   
0889: E41C                EXTRACT:            
0890: E41C     218000     	LXI	H,Pg0Buffer    
0891: E41F     81         	ADD	C              
0892: E420     CD42E2     	CALL	AddAtoHL      
0893: E423     7E         	MOV	A,M            
0894: E424     C9         	RET                
0895: E425                ;                   
0896: E425                ;  Check drive specified. If it means a change, then the new
0897: E425                ; drive will be selected. In any case, the drive byte of the
0898: E425                ; fcb will be set to null (means use current drive).
0899: E425                ;                   
0900: E425                SelectDrive:        
0901: E425     AF         	XRA		A					; clear the Acc
0902: E426     3298E7     	STA		FCBfromCCP			; null out first byte of fcb. ie make it the default drive.
0903: E429     3ABBE7     	LDA		ChangeDriveFlag		; is a drive change indicated?
0904: E42C     B7         	ORA		A             
0905: E42D     C8         	RZ							; No, drive OK
0906: E42E     3D         	DCR		A					; yes, is it the same as the current drive?
0907: E42F     21BAE7     	LXI		H,CDRIVE      
0908: E432     BE         	CMP		M					; FCB drive number same as this?
0909: E433     C8         	RZ							; Yes, return 					
0910: E434     C3BAE0     	JMP		DiskSelect			;	no. Select it then.
0911: E437                ;                   
0912: E437                ;   Check the drive selection and reset it to the previous
0913: E437                ; drive if it was changed for the preceeding command.
0914: E437                ;                   
0915: E437                RESETDR:            
0916: E437     3ABBE7     	LDA	ChangeDriveFlag	;drive change indicated?
0917: E43A     B7         	ORA	A              
0918: E43B     C8         	RZ                 
0919: E43C     3D         	DCR	A	;yes, was it a different drive?
0920: E43D     21BAE7     	LXI	H,CDRIVE       
0921: E440     BE         	CMP	M              
0922: E441     C8         	RZ                 
0923: E442     3ABAE7     	LDA	CDRIVE	;yes, re-select our old drive.
0924: E445     C3BAE0     	JMP	DiskSelect     
0925: E448                ;                   
0926: E448                ;**************************************************************
0927: E448                ;*                  
0928: E448                ;*           D I R E C T O R Y   C O M M A N D
0929: E448                ;*                  
0930: E448                ;**************************************************************
0931: E448                ;                   
0932: E448                DIRECT:             
0933: E448     CD47E2     	CALL	ConvertFirstName	; convert file name.
0934: E44B     CD25E4     	CALL	SelectDrive			; select indicated drive.
0935: E44E     2199E7     	LXI		H,FCBfromCCP + 1	; was any file indicated?
0936: E451     7E         	MOV		A,M           
0937: E452     FE20       	CPI		BLANK         
0938: E454     C260E4     	JNZ		DIRECT2				; Skip if yes
0939: E457                	                   
0940: E457     060B       	MVI		B,11				; no. Fill field with '?' - same as *.*.
0941: E459                DIRECT1:            
0942: E459     363F       	MVI		M,QMARK				; '?'
0943: E45B     23         	INX		H             
0944: E45C     05         	DCR		B             
0945: E45D     C259E4     	JNZ		DIRECT1				; stay at it util all 11 bytes are filled with "?"s
0946: E460                	                   
0947: E460                DIRECT2:            
0948: E460     1E00       	MVI		E,0					; set initial file name position.
0949: E462     D5         	PUSH	D					; save file name position. (e)
0950: E463     CDE6E0     	CALL	SRCHFCB				; get first file name.
0951: E466     CCBBE3     	CZ		FileNotFound		; none file found at all?
0952: E469                DIRECT3:            
0953: E469     CAE9E4     	JZ		DIRECT9				; terminate if no more names.
0954: E46C     3AB9E7     	LDA		RTNCODE				; get file's position in segment (0-3).
0955: E46F     0F         	RRC                
0956: E470     0F         	RRC                
0957: E471     0F         	RRC                
0958: E472     E660       	ANI		60H					;(A)=position*32 ie correct FCB
0959: E474     4F         	MOV		C,A           
0960: E475     3E0A       	MVI		A,10          
0961: E477     CD1CE4     	CALL	EXTRACT				; get T2 , because it has system file flag
0962: E47A     17         	RAL							; Rotate the flag (msb) to the carry
0963: E47B     DADDE4     	JC		DIRECT8				; we don't list it if it is System aka hidden.
0964: E47E     D1         	POP		D					; get saved file name position.
0965: E47F     7B         	MOV		A,E					;  put in Acc
0966: E480     1C         	INR		E					; increment the file name position
0967: E481     D5         	PUSH	D					; and save it for later
0968: E482     E603       	ANI		03H					; at end of line?
0969: E484     F5         	PUSH	PSW					; save current name position
0970: E485     C29DE4     	JNZ		DIRECT4       
0971: E488     CD95E0     	CALL	SendEndOfLine		; yes, end this line and start another.
0972: E48B     C5         	PUSH	B             
0973: E48C     CDCDE1     	CALL	GetCurrentDisk		; start line with ('A:').
0974: E48F     C1         	POP		B             
0975: E490     C641       	ADI		041H				; convert to ascii'A'
0976: E492     CD8FE0     	CALL	PRINTB				; send to console
0977: E495     3E3A       	MVI		A,COLON				; ':'
0978: E497     CD8FE0     	CALL	PRINTB				; send to console
0979: E49A     C3A5E4     	JMP	DIRECT5        
0980: E49D                DIRECT4:            
0981: E49D     CD9FE0     	CALL	SpaceToConsole		; add seperator between file names.
0982: E4A0     3E3A       	MVI		A, COLON			;	':'
0983: E4A2     CD8FE0     	CALL	PRINTB        
0984: E4A5                DIRECT5:            
0985: E4A5     CD9FE0     	CALL	SpaceToConsole
0986: E4A8     0601       	MVI		B,1					; 'extract' each file name character at a time.
0987: E4AA                DIRECT6:            
0988: E4AA     78         	MOV		A,B           
0989: E4AB     CD1CE4     	CALL	EXTRACT       
0990: E4AE     E67F       	ANI		7FH					; strip bit 7 (status bit).
0991: E4B0     FE20       	CPI		BLANK				; are we at the end of the name?
0992: E4B2     C2CAE4     	JNZ		DRECT65       
0993: E4B5     F1         	POP	PSW	;yes, don't print spaces at the end of a line.
0994: E4B6     F5         	PUSH	PSW           
0995: E4B7     FE03       	CPI	3              
0996: E4B9     C2C8E4     	JNZ	DRECT63        
0997: E4BC     3E09       	MVI	A,9	;first check for no extension.
0998: E4BE     CD1CE4     	CALL	EXTRACT       
0999: E4C1     E67F       	ANI	7FH            
1000: E4C3     FE20       	CPI	BLANK          
1001: E4C5     CADCE4     	JZ	DIRECT7	;don't print spaces.
1002: E4C8                DRECT63:            
1003: E4C8     3E20       	MVI	A,BLANK	;else print them.
1004: E4CA                DRECT65:            
1005: E4CA     CD8FE0     	CALL	PRINTB        
1006: E4CD     04         	INR		B				; bump to next character psoition.
1007: E4CE     78         	MOV		A,B           
1008: E4CF     FE0C       	CPI		12				; end of the name?
1009: E4D1     D2DCE4     	JNC		DIRECT7			; yes , we are done with this one
1010: E4D4     FE09       	CPI		9				; nope, starting extension?
1011: E4D6     CC9FE0     	CZ		SpaceToConsole	; yes, add seperating space.
1012: E4D9     C3AAE4     	JMP		DIRECT6       
1013: E4DC                	                   
1014: E4DC                DIRECT7:            
1015: E4DC     F1         	POP		PSW				; get the next file name.
1016: E4DD                DIRECT8:            
1017: E4DD     CDBFE1     	CALL	CHKCON	;first check console, quit on anything.
1018: E4E0     C2E9E4     	JNZ	DIRECT9        
1019: E4E3     CDE1E0     	CALL	SearchForNext	;get next name.
1020: E4E6     C369E4     	JMP	DIRECT3	;and continue with our list.
1021: E4E9                DIRECT9:            
1022: E4E9     D1         	POP	D	;restore the stack and return to command level.
1023: E4EA     C351E7     	JMP	GETBACK        
1024: E4ED                ;                   
1025: E4ED                ;**************************************************************
1026: E4ED                ;*                  
1027: E4ED                ;*                E R A S E   C O M M A N D
1028: E4ED                ;*                  
1029: E4ED                ;**************************************************************
1030: E4ED                ;                   
1031: E4ED                ERASE:              
1032: E4ED     CD47E2     	CALL	ConvertFirstName	;convert file name.
1033: E4F0     FE0B       	CPI	11	;was '*.*' entered?
1034: E4F2     C210E5     	JNZ	ERASE1         
1035: E4F5     0120E5     	LXI	B,YESNO	;yes, ask for confirmation.
1036: E4F8     CDA4E0     	CALL	PLINE         
1037: E4FB     CD36E1     	CALL	InputLine     
1038: E4FE     2107E0     	LXI	H,InBuffCount  
1039: E501     35         	DCR	M	;must be exactly 'y'.
1040: E502     C253E3     	JNZ	CMMND1         
1041: E505     23         	INX	H              
1042: E506     7E         	MOV	A,M            
1043: E507     FE59       	CPI	059H	; 'Y'     
1044: E509     C253E3     	JNZ	CMMND1         
1045: E50C     23         	INX	H              
1046: E50D     2285E0     	SHLD	InBuffAddress	;save input line pointer.
1047: E510                ERASE1:             
1048: E510     CD25E4     	CALL	SelectDrive	;select desired disk.
1049: E513     1198E7     	LXI	D,FCBfromCCP   
1050: E516     CDECE0     	CALL	DeleteFile	;delete the file.
1051: E519     3C         	INR	A              
1052: E51A     CCBBE3     	CZ	FileNotFound	;not there?
1053: E51D     C351E7     	JMP	GETBACK	;return to command level now.
1054: E520                YESNO:              
1055: E520     414C4C2028592F4E293F00 	DB	'All (y/n)?',0  
1056: E52B                ;                   
1057: E52B                ;**************************************************************
1058: E52B                ;*                  
1059: E52B                ;*            T Y P E   C O M M A N D
1060: E52B                ;*                  
1061: E52B                ;**************************************************************
1062: E52B                ;                   
1063: E52B                TYPE:               
1064: E52B     CD47E2     	CALL	ConvertFirstName	;convert file name.
1065: E52E     C2F2E1     	JNZ	SYNERR	;wild cards not allowed.
1066: E531     CD25E4     	CALL	SelectDrive	;select indicated drive.
1067: E534     CDCDE0     	CALL	OPENFCB	;open the file.
1068: E537     CA75E5     	JZ	TYPE5	;not there?
1069: E53A     CD95E0     	CALL	SendEndOfLine	;ok, start a new line on the screen.
1070: E53D     21BCE7     	LXI	H,NBYTES;initialize byte counter.
1071: E540     36FF       	MVI	M,0FFH	;set to read first sector.
1072: E542                TYPE1:              
1073: E542     21BCE7     	LXI	H,NBYTES       
1074: E545                TYPE2:              
1075: E545     7E         	MOV	A,M	;have we written the entire sector?
1076: E546     FE80       	CPI	LogicalSecSize 
1077: E548     DA55E5     	JC	TYPE3           
1078: E54B     E5         	PUSH	H	;yes, read in the next one.
1079: E54C     CDFBE0     	CALL	READFCB       
1080: E54F     E1         	POP	H              
1081: E550     C26EE5     	JNZ	TYPE4	;end or error?
1082: E553     AF         	XRA	A	;ok, clear byte counter.
1083: E554     77         	MOV	M,A            
1084: E555                TYPE3:              
1085: E555     34         	INR	M	;count this byte.
1086: E556     218000     	LXI	H,Pg0Buffer	;and get the (A)th one from the buffer (Pg0Buffer).
1087: E559     CD42E2     	CALL	AddAtoHL      
1088: E55C     7E         	MOV	A,M            
1089: E55D     FE1A       	CPI	CNTRLZ	;end of file mark?
1090: E55F     CA51E7     	JZ	GETBACK         
1091: E562     CD89E0     	CALL	PRINT	;no, print it.
1092: E565     CDBFE1     	CALL	CHKCON	;check console, quit if anything ready.
1093: E568     C251E7     	JNZ	GETBACK        
1094: E56B     C342E5     	JMP	TYPE1          
1095: E56E                ;                   
1096: E56E                ;   Get here on an end of file or read error.
1097: E56E                ;                   
1098: E56E                TYPE4:              
1099: E56E     3D         	DCR	A	;read error? 
1100: E56F     CA51E7     	JZ	GETBACK         
1101: E572     CDAAE3     	CALL	RDERROR	;yes, print message.
1102: E575                TYPE5:              
1103: E575     CD37E4     	CALL	RESETDR	;and reset proper drive
1104: E578     C3F2E1     	JMP	SYNERR	;now print file name with problem.
1105: E57B                ;                   
1106: E57B                ;**************************************************************
1107: E57B                ;*                  
1108: E57B                ;*            S A V E   C O M M A N D
1109: E57B                ;*                  
1110: E57B                ;**************************************************************
1111: E57B                ;                   
1112: E57B                SAVE:               
1113: E57B     CDC9E3     	CALL	GetCmdNumber		; get numeric number that follows SAVE.
1114: E57E     F5         	PUSH	PSW					; save number of pages to write.
1115: E57F     CD47E2     	CALL	ConvertFirstName	; convert file name linepointer past the number.
1116: E582     C2F2E1     	JNZ		SYNERR				; exit with syntax error -wild cards not allowed.
1117: E585     CD25E4     	CALL	SelectDrive			; select specified drive.
1118: E588     1198E7     	LXI		D,FCBfromCCP		; now delete this file.
1119: E58B     D5         	PUSH	D					; save the fcb
1120: E58C     CDECE0     	CALL	DeleteFile    
1121: E58F     D1         	POP		D             
1122: E590     CD06E1     	CALL	CREATE				; and create it again.
1123: E593     CAC9E5     	JZ		SAVE3				; can't create?
1124: E596     AF         	XRA		A					; clear record number byte.
1125: E597     32B8E7     	STA		FCBfromCCP+32 
1126: E59A     F1         	POP		PSW					; convert pages to sectors.
1127: E59B     6F         	MOV		L,A           
1128: E59C     2600       	MVI		H,0           
1129: E59E     29         	DAD		H					;(HL)=number of sectors to write.
1130: E59F     110001     	LXI		D,TBASE				; and we start from here.
1131: E5A2                SAVE1:              
1132: E5A2     7C         	MOV		A,H			;done yet?
1133: E5A3     B5         	ORA		L             
1134: E5A4     CABFE5     	JZ		SAVE2          
1135: E5A7     2B         	DCX		H			;nope, count this and compute the start
1136: E5A8     E5         	PUSH	H			;of the next 128 byte sector.
1137: E5A9     218000     	LXI		H,LogicalSecSize
1138: E5AC     19         	DAD		D             
1139: E5AD     E5         	PUSH	H			;save it and set the transfer address.
1140: E5AE     CDD5E1     	CALL	setDMA        
1141: E5B1     1198E7     	LXI		D,FCBfromCCP	;write out this sector now.
1142: E5B4     CD01E1     	CALL	WRTREC        
1143: E5B7     D1         	POP		D			;reset (DE) to the start of the last sector.
1144: E5B8     E1         	POP		H			;restore sector count.
1145: E5B9     C2C9E5     	JNZ		SAVE3		;write error?
1146: E5BC     C3A2E5     	JMP		SAVE1         
1147: E5BF                ;                   
1148: E5BF                ;   Get here after writing all of the file.
1149: E5BF                ;                   
1150: E5BF                SAVE2:              
1151: E5BF     1198E7     	LXI		D,FCBfromCCP	;now close the file.
1152: E5C2     CDD7E0     	CALL	CLOSE         
1153: E5C5     3C         	INR		A			;did it close ok?
1154: E5C6     C2CFE5     	JNZ		SAVE4         
1155: E5C9                ;                   
1156: E5C9                ;   Print out error message (no space).
1157: E5C9                ;                   
1158: E5C9                SAVE3:              
1159: E5C9     01D5E5     	LXI		B,NOSPACE     
1160: E5CC     CDA4E0     	CALL	PLINE         
1161: E5CF                SAVE4:              
1162: E5CF     CDD2E1     	CALL	STDDMA		;reset the standard dma address.
1163: E5D2     C351E7     	JMP		GETBACK       
1164: E5D5                NOSPACE:            
1165: E5D5     4E4F20535041434500 	DB	'No space',0    
1166: E5DE                ;                   
1167: E5DE                ;**************************************************************
1168: E5DE                ;*                  
1169: E5DE                ;*           R E N A M E   C O M M A N D
1170: E5DE                ;*                  
1171: E5DE                ;**************************************************************
1172: E5DE                ;                   
1173: E5DE                RENAME:             
1174: E5DE     CD47E2     	CALL	ConvertFirstName	;convert first file name.
1175: E5E1     C2F2E1     	JNZ	SYNERR	;wild cards not allowed.
1176: E5E4     3ABBE7     	LDA	ChangeDriveFlag	;remember any change in drives specified.
1177: E5E7     F5         	PUSH	PSW           
1178: E5E8     CD25E4     	CALL	SelectDrive	;and select this drive.
1179: E5EB     CDE6E0     	CALL	SRCHFCB	;is this file present?
1180: E5EE     C247E6     	JNZ	RENAME6	;yes, print error message.
1181: E5F1     2198E7     	LXI	H,FCBfromCCP;yes, move this name into second slot.
1182: E5F4     11A8E7     	LXI	D,FCBfromCCP+16
1183: E5F7     0610       	MVI	B,16           
1184: E5F9     CD13E4     	CALL	HL2DE         
1185: E5FC     2A85E0     	LHLD	InBuffAddress	;get input pointer.
1186: E5FF     EB         	XCHG               
1187: E600     CD38E2     	CALL	NextNonBlankChar;get next non blank character.
1188: E603     FE3D       	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1189: E605     CA0DE6     	JZ	RENAME1         
1190: E608     FE5F       	CPI	USCORE		; '_'  
1191: E60A     C241E6     	JNZ	RENAME5        
1192: E60D                RENAME1:            
1193: E60D     EB         	XCHG               
1194: E60E     23         	INX	H	;ok, skip seperator.
1195: E60F     2285E0     	SHLD	InBuffAddress	;save input line pointer.
1196: E612     CD47E2     	CALL	ConvertFirstName	;convert this second file name now.
1197: E615     C241E6     	JNZ	RENAME5	;again, no wild cards.
1198: E618     F1         	POP	PSW	;if a drive was specified, then it
1199: E619     47         	MOV	B,A	;must be the same as before.
1200: E61A     21BBE7     	LXI	H,ChangeDriveFlag
1201: E61D     7E         	MOV	A,M            
1202: E61E     B7         	ORA	A              
1203: E61F     CA27E6     	JZ	RENAME2         
1204: E622     B8         	CMP	B              
1205: E623     70         	MOV	M,B            
1206: E624     C241E6     	JNZ	RENAME5	;they were different, error.
1207: E627                RENAME2:            
1208: E627     70         	MOV	M,B;	reset as per the first file specification.
1209: E628     AF         	XRA	A              
1210: E629     3298E7     	STA	FCBfromCCP;clear the drive byte of the fcb.
1211: E62C                RENAME3:            
1212: E62C     CDE6E0     	CALL	SRCHFCB	;and go look for second file.
1213: E62F     CA3BE6     	JZ	RENAME4	;doesn't exist?
1214: E632     1198E7     	LXI	D,FCBfromCCP   
1215: E635     CD0BE1     	CALL	RENAM	;ok, rename the file.
1216: E638     C351E7     	JMP	GETBACK        
1217: E63B                ;                   
1218: E63B                ;   Process rename errors here.
1219: E63B                ;                   
1220: E63B                RENAME4:            
1221: E63B     CDBBE3     	CALL	FileNotFound	;file not there.
1222: E63E     C351E7     	JMP	GETBACK        
1223: E641                RENAME5:            
1224: E641     CD37E4     	CALL	RESETDR	;bad command format.
1225: E644     C3F2E1     	JMP	SYNERR         
1226: E647                RENAME6:            
1227: E647     0150E6     	LXI	B,EXISTS;destination file already exists.
1228: E64A     CDA4E0     	CALL	PLINE         
1229: E64D     C351E7     	JMP	GETBACK        
1230: E650                EXISTS:             
1231: E650     46494C452045584953545300 	DB	'File exists',0 
1232: E65C                ;                   
1233: E65C                ;**************************************************************
1234: E65C                ;*                  
1235: E65C                ;*             U S E R   C O M M A N D
1236: E65C                ;*                  
1237: E65C                ;**************************************************************
1238: E65C                ;                   
1239: E65C                USER:               
1240: E65C     CDC9E3     	CALL	GetCmdNumber	;get numeric value following command.
1241: E65F     FE10       	CPI	16	;legal user number?
1242: E661     D2F2E1     	JNC	SYNERR         
1243: E664     5F         	MOV	E,A	;yes but is there anything else?
1244: E665     3A99E7     	LDA	FCBfromCCP+1   
1245: E668     FE20       	CPI	BLANK          
1246: E66A     CAF2E1     	JZ	SYNERR	;yes, that is not allowed.
1247: E66D     CD12E1     	CALL	GetSetCurrentUser;ok, set user code.
1248: E670     C354E7     	JMP	GETBACK1       
1249: E673                ;                   
1250: E673                ;**************************************************************
1251: E673                ;*                  
1252: E673                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1253: E673                ;*                  
1254: E673                ;**************************************************************
1255: E673                ;                   
1256: E673                UNKNOWN:            
1257: E673                ;e68b	CALL	VERIFY	;check for valid system (why?).
1258: E673     3A99E7     	LDA		FCBfromCCP+1		; anything to execute?
1259: E676     FE20       	CPI		BLANK				; is it a Space?
1260: E678     C28FE6     	JNZ		UNKWN1        
1261: E67B     3ABBE7     	LDA		ChangeDriveFlag		; No, only a drive change?
1262: E67E     B7         	ORA		A					; Is itEmpty (00)
1263: E67F     CA54E7     	JZ		GETBACK1			; Yes, get otta here?
1264: E682     3D         	DCR		A             
1265: E683     32BAE7     	STA		CDRIVE				; ok, store new drive.
1266: E686     CD26E1     	CALL	MOVECD				; set (TDRIVE) also.
1267: E689     CDBAE0     	CALL	DiskSelect			; and select this drive.
1268: E68C     C354E7     	JMP		GETBACK1			; then return.
1269: E68F                ;                   
1270: E68F                ;   Here a file name was typed. Prepare to execute it.
1271: E68F                ;                   
1272: E68F                UNKWN1:             
1273: E68F     11A1E7     	LXI	D,FCBfromCCP+9	;an extension specified?
1274: E692     1A         	LDAX	D             
1275: E693     FE20       	CPI	BLANK          
1276: E695     C2F2E1     	JNZ	SYNERR	;yes, not allowed.
1277: E698                UNKWN2:             
1278: E698     D5         	PUSH	D             
1279: E699     CD25E4     	CALL	SelectDrive	;select specified drive.
1280: E69C     D1         	POP	D              
1281: E69D     214EE7     	LXI	H,COMFILE	;set the extension to 'COM'.
1282: E6A0     CD11E4     	CALL	MOVE3         
1283: E6A3     CDCDE0     	CALL	OPENFCB	;and open this file.
1284: E6A6     CA36E7     	JZ	UNKWN9	;not present?
1285: E6A9                ;                   
1286: E6A9                ;   Load in the program.
1287: E6A9                ;                   
1288: E6A9     210001     	LXI	H,TBASE	;store the program starting here.
1289: E6AC                UNKWN3:             
1290: E6AC     E5         	PUSH	H             
1291: E6AD     EB         	XCHG               
1292: E6AE     CDD5E1     	CALL	setDMA	;set transfer address.
1293: E6B1     1198E7     	LXI	D,FCBfromCCP;and read the next record.
1294: E6B4     CDF6E0     	CALL	RDREC         
1295: E6B7     C2CCE6     	JNZ	UNKWN4	;end of file or read error?
1296: E6BA     E1         	POP	H	;nope, bump pointer for next sector.
1297: E6BB     118000     	LXI	D,LogicalSecSize
1298: E6BE     19         	DAD	D              
1299: E6BF     1100E0     	LXI	D,CBASE	;enough room for the whole file?
1300: E6C2     7D         	MOV	A,L            
1301: E6C3     93         	SUB	E              
1302: E6C4     7C         	MOV	A,H            
1303: E6C5     9A         	SBB	D              
1304: E6C6     D23CE7     	JNC	UNKWN0	;no, it can't fit.
1305: E6C9     C3ACE6     	JMP	UNKWN3         
1306: E6CC                ;                   
1307: E6CC                ;   Get here after finished reading.
1308: E6CC                ;                   
1309: E6CC                UNKWN4:             
1310: E6CC     E1         	POP	H              
1311: E6CD     3D         	DCR	A	;normal end of file?
1312: E6CE     C23CE7     	JNZ	UNKWN0         
1313: E6D1     CD37E4     	CALL	RESETDR	;yes, reset previous drive.
1314: E6D4     CD47E2     	CALL	ConvertFirstName	;convert the first file name that follows
1315: E6D7     21BBE7     	LXI	H,ChangeDriveFlag;command name.
1316: E6DA     E5         	PUSH	H             
1317: E6DB     7E         	MOV	A,M	;set drive code in default fcb.
1318: E6DC     3298E7     	STA	FCBfromCCP     
1319: E6DF     3E10       	MVI	A,16	;put second name 16 bytes later.
1320: E6E1     CD49E2     	CALL	ConvertFileName	;convert second file name.
1321: E6E4     E1         	POP	H              
1322: E6E5     7E         	MOV	A,M	;and set the drive for this second file.
1323: E6E6     32A8E7     	STA	FCBfromCCP+16  
1324: E6E9     AF         	XRA	A	;clear record byte in fcb.
1325: E6EA     32B8E7     	STA	FCBfromCCP+32  
1326: E6ED     115C00     	LXI	D,DefaultFCB	;move it into place at(005Ch).
1327: E6F0     2198E7     	LXI	H,FCBfromCCP   
1328: E6F3     0621       	MVI	B,33           
1329: E6F5     CD13E4     	CALL	HL2DE         
1330: E6F8     2108E0     	LXI	H,InBuff			;now move the remainder of the input
1331: E6FB                UNKWN5:             
1332: E6FB     7E         	MOV	A,M	;line down to (0080h). Look for a non blank.
1333: E6FC     B7         	ORA	A	;or a null.  
1334: E6FD     CA09E7     	JZ	UNKWN6          
1335: E700     FE20       	CPI	BLANK          
1336: E702     CA09E7     	JZ	UNKWN6          
1337: E705     23         	INX	H              
1338: E706     C3FBE6     	JMP	UNKWN5         
1339: E709                ;                   
1340: E709                ;   Do the line move now. It ends in a null byte.
1341: E709                ;                   
1342: E709                UNKWN6:             
1343: E709     0600       	MVI	B,0	;keep a character count.
1344: E70B     118100     	LXI	D,Pg0Buffer+1;data gets put here.
1345: E70E                UNKWN7:             
1346: E70E     7E         	MOV	A,M	;move it now.
1347: E70F     12         	STAX	D             
1348: E710     B7         	ORA	A              
1349: E711     CA1AE7     	JZ	UNKWN8          
1350: E714     04         	INR	B              
1351: E715     23         	INX	H              
1352: E716     13         	INX	D              
1353: E717     C30EE7     	JMP	UNKWN7         
1354: E71A                UNKWN8:             
1355: E71A     78         	MOV	A,B	;now store the character count.
1356: E71B     328000     	STA	Pg0Buffer      
1357: E71E     CD95E0     	CALL	SendEndOfLine	;clean up the screen.
1358: E721     CDD2E1     	CALL	STDDMA	;set standard transfer address.
1359: E724     CD17E1     	CALL	SetCurrentDrive	;reset current drive.
1360: E727     CD0001     	CALL	TBASE	;and execute the program.
1361: E72A                ;                   
1362: E72A                ;   Transiant programs return here (or reboot).
1363: E72A                ;                   
1364: E72A     3176E7     	LXI	SP,BatchFlag	;set stack first off.
1365: E72D     CD26E1     	CALL	MOVECD	;move current drive into place (TDRIVE).
1366: E730     CDBAE0     	CALL	DiskSelect	;and reselect it.
1367: E733     C353E3     	JMP	CMMND1	;back to comand mode.
1368: E736                ;                   
1369: E736                ;   Get here if some error occured.
1370: E736                ;                   
1371: E736                UNKWN9:             
1372: E736     CD37E4     	CALL	RESETDR	;inproper format.
1373: E739     C3F2E1     	JMP	SYNERR         
1374: E73C                UNKWN0:             
1375: E73C     0145E7     	LXI	B,BADLOAD;read error or won't fit.
1376: E73F     CDA4E0     	CALL	PLINE         
1377: E742     C351E7     	JMP	GETBACK        
1378: E745                BADLOAD:            
1379: E745     424144204C4F414400 	DB	'Bad load',EndOfMessage
1380: E74E                COMFILE:            
1381: E74E     434F4D     	DB	'COM'	;command file extension.
1382: E751                ;                   
1383: E751                ;   Get here to return to command level. We will reset the
1384: E751                ; previous active drive and then either return to command
1385: E751                ; level directly or print error message and then return.
1386: E751                ;                   
1387: E751                GETBACK:            
1388: E751     CD37E4     	CALL	RESETDR	;reset previous drive.
1389: E754                GETBACK1:           
1390: E754     CD47E2     	CALL	ConvertFirstName	;convert first name in (FCB).
1391: E757     3A99E7     	LDA	FCBfromCCP+1	;if this was just a drive change request,
1392: E75A     D620       	SUI	BLANK	;make sure it was valid.
1393: E75C     21BBE7     	LXI	H,ChangeDriveFlag
1394: E75F     B6         	ORA	M              
1395: E760     C2F2E1     	JNZ	SYNERR         
1396: E763     C353E3     	JMP	CMMND1	;ok, return to command level.
1397: E766                ;                   
1398: E766                ;   ccp stack area. 
1399: E766                ;                   
1400: E766     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1401: E776                CCPStack	EQU	$	;end of ccp stack area.
1402: E776                ;                   
1403: E776                ;   Batch (or SUBMIT) processing information storage.
1404: E776                ;                   
1405: E776                BatchFlag:          
1406: E776     00         	DB	0	;batch mode flag (0=not active).
1407: E777                BATCHFCB:           
1408: E777     002424242020202020535542000000000000000000000000000000000000000000 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1409: E798                ;                   
1410: E798                ;   File control block setup by the CCP.
1411: E798                ;                   
1412: E798                FCBfromCCP:         
1413: E798     002020202020202020202020000000000020202020202020202020200000000000 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1414: E7B9                RTNCODE:            
1415: E7B9     00         	DB	0	;status returned from bdos call.
1416: E7BA                CDRIVE:             
1417: E7BA     00         	DB	0	;currently active drive.
1418: E7BB                ChangeDriveFlag:    
1419: E7BB     00         	DB	0	;change in drives flag (0=no change).
1420: E7BC                NBYTES:             
1421: E7BC     0000       	DW	0	;byte counter used by TYPE.
1422: E7BE                ;                   
1423: E7BE                ;   Room for expansion?
1424: E7BE                ;                   
1425: E7BE     00000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1426: E7CB                ;                   
1427: E7CB                ;   Note that the following six bytes must match those at
1428: E7CB                ; (PATTRN1) or cp/m will HALT. Why?
1429: E7CB                ;                   
1430: E7CB                ;PATTRN2:           
1431: E7CB                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
1432: E7CB                ;                   
1433: E7CB                ;**************************************************************
1434: E7CB                ;*                  
1435: E7CB                ;*                    B D O S   E N T R Y
1436: E7CB                ;*                  
1437: E7CB                ;**************************************************************
1438: E7CB                ;                   
1439: E7CB                ;   Entry into bdos.
1440: E7CB                ;			Parameters: (DE) or (E) are the parameters passed. The
1441: E7CB                ;						(C) - function number
1442: E7CB                ;	The user's stack is saved (UserStack) 
1443: E7CB                ;	BDOS uses its own stack  (BDOSstack)
1444: E7CB                ;	The Function number is checked
1445: E7CB                ;	The corect routine is calcualted using the FunctionVector and (C)
1446: E7CB                ;                   
1447: E7CB                	ORG  0E806H					; forces - see start of bios fix later
1448: E806                BDOSEntry:          
1449: E806                ;	JMP	BDOSSetup     
1450: E806                ;BDOSSetup:         
1451: E806     EB         	XCHG						; Swap  (DE) and (HL). **23**
1452: E807     223CE8     	SHLD	ParamsDE			; Save (DE)
1453: E80A     EB         	XCHG						; Restore (DE) and (HL) to original values
1454: E80B     7B         	MOV		A,E	          
1455: E80C     323EE8     	STA		ParamE				; Save register (E) in particular.
1456: E80F     210000     	LXI		H,0           
1457: E812     223FE8     	SHLD	StatusBDOSReturn	; clear return status.
1458: E815     39         	DAD		SP            
1459: E816     2241E8     	SHLD	UserStack			; save users stack pointer.
1460: E819     3173E8     	LXI		SP,BDOSstack		; and set our own.
1461: E81C     AF         	XRA		A					; clear A for flags resets
1462: E81D     32D7F5     	STA		AutoSelectFlag		; clear auto select storage Flag
1463: E820     32D5F5     	STA		AutoSelectActive	; clear auto select Active Flag
1464: E823     2173E8     	LXI		H,BDOSExit			; get return address to BDOSExit routine
1465: E826     E5         	PUSH	H					; put it on the stack
1466: E827     79         	MOV		A,C					; get function number and put into A.
1467: E828     FE29       	CPI		FunctionCount + 1	; valid function number?
1468: E82A     D0         	RNC							; Exit if not valid
1469: E82B     4B         	MOV		C,E					; keep single register function value in C.
1470: E82C     219AE8     	LXI		H,FunctionVector	; now look thru the function table.
1471: E82F     5F         	MOV		E,A           
1472: E830     1600       	MVI		D,0					;(DE)=function number.
1473: E832     19         	DAD		D             
1474: E833     19         	DAD		D					;(HL)=(start of table)+2*(function number).
1475: E834     5E         	MOV		E,M           
1476: E835     23         	INX		H             
1477: E836     56         	MOV		D,M					; now (DE)=address for this function.
1478: E837     2A3CE8     	LHLD	ParamsDE			; retrieve parameters.
1479: E83A     EB         	XCHG						;now (DE) has the original parameters.
1480: E83B     E9         	PCHL						;execute desired function.
1481: E83C                ;----------------------------------
1482: E83C     0000       ParamsDE:			DW	0	;(DE) parameters saved here on entry to BDOS.
1483: E83E     00         ParamE:				DB	0	;storage for register (E) on entry to bdos.
1484: E83F     0000       StatusBDOSReturn:	DW	0	;status returned from bdos function.
1485: E841     0000       UserStack:			DW	0	;save users stack pointer here.
1486: E843                ;                   
1487: E843                ;   Stack area for BDOS calls.
1488: E843                ;                   
1489: E843                					DS	030H        
1490: E873                BDOSstack	EQU	$	;end of stack area.
1491: E873                ;----------------------------------
1492: E873                BDOSExit:           
1493: E873     3AD5F5     	LDA	AutoSelectActive	;was auto select activated?
1494: E876     B7         	ORA	A              
1495: E877     CA90E8     	JZ	BDOSExit1       
1496: E87A     2A3CE8     	LHLD	ParamsDE	;yes, but was a change made?
1497: E87D     3600       	MVI	M,0	;(* reset first byte of fcb *)
1498: E87F     3AD7F5     	LDA	AutoSelectFlag 
1499: E882     B7         	ORA	A              
1500: E883     CA90E8     	JZ	BDOSExit1       
1501: E886     77         	MOV	M,A	;yes, reset first byte properly.
1502: E887     3AD6F5     	LDA	OldDrive	;and get the old drive and select it.
1503: E88A     323EE8     	STA	ParamE         
1504: E88D     CD61F4     	CALL	fcSelectDisk  
1505: E890                BDOSExit1:          
1506: E890     2A41E8     	LHLD		UserStack			;Get  the users stack pointer.
1507: E893     F9         	SPHL		             
1508: E894     2A3FE8     	LHLD		StatusBDOSReturn	;get return status.
1509: E897     7D         	MOV	A,L							;force version 1.4 compatability.
1510: E898     44         	MOV	B,H            
1511: E899     C9         	RET			;and go back to user.
1512: E89A                                    
1513: E89A                	                   
1514: E89A                	                   
1515: E89A                ;                   
1516: E89A                ;   BDOS function jump table.
1517: E89A                ;                   
1518: E89A                ;NFUNCTS	EQU	41	;number of functions in followin table.
1519: E89A                ;                   
1520: E89A                FunctionVector:     
1521: E89A     03F6       	DW	fcSystemReset			;0		Overall system and BDOS reset
1522: E89C     23EB       	DW	fcConsoleIn				;1		Read a byte from the console keyboard
1523: E89E     EBE9       	DW	fcConsoleOut			;2		Write a byte to the console screen
1524: E8A0     29EB       	DW	fcReaderIn				;3		Read a byte from the logical reader device
1525: E8A2     12F6       	DW	fcPunchOut				;4		Write a byte to the logical PUNCH device
1526: E8A4     0FF6       	DW	fcListOut				;5		Write a byte to the logical list device
1527: E8A6     2FEB       	DW	fcDirectConsoleOut		;6		Direct console I/O (no CCP-style editing)
1528: E8A8     48EB       	DW	fcGetIOByte				;7		Read the current setting of the IOBYTE
1529: E8AA     4EEB       	DW	fcSetIOByte				;8		Set a new value of the IOBYTE
1530: E8AC     53EB       	DW	fcConsoleStringOut		;9		Send a "$"-terminated string to the console
1531: E8AE     3CEA       	DW	fcConsoleStringIn		;10		Read a string from the console into a buffer
1532: E8B0     59EB       	DW	fcConsoleStatusIn		;11		Check if a console key is waiting to be read
1533: E8B2     9AF4       	DW	fcGetVersion			;12		Return the CP/M version number
1534: E8B4                	                   
1535: E8B4     9FF4       	DW	fcResetDiskSystem		;13		Reset disk system
1536: E8B6     61F4       	DW	fcSelectDisk			;14		Select specified logical disk drive
1537: E8B8     B8F4       	DW	fcOpenFile				;15		Open specified file for reading/writing
1538: E8BA     C1F4       	DW	fcCloseFile				;16		Close specified file after reading/writing
1539: E8BC     C7F4       	DW	fcSearchForFirst		;17		Search file directory for first match with filename
1540: E8BE     E4F4       	DW	fcSearchForNext			;18		Search file directory for next match with filename
1541: E8C0     F3F4       	DW	fcDeleteFile			;19		Delete (erase) file
1542: E8C2     FCF4       	DW	fcReadSequential		;20		Read the next "record" sequentially
1543: E8C4     02F5       	DW	fcWriteSequential		;21		Write the next "record" sequentially
1544: E8C6     08F5       	DW	fcCreateFile			;22		Create a new file with the specified name
1545: E8C8     11F5       	DW	fcRenameFile			;23		Rename a file to a new name
1546: E8CA     1AF5       	DW	fcGetActiveDisks		;24		Indicate which logical disks are active
1547: E8CC     20F5       	DW	fcGetCurrentDisk		;25		Return the current default disk drive number
1548: E8CE     26F5       	DW	fcSetDMA				;26		Set the DMA address (read/write address)
1549: E8D0     2DF5       	DW	fcGetFATtable			;27		Return the address of an allocation vector
1550: E8D2     35ED       	DW	fcSetDiskRO				;28		Set disk to Read-Only
1551: E8D4     33F5       	DW	fcGetROdisks			;29		Indicate which disks are currently Read-Only status
1552: E8D6     39F5       	DW	fcSetFileAttributes		;30		Set specified file to System or Read-Only status
1553: E8D8     42F5       	DW	fcGetDPB				;31		Return address of disk parameter block (DPB)
1554: E8DA     49F5       	DW	fcGetUser				;32		Set/Get the current user number
1555: E8DC     5DF5       	DW	fcReadRandom			;33		Set/Get the current user number
1556: E8DE     63F5       	DW	fcWriteRandom			;34		Write a "record" randomly
1557: E8E0     69F5       	DW	fcGetFileSize			;35		Return logical file size (even for random files)
1558: E8E2     B6F3       	DW	fcSetRecordNumber		;36		Set record number for the next random read/write
1559: E8E4     6FF5       	DW	fcResetDrive			;37
1560: E8E6     5FEB       	DW	fcReturn				;38		Simple Return
1561: E8E8     5FEB       	DW	fcReturn				;39		Simple Return
1562: E8EA     90F5       	DW	fcWriteZeroFill			;40		Write a "record" randomly with zero fill
1563: E8EC                	                   
1564: E8EC                FunctionCount	EQU	 ($ -FunctionVector)/2
1565: E8EC                                    
1566: E8EC                ;                   
1567: E8EC                ;   Bdos error table.
1568: E8EC                ;                   
1569: E8EC     F4E8       BADSCTR:	DW	ERROR1	;bad sector on read or write.
1570: E8EE     00E9       BADSLCT:	DW	ERROR2	;bad disk select.
1571: E8F0     06E9       RODISK:		DW	ERROR3	;disk is read only.
1572: E8F2     0CE9       ROFILE:		DW	ERROR4	;file is read only.
1573: E8F4                ;                   
1574: E8F4                ;                   
1575: E8F4                ;   Bdos error message section.
1576: E8F4                ;                   
1577: E8F4                ERROR1:             
1578: E8F4     2125E9     	LXI	H,BADSEC	;bad sector message.
1579: E8F7     CD40E9     	CALL	PRTERR	;print it and get a 1 char responce.
1580: E8FA     FE03       	CPI	CNTRLC	;re-boot request (control-c)?
1581: E8FC     CA0000     	JZ	0	;yes.         
1582: E8FF     C9         	RET		;no, return to retry i/o function.
1583: E900                ;                   
1584: E900                ERROR2:             
1585: E900     2130E9     	LXI	H,BADSEL	;bad drive selected.
1586: E903     C30FE9     	JMP	ERROR5         
1587: E906                ;                   
1588: E906                ERROR3:             
1589: E906     213CE9     	LXI	H,DISKRO	;disk is read only.
1590: E909     C30FE9     	JMP	ERROR5         
1591: E90C                ;                   
1592: E90C                ERROR4:             
1593: E90C     2137E9     	LXI	H,FILERO	;file is read only.
1594: E90F                ;                   
1595: E90F                ERROR5:             
1596: E90F     CD40E9     	CALL	PRTERR        
1597: E912     C30000     	JMP	0	;always reboot on these errors.
1598: E915                ;                   
1599: E915     42444F5320455252204F4E20 BDOSERR:	DB	'Bdos Err On '
1600: E921     203A2024   BDOSDRV:	DB	' : $'  
1601: E925     42414420534543544F5224 BADSEC:		DB	'Bad Sector$'
1602: E930     53454C45435424 BADSEL:		DB	'Select$'
1603: E937     46494C4520 FILERO:		DB	'File ' 
1604: E93C     522F4F24   DISKRO:		DB	'R/O$'  
1605: E940                ;                   
1606: E940                ;   Print bdos error message.
1607: E940                ;                   
1608: E940                PRTERR:             
1609: E940     E5         	PUSH	H	;save second message pointer.
1610: E941     CD24EA     	CALL	EndOfLineToConsole	;send (cr)(lf).
1611: E944     3AA2F5     	LDA	CurrentDrive	;get Current Drive drive.
1612: E947     C641       	ADI	041H	; 'A'	;make ascii.
1613: E949     3221E9     	STA	BDOSDRV	;and put in message.
1614: E94C     0115E9     	LXI	B,BDOSERR;and print it.
1615: E94F     CD2EEA     	CALL	PRTMESG       
1616: E952     C1         	POP	B	;print second message line now.
1617: E953     CD2EEA     	CALL	PRTMESG       
1618: E956                ;                   
1619: E956                ;   Get an input character. We will check our 1 character
1620: E956                ; buffer first. This may be set by the console status routine.
1621: E956                ;                   
1622: E956                GETCHAR:            
1623: E956     2169EB     	LXI	H,CHARBUF;check character buffer.
1624: E959     7E         	MOV	A,M	;anything present already?
1625: E95A     3600       	MVI	M,0	;...either case clear it.
1626: E95C     B7         	ORA	A              
1627: E95D     C0         	RNZ		;yes, use it. 
1628: E95E     C309F6     	JMP	biosConsoleIn	;nope, go get a character responce.
1629: E961                ;                   
1630: E961                ;   Input and echo a character.
1631: E961                ;                   
1632: E961                GETECHO:            
1633: E961     CD56E9     	CALL	GETCHAR	;input a character.
1634: E964     CD6FE9     	CALL	CHKCHAR	;carriage control?
1635: E967     D8         	RC		;no, a regular control char so don't echo.
1636: E968     F5         	PUSH	PSW	;ok, save character now.
1637: E969     4F         	MOV	C,A            
1638: E96A     CDEBE9     	CALL	fcConsoleOut	;and echo it.
1639: E96D     F1         	POP	PSW	;get character and return.
1640: E96E     C9         	RET                
1641: E96F                ;                   
1642: E96F                ;   Check character in (A). Set the zero flag on a carriage
1643: E96F                ; control character and the carry flag on any other control
1644: E96F                ; character.        
1645: E96F                ;                   
1646: E96F                CHKCHAR:            
1647: E96F     FE0D       	CPI	CR	;check for carriage return, line feed, backspace,
1648: E971     C8         	RZ		;or a tab.     
1649: E972     FE0A       	CPI	LF             
1650: E974     C8         	RZ                 
1651: E975     FE09       	CPI	TAB            
1652: E977     C8         	RZ                 
1653: E978     FE08       	CPI	BS             
1654: E97A     C8         	RZ                 
1655: E97B     FE20       	CPI	BLANK	;other control char? Set carry flag.
1656: E97D     C9         	RET                
1657: E97E                ;                   
1658: E97E                ;   Check the console during output. Halt on a control-s, then
1659: E97E                ; reboot on a control-c. If anything else is ready, clear the
1660: E97E                ; zero flag and return (the calling routine may want to do
1661: E97E                ; something).       
1662: E97E                ;                   
1663: E97E                CKCONSOL:           
1664: E97E     3A69EB     	LDA	CHARBUF	;check buffer.
1665: E981     B7         	ORA	A	;if anything, just return without checking.
1666: E982     C2A0E9     	JNZ	CKCON2         
1667: E985     CD06F6     	CALL	biosConsoleStatus	;nothing in buffer. Check console.
1668: E988     E601       	ANI	01H	;look at bit 0.
1669: E98A     C8         	RZ		;return if nothing.
1670: E98B     CD09F6     	CALL	biosConsoleIn	;ok, get it.
1671: E98E     FE13       	CPI	CNTRLS	;if not control-s, return with zero cleared.
1672: E990     C29DE9     	JNZ	CKCON1         
1673: E993     CD09F6     	CALL	biosConsoleIn	;halt processing until another char
1674: E996     FE03       	CPI	CNTRLC	;is typed. Control-c?
1675: E998     CA0000     	JZ	0	;yes, reboot now.
1676: E99B     AF         	XRA	A	;no, just pretend nothing was ever ready.
1677: E99C     C9         	RET                
1678: E99D                CKCON1:             
1679: E99D     3269EB     	STA	CHARBUF	;save character in buffer for later processing.
1680: E9A0                CKCON2:             
1681: E9A0     3E01       	MVI	A,1	;set (A) to non zero to mean something is ready.
1682: E9A2     C9         	RET                
1683: E9A3                ;                   
1684: E9A3                ;   Output (C) to the screen. If the printer flip-flop flag
1685: E9A3                ; is set, we will send character to printer also. The console
1686: E9A3                ; will be checked in the process.
1687: E9A3                ;                   
1688: E9A3                OUTCHAR:            
1689: E9A3     3A65EB     	LDA	OutPutFlag	;check output flag.
1690: E9A6     B7         	ORA	A	;anything and we won't generate output.
1691: E9A7     C2BDE9     	JNZ	OUTCHR1        
1692: E9AA     C5         	PUSH	B             
1693: E9AB     CD7EE9     	CALL	CKCONSOL;check console (we don't care whats there).
1694: E9AE     C1         	POP	B              
1695: E9AF     C5         	PUSH	B             
1696: E9B0     CD0CF6     	CALL	biosConsoleOut	;output (C) to the screen.
1697: E9B3     C1         	POP	B              
1698: E9B4     C5         	PUSH	B             
1699: E9B5     3A68EB     	LDA	PrinterFlag	;check printer flip-flop flag.
1700: E9B8     B7         	ORA	A              
1701: E9B9     C40FF6     	CNZ	fcListOut	;print it also if non-zero.
1702: E9BC     C1         	POP	B              
1703: E9BD                OUTCHR1:            
1704: E9BD     79         	MOV	A,C	;update cursors position.
1705: E9BE     2167EB     	LXI	H,CursorPosition
1706: E9C1     FE7F       	CPI	DEL	;rubouts don't do anything here.
1707: E9C3     C8         	RZ                 
1708: E9C4     34         	INR	M	;bump line pointer.
1709: E9C5     FE20       	CPI	BLANK	;and return if a normal character.
1710: E9C7     D0         	RNC                
1711: E9C8     35         	DCR	M	;restore and check for the start of the line.
1712: E9C9     7E         	MOV	A,M            
1713: E9CA     B7         	ORA	A              
1714: E9CB     C8         	RZ		;ingnore control characters at the start of the line.
1715: E9CC     79         	MOV	A,C            
1716: E9CD     FE08       	CPI	BS	;is it a backspace?
1717: E9CF     C2D4E9     	JNZ	OUTCHR2        
1718: E9D2     35         	DCR	M	;yes, backup pointer.
1719: E9D3     C9         	RET                
1720: E9D4                OUTCHR2:            
1721: E9D4     FE0A       	CPI	LF	;is it a line feed?
1722: E9D6     C0         	RNZ		;ignore anything else.
1723: E9D7     3600       	MVI	M,0	;reset pointer to start of line.
1724: E9D9     C9         	RET                
1725: E9DA                ;                   
1726: E9DA                ;   Output (A) to the screen. If it is a control character
1727: E9DA                ; (other than carriage control), use ^x format.
1728: E9DA                ;                   
1729: E9DA                DisplayAcc:         
1730: E9DA     79         	MOV	A,C            
1731: E9DB     CD6FE9     	CALL	CHKCHAR	;check character.
1732: E9DE     D2EBE9     	JNC	fcConsoleOut	;not a control, use normal output.
1733: E9E1     F5         	PUSH	PSW           
1734: E9E2     0E5E       	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1735: E9E4     CDA3E9     	CALL	OUTCHAR       
1736: E9E7     F1         	POP	PSW            
1737: E9E8     F640       	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1738: E9EA     4F         	MOV	C,A            
1739: E9EB                ;                   
1740: E9EB                ;   Function to output (C) to the console device and expand tabs
1741: E9EB                ; if necessary.     
1742: E9EB                ;                   
1743: E9EB                fcConsoleOut:       
1744: E9EB     79         	MOV	A,C            
1745: E9EC     FE09       	CPI	TAB	;is it a tab?
1746: E9EE     C2A3E9     	JNZ	OUTCHAR	;use regular output.
1747: E9F1                fcConsoleOut1:      
1748: E9F1     0E20       	MVI	C,BLANK	;yes it is, use spaces instead.
1749: E9F3     CDA3E9     	CALL	OUTCHAR       
1750: E9F6     3A67EB     	LDA	CursorPosition	;go until the cursor is at a multiple of 8
1751: E9F9                                    
1752: E9F9     E607       	ANI	07H	;position. 
1753: E9FB     C2F1E9     	JNZ	fcConsoleOut1  
1754: E9FE     C9         	RET                
1755: E9FF                ;                   
1756: E9FF                ;   Echo a backspace character. Erase the prevoius character
1757: E9FF                ; on the screen.    
1758: E9FF                ;                   
1759: E9FF                BackUp:             
1760: E9FF     CD07EA     	CALL	BackUp1	;backup the screen 1 place.
1761: EA02     0E20       	MVI	C,BLANK	;then blank that character.
1762: EA04     CD0CF6     	CALL	biosConsoleOut
1763: EA07                BackUp1:            
1764: EA07     0E08       	MVI	C,BS	;then back space once more.
1765: EA09     C30CF6     	JMP	biosConsoleOut 
1766: EA0C                ;                   
1767: EA0C                ;   Signal a deleted line. Print a '#' at the end and start
1768: EA0C                ; over.             
1769: EA0C                ;                   
1770: EA0C                NEWLINE:            
1771: EA0C     0E23       	MVI	C, POUNDSN		; '#'
1772: EA0E     CDA3E9     	CALL	OUTCHAR	;print this.
1773: EA11     CD24EA     	CALL	EndOfLineToConsole	;start new line.
1774: EA14                NEWLN1:             
1775: EA14     3A67EB     	LDA	CursorPosition	;move the cursor to the starting position.
1776: EA17     2166EB     	LXI	H,CursorPositionStart
1777: EA1A     BE         	CMP	M              
1778: EA1B     D0         	RNC		;there yet?   
1779: EA1C     0E20       	MVI	C,BLANK        
1780: EA1E     CDA3E9     	CALL	OUTCHAR	;nope, keep going.
1781: EA21     C314EA     	JMP	NEWLN1         
1782: EA24                ;                   
1783: EA24                ;   Output a (cr) (lf) to the console device (screen).
1784: EA24                ;                   
1785: EA24                EndOfLineToConsole: 
1786: EA24     0E0D       	MVI	C,CR           
1787: EA26     CDA3E9     	CALL	OUTCHAR       
1788: EA29     0E0A       	MVI	C,LF           
1789: EA2B     C3A3E9     	JMP	OUTCHAR        
1790: EA2E                ;                   
1791: EA2E                ;   Print message pointed to by (BC). It will end with a '$'.
1792: EA2E                ;                   
1793: EA2E                PRTMESG:            
1794: EA2E     0A         	LDAX	B	;check for terminating character.
1795: EA2F     FE24       	CPI	DOLLAR		; '$'  
1796: EA31     C8         	RZ                 
1797: EA32     03         	INX	B              
1798: EA33     C5         	PUSH	B	;otherwise, bump pointer and print it.
1799: EA34     4F         	MOV	C,A            
1800: EA35     CDEBE9     	CALL	fcConsoleOut  
1801: EA38     C1         	POP	B              
1802: EA39     C32EEA     	JMP	PRTMESG        
1803: EA3C                ;                   
1804: EA3C                ;   Function to execute a buffered read.
1805: EA3C                ;                   
1806: EA3C                fcConsoleStringIn:  
1807: EA3C     3A67EB     	LDA		CursorPosition		;use present location as starting one.
1808: EA3F     3266EB     	STA		CursorPositionStart
1809: EA42     2A3CE8     	LHLD	ParamsDE			; get the pointer to maximum buffer space.
1810: EA45     4E         	MOV		C,M					; load size in C
1811: EA46     23         	INX		H					; point to first available space.
1812: EA47     E5         	PUSH	H					; and save.
1813: EA48     0600       	MVI		B,0					; keep a character count.
1814: EA4A                RDBUF1:             
1815: EA4A     C5         	PUSH	B					; save the buffer size (C) and character count (B)
1816: EA4B     E5         	PUSH	H					; save buffer position 
1817: EA4C                RDBUF2:             
1818: EA4C     CD56E9     	CALL	GETCHAR				; get the next input character.
1819: EA4F     E67F       	ANI		7FH					; strip bit 7. - only want 7-bit ascii
1820: EA51     E1         	POP		H					; get the buffer position
1821: EA52     C1         	POP		B					; save the buffer size (C) and character count (B)
1822: EA53     FE0D       	CPI		CR					; end of the line?
1823: EA55     CA1CEB     	JZ		RDBUF17				; Yes - then were are done
1824: EA58     FE0A       	CPI		LF            
1825: EA5A     CA1CEB     	JZ		RDBUF17				; same goes for Carriage Return
1826: EA5D                	                   
1827: EA5D     FE08       	CPI		BS					; how about a backspace?
1828: EA5F     C271EA     	JNZ		RDBUF3				; if not skip the following
1829: EA62                								; backSpace 
1830: EA62     78         	MOV		A,B					; ignore at the beginning of the line.
1831: EA63     B7         	ORA		A             
1832: EA64     CA4AEA     	JZ		RDBUF1				; go back if at start of the line
1833: EA67                	                   
1834: EA67     05         	DCR		B					; ok, update counter.
1835: EA68     3A67EB     	LDA		CursorPosition		; if we backspace to the start of the line,
1836: EA6B     3265EB     	STA		OutPutFlag			; treat as a cancel (control-x).
1837: EA6E     C3CBEA     	JMP		RDBUF10       
1838: EA71                	                   
1839: EA71                RDBUF3:             
1840: EA71     FE7F       	CPI		DEL					; user typed a rubout?
1841: EA73     C281EA     	JNZ		RDBUF4				; no? - skip the following
1842: EA76     78         	MOV		A,B					; at the start of the line?.
1843: EA77     B7         	ORA		A             
1844: EA78     CA4AEA     	JZ		RDBUF1				; ignore at the start of the line.
1845: EA7B                	                   
1846: EA7B     7E         	MOV		A,M					; ok, echo the prevoius character.
1847: EA7C     05         	DCR		B					; and reset pointers (counters).
1848: EA7D     2B         	DCX		H             
1849: EA7E     C304EB     	JMP		RDBUF15       
1850: EA81                	                   
1851: EA81                RDBUF4:             
1852: EA81     FE05       	CPI		CNTRLE				; physical end of line?
1853: EA83     C292EA     	JNZ		RDBUF5				; yes, skip the following
1854: EA86     C5         	PUSH	B					; save the buffer size (C) and character count (B)
1855: EA87     E5         	PUSH	H					; save buffer position 
1856: EA88     CD24EA     	CALL	EndOfLineToConsole				; send a crlf to the console
1857: EA8B     AF         	XRA		A					; and update starting position.
1858: EA8C     3266EB     	STA		CursorPositionStart
1859: EA8F     C34CEA     	JMP		RDBUF2				; aqnd keep on trucking
1860: EA92                	                   
1861: EA92                RDBUF5:             
1862: EA92     FE10       	CPI		CNTRLP				; control-p? Print flag toggle
1863: EA94     C2A3EA     	JNZ		RDBUF6				; if not skip the following
1864: EA97     E5         	PUSH	H					; yes, flip the print flag filp-flop byte.
1865: EA98     2168EB     	LXI		H,PrinterFlag 
1866: EA9B     3E01       	MVI		A,1					; PrinterFlag=1-PrinterFlag
1867: EA9D     96         	SUB		M             
1868: EA9E     77         	MOV		M,A           
1869: EA9F     E1         	POP		H					; get the buffer position
1870: EAA0     C34AEA     	JMP		RDBUF1				; nothing to put into buffer go back for more
1871: EAA3                	                   
1872: EAA3                RDBUF6:             
1873: EAA3     FE18       	CPI		CNTRLX				; control-x (cancel)?
1874: EAA5     C2BAEA     	JNZ		RDBUF8				; no? skip the following
1875: EAA8     E1         	POP		H					; get the buffer position
1876: EAA9                RDBUF7:             
1877: EAA9     3A66EB     	LDA		CursorPositionStart ; yes, backup the cursor to here.
1878: EAAC     2167EB     	LXI		H,CursorPosition
1879: EAAF     BE         	CMP		M					; done yet?
1880: EAB0     D23CEA     	JNC		fcConsoleStringIn	; yes - go back to the start of reading a line of input
1881: EAB3     35         	DCR		M					; no, decrement pointer and output back up one space.
1882: EAB4     CDFFE9     	CALL	BackUp				; do the backup
1883: EAB7     C3A9EA     	JMP		RDBUF7				; keep doing until done
1884: EABA                	                   
1885: EABA                RDBUF8:             
1886: EABA     FE15       	CPI		CNTRLU				; cntrol-u (cancel line)?
1887: EABC     C2C6EA     	JNZ		RDBUF9        
1888: EABF     CD0CEA     	CALL	NEWLINE				; start a new line.
1889: EAC2     E1         	POP		H					; get the buffer position
1890: EAC3     C33CEA     	JMP		fcConsoleStringIn	; go back to the start of reading a line of input
1891: EAC6                	                   
1892: EAC6                RDBUF9:             
1893: EAC6     FE12       	CPI		CNTRLR				; control-r?
1894: EAC8     C201EB     	JNZ		RDBUF14       
1895: EACB                RDBUF10:;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1896: EACB     C5         	PUSH	B					; save the buffer size (C) and character count (B)
1897: EACC     CD0CEA     	CALL	NEWLINE       
1898: EACF     E1         	POP		H					; get the buffer position
1899: EAD0     C1         	POP		B					; save the buffer size (C) and character count (B)
1900: EAD1     C5         	PUSH	B					; save the buffer size (C) and character count (B)
1901: EAD2     E5         	PUSH	H					; save buffer position 
1902: EAD3                RDBUF11:            
1903: EAD3     78         	MOV	A,B	;done whole line yet?
1904: EAD4     B7         	ORA	A              
1905: EAD5     CAE5EA     	JZ	RDBUF12         
1906: EAD8     23         	INX	H	;nope, get next character.
1907: EAD9     4E         	MOV	C,M            
1908: EADA     05         	DCR	B	;count it.   
1909: EADB     C5         	PUSH	B					; save the buffer size (C) and character count (B)
1910: EADC     E5         	PUSH	H					; save buffer position 
1911: EADD     CDDAE9     	CALL	DisplayAcc	;and display it.
1912: EAE0     E1         	POP		H					; get the buffer position
1913: EAE1     C1         	POP		B					; save the buffer size (C) and character count (B)
1914: EAE2     C3D3EA     	JMP	RDBUF11        
1915: EAE5                RDBUF12:            
1916: EAE5     E5         	PUSH	H					; save buffer position 
1917: EAE6     3A65EB     	LDA	OutPutFlag	;then update cursor position.
1918: EAE9     B7         	ORA	A              
1919: EAEA     CA4CEA     	JZ	RDBUF2          
1920: EAED     2167EB     	LXI	H,CursorPosition;because this line is shorter, we must
1921: EAF0     96         	SUB	M	;back up the cursor (not the screen however)
1922: EAF1     3265EB     	STA	OutPutFlag	;some number of positions.
1923: EAF4                RDBUF13:            
1924: EAF4     CDFFE9     	CALL	BackUp	;note that as long as (OutPutFlag) is non
1925: EAF7     2165EB     	LXI	H,OutPutFlag;zero, the screen will not be changed.
1926: EAFA     35         	DCR	M              
1927: EAFB     C2F4EA     	JNZ	RDBUF13        
1928: EAFE     C34CEA     	JMP	RDBUF2	;now just get the next character.
1929: EB01                ;                   
1930: EB01                ;   Just a normal character, put this in our buffer and echo.
1931: EB01                ;                   
1932: EB01                RDBUF14:            
1933: EB01     23         	INX		H             
1934: EB02     77         	MOV		M,A				; store character.
1935: EB03     04         	INR		B				; and count it.
1936: EB04                RDBUF15:            
1937: EB04     C5         	PUSH	B				; save the buffer size (C) and character count (B)
1938: EB05     E5         	PUSH	H				; save buffer position 
1939: EB06     4F         	MOV		C,A				;echo it now.
1940: EB07     CDDAE9     	CALL	DisplayAcc		; put it out to the console
1941: EB0A     E1         	POP		H				; get the buffer position
1942: EB0B     C1         	POP		B				; save the buffer size (C) and character count (B)
1943: EB0C     7E         	MOV		A,M				; was it an abort request?
1944: EB0D     FE03       	CPI		CNTRLC			; control-c abort?
1945: EB0F     78         	MOV		A,B				; get character count to Acc
1946: EB10     C218EB     	JNZ		RDBUF16       
1947: EB13     FE01       	CPI		1				; only if at start of line.
1948: EB15     CA0000     	JZ		0				; do we do a reboot
1949: EB18                RDBUF16:            
1950: EB18     B9         	CMP		C				; have we filled the buffer?
1951: EB19     DA4AEA     	JC		RDBUF1			; no- go back for more		
1952: EB1C                RDBUF17:            
1953: EB1C     E1         	POP		H				; yes end the line and return.
1954: EB1D     70         	MOV		M,B           
1955: EB1E     0E0D       	MVI		C,CR          
1956: EB20     C3A3E9     	JMP		OUTCHAR	;output (cr) and return.
1957: EB23                ;                   
1958: EB23                ;   Function to get a character from the console device.
1959: EB23                ;                   
1960: EB23                fcConsoleIn:        
1961: EB23     CD61E9     	CALL	GETECHO	;get and echo.
1962: EB26     C35CEB     	JMP	SetStatusBDOS	;save status and return.
1963: EB29                ;                   
1964: EB29                ;   Function to get a character from the tape reader device.
1965: EB29                ;                   
1966: EB29                fcReaderIn:         
1967: EB29     CD15F6     	CALL	biosReaderIn	;get a character from reader, set status and return.
1968: EB2C     C35CEB     	JMP	SetStatusBDOS  
1969: EB2F                ;                   
1970: EB2F                ;  Function to perform direct console i/o. If (C) contains (FF)
1971: EB2F                ; then this is an input request. If (C) contains (FE) then
1972: EB2F                ; this is a status request. Otherwise we are to output (C).
1973: EB2F                ;                   
1974: EB2F                fcDirectConsoleOut: 
1975: EB2F     79         	MOV	A,C	;test for (FF).
1976: EB30     3C         	INR	A              
1977: EB31     CA3BEB     	JZ	DIRC1           
1978: EB34     3C         	INR	A	;test for (FE).
1979: EB35     CA06F6     	JZ	biosConsoleStatus
1980: EB38     C30CF6     	JMP	biosConsoleOut	;just output (C).
1981: EB3B                DIRC1:              
1982: EB3B     CD06F6     	CALL	biosConsoleStatus	;this is an input request.
1983: EB3E     B7         	ORA	A              
1984: EB3F     CA90E8     	JZ	BDOSExit1	;not ready? Just return (directly).
1985: EB42     CD09F6     	CALL	biosConsoleIn	;yes, get character.
1986: EB45     C35CEB     	JMP	SetStatusBDOS	;set status and return.
1987: EB48                ;                   
1988: EB48                ;   Function to return the i/o byte.
1989: EB48                ;                   
1990: EB48                fcGetIOByte:        
1991: EB48     3A0300     	LDA	IOBYTE         
1992: EB4B     C35CEB     	JMP	SetStatusBDOS  
1993: EB4E                ;                   
1994: EB4E                ;   Function to set the i/o byte.
1995: EB4E                ;                   
1996: EB4E                fcSetIOByte:        
1997: EB4E     210300     	LXI	H,IOBYTE       
1998: EB51     71         	MOV	M,C            
1999: EB52     C9         	RET                
2000: EB53                ;                   
2001: EB53                ;   Function to print the character string pointed to by (DE)
2002: EB53                ; on the console device. The string ends with a '$'.
2003: EB53                ;                   
2004: EB53                fcConsoleStringOut: 
2005: EB53     EB         	XCHG               
2006: EB54     4D         	MOV	C,L            
2007: EB55     44         	MOV	B,H	;now (BC) points to it.
2008: EB56     C32EEA     	JMP	PRTMESG        
2009: EB59                ;                   
2010: EB59                ;   Function to interigate the console device.
2011: EB59                ;                   
2012: EB59                fcConsoleStatusIn:  
2013: EB59     CD7EE9     	CALL	CKCONSOL      
2014: EB5C                ;                   
2015: EB5C                ;   Get here to set the status and return to the cleanup
2016: EB5C                ; section. Then back to the user.
2017: EB5C                ;                   
2018: EB5C                SetStatusBDOS:      
2019: EB5C     323FE8     	STA		StatusBDOSReturn
2020: EB5F                fcReturn:           
2021: EB5F     C9         	RET                
2022: EB60                ;                   
2023: EB60                ;   Set the status to 1 (read or write error code).
2024: EB60                ;                   
2025: EB60                IOERR1:             
2026: EB60     3E01       	MVI	A,1            
2027: EB62     C35CEB     	JMP	SetStatusBDOS  
2028: EB65                ;                   
2029: EB65     00         OutPutFlag:	DB	0	;output flag (non zero means no output).
2030: EB66     02         CursorPositionStart:	DB	2	;starting position for cursor.
2031: EB67     00         CursorPosition:		DB	0	;cursor position (0=start of line).
2032: EB68     00         PrinterFlag:	DB	0	;printer flag (control-p toggle). List if non zero.
2033: EB69     00         CHARBUF:	DB	0	;single input character buffer.
2034: EB6A                ;                   
2035: EB6A                ;   Stack area for BDOS calls.
2036: EB6A                ;                   
2037: EB6A                                    
2038: EB6A                ;                   
2039: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2040: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2041: EB6A                ;BDOSstack	EQU	$	;end of stack area.
2042: EB6A                ;                   
2043: EB6A                ;                   
2044: EB6A                ;   Select error occured, jump to error routine.
2045: EB6A                ;                   
2046: EB6A                SLCTERR:            
2047: EB6A     21EEE8     	LXI		H,BADSLCT     
2048: EB6D                ;                   
2049: EB6D                ;   Jump to (HL) indirectly.
2050: EB6D                ;                   
2051: EB6D                JumpToHL:           
2052: EB6D     5E         	MOV		E,M           
2053: EB6E     23         	INX		H             
2054: EB6F     56         	MOV		D,M			;now (DE) contain the desired address.
2055: EB70     EB         	XCHG               
2056: EB71     E9         	PCHL               
2057: EB72                ;                   
2058: EB72                ;   Block move. (DE) to (HL), (C) bytes total.
2059: EB72                ;                   
2060: EB72                DEtoHL:             
2061: EB72     0C         	INR		C			; manage counter
2062: EB73                DEtoHL1:            
2063: EB73     0D         	DCR		C			; decrement counter
2064: EB74     C8         	RZ					; Return if done
2065: EB75                	                   
2066: EB75     1A         	LDAX	D			; move a byte.
2067: EB76     77         	MOV		M,A           
2068: EB77     13         	INX		D             
2069: EB78     23         	INX		H             
2070: EB79     C373EB     	JMP		DEtoHL1		;	and repeat.
2071: EB7C                ;                   
2072: EB7C                ;   Select the desired drive.
2073: EB7C                ; it will set up all the disk parameters blocks 
2074: EB7C                ;                   
2075: EB7C                SelectDisk:         
2076: EB7C     3AA2F5     	LDA		CurrentDrive		; get active disk.
2077: EB7F     4F         	MOV		C,A					; set up for Bios call, put disk in (C)
2078: EB80     CD1BF6     	CALL	biosSelectDisk		; call into BIOS to select it.
2079: EB83     7C         	MOV		A,H					; HL = 0000 if invalid
2080: EB84     B5         	ORA		L					; otherwise it points to the correct Disk Parameter Block
2081: EB85     C8         	RZ							; so, return if HL = 0000
2082: EB86                ;                   
2083: EB86                ;   Here, the BIOS returned the address of the parameter block
2084: EB86                ; in (HL). We will extract the necessary pointers and save them.
2085: EB86                ;                   
2086: EB86     5E         	MOV		E,M					; first word of DPB points to the drive's skew table
2087: EB87     23         	INX		H             
2088: EB88     56         	MOV		D,M					; Get it and put it into (DE)
2089: EB89     23         	INX		H             
2090: EB8A                						;save pointers to BDOS scratch areas
2091: EB8A     22ABF5     	SHLD	FilePosInDirSegment		; save Relative position for file		.
2092: EB8D     23         	INX		H             
2093: EB8E     23         	INX		H             
2094: EB8F     22ADF5     	SHLD	LastTrackNumber		; save last track referenced			
2095: EB92     23         	INX		H             
2096: EB93     23         	INX		H             
2097: EB94     22AFF5     	SHLD	LastSectorNumber	; save last sector referenced	
2098: EB97     23         	INX		H             
2099: EB98     23         	INX		H					; get directory buffer
2100: EB99     EB         	XCHG						; been holding the translation table address in DE, now in HL
2101: EB9A                								; Moved Directory buffer pointer into DE (from HL
2102: EB9A     22C8F5     	SHLD	XLATE				; save skew table address				
2103: EB9D     21B1F5     	LXI		H,DirBuffAddr			; get address of the directory buffer vector
2104: EBA0     0E08       	MVI		C,8					; they consist of the directory buffer
2105: EBA2     CD72EB     	CALL	DEtoHL				; pointer, parameter block pointer,check and allocation vectors.
2106: EBA5     2AB3F5     	LHLD	DiskParamBlock				;  * DISK PARAMTER BLOCK POINTER
2107: EBA8     EB         	XCHG						; put into DE
2108: EBA9     21B9F5     	LXI		H,SECTORS			; point at  Sectors per Block
2109: EBAC     0E0F       	MVI		C,15				; it is 15 bytes long. 
2110: EBAE     CD72EB     	CALL	DEtoHL				; move disk parameter block from BIOS to BDOS for current disk
2111: EBB1     2ABEF5     	LHLD	DiskSize			; check disk size.
2112: EBB4     7C         	MOV		A,H					; more than 256 blocks on this?
2113: EBB5     21D4F5     	LXI		H,SmallDisk			; should be called SmallDisk [ if SmallDisk =0 then > 256 block long])
2114: EBB8     36FF       	MVI		M,0FFH				; set to small.
2115: EBBA     B7         	ORA		A             
2116: EBBB     CAC0EB     	JZ		SelectDisk1    
2117: EBBE     3600       	MVI		M,0					; wrong, set to large.
2118: EBC0                SelectDisk1:        
2119: EBC0     3EFF       	MVI		A,0FFH				; clear the zero flag.
2120: EBC2     B7         	ORA		A             
2121: EBC3     C9         	RET                
2122: EBC4                ;                   
2123: EBC4                ;   Routine to home the disk track head and clear pointers.
2124: EBC4                ;                   
2125: EBC4                HomeDrive:          
2126: EBC4     CD18F6     	CALL	biosHomeDisk			; home the head.
2127: EBC7     AF         	XRA		A				; set accumulator to 00	
2128: EBC8     2AADF5     	LHLD	LastTrackNumber	; set track pointer to 00.
2129: EBCB     77         	MOV		M,A           
2130: EBCC     23         	INX		H             
2131: EBCD     77         	MOV		M,A           
2132: EBCE     2AAFF5     	LHLD	LastSectorNumber; set sector pointer to 00.
2133: EBD1     77         	MOV		M,A           
2134: EBD2     23         	INX		H             
2135: EBD3     77         	MOV		M,A           
2136: EBD4     C9         	RET                
2137: EBD5                ;                   
2138: EBD5                ;   Do the actual disk read and check the error return status.
2139: EBD5                ;                   
2140: EBD5                DOREAD:             
2141: EBD5     CD27F6     	CALL	biosReadDisk  
2142: EBD8     C3DEEB     	JMP	IORET          
2143: EBDB                ;                   
2144: EBDB                ;   Do the actual disk write and handle any bios error.
2145: EBDB                ;                   
2146: EBDB                DOWRITE:            
2147: EBDB     CD2AF6     	CALL	biosWriteDisk 
2148: EBDE                IORET:              
2149: EBDE     B7         	ORA	A              
2150: EBDF     C8         	RZ		;return unless an error occured.
2151: EBE0     21ECE8     	LXI	H,BADSCTR;bad read/write on this sector.
2152: EBE3     C36DEB     	JMP	JumpToHL       
2153: EBE6                ;                   
2154: EBE6                ;   Routine to select the track and sector that the desired
2155: EBE6                ; block number falls in.
2156: EBE6                ;                   
2157: EBE6                TrackSectorForDir:  
2158: EBE6     2AE1F5     	LHLD	FilePosInDirectory		; get position of last accessed file
2159: EBE9     0E02       	MVI		C,2						; there are 4 directory entries/Sector.
2160: EBEB     CD0DED     	CALL	HLrightC				; file-position/4 = sector #
2161: EBEE     22DCF5     	SHLD	BlockNumber				; save this as the block number of interest.
2162: EBF1     22E3F5     	SHLD	DirectoryRecord			; (what's it doing here?)
2163: EBF4                ;                   
2164: EBF4                ;   if the sector number has already been set (BlockNumber), enter
2165: EBF4                ; at this point.    
2166: EBF4                ;Save               
2167: EBF4                TrackSectorForBlock:
2168: EBF4                		;move Desired Block number into (BC).
2169: EBF4     21DCF5     	LXI		H,BlockNumber 
2170: EBF7     4E         	MOV		C,M				       
2171: EBF8     23         	INX		H             
2172: EBF9     46         	MOV		B,M           
2173: EBFA                		;move Last sector number into (DE).
2174: EBFA     2AAFF5     	LHLD	LastSectorNumber
2175: EBFD     5E         	MOV		E,M	          
2176: EBFE     23         	INX		H             
2177: EBFF     56         	MOV		D,M           
2178: EC00                		;move current track number into (HL).
2179: EC00     2AADF5     	LHLD	LastTrackNumber
2180: EC03     7E         	MOV		A,M           
2181: EC04     23         	INX		H             
2182: EC05     66         	MOV		H,M           
2183: EC06     6F         	MOV		L,A           
2184: EC07                	                   
2185: EC07                TrackSectorForBlock1:
2186: EC07     79         	MOV		A,C			;is desired sector before current one?
2187: EC08     93         	SUB		E             
2188: EC09     78         	MOV		A,B           
2189: EC0A     9A         	SBB		D             
2190: EC0B     D21DEC     	JNC		TrackSectorForBlock2
2191: EC0E     E5         	PUSH	H			;yes, decrement sectors by one track.
2192: EC0F     2AB9F5     	LHLD	SECTORS		;get sectors per track.
2193: EC12     7B         	MOV		A,E           
2194: EC13     95         	SUB		L             
2195: EC14     5F         	MOV		E,A           
2196: EC15     7A         	MOV		A,D           
2197: EC16     9C         	SBB		H             
2198: EC17     57         	MOV		D,A			;now we have backed up one full track.
2199: EC18     E1         	POP		H             
2200: EC19     2B         	DCX		H			;adjust track counter.
2201: EC1A     C307EC     	JMP		TrackSectorForBlock1
2202: EC1D                TrackSectorForBlock2:
2203: EC1D     E5         	PUSH	H			;desired sector is after current one.
2204: EC1E     2AB9F5     	LHLD	SECTORS		;get sectors per track.
2205: EC21     19         	DAD	D				;bump sector pointer to next track.
2206: EC22     DA32EC     	JC		TrackSectorForBlock3
2207: EC25     79         	MOV		A,C			;is desired sector now before current one?
2208: EC26     95         	SUB		L             
2209: EC27     78         	MOV		A,B           
2210: EC28     9C         	SBB		H             
2211: EC29     DA32EC     	JC		TrackSectorForBlock3
2212: EC2C     EB         	XCHG				;not yes, increment track counter
2213: EC2D     E1         	POP		H			;and continue until it is.
2214: EC2E     23         	INX		H             
2215: EC2F     C31DEC     	JMP		TrackSectorForBlock2
2216: EC32                ;                   
2217: EC32                ;   here we have determined the track number that contains the
2218: EC32                ; desired sector.   
2219: EC32                ;                   
2220: EC32                TrackSectorForBlock3:
2221: EC32     E1         	POP		H			;get track number (HL).
2222: EC33     C5         	PUSH	B             
2223: EC34     D5         	PUSH	D             
2224: EC35     E5         	PUSH	H             
2225: EC36     EB         	XCHG               
2226: EC37     2AC6F5     	LHLD	OFFSET		;adjust for first track offset.
2227: EC3A     19         	DAD		D             
2228: EC3B     44         	MOV		B,H           
2229: EC3C     4D         	MOV		C,L           
2230: EC3D     CD1EF6     	CALL	biosSetTrack		;select this track.
2231: EC40     D1         	POP		D			;reset current track pointer.
2232: EC41     2AADF5     	LHLD	LastTrackNumber
2233: EC44     73         	MOV		M,E           
2234: EC45     23         	INX		H             
2235: EC46     72         	MOV		M,D           
2236: EC47     D1         	POP		D             
2237: EC48     2AAFF5     	LHLD	LastSectorNumber	;reset the first sector on this track.
2238: EC4B     73         	MOV		M,E           
2239: EC4C     23         	INX		H             
2240: EC4D     72         	MOV		M,D           
2241: EC4E     C1         	POP		B             
2242: EC4F     79         	MOV		A,C			;now subtract the desired one.
2243: EC50     93         	SUB		E			;to make it relative (1-# sectors/track).
2244: EC51     4F         	MOV		C,A           
2245: EC52     78         	MOV		A,B           
2246: EC53     9A         	SBB		D             
2247: EC54     47         	MOV		B,A           
2248: EC55     2AC8F5     	LHLD	XLATE		;translate this sector according to this table.
2249: EC58     EB         	XCHG               
2250: EC59     CD30F6     	CALL	biosSectorTranslate		;let the bios translate it.
2251: EC5C     4D         	MOV		C,L           
2252: EC5D     44         	MOV		B,H           
2253: EC5E     C321F6     	JMP		biosSetSector		;and select it.
2254: EC61                ;                   
2255: EC61                ;   Compute block number from record number (SAVNREC) and
2256: EC61                ; extent number (SAVEXT).
2257: EC61                ;                   
2258: EC61                GETBLOCK:           
2259: EC61     21BBF5     	LXI	H,BLKSHFT;get logical to physical conversion.
2260: EC64     4E         	MOV	C,M	;note that this is base 2 log of ratio.
2261: EC65     3ADAF5     	LDA	SAVNREC	;get record number.
2262: EC68                GETBLK1:            
2263: EC68     B7         	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2264: EC69     1F         	RAR                
2265: EC6A     0D         	DCR	C              
2266: EC6B     C268EC     	JNZ	GETBLK1        
2267: EC6E     47         	MOV	B,A	;save result in (B).
2268: EC6F     3E08       	MVI	A,8            
2269: EC71     96         	SUB	M              
2270: EC72     4F         	MOV	C,A	;compute (C)=8-BLKSHFT.
2271: EC73     3AD9F5     	LDA	SAVEXT         
2272: EC76                GETBLK2:            
2273: EC76     0D         	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2274: EC77     CA7FEC     	JZ	GETBLK3         
2275: EC7A     B7         	ORA	A              
2276: EC7B     17         	RAL                
2277: EC7C     C376EC     	JMP	GETBLK2        
2278: EC7F                GETBLK3:            
2279: EC7F     80         	ADD	B              
2280: EC80     C9         	RET                
2281: EC81                ;                   
2282: EC81                ;   Routine to extract the (BC) block byte from the fcb pointed
2283: EC81                ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2284: EC81                ; block numbers, else they are 8 bit numbers.
2285: EC81                ; Number is returned in (HL).
2286: EC81                ;                   
2287: EC81                EXTBLK:             
2288: EC81     2A3CE8     	LHLD	ParamsDE	;get fcb address.
2289: EC84     111000     	LXI	D,16	;block numbers start 16 bytes into fcb.
2290: EC87     19         	DAD	D              
2291: EC88     09         	DAD	B              
2292: EC89     3AD4F5     	LDA	SmallDisk	;are we using a big-disk?
2293: EC8C     B7         	ORA	A              
2294: EC8D     CA94EC     	JZ	EXTBLK1         
2295: EC90     6E         	MOV	L,M	;no, extract an 8 bit number from the fcb.
2296: EC91     2600       	MVI	H,0            
2297: EC93     C9         	RET                
2298: EC94                EXTBLK1:            
2299: EC94     09         	DAD	B	;yes, extract a 16 bit number.
2300: EC95     5E         	MOV	E,M            
2301: EC96     23         	INX	H              
2302: EC97     56         	MOV	D,M            
2303: EC98     EB         	XCHG		;return in (HL).
2304: EC99     C9         	RET                
2305: EC9A                ;                   
2306: EC9A                ;   Compute block number.
2307: EC9A                ;                   
2308: EC9A                COMBLK:             
2309: EC9A     CD61EC     	CALL	GETBLOCK      
2310: EC9D     4F         	MOV	C,A            
2311: EC9E     0600       	MVI	B,0            
2312: ECA0     CD81EC     	CALL	EXTBLK        
2313: ECA3     22DCF5     	SHLD	BlockNumber   
2314: ECA6     C9         	RET                
2315: ECA7                ;                   
2316: ECA7                ;   Check for a zero block number (unused).
2317: ECA7                ;                   
2318: ECA7                CHKBLK:             
2319: ECA7     2ADCF5     	LHLD	BlockNumber   
2320: ECAA     7D         	MOV	A,L	;is it zero?
2321: ECAB     B4         	ORA	H              
2322: ECAC     C9         	RET                
2323: ECAD                ;                   
2324: ECAD                ;   Adjust physical block (BlockNumber) and convert to logical
2325: ECAD                ; sector (LOGSECT). This is the starting sector of this block.
2326: ECAD                ; The actual sector of interest is then added to this and the
2327: ECAD                ; resulting sector number is stored back in (BlockNumber). This
2328: ECAD                ; will still have to be adjusted for the track number.
2329: ECAD                ;                   
2330: ECAD                LOGICAL:            
2331: ECAD     3ABBF5     	LDA	BLKSHFT	;get log2(physical/logical sectors).
2332: ECB0     2ADCF5     	LHLD	BlockNumber	;get physical sector desired.
2333: ECB3                LOGICL1:            
2334: ECB3     29         	DAD	H	;compute logical sector number.
2335: ECB4     3D         	DCR	A	;note logical sectors are 128 bytes long.
2336: ECB5     C2B3EC     	JNZ	LOGICL1        
2337: ECB8     22DEF5     	SHLD	LOGSECT	;save logical sector.
2338: ECBB     3ABCF5     	LDA	BLKMASK	;get block mask.
2339: ECBE     4F         	MOV	C,A            
2340: ECBF     3ADAF5     	LDA	SAVNREC	;get next sector to access.
2341: ECC2     A1         	ANA	C	;extract the relative position within physical block.
2342: ECC3     B5         	ORA	L	;and add it too logical sector.
2343: ECC4     6F         	MOV	L,A            
2344: ECC5     22DCF5     	SHLD	BlockNumber	;and store.
2345: ECC8     C9         	RET                
2346: ECC9                ;                   
2347: ECC9                ;   Set (HL) to point to extent byte in fcb.
2348: ECC9                ;                   
2349: ECC9                SETEXT:             
2350: ECC9     2A3CE8     	LHLD	ParamsDE      
2351: ECCC     110C00     	LXI	D,12	;it is the twelth byte.
2352: ECCF     19         	DAD	D              
2353: ECD0     C9         	RET                
2354: ECD1                ;                   
2355: ECD1                ;   Set (HL) to point to record count byte in fcb and (DE) to
2356: ECD1                ; next record number byte.
2357: ECD1                ;                   
2358: ECD1                SETHLDE:            
2359: ECD1     2A3CE8     	LHLD	ParamsDE      
2360: ECD4     110F00     	LXI	D,15	;record count byte (#15).
2361: ECD7     19         	DAD	D              
2362: ECD8     EB         	XCHG               
2363: ECD9     211100     	LXI	H,17	;next record number (#32).
2364: ECDC     19         	DAD	D              
2365: ECDD     C9         	RET                
2366: ECDE                ;                   
2367: ECDE                ;   Save current file data from fcb.
2368: ECDE                ;                   
2369: ECDE                STRDATA:            
2370: ECDE     CDD1EC     	CALL	SETHLDE       
2371: ECE1     7E         	MOV	A,M	;get and store record count byte.
2372: ECE2     32DAF5     	STA	SAVNREC        
2373: ECE5     EB         	XCHG               
2374: ECE6     7E         	MOV	A,M	;get and store next record number byte.
2375: ECE7     32D8F5     	STA	SAVNXT         
2376: ECEA     CDC9EC     	CALL	SETEXT	;point to extent byte.
2377: ECED     3ABDF5     	LDA	EXTMASK	;get extent mask.
2378: ECF0     A6         	ANA	M              
2379: ECF1     32D9F5     	STA	SAVEXT	;and save extent here.
2380: ECF4     C9         	RET                
2381: ECF5                ;                   
2382: ECF5                ;   Set the next record to access. If (MODE) is set to 2, then
2383: ECF5                ; the last record byte (SAVNREC) has the correct number to access.
2384: ECF5                ; For sequential access, (MODE) will be equal to 1.
2385: ECF5                ;                   
2386: ECF5                SETNREC:            
2387: ECF5     CDD1EC     	CALL	SETHLDE       
2388: ECF8     3ACDF5     	LDA	MODE	;get sequential flag (=1).
2389: ECFB     FE02       	CPI	2	;a 2 indicates that no adder is needed.
2390: ECFD     C201ED     	JNZ	STNREC1        
2391: ED00     AF         	XRA	A	;clear adder (random access?).
2392: ED01                STNREC1:            
2393: ED01     4F         	MOV	C,A            
2394: ED02     3ADAF5     	LDA	SAVNREC	;get last record number.
2395: ED05     81         	ADD	C	;increment record count.
2396: ED06     77         	MOV	M,A	;and set fcb's next record byte.
2397: ED07     EB         	XCHG               
2398: ED08     3AD8F5     	LDA	SAVNXT	;get next record byte from storage.
2399: ED0B     77         	MOV	M,A	;and put this into fcb as number of records used.
2400: ED0C     C9         	RET                
2401: ED0D                ;                   
2402: ED0D                ;   Shift HL right (C) bits.
2403: ED0D                ;                   
2404: ED0D                HLrightC:           
2405: ED0D     0C         	INR		C			; minor adjustment
2406: ED0E                HLrightC1:          
2407: ED0E     0D         	DCR		C			; count down
2408: ED0F     C8         	RZ					; exit if done
2409: ED10     7C         	MOV		A,H			; get the hi byte
2410: ED11     B7         	ORA		A			; reset carry bit
2411: ED12     1F         	RAR					; rotate right thru carry
2412: ED13     67         	MOV		H,A			; return new hi byte
2413: ED14     7D         	MOV		A,L			; get lo byte
2414: ED15     1F         	RAR					; rotate right thru carry
2415: ED16     6F         	MOV		L,A			; return new lo byte
2416: ED17     C30EED     	JMP		HLrightC1		; keep doing it
2417: ED1A                ;                   
2418: ED1A                ;	Compute the check-sum for the directory buffer.
2419: ED1A                ;	Return integer sum in (A).
2420: ED1A                ;   add all values in the buffer ignoring carrys
2421: ED1A                ;                   
2422: ED1A                CheckSum:           
2423: ED1A     0E80       	MVI		C,DirBuffSize		; length of buffer.
2424: ED1C     2AB1F5     	LHLD	DirBuffAddr			; get its address.
2425: ED1F     AF         	XRA		A					; clear summation byte.
2426: ED20                CheckSum1:          
2427: ED20     86         	ADD		M					; compute running sum ignoring carries.
2428: ED21     23         	INX		H             
2429: ED22     0D         	DCR		C             
2430: ED23     C220ED     	JNZ		CheckSum1			; keep adding until all bytes have been added
2431: ED26     C9         	RET                
2432: ED27                                    
2433: ED27                ;                   
2434: ED27                ;   Extract the write protect status bit for the current drive.
2435: ED27                ; 	The result is returned in (A), bit 0.
2436: ED27                ;                   
2437: ED27                GetDiskROStatus:    
2438: ED27     2AA5F5     	LHLD	ROBitMap			;get Read Only Bit Map
2439: ED2A     3AA2F5     	LDA		CurrentDrive		;which drive is current?
2440: ED2D     4F         	MOV		C,A           
2441: ED2E     CD0DED     	CALL	HLrightC			;shift status such that bit 0 is the
2442: ED31     7D         	MOV		A,L					;one of interest for this drive.
2443: ED32     E601       	ANI		01H					;and isolate it.
2444: ED34     C9         	RET							; Zero if not write protected
2445: ED35                ;                   
2446: ED35                ;   Function to write protect the current disk.
2447: ED35                ;                   
2448: ED35                fcSetDiskRO:        
2449: ED35     21A5F5     	LXI	H,ROBitMap	;point to Read Only Bit Map
2450: ED38     4E         	MOV	C,M	;set (BC) equal to the status.
2451: ED39     23         	INX	H              
2452: ED3A     46         	MOV	B,M            
2453: ED3B     CD4BF4     	CALL	SetBit	;and set this bit according to current drive.
2454: ED3E     22A5F5     	SHLD	ROBitMap	;then save.
2455: ED41     2AC0F5     	LHLD	DrectorySize	;now save directory size limit.
2456: ED44     23         	INX	H	;remember the last one.
2457: ED45     EB         	XCHG               
2458: ED46     2AABF5     	LHLD	FilePosInDirSegment;and store it here.
2459: ED49     73         	MOV	M,E	;put low byte.
2460: ED4A     23         	INX	H              
2461: ED4B     72         	MOV	M,D	;then high byte.
2462: ED4C     C9         	RET                
2463: ED4D                ;                   
2464: ED4D                ;   Check for a read only file.
2465: ED4D                ;                   
2466: ED4D                CHKROFL:            
2467: ED4D     CD67ED     	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2468: ED50                CKROF1:             
2469: ED50     110900     	LXI	D,9	;look at bit 7 of the ninth byte.
2470: ED53     19         	DAD	D              
2471: ED54     7E         	MOV	A,M            
2472: ED55     17         	RAL                
2473: ED56     D0         	RNC		;return if ok.
2474: ED57     21F2E8     	LXI	H,ROFILE;else, print error message and terminate.
2475: ED5A     C36DEB     	JMP	JumpToHL       
2476: ED5D                ;                   
2477: ED5D                ;   Check the write protect status of the active disk.
2478: ED5D                ;                   
2479: ED5D                IsDiskRO:           
2480: ED5D     CD27ED     	CALL	GetDiskROStatus			; is it write protected ?
2481: ED60     C8         	RZ						; NO, return.
2482: ED61     21F0E8     	LXI		H,RODISK      
2483: ED64     C36DEB     	JMP	JumpToHL		; else print message and terminate.
2484: ED67                ;                   
2485: ED67                ;   Routine to set (HL) pointing to the proper entry in the
2486: ED67                ; directory buffer. 
2487: ED67                ;                   
2488: ED67                FCB2HL:             
2489: ED67     2AB1F5     	LHLD	DirBuffAddr		;get address of buffer.
2490: ED6A     3AE0F5     	LDA		FCBPosition		;relative position of file.
2491: ED6D                ;                   
2492: ED6D                ;   Routine to add (A) to (HL).
2493: ED6D                ;                   
2494: ED6D                ADDA2HL:            
2495: ED6D     85         	ADD		L             
2496: ED6E     6F         	MOV		L,A           
2497: ED6F     D0         	RNC	               
2498: ED70     24         	INR		H			;take care of any carry.
2499: ED71     C9         	RET                
2500: ED72                ;                   
2501: ED72                ;   Routine to get the 's2' byte(Extent Count) from the fcb supplied in
2502: ED72                ; the initial parameter specification.
2503: ED72                ;                   
2504: ED72                GetS2:              
2505: ED72     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
2506: ED75     110E00     	LXI		D,14		;relative position of 's2'.
2507: ED78     19         	DAD		D             
2508: ED79     7E         	MOV		A,M			;extract this byte.
2509: ED7A     C9         	RET                
2510: ED7B                ;                   
2511: ED7B                ;   Clear the 's2' byte in the fcb.
2512: ED7B                ;                   
2513: ED7B                ClearS2:            
2514: ED7B     CD72ED     	CALL	GetS2		;this sets (HL) pointing to it.
2515: ED7E     3600       	MVI		M,0			;now clear it.
2516: ED80     C9         	RET                
2517: ED81                ;                   
2518: ED81                ;   Set bit 7 in the 's2' byte of the fcb.
2519: ED81                ;                   
2520: ED81                SetBit7InS2:        
2521: ED81     CD72ED     	CALL	GetS2		;get the byte.
2522: ED84     F680       	ORI		80H			;and set bit 7.
2523: ED86     77         	MOV		M,A			;then store.
2524: ED87     C9         	RET                
2525: ED88                ;                   
2526: ED88                ;   Compare (FilePosInDirectory) with (FilePosInDirSegment) and set flags based on
2527: ED88                ; the difference. This checks to see if there are more file
2528: ED88                ; names in the directory. We are at (FilePosInDirectory) and there are
2529: ED88                ; (FilePosInDirSegment) of them to check.
2530: ED88                ;                   
2531: ED88                AnyMoreFiles:       
2532: ED88     2AE1F5     	LHLD	FilePosInDirectory			;we are here.
2533: ED8B     EB         	XCHG               
2534: ED8C     2AABF5     	LHLD	FilePosInDirSegment	;and don't go past here.
2535: ED8F     7B         	MOV		A,E				;compute difference but don't keep.
2536: ED90     96         	SUB		M             
2537: ED91     23         	INX		H             
2538: ED92     7A         	MOV		A,D           
2539: ED93     9E         	SBB		M				;set carry if no more names.
2540: ED94     C9         	RET                
2541: ED95                ;                   
2542: ED95                ;   Call this routine to prevent (FilePosInDirSegment) from being greater
2543: ED95                ; than (FilePosInDirectory).
2544: ED95                ;                   
2545: ED95                CHKNMBR:            
2546: ED95     CD88ED     	CALL	AnyMoreFiles		;FilePosInDirSegment too big?
2547: ED98     D8         	RC                 
2548: ED99     13         	INX		D		;yes, reset it to (FilePosInDirectory).
2549: ED9A     72         	MOV		M,D           
2550: ED9B     2B         	DCX		H             
2551: ED9C     73         	MOV		M,E           
2552: ED9D     C9         	RET                
2553: ED9E                ;                   
2554: ED9E                ;   Compute (HL)=(DE)-(HL)
2555: ED9E                ;                   
2556: ED9E                DEminusHL2HL:       
2557: ED9E     7B         	MOV		A,E		;compute difference.
2558: ED9F     95         	SUB		L             
2559: EDA0     6F         	MOV		L,A		;store low byte.
2560: EDA1     7A         	MOV		A,D           
2561: EDA2     9C         	SBB		H             
2562: EDA3     67         	MOV		H,A		;and then high byte.
2563: EDA4     C9         	RET                
2564: EDA5                ;                   
2565: EDA5                ;   Set the directory checksum byte.
2566: EDA5                ;                   
2567: EDA5                SETDIR:             
2568: EDA5     0EFF       	MVI	C,0FFH         
2569: EDA7                ;                   
2570: EDA7                ;   Routine to set or compare the directory checksum byte. If
2571: EDA7                ; (C)=0ffh, then this will set the checksum byte. Else the byte
2572: EDA7                ; will be checked. If the check fails (the disk has been changed),
2573: EDA7                ; then this disk will be write protected.
2574: EDA7                ;                   
2575: EDA7                CHECKDIR:           
2576: EDA7     2AE5F5     	LHLD	CheckSumTable 
2577: EDAA     EB         	XCHG               
2578: EDAB     2AC4F5     	LHLD	DirectoryFAT1 
2579: EDAE     CD9EED     	CALL	DEminusHL2HL  
2580: EDB1     D0         	RNC								; ok if (CheckSumTable) > (DirectoryFAT1), so return.
2581: EDB2     C5         	PUSH	B						; save set/check flag (c)
2582: EDB3     CD1AED     	CALL	CheckSum				;else compute checksum.
2583: EDB6     2AB5F5     	LHLD	CHKVECT	;get address of checksum table.
2584: EDB9     EB         	XCHG               
2585: EDBA     2AE5F5     	LHLD	CheckSumTable 
2586: EDBD     19         	DAD	D	;set (HL) to point to byte for this drive.
2587: EDBE     C1         	POP	B              
2588: EDBF     0C         	INR	C	;set or check ?
2589: EDC0     CACDED     	JZ	CHKDIR1         
2590: EDC3     BE         	CMP	M	;check them. 
2591: EDC4     C8         	RZ		;return if they are the same.
2592: EDC5     CD88ED     	CALL	AnyMoreFiles	;not the same, do we care?
2593: EDC8     D0         	RNC                
2594: EDC9     CD35ED     	CALL	fcSetDiskRO	;yes, mark this as write protected.
2595: EDCC     C9         	RET                
2596: EDCD                CHKDIR1:            
2597: EDCD     77         	MOV	M,A	;just set the byte.
2598: EDCE     C9         	RET                
2599: EDCF                ;                   
2600: EDCF                ;   Do a write to the directory of the current disk.
2601: EDCF                ;                   
2602: EDCF                DIRWRITE:           
2603: EDCF     CDA5ED     	CALL	SETDIR			;set checksum byte.
2604: EDD2     CDE9ED     	CALL	SetDirDMA		;set directory dma address.
2605: EDD5     0E01       	MVI		C,1				;tell the bios to actually write.
2606: EDD7     CDDBEB     	CALL	DOWRITE			;then do the write.
2607: EDDA     C3E3ED     	JMP		Set2UsersDMA  
2608: EDDD                ;                   
2609: EDDD                ;   Read from the directory.
2610: EDDD                ;                   
2611: EDDD                DIRREAD:            
2612: EDDD     CDE9ED     	CALL	SetDirDMA	;set the directory dma address.
2613: EDE0     CDD5EB     	CALL	DOREAD	;and read it.
2614: EDE3                ;                   
2615: EDE3                ;   Routine to set the dma address to the users choice.
2616: EDE3                ;                   
2617: EDE3                Set2UsersDMA:       
2618: EDE3     21A9F5     	LXI		H,UsersDMA		;reset the default dma address and return.
2619: EDE6     C3ECED     	JMP		SetDMA0       
2620: EDE9                ;                   
2621: EDE9                ;   Routine to set the dma address for directory work.
2622: EDE9                ;                   
2623: EDE9                SetDirDMA:          
2624: EDE9     21B1F5     	LXI		H,DirBuffAddr 
2625: EDEC                ;                   
2626: EDEC                ;   Set the dma address. On entry, (HL) points to
2627: EDEC                ; word containing the desired dma address.
2628: EDEC                ;                   
2629: EDEC                SetDMA0:            
2630: EDEC     4E         	MOV		C,M           
2631: EDED     23         	INX		H             
2632: EDEE     46         	MOV		B,M			;setup (BC) and go to the bios to set it.
2633: EDEF     C324F6     	JMP		biosSetDMA    
2634: EDF2                ;                   
2635: EDF2                ;   Move the directory buffer into user's dma space.
2636: EDF2                ;                   
2637: EDF2                MOVEDIR:            
2638: EDF2     2AB1F5     	LHLD	DirBuffAddr	;buffer is located here, and
2639: EDF5     EB         	XCHG               
2640: EDF6     2AA9F5     	LHLD	UsersDMA; put it here.
2641: EDF9     0E80       	MVI	C,DirBuffSize	;this is its length.
2642: EDFB     C372EB     	JMP	DEtoHL	;move it now and return.
2643: EDFE                ;                   
2644: EDFE                ;   Check (FilePosInDirectory) and set the zero flag if it equals 0ffffh.
2645: EDFE                ; if it is -1 then no active file found
2646: EDFE                ;                   
2647: EDFE                CheckFilePosition:	 
2648: EDFE     21E1F5     	LXI	H,FilePosInDirectory
2649: EE01     7E         	MOV	A,M            
2650: EE02     23         	INX	H              
2651: EE03     BE         	CMP	M	;are both bytes the same?
2652: EE04     C0         	RNZ                
2653: EE05     3C         	INR	A	;yes, but are they each 0ffh?
2654: EE06     C9         	RET                
2655: EE07                ;                   
2656: EE07                ;   Set location (FilePosInDirectory) to 0ffffh.
2657: EE07                ;                   
2658: EE07                InitializeFilePosition:
2659: EE07     21FFFF     	LXI		H,-1          
2660: EE0A     22E1F5     	SHLD	FilePosInDirectory
2661: EE0D     C9         	RET                
2662: EE0E                ;                   
2663: EE0E                ;   Move on to the next file position within the current
2664: EE0E                ; directory buffer. If no more exist, set pointer to 0ffffh
2665: EE0E                ; and the calling routine will check for this. Enter with (C)
2666: EE0E                ; equal to 0ffh to cause the checksum byte to be set, else we
2667: EE0E                ; will check this disk and set write protect if checksums are
2668: EE0E                ; not the same (applies only if another directory sector must
2669: EE0E                ; be read).         
2670: EE0E                ;                   
2671: EE0E                GetNextEntry:       
2672: EE0E     2AC0F5     	LHLD	DrectorySize				; get directory entry size limit.
2673: EE11     EB         	XCHG               
2674: EE12     2AE1F5     	LHLD	FilePosInDirectory			; get index into directory.
2675: EE15     23         	INX		H					        
2676: EE16     22E1F5     	SHLD	FilePosInDirectory			; save  the next location
2677: EE19     CD9EED     	CALL	DEminusHL2HL				; (HL)=(DrectorySize)-(FilePosInDirectory)
2678: EE1C     DA07EE     	JC		InitializeFilePosition		; If no more entries, set this flag and exit.
2679: EE1F                                    
2680: EE1F     3AE1F5     	LDA		FilePosInDirectory		; Get current index for file in the  directory.
2681: EE22     E603       	ANI		03H						; only look within this sector (only 4 entries fit).
2682: EE24                									; - so taking the mod of position in directory
2683: EE24                									;  - gives us the relative position in the sector
2684: EE24     87         	ADD		A						; a * 2  - each directory entry is 32 bytes long.
2685: EE25     87         	ADD		A						; a * 4 - so relative position * 32 gives us the 
2686: EE26     87         	ADD		A						; a * 8  - start of the directory entry for this
2687: EE27     87         	ADD		A						; a * 16 - file
2688: EE28     87         	ADD		A						; a * 32
2689: EE29                						; The value in A is: 0,32,64 or 96
2690: EE29     32E0F5     	STA		FCBPosition			; save it as position of fcb.
2691: EE2C     B7         	ORA		A             
2692: EE2D     C0         	RNZ							; return If Not a New Record ?????????
2693: EE2E     C5         	PUSH	B					; save C, checksum behavior flag
2694: EE2F     CDE6EB     	CALL	TrackSectorForDir		;we need the next directory sector.
2695: EE32     CDDDED     	CALL	DIRREAD       
2696: EE35     C1         	POP		B             
2697: EE36     C3A7ED     	JMP		CHECKDIR      
2698: EE39                ;                   
2699: EE39                ;   Routine to to get a bit from the disk space allocation
2700: EE39                ; map. It is returned in (A), bit position 0. On entry to here,
2701: EE39                ; set (BC) to the block number on the disk to check.
2702: EE39                ; On return, (D) will contain the original bit position for
2703: EE39                ; this block number and (HL) will point to the address for it.
2704: EE39                ; Bit is determined by Block Number Mod 8
2705: EE39                ; Byte is determined by Block Number / 8
2706: EE39                                    
2707: EE39                CKBITMAP:           
2708: EE39     79         	MOV		A,C			; Determine Bit  interest.
2709: EE3A     E607       	ANI		07H			; mod 8 
2710: EE3C     3C         	INR		A			; add 1? and save
2711: EE3D     5F         	MOV		E,A			; Save particular bit number.
2712: EE3E     57         	MOV		D,A			; save it again
2713: EE3F                ;                     
2714: EE3F                ;   compute (BC)=(BC)/8.
2715: EE3F                ;   to determin in which Allocation block the number resides
2716: EE3F                ;                   
2717: EE3F     79         	MOV		A,C			; get the block
2718: EE40     0F         	RRC					; now shift right 3 bits.
2719: EE41     0F         	RRC      	  		; to divide by 8
2720: EE42     0F         	RRC                
2721: EE43     E61F       	ANI		1FH			; and clear bits 7,6,5.
2722: EE45     4F         	MOV		C,A			; put result in c           
2723: EE46     78         	MOV		A,B			           
2724: EE47     87         	ADD		A			; now shift
2725: EE48     87         	ADD		A           ; hi byte's bits 0,1 & 2   
2726: EE49     87         	ADD		A           ; int bit positions 6,7, & 8  
2727: EE4A     87         	ADD		A           ; so we can put continue the   
2728: EE4B     87         	ADD		A           ; divide by 8 of the whole word  
2729: EE4C     B1         	ORA		C			; combile with (C)(bits 0,1,2,3 & 4).
2730: EE4D     4F         	MOV		C,A			; ok, (C), the low byte has been completed.
2731: EE4E     78         	MOV		A,B			; Now to finish with
2732: EE4F     0F         	RRC 	       		; the high order byte                
2733: EE50     0F         	RRC                
2734: EE51     0F         	RRC 	       		; divide by 8
2735: EE52     E61F       	ANI		1FH			; zero out bits 5,6 & 7           
2736: EE54     47         	MOV		B,A			;and now (B) is completed.
2737: EE55                ;                     
2738: EE55                ;   use this as an offset into the disk space allocation
2739: EE55                ; table.            
2740: EE55                ;                   
2741: EE55     2AB7F5     	LHLD	FATpointer    
2742: EE58     09         	DAD	B              
2743: EE59     7E         	MOV	A,M				; we now have correct byte.
2744: EE5A                CKBMAP1:            
2745: EE5A     07         	RLC		;get correct bit into position 0.
2746: EE5B     1D         	DCR	E              
2747: EE5C     C25AEE     	JNZ	CKBMAP1        
2748: EE5F     C9         	RET                
2749: EE60                ;                   
2750: EE60                ;   Set or clear the bit map such that block number (BC) will be marked
2751: EE60                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2752: EE60                ; 1 then it will be set (don't use anyother values).
2753: EE60                ;                   
2754: EE60                STBITMAP:           
2755: EE60                ;	PUSH	D				; Save Set/Clear indicator
2756: EE60     CD39EE     	CALL	CKBITMAP		; Get the byte of interest.
2757: EE63     E6FE       	ANI		0FEH			; clear the affected bit.
2758: EE65     4F         	MOV		C,A				; Save it in C
2759: EE66     3AA3F5     	LDA		BitSetFlag		; get the flag
2760: EE69     B1         	ORA		C				; and now set(01)/reset(01) acording to flag
2761: EE6A                ;	POP	B             
2762: EE6A                ;	ORA	C	;and now set it acording to (C).
2763: EE6A                ;                   
2764: EE6A                ;  entry to restore the original bit position and then store
2765: EE6A                ; in table. (A) contains the value, (D) contains the bit
2766: EE6A                ; position (1-8), and (HL) points to the address within the
2767: EE6A                ; space allocation table for this byte.
2768: EE6A                ;                   
2769: EE6A                STBMAP1:            
2770: EE6A     0F         	RRC		;restore original bit position.
2771: EE6B     15         	DCR	D              
2772: EE6C     C26AEE     	JNZ	STBMAP1        
2773: EE6F     77         	MOV	M,A	;and stor byte in table.
2774: EE70     C9         	RET                
2775: EE71                ;                   
2776: EE71                ;   Set/clear space used bits in allocation map for this file.
2777: EE71                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2778: EE71                ;                   
2779: EE71                SetClearFATbits:    
2780: EE71     CD67ED     	CALL	FCB2HL			; Get address of fcb
2781: EE74     111000     	LXI		D,16			; Offset to Block Pointers in Directory entry
2782: EE77     19         	DAD		D				; Compute start to block number bytes. (A1..A10)
2783: EE78                ;	PUSH	B				; Save Set/Clear indicator 
2784: EE78     0E11       	MVI		C,17			; Check all 16 bytes (max) of table.
2785: EE7A                SETFL1:             
2786: EE7A                ;	POP		D				; Retreive Set/Clear indicator
2787: EE7A     0D         	DCR		C				; Counter
2788: EE7B     C8         	RZ						; Done?, then return
2789: EE7C                	                   
2790: EE7C                ;	PUSH	D				; Save Set/Clear indicator
2791: EE7C     3AD4F5     	LDA		SmallDisk			; check disk size .
2792: EE7F     B7         	ORA		A             
2793: EE80     CA8BEE     	JZ		SETFL2			; If it is a big disk, use 16 bits
2794: EE83                	                   
2795: EE83     C5         	PUSH	B				; Only 8 bit numbers. Save counter.
2796: EE84     E5         	PUSH	H				; Save pointer to current Allocation byte
2797: EE85     4E         	MOV		C,M				; Get low byte from table, always
2798: EE86     0600       	MVI		B,0				; Set high byte to zero.
2799: EE88     C391EE     	JMP		SETFL3			; skip 16 bit number processing
2800: EE8B                	                   
2801: EE8B                SETFL2:             
2802: EE8B     0D         	DCR		C				; Adjust counter for 16 bit block numbers,.
2803: EE8C     C5         	PUSH	B				; Save Counter
2804: EE8D     4E         	MOV		C,M				; Now get both the low and high bytes.
2805: EE8E     23         	INX		H             
2806: EE8F     46         	MOV		B,M           
2807: EE90     E5         	PUSH	H				; Save pointer to current Allocation byte
2808: EE91                SETFL3:             
2809: EE91     79         	MOV		A,C				; Block used? if both (b) and (c) are 00
2810: EE92     B0         	ORA		B				; the block is NOT used
2811: EE93     CAA0EE     	JZ		SETFL4			; NOT used move on			
2812: EE96     2ABEF5     	LHLD	DiskSize		; Is this block number within the
2813: EE99     7D         	MOV		A,L	          
2814: EE9A     91         	SUB		C             
2815: EE9B     7C         	MOV		A,H           
2816: EE9C     98         	SBB		B             
2817: EE9D     D460EE     	CNC		STBITMAP		; Yes, set the proper bit.
2818: EEA0                SETFL4:             
2819: EEA0     E1         	POP	H					; Point to next block number in fcb.
2820: EEA1     23         	INX	H              
2821: EEA2     C1         	POP	B					; Retreive the counter
2822: EEA3     C37AEE     	JMP	SETFL1         
2823: EEA6                                    
2824: EEA6                ;                   
2825: EEA6                ;   Set the status (StatusBDOSReturn) and return.
2826: EEA6                ;                   
2827: EEA6                STSTATUS:           
2828: EEA6     3ACCF5     	LDA	FileFoundFlag  
2829: EEA9     C35CEB     	JMP	SetStatusBDOS  
2830: EEAC                ;                   
2831: EEAC                ;   Check extents in (A) and (C). Set the zero flag if they
2832: EEAC                ; are the same. The number of 16k chunks of disk space that
2833: EEAC                ; the directory extent covers is expressad is (EXTMASK+1).
2834: EEAC                ; No registers are modified.
2835: EEAC                ;                   
2836: EEAC                SAMEXT:             
2837: EEAC     C5         	PUSH	B             
2838: EEAD     F5         	PUSH	PSW           
2839: EEAE     3ABDF5     	LDA	EXTMASK	;get extent mask and use it to
2840: EEB1     2F         	CMA		;to compare both extent numbers.
2841: EEB2     47         	MOV	B,A	;save resulting mask here.
2842: EEB3     79         	MOV	A,C	;mask first extent and save in (C).
2843: EEB4     A0         	ANA	B              
2844: EEB5     4F         	MOV	C,A            
2845: EEB6     F1         	POP	PSW	;now mask second extent and compare
2846: EEB7     A0         	ANA	B	;with the first one.
2847: EEB8     91         	SUB	C              
2848: EEB9     E61F       	ANI	1FH	;(* only check buts 0-4 *)
2849: EEBB     C1         	POP	B	;the zero flag is set if they are the same.
2850: EEBC     C9         	RET		;restore (BC) and return.
2851: EEBD                ;                   
2852: EEBD                ;   Search for the first occurence of a file name. On entry,
2853: EEBD                ; register (C) should contain the number of bytes of the fcb
2854: EEBD                ; that must match.  
2855: EEBD                ;                   
2856: EEBD                FindFirst:          
2857: EEBD     3EFF       	MVI		A,0FFH        
2858: EEBF     32CCF5     	STA		FileFoundFlag		; set flag to: not match found
2859: EEC2     21CFF5     	LXI		H,CharCounter		; point at character counter.
2860: EEC5     71         	MOV		M,C					; put in number of bytes to match
2861: EEC6     2A3CE8     	LHLD	ParamsDE			; get filename to match.
2862: EEC9     22D0F5     	SHLD	SaveFCB				; and save.
2863: EECC     CD07EE     	CALL	InitializeFilePosition	; clear initial file position (set to 0ffffh).
2864: EECF     CDC4EB     	CALL	HomeDrive			;home the drive.
2865: EED2                ;                   
2866: EED2                ;   Entry to locate the next occurence of a filename within the
2867: EED2                ; directory. The disk is not expected to have been changed. If
2868: EED2                ; it was, then it will be write protected.
2869: EED2                ;                   
2870: EED2                FindNext:           
2871: EED2     0E00       	MVI		C,0					; write protect the disk if changed.
2872: EED4     CD0EEE     	CALL	GetNextEntry		; get next filename entry in directory.
2873: EED7     CDFEED     	CALL	CheckFilePosition	; is file position = 0ffffh?
2874: EEDA     CA39EF     	JZ		FindNext6			; yes, exit now then.
2875: EEDD     2AD0F5     	LHLD	SaveFCB				; get (DE) pointing to filename to match.
2876: EEE0     EB         	XCHG               
2877: EEE1     1A         	LDAX	D             
2878: EEE2     FEE5       	CPI		EmptyFileFlag		; is it an empty directory entry?
2879: EEE4     CAEFEE     	JZ		FindNext1			; yes - Skip it
2880: EEE7                						; No process it
2881: EEE7     D5         	PUSH	D					; Save  pointer to filename to match.	
2882: EEE8     CD88ED     	CALL	AnyMoreFiles		; more files in directory?
2883: EEEB     D1         	POP		D					; retreive  pointer to filename to match.	
2884: EEEC     D239EF     	JNC		FindNext6				; no more. Exit now.
2885: EEEF                FindNext1:          
2886: EEEF     CD67ED     	CALL	FCB2HL				; get address of this fcb in directory.
2887: EEF2     3ACFF5     	LDA		CharCounter			; get number of bytes (characters) to check.
2888: EEF5     4F         	MOV		C,A					; move to Acc
2889: EEF6     0600       	MVI		B,0					; initialize byte position counter.
2890: EEF8                FindNext2:          
2891: EEF8     79         	MOV		A,C					; get counter to reach
2892: EEF9     B7         	ORA		A             
2893: EEFA     CA28EF     	JZ		FindNext5			; Skip if all characters have been checked
2894: EEFD                	                   
2895: EEFD     1A         	LDAX	D					; check next byte.
2896: EEFE     FE3F       	CPI		QMARK				; '?'	;don't care about this character?
2897: EF00     CA21EF     	JZ		FindNext4      
2898: EF03                	                   
2899: EF03     78         	MOV		A,B					; get bytes position in fcb.
2900: EF04     FE0D       	CPI		13					; don't care about the thirteenth byte either.
2901: EF06     CA21EF     	JZ		FindNext4      
2902: EF09     FE0C       	CPI		12					; is it an extent byte?
2903: EF0B     1A         	LDAX	D					; get the next character
2904: EF0C     CA18EF     	JZ		FindNext3			; skip if extent
2905: EF0F     96         	SUB		M					; otherwise compare characters.
2906: EF10     E67F       	ANI		7FH           
2907: EF12     C2D2EE     	JNZ		FindNext			; not the same, check next entry.
2908: EF15     C321EF     	JMP	FindNext4	;so far so good, keep checking.
2909: EF18                FindNext3:          
2910: EF18     C5         	PUSH	B	;check the extent byte here.
2911: EF19     4E         	MOV	C,M            
2912: EF1A     CDACEE     	CALL	SAMEXT        
2913: EF1D     C1         	POP	B              
2914: EF1E     C2D2EE     	JNZ	FindNext	;not the same, look some more.
2915: EF21                ;                   
2916: EF21                ;   So far the names compare. Bump pointers to the next byte
2917: EF21                ; and continue until all (C) characters have been checked.
2918: EF21                ;                   
2919: EF21                FindNext4:          
2920: EF21     13         	INX	D	;bump pointers.
2921: EF22     23         	INX	H              
2922: EF23     04         	INR	B              
2923: EF24     0D         	DCR	C	;adjust character counter.
2924: EF25     C3F8EE     	JMP	FindNext2      
2925: EF28                FindNext5:          
2926: EF28     3AE1F5     	LDA	FilePosInDirectory	;return the position of this entry.
2927: EF2B     E603       	ANI	03H            
2928: EF2D     323FE8     	STA	StatusBDOSReturn
2929: EF30     21CCF5     	LXI	H,FileFoundFlag
2930: EF33     7E         	MOV	A,M            
2931: EF34     17         	RAL                
2932: EF35     D0         	RNC                
2933: EF36     AF         	XRA	A              
2934: EF37     77         	MOV	M,A            
2935: EF38     C9         	RET                
2936: EF39                ;                   
2937: EF39                ;   Filename was not found. Set appropriate status.
2938: EF39                ;                   
2939: EF39                FindNext6:          
2940: EF39     CD07EE     	CALL	InitializeFilePosition;set (FilePosInDirectory) to 0ffffh.
2941: EF3C     3EFF       	MVI	A,0FFH	;say not located.
2942: EF3E     C35CEB     	JMP	SetStatusBDOS  
2943: EF41                ;                   
2944: EF41                ;   Erase files from the directory. Only the first byte of the
2945: EF41                ; fcb will be affected. It is set to (E5).
2946: EF41                ;                   
2947: EF41                EraseFile:          
2948: EF41     CD5DED     	CALL	IsDiskRO		; if disk write is  protected exit via error message
2949: EF44     0E0C       	MVI		C,12			; only compare file names.
2950: EF46     CDBDEE     	CALL	FindFirst		; get first file name.
2951: EF49                ERAFIL1:            
2952: EF49     CDFEED     	CALL	CheckFilePosition	;any found?
2953: EF4C     C8         	RZ						; nope, we must be done.
2954: EF4D     CD4DED     	CALL	CHKROFL			; is file read only?
2955: EF50     CD67ED     	CALL	FCB2HL	;nope, get address of fcb and
2956: EF53     36E5       	MVI	M,EmptyFileFlag	;set first byte to 'empty'.
2957: EF55                ;	MVI	C,0	;clear the space from the bit map.
2958: EF55     3E00       	MVI		A,00H		; want to clear the bit
2959: EF57     32A3F5     	STA		BitSetFlag	; Flag = 00, clear bit
2960: EF5A     CD71EE     	CALL	SetClearFATbits
2961: EF5D     CDCFED     	CALL	DIRWRITE;now write the directory sector back out.
2962: EF60     CDD2EE     	CALL	FindNext	;find the next file name.
2963: EF63     C349EF     	JMP	ERAFIL1	;and repeat process.
2964: EF66                ;                   
2965: EF66                ;   Look through the space allocation map (bit map) for the
2966: EF66                ; next available block. Start searching at block number (BC-1).
2967: EF66                ; The search procedure is to look for an empty block that is
2968: EF66                ; before the starting block. If not empty, look at a later
2969: EF66                ; block number. In this way, we return the closest empty block
2970: EF66                ; on either side of the 'target' block number. This will speed
2971: EF66                ; access on random devices. For serial devices, this should be
2972: EF66                ; changed to look in the forward direction first and then start
2973: EF66                ; at the front and search some more.
2974: EF66                ;                   
2975: EF66                ;   On return, (DE)= block number that is empty and (HL) =0
2976: EF66                ; if no empry block was found.
2977: EF66                ;                   
2978: EF66                FNDSPACE:           
2979: EF66     50         	MOV	D,B	;set (DE) as the block that is checked.
2980: EF67     59         	MOV	E,C            
2981: EF68                ;                   
2982: EF68                ;   Look before target block. Registers (BC) are used as the lower
2983: EF68                ; pointer and (DE) as the upper pointer.
2984: EF68                ;                   
2985: EF68                FNDSPA1:            
2986: EF68     79         	MOV	A,C	;is block 0 specified?
2987: EF69     B0         	ORA	B              
2988: EF6A     CA79EF     	JZ	FNDSPA2         
2989: EF6D     0B         	DCX	B	;nope, check previous block.
2990: EF6E     D5         	PUSH	D             
2991: EF6F     C5         	PUSH	B             
2992: EF70     CD39EE     	CALL	CKBITMAP      
2993: EF73     1F         	RAR		;is this block empty?
2994: EF74     D294EF     	JNC	FNDSPA3	;yes. use this.
2995: EF77                ;                   
2996: EF77                ;   Note that the above logic gets the first block that it finds
2997: EF77                ; that is empty. Thus a file could be written 'backward' making
2998: EF77                ; it very slow to access. This could be changed to look for the
2999: EF77                ; first empty block and then continue until the start of this
3000: EF77                ; empty space is located and then used that starting block.
3001: EF77                ; This should help speed up access to some files especially on
3002: EF77                ; a well used disk with lots of fairly small 'holes'.
3003: EF77                ;                   
3004: EF77     C1         	POP	B	;nope, check some more.
3005: EF78     D1         	POP	D              
3006: EF79                ;                   
3007: EF79                ;   Now look after target block.
3008: EF79                ;                   
3009: EF79                FNDSPA2:            
3010: EF79     2ABEF5     	LHLD	DiskSize	;is block (DE) within disk limits?
3011: EF7C     7B         	MOV	A,E            
3012: EF7D     95         	SUB	L              
3013: EF7E     7A         	MOV	A,D            
3014: EF7F     9C         	SBB	H              
3015: EF80     D29CEF     	JNC	FNDSPA4        
3016: EF83     13         	INX	D	;yes, move on to next one.
3017: EF84     C5         	PUSH	B             
3018: EF85     D5         	PUSH	D             
3019: EF86     42         	MOV	B,D            
3020: EF87     4B         	MOV	C,E            
3021: EF88     CD39EE     	CALL	CKBITMAP;check it.
3022: EF8B     1F         	RAR		;empty?       
3023: EF8C     D294EF     	JNC	FNDSPA3        
3024: EF8F     D1         	POP	D	;nope, continue searching.
3025: EF90     C1         	POP	B              
3026: EF91     C368EF     	JMP	FNDSPA1        
3027: EF94                ;                   
3028: EF94                ;   Empty block found. Set it as used and return with (HL)
3029: EF94                ; pointing to it (true?).
3030: EF94                ;                   
3031: EF94                FNDSPA3:            
3032: EF94     17         	RAL		;reset byte.  
3033: EF95     3C         	INR	A	;and set bit 0.
3034: EF96     CD6AEE     	CALL	STBMAP1	;update bit map.
3035: EF99     E1         	POP	H	;set return registers.
3036: EF9A     D1         	POP	D              
3037: EF9B     C9         	RET                
3038: EF9C                ;                   
3039: EF9C                ;   Free block was not found. If (BC) is not zero, then we have
3040: EF9C                ; not checked all of the disk space.
3041: EF9C                ;                   
3042: EF9C                FNDSPA4:            
3043: EF9C     79         	MOV	A,C            
3044: EF9D     B0         	ORA	B              
3045: EF9E     C268EF     	JNZ	FNDSPA1        
3046: EFA1     210000     	LXI	H,0	;set 'not found' status.
3047: EFA4     C9         	RET                
3048: EFA5                ;                   
3049: EFA5                ;   Move a complete fcb entry into the directory and write it.
3050: EFA5                ;                   
3051: EFA5                FCBSET:             
3052: EFA5     0E00       	MVI	C,0            
3053: EFA7     1E20       	MVI	E,32	;length of each entry.
3054: EFA9                ;                   
3055: EFA9                ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3056: EFA9                ; fcb in directory starting at relative byte (C). This updated
3057: EFA9                ; directory buffer is then written to the disk.
3058: EFA9                ;                   
3059: EFA9                UPDATE:             
3060: EFA9     D5         	PUSH	D             
3061: EFAA     0600       	MVI	B,0	;set (BC) to relative byte position.
3062: EFAC     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3063: EFAF     09         	DAD	B	;compute starting byte.
3064: EFB0     EB         	XCHG               
3065: EFB1     CD67ED     	CALL	FCB2HL	;get address of fcb to update in directory.
3066: EFB4     C1         	POP	B	;set (C) to number of bytes to change.
3067: EFB5     CD72EB     	CALL	DEtoHL        
3068: EFB8                UPDATE1:            
3069: EFB8     CDE6EB     	CALL	TrackSectorForDir	;determine the track and sector affected.
3070: EFBB     C3CFED     	JMP	DIRWRITE	;then write this sector out.
3071: EFBE                ;                   
3072: EFBE                ;   Routine to change the name of all files on the disk with a
3073: EFBE                ; specified name. The fcb contains the current name as the
3074: EFBE                ; first 12 characters and the new name 16 bytes into the fcb.
3075: EFBE                ;                   
3076: EFBE                CHGNAMES:           
3077: EFBE     CD5DED     	CALL	IsDiskRO	;check for a write protected disk.
3078: EFC1     0E0C       	MVI	C,12	;match first 12 bytes of fcb only.
3079: EFC3     CDBDEE     	CALL	FindFirst	;get first name.
3080: EFC6     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3081: EFC9     7E         	MOV	A,M	;get user number.
3082: EFCA     111000     	LXI	D,16	;move over to desired name.
3083: EFCD     19         	DAD	D              
3084: EFCE     77         	MOV	M,A	;keep same user number.
3085: EFCF                CHGNAM1:            
3086: EFCF     CDFEED     	CALL	CheckFilePosition;any matching file found?
3087: EFD2     C8         	RZ		;no, we must be done.
3088: EFD3     CD4DED     	CALL	CHKROFL	;check for read only file.
3089: EFD6     0E10       	MVI	C,16	;start 16 bytes into fcb.
3090: EFD8     1E0C       	MVI	E,12	;and update the first 12 bytes of directory.
3091: EFDA     CDA9EF     	CALL	UPDATE        
3092: EFDD     CDD2EE     	CALL	FindNext	;get te next file name.
3093: EFE0     C3CFEF     	JMP	CHGNAM1	;and continue.
3094: EFE3                ;                   
3095: EFE3                ;   Update a files attributes. The procedure is to search for
3096: EFE3                ; every file with the same name as shown in fcb (ignoring bit 7)
3097: EFE3                ; and then to update it (which includes bit 7). No other changes
3098: EFE3                ; are made.         
3099: EFE3                ;                   
3100: EFE3                SAVEATTR:           
3101: EFE3     0E0C       	MVI	C,12	;match first 12 bytes.
3102: EFE5     CDBDEE     	CALL	FindFirst	;look for first filename.
3103: EFE8                SAVATR1:            
3104: EFE8     CDFEED     	CALL	CheckFilePosition;was one found?
3105: EFEB     C8         	RZ		;nope, we must be done.
3106: EFEC     0E00       	MVI	C,0	;yes, update the first 12 bytes now.
3107: EFEE     1E0C       	MVI	E,12           
3108: EFF0     CDA9EF     	CALL	UPDATE	;update filename and write directory.
3109: EFF3     CDD2EE     	CALL	FindNext	;and get the next file.
3110: EFF6     C3E8EF     	JMP	SAVATR1	;then continue until done.
3111: EFF9                ;                   
3112: EFF9                ;  Open a file (name specified in fcb).
3113: EFF9                ;                   
3114: EFF9                OPENIT:             
3115: EFF9     0E0F       	MVI	C,15	;compare the first 15 bytes.
3116: EFFB     CDBDEE     	CALL	FindFirst	;get the first one in directory.
3117: EFFE     CDFEED     	CALL	CheckFilePosition;any at all?
3118: F001     C8         	RZ                 
3119: F002                OPENIT1:            
3120: F002     CDC9EC     	CALL	SETEXT	;point to extent byte within users fcb.
3121: F005     7E         	MOV	A,M	;and get it.
3122: F006     F5         	PUSH	PSW	;save it and address.
3123: F007     E5         	PUSH	H             
3124: F008     CD67ED     	CALL	FCB2HL	;point to fcb in directory.
3125: F00B     EB         	XCHG               
3126: F00C     2A3CE8     	LHLD	ParamsDE	;this is the users copy.
3127: F00F     0E20       	MVI	C,32	;move it into users space.
3128: F011     D5         	PUSH	D             
3129: F012     CD72EB     	CALL	DEtoHL        
3130: F015     CD81ED     	CALL	SetBit7InS2	;set bit 7 in 's2' byte (unmodified).
3131: F018     D1         	POP	D	;now get the extent byte from this fcb.
3132: F019     210C00     	LXI	H,12           
3133: F01C     19         	DAD	D              
3134: F01D     4E         	MOV	C,M	;into (C). 
3135: F01E     210F00     	LXI	H,15	;now get the record count byte into (B).
3136: F021     19         	DAD	D              
3137: F022     46         	MOV	B,M            
3138: F023     E1         	POP	H	;keep the same extent as the user had originally.
3139: F024     F1         	POP	PSW            
3140: F025     77         	MOV	M,A            
3141: F026     79         	MOV	A,C	;is it the same as in the directory fcb?
3142: F027     BE         	CMP	M              
3143: F028     78         	MOV	A,B	;if yes, then use the same record count.
3144: F029     CA33F0     	JZ	OPENIT2         
3145: F02C     3E00       	MVI	A,0	;if the user specified an extent greater than
3146: F02E     DA33F0     	JC	OPENIT2	;the one in the directory, then set record count to 0.
3147: F031     3E80       	MVI	A,DirBuffSize	;otherwise set to maximum.
3148: F033                OPENIT2:            
3149: F033     2A3CE8     	LHLD	ParamsDE	;set record count in users fcb to (A).
3150: F036     110F00     	LXI	D,15           
3151: F039     19         	DAD	D	;compute relative position.
3152: F03A     77         	MOV	M,A	;and set the record count.
3153: F03B     C9         	RET                
3154: F03C                ;                   
3155: F03C                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3156: F03C                ; point to a zero value (16 bit).
3157: F03C                ;   Return with zero flag set it (DE) was moved. Registers (DE)
3158: F03C                ; and (HL) are not changed. However (A) is.
3159: F03C                ;                   
3160: F03C                MOVEWORD:           
3161: F03C     7E         	MOV	A,M	;check for a zero word.
3162: F03D     23         	INX	H              
3163: F03E     B6         	ORA	M	;both bytes zero?
3164: F03F     2B         	DCX	H              
3165: F040     C0         	RNZ		;nope, just return.
3166: F041     1A         	LDAX	D	;yes, move two bytes from (DE) into
3167: F042     77         	MOV	M,A	;this zero space.
3168: F043     13         	INX	D              
3169: F044     23         	INX	H              
3170: F045     1A         	LDAX	D             
3171: F046     77         	MOV	M,A            
3172: F047     1B         	DCX	D	;don't disturb these registers.
3173: F048     2B         	DCX	H              
3174: F049     C9         	RET                
3175: F04A                ;                   
3176: F04A                ;   Get here to close a file specified by (fcb).
3177: F04A                ;                   
3178: F04A                CLOSEIT:            
3179: F04A     AF         	XRA	A	;clear status and file position bytes.
3180: F04B     323FE8     	STA	StatusBDOSReturn
3181: F04E     32E1F5     	STA	FilePosInDirectory
3182: F051     32E2F5     	STA	FilePosInDirectory+1
3183: F054     CD27ED     	CALL	GetDiskROStatus	;get write protect bit for this drive.
3184: F057     C0         	RNZ		;just return if it is set.
3185: F058     CD72ED     	CALL	GetS2	;else get the 's2' byte.
3186: F05B     E680       	ANI	80H	;and look at bit 7 (file unmodified?).
3187: F05D     C0         	RNZ		;just return if set.
3188: F05E     0E0F       	MVI	C,15	;else look up this file in directory.
3189: F060     CDBDEE     	CALL	FindFirst     
3190: F063     CDFEED     	CALL	CheckFilePosition;was it found?
3191: F066     C8         	RZ		;just return if not.
3192: F067     011000     	LXI	B,16	;set (HL) pointing to records used section.
3193: F06A     CD67ED     	CALL	FCB2HL        
3194: F06D     09         	DAD	B              
3195: F06E     EB         	XCHG               
3196: F06F     2A3CE8     	LHLD	ParamsDE	;do the same for users specified fcb.
3197: F072     09         	DAD	B              
3198: F073     0E10       	MVI	C,16	;this many bytes are present in this extent.
3199: F075                CLOSEIT1:           
3200: F075     3AD4F5     	LDA	SmallDisk	;8 or 16 bit record numbers?
3201: F078     B7         	ORA	A              
3202: F079     CA90F0     	JZ	CLOSEIT4        
3203: F07C     7E         	MOV	A,M	;just 8 bit. Get one from users fcb.
3204: F07D     B7         	ORA	A              
3205: F07E     1A         	LDAX	D	;now get one from directory fcb.
3206: F07F     C283F0     	JNZ	CLOSEIT2       
3207: F082     77         	MOV	M,A	;users byte was zero. Update from directory.
3208: F083                CLOSEIT2:           
3209: F083     B7         	ORA	A              
3210: F084     C289F0     	JNZ	CLOSEIT3       
3211: F087     7E         	MOV	A,M	;directories byte was zero, update from users fcb.
3212: F088     12         	STAX	D             
3213: F089                CLOSEIT3:           
3214: F089     BE         	CMP	M	;if neither one of these bytes were zero,
3215: F08A     C2C7F0     	JNZ	CLOSEIT7	;then close error if they are not the same.
3216: F08D     C3A5F0     	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3217: F090                CLOSEIT4:           
3218: F090     CD3CF0     	CALL	MOVEWORD;update users fcb if it is zero.
3219: F093     EB         	XCHG               
3220: F094     CD3CF0     	CALL	MOVEWORD;update directories fcb if it is zero.
3221: F097     EB         	XCHG               
3222: F098     1A         	LDAX	D	;if these two values are no different,
3223: F099     BE         	CMP	M	;then a close error occured.
3224: F09A     C2C7F0     	JNZ	CLOSEIT7       
3225: F09D     13         	INX	D	;check second byte.
3226: F09E     23         	INX	H              
3227: F09F     1A         	LDAX	D             
3228: F0A0     BE         	CMP	M              
3229: F0A1     C2C7F0     	JNZ	CLOSEIT7       
3230: F0A4     0D         	DCR	C	;remember 16 bit values.
3231: F0A5                CLOSEIT5:           
3232: F0A5     13         	INX	D	;bump to next item in table.
3233: F0A6     23         	INX	H              
3234: F0A7     0D         	DCR	C	;there are 16 entries only.
3235: F0A8     C275F0     	JNZ	CLOSEIT1;continue if more to do.
3236: F0AB     01ECFF     	LXI	B,0FFECH;backup 20 places (extent byte).
3237: F0AE     09         	DAD	B              
3238: F0AF     EB         	XCHG               
3239: F0B0     09         	DAD	B              
3240: F0B1     1A         	LDAX	D             
3241: F0B2     BE         	CMP	M	;directory's extent already greater than the
3242: F0B3     DABFF0     	JC	CLOSEIT6	;users extent?
3243: F0B6     77         	MOV	M,A	;no, update directory extent.
3244: F0B7     010300     	LXI	B,3	;and update the record count byte in
3245: F0BA     09         	DAD	B	;directories fcb.
3246: F0BB     EB         	XCHG               
3247: F0BC     09         	DAD	B              
3248: F0BD     7E         	MOV	A,M	;get from user.
3249: F0BE     12         	STAX	D	;and put in directory.
3250: F0BF                CLOSEIT6:           
3251: F0BF     3EFF       	MVI	A,0FFH	;set 'was open and is now closed' byte.
3252: F0C1     32CAF5     	STA	CLOSEFLG       
3253: F0C4     C3B8EF     	JMP	UPDATE1	;update the directory now.
3254: F0C7                CLOSEIT7:           
3255: F0C7     213FE8     	LXI	H,StatusBDOSReturn;set return status and then return.
3256: F0CA     35         	DCR	M              
3257: F0CB     C9         	RET                
3258: F0CC                ;                   
3259: F0CC                ;   Routine to get the next empty space in the directory. It
3260: F0CC                ; will then be cleared for use.
3261: F0CC                ;                   
3262: F0CC                GetEmptyDirSlot:    
3263: F0CC     CD5DED     	CALL	IsDiskRO	;make sure disk is not write protected.
3264: F0CF     2A3CE8     	LHLD	ParamsDE	;save current parameters (fcb).
3265: F0D2     E5         	PUSH	H             
3266: F0D3     21A4F5     	LXI		H,EmptyDir	;use special one for empty space.
3267: F0D6     223CE8     	SHLD	ParamsDE      
3268: F0D9     0E01       	MVI	C,1	;search for first empty spot in directory.
3269: F0DB     CDBDEE     	CALL	FindFirst	;(* only check first byte *)
3270: F0DE     CDFEED     	CALL	CheckFilePosition;none?
3271: F0E1     E1         	POP	H              
3272: F0E2     223CE8     	SHLD	ParamsDE	;restore original fcb address.
3273: F0E5     C8         	RZ		;return if no more space.
3274: F0E6     EB         	XCHG               
3275: F0E7     210F00     	LXI	H,15	;point to number of records for this file.
3276: F0EA     19         	DAD	D              
3277: F0EB     0E11       	MVI	C,17	;and clear all of this space.
3278: F0ED     AF         	XRA	A              
3279: F0EE                GETMT1:             
3280: F0EE     77         	MOV	M,A            
3281: F0EF     23         	INX	H              
3282: F0F0     0D         	DCR	C              
3283: F0F1     C2EEF0     	JNZ	GETMT1         
3284: F0F4     210D00     	LXI	H,13	;clear the 's1' byte also.
3285: F0F7     19         	DAD	D              
3286: F0F8     77         	MOV	M,A            
3287: F0F9     CD95ED     	CALL	CHKNMBR	;keep (FilePosInDirSegment) within bounds.
3288: F0FC     CDA5EF     	CALL	FCBSET	;write out this fcb entry to directory.
3289: F0FF     C381ED     	JMP	SetBit7InS2	;set 's2' byte bit 7 (unmodified at present).
3290: F102                ;                   
3291: F102                ;   Routine to close the current extent and open the next one
3292: F102                ; for reading.      
3293: F102                ;                   
3294: F102                GETNEXT:            
3295: F102     AF         	XRA	A              
3296: F103     32CAF5     	STA	CLOSEFLG;clear close flag.
3297: F106     CD4AF0     	CALL	CLOSEIT	;close this extent.
3298: F109     CDFEED     	CALL	CheckFilePosition
3299: F10C     C8         	RZ		;not there???  
3300: F10D     2A3CE8     	LHLD	ParamsDE	;get extent byte.
3301: F110     010C00     	LXI	B,12           
3302: F113     09         	DAD	B              
3303: F114     7E         	MOV	A,M	;and increment it.
3304: F115     3C         	INR	A              
3305: F116     E61F       	ANI	1FH	;keep within range 0-31.
3306: F118     77         	MOV	M,A            
3307: F119     CA2BF1     	JZ	GTNEXT1	;overflow?
3308: F11C     47         	MOV	B,A	;mask extent byte.
3309: F11D     3ABDF5     	LDA	EXTMASK        
3310: F120     A0         	ANA	B              
3311: F121     21CAF5     	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3312: F124     A6         	ANA	M              
3313: F125     CA36F1     	JZ	GTNEXT2	;if zero, we must read in next extent.
3314: F128     C354F1     	JMP	GTNEXT3	;else, it is already in memory.
3315: F12B                GTNEXT1:            
3316: F12B     010200     	LXI	B,2	;Point to the 's2' byte.
3317: F12E     09         	DAD	B              
3318: F12F     34         	INR	M	;and bump it.
3319: F130     7E         	MOV	A,M	;too many extents?
3320: F131     E60F       	ANI	0FH            
3321: F133     CA5EF1     	JZ	GTNEXT5	;yes, set error code.
3322: F136                ;                   
3323: F136                ;   Get here to open the next extent.
3324: F136                ;                   
3325: F136                GTNEXT2:            
3326: F136     0E0F       	MVI	C,15	;set to check first 15 bytes of fcb.
3327: F138     CDBDEE     	CALL	FindFirst	;find the first one.
3328: F13B     CDFEED     	CALL	CheckFilePosition;none available?
3329: F13E     C254F1     	JNZ	GTNEXT3        
3330: F141     3ACBF5     	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3331: F144     3C         	INR	A	;0ffh means reading (so not possible).
3332: F145     CA5EF1     	JZ	GTNEXT5	;or an error.
3333: F148     CDCCF0     	CALL	GetEmptyDirSlot;we are writing, get an empty entry.
3334: F14B     CDFEED     	CALL	CheckFilePosition;none?
3335: F14E     CA5EF1     	JZ	GTNEXT5	;error if true.
3336: F151     C357F1     	JMP	GTNEXT4	;else we are almost done.
3337: F154                GTNEXT3:            
3338: F154     CD02F0     	CALL	OPENIT1	;open this extent.
3339: F157                GTNEXT4:            
3340: F157     CDDEEC     	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3341: F15A     AF         	XRA	A	;clear status and return.
3342: F15B     C35CEB     	JMP	SetStatusBDOS  
3343: F15E                ;                   
3344: F15E                ;   Error in extending the file. Too many extents were needed
3345: F15E                ; or not enough space on the disk.
3346: F15E                ;                   
3347: F15E                GTNEXT5:            
3348: F15E     CD60EB     	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3349: F161     C381ED     	JMP	SetBit7InS2	;so this is not written on a close.
3350: F164                ;                   
3351: F164                ;   Read a sequential file.
3352: F164                ;                   
3353: F164                RDSEQ:              
3354: F164     3E01       	MVI	A,1	;set sequential access mode.
3355: F166     32CDF5     	STA	MODE           
3356: F169                RDSEQ1:             
3357: F169     3EFF       	MVI	A,0FFH	;don't allow reading unwritten space.
3358: F16B     32CBF5     	STA	RDWRTFLG       
3359: F16E     CDDEEC     	CALL	STRDATA	;put rec# and ext# into fcb.
3360: F171     3ADAF5     	LDA	SAVNREC	;get next record to read.
3361: F174     21D8F5     	LXI	H,SAVNXT;get number of records in extent.
3362: F177     BE         	CMP	M	;within this extent?
3363: F178     DA8EF1     	JC	RDSEQ2          
3364: F17B     FE80       	CPI	LogicalSecSize	;no. Is this extent fully used?
3365: F17D     C2A3F1     	JNZ	RDSEQ3	;no. End-of-file.
3366: F180     CD02F1     	CALL	GETNEXT	;yes, open the next one.
3367: F183     AF         	XRA	A	;reset next record to read.
3368: F184     32DAF5     	STA	SAVNREC        
3369: F187     3A3FE8     	LDA	StatusBDOSReturn	;check on open, successful?
3370: F18A     B7         	ORA	A              
3371: F18B     C2A3F1     	JNZ	RDSEQ3	;no, error.
3372: F18E                RDSEQ2:             
3373: F18E     CD9AEC     	CALL	COMBLK	;ok. compute block number to read.
3374: F191     CDA7EC     	CALL	CHKBLK	;check it. Within bounds?
3375: F194     CAA3F1     	JZ	RDSEQ3	;no, error.
3376: F197     CDADEC     	CALL	LOGICAL	;convert (BlockNumber) to logical sector (128 byte).
3377: F19A     CDF4EB     	CALL	TrackSectorForBlock	;set the track and sector for this block #.
3378: F19D     CDD5EB     	CALL	DOREAD	;and read it.
3379: F1A0     C3F5EC     	JMP	SETNREC	;and set the next record to be accessed.
3380: F1A3                ;                   
3381: F1A3                ;   Read error occured. Set status and return.
3382: F1A3                ;                   
3383: F1A3                RDSEQ3:             
3384: F1A3     C360EB     	JMP	IOERR1         
3385: F1A6                ;                   
3386: F1A6                ;   Write the next sequential record.
3387: F1A6                ;                   
3388: F1A6                WTSEQ:              
3389: F1A6     3E01       	MVI	A,1	;set sequential access mode.
3390: F1A8     32CDF5     	STA	MODE           
3391: F1AB                WTSEQ1:             
3392: F1AB     3E00       	MVI	A,0	;allow an addition empty extent to be opened.
3393: F1AD     32CBF5     	STA	RDWRTFLG       
3394: F1B0     CD5DED     	CALL	IsDiskRO	;check write protect status.
3395: F1B3     2A3CE8     	LHLD	ParamsDE      
3396: F1B6     CD50ED     	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3397: F1B9     CDDEEC     	CALL	STRDATA	;put updated data into fcb.
3398: F1BC     3ADAF5     	LDA	SAVNREC	;get record number to write.
3399: F1BF     FE80       	CPI	LogicalSecSize	;within range?
3400: F1C1     D260EB     	JNC	IOERR1	;no, error(?).
3401: F1C4     CD9AEC     	CALL	COMBLK	;compute block number.
3402: F1C7     CDA7EC     	CALL	CHKBLK	;check number.
3403: F1CA     0E00       	MVI	C,0	;is there one to write to?
3404: F1CC     C216F2     	JNZ	WTSEQ6	;yes, go do it.
3405: F1CF     CD61EC     	CALL	GETBLOCK;get next block number within fcb to use.
3406: F1D2     32CEF5     	STA	RELBLOCK;and save.
3407: F1D5     010000     	LXI	B,0	;start looking for space from the start
3408: F1D8     B7         	ORA	A	;if none allocated as yet.
3409: F1D9     CAE3F1     	JZ	WTSEQ2          
3410: F1DC     4F         	MOV	C,A	;extract previous block number from fcb
3411: F1DD     0B         	DCX	B	;so we can be closest to it.
3412: F1DE     CD81EC     	CALL	EXTBLK        
3413: F1E1     44         	MOV	B,H            
3414: F1E2     4D         	MOV	C,L            
3415: F1E3                WTSEQ2:             
3416: F1E3     CD66EF     	CALL	FNDSPACE;find the next empty block nearest number (BC).
3417: F1E6     7D         	MOV	A,L	;check for a zero number.
3418: F1E7     B4         	ORA	H              
3419: F1E8     C2F0F1     	JNZ	WTSEQ3         
3420: F1EB     3E02       	MVI	A,2	;no more space?
3421: F1ED     C35CEB     	JMP	SetStatusBDOS  
3422: F1F0                WTSEQ3:             
3423: F1F0     22DCF5     	SHLD	BlockNumber	;save block number to access.
3424: F1F3     EB         	XCHG		;put block number into (DE).
3425: F1F4     2A3CE8     	LHLD	ParamsDE	;now we must update the fcb for this
3426: F1F7     011000     	LXI	B,16	;newly allocated block.
3427: F1FA     09         	DAD	B              
3428: F1FB     3AD4F5     	LDA	SmallDisk	;8 or 16 bit block numbers?
3429: F1FE     B7         	ORA	A              
3430: F1FF     3ACEF5     	LDA	RELBLOCK	;(* update this entry *)
3431: F202     CA0CF2     	JZ	WTSEQ4	;zero means 16 bit ones.
3432: F205     CD6DED     	CALL	ADDA2HL	;(HL)=(HL)+(A)
3433: F208     73         	MOV	M,E	;store new block number.
3434: F209     C314F2     	JMP	WTSEQ5         
3435: F20C                WTSEQ4:             
3436: F20C     4F         	MOV	C,A	;compute spot in this 16 bit table.
3437: F20D     0600       	MVI	B,0            
3438: F20F     09         	DAD	B              
3439: F210     09         	DAD	B              
3440: F211     73         	MOV	M,E	;stuff block number (DE) there.
3441: F212     23         	INX	H              
3442: F213     72         	MOV	M,D            
3443: F214                WTSEQ5:             
3444: F214     0E02       	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3445: F216                WTSEQ6:             
3446: F216     3A3FE8     	LDA	StatusBDOSReturn	;are we ok so far?
3447: F219     B7         	ORA	A              
3448: F21A     C0         	RNZ                
3449: F21B     C5         	PUSH	B	;yes, save write flag for bios (register C).
3450: F21C     CDADEC     	CALL	LOGICAL	;convert (BlockNumber) over to loical sectors.
3451: F21F     3ACDF5     	LDA	MODE	;get access mode flag (1=sequential,
3452: F222     3D         	DCR	A	;0=random, 2=special?).
3453: F223     3D         	DCR	A              
3454: F224     C263F2     	JNZ	WTSEQ9         
3455: F227                ;                   
3456: F227                ;   Special random i/o from function #40. Maybe for M/PM, but the
3457: F227                ; current block, if it has not been written to, will be zeroed
3458: F227                ; out and then written (reason?).
3459: F227                ;                   
3460: F227     C1         	POP	B              
3461: F228     C5         	PUSH	B             
3462: F229     79         	MOV	A,C	;get write status flag (2=writing unused space).
3463: F22A     3D         	DCR	A              
3464: F22B     3D         	DCR	A              
3465: F22C     C263F2     	JNZ	WTSEQ9         
3466: F22F     E5         	PUSH	H             
3467: F230     2AB1F5     	LHLD	DirBuffAddr	;zero out the directory buffer.
3468: F233     57         	MOV	D,A	;note that (A) is zero here.
3469: F234                WTSEQ7:             
3470: F234     77         	MOV	M,A            
3471: F235     23         	INX	H              
3472: F236     14         	INR	D	;do 128 bytes.
3473: F237     F234F2     	JP	WTSEQ7          
3474: F23A     CDE9ED     	CALL	SetDirDMA	;tell the bios the dma address for directory access.
3475: F23D     2ADEF5     	LHLD	LOGSECT	;get sector that starts current block.
3476: F240     0E02       	MVI	C,2	;set 'writing to unused space' flag.
3477: F242                WTSEQ8:             
3478: F242     22DCF5     	SHLD	BlockNumber	;save sector to write.
3479: F245     C5         	PUSH	B             
3480: F246     CDF4EB     	CALL	TrackSectorForBlock	;determine its track and sector numbers.
3481: F249     C1         	POP	B              
3482: F24A     CDDBEB     	CALL	DOWRITE	;now write out 128 bytes of zeros.
3483: F24D     2ADCF5     	LHLD	BlockNumber	;get sector number.
3484: F250     0E00       	MVI	C,0	;set normal write flag.
3485: F252     3ABCF5     	LDA	BLKMASK	;determine if we have written the entire
3486: F255     47         	MOV	B,A	;physical block.
3487: F256     A5         	ANA	L              
3488: F257     B8         	CMP	B              
3489: F258     23         	INX	H	;prepare for the next one.
3490: F259     C242F2     	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3491: F25C     E1         	POP	H	;reset next sector number.
3492: F25D     22DCF5     	SHLD	BlockNumber   
3493: F260     CDE3ED     	CALL	Set2UsersDMA	;and reset dma address.
3494: F263                ;                   
3495: F263                ;   Normal disk write. Set the desired track and sector then
3496: F263                ; do the actual write.
3497: F263                ;                   
3498: F263                WTSEQ9:             
3499: F263     CDF4EB     	CALL	TrackSectorForBlock	;determine track and sector for this write.
3500: F266     C1         	POP	B	;get write status flag.
3501: F267     C5         	PUSH	B             
3502: F268     CDDBEB     	CALL	DOWRITE	;and write this out.
3503: F26B     C1         	POP	B              
3504: F26C     3ADAF5     	LDA	SAVNREC	;get number of records in file.
3505: F26F     21D8F5     	LXI	H,SAVNXT;get last record written.
3506: F272     BE         	CMP	M              
3507: F273     DA7AF2     	JC	WTSEQ10         
3508: F276     77         	MOV	M,A	;we have to update record count.
3509: F277     34         	INR	M              
3510: F278     0E02       	MVI	C,2            
3511: F27A                ;                   
3512: F27A                ;*   This area has been patched to correct disk update problem
3513: F27A                ;* when using blocking and de-blocking in the BIOS.
3514: F27A                ;                   
3515: F27A                WTSEQ10:            
3516: F27A     00         	NOP		;was 'dcr c'  
3517: F27B     00         	NOP		;was 'dcr c'  
3518: F27C     210000     	LXI	H,0	;was 'jnz wtseq99'
3519: F27F                ;                   
3520: F27F                ; *   End of patch. 
3521: F27F                ;                   
3522: F27F     F5         	PUSH	PSW           
3523: F280     CD72ED     	CALL	GetS2	;set 'extent written to' flag.
3524: F283     E67F       	ANI	7FH	;(* clear bit 7 *)
3525: F285     77         	MOV	M,A            
3526: F286     F1         	POP	PSW	;get record count for this extent.
3527: F287                WTSEQ99:            
3528: F287     FE7F       	CPI	127	;is it full?
3529: F289     C2A8F2     	JNZ	WTSEQ12        
3530: F28C     3ACDF5     	LDA	MODE	;yes, are we in sequential mode?
3531: F28F     FE01       	CPI	1              
3532: F291     C2A8F2     	JNZ	WTSEQ12        
3533: F294     CDF5EC     	CALL	SETNREC	;yes, set next record number.
3534: F297     CD02F1     	CALL	GETNEXT	;and get next empty space in directory.
3535: F29A     213FE8     	LXI	H,StatusBDOSReturn;ok?
3536: F29D     7E         	MOV	A,M            
3537: F29E     B7         	ORA	A              
3538: F29F     C2A6F2     	JNZ	WTSEQ11        
3539: F2A2     3D         	DCR	A	;yes, set record count to -1.
3540: F2A3     32DAF5     	STA	SAVNREC        
3541: F2A6                WTSEQ11:            
3542: F2A6     3600       	MVI	M,0	;clear status.
3543: F2A8                WTSEQ12:            
3544: F2A8     C3F5EC     	JMP	SETNREC	;set next record to access.
3545: F2AB                ;                   
3546: F2AB                ;   For random i/o, set the fcb for the desired record number
3547: F2AB                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3548: F2AB                ; used as follows:  
3549: F2AB                ;                   
3550: F2AB                ;       fcb+35            fcb+34            fcb+33
3551: F2AB                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3552: F2AB                ;  |7             0 | 7             0 | 7             0|
3553: F2AB                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3554: F2AB                ;  |    overflow   | | extra |  extent   |   record #  |
3555: F2AB                ;  | ______________| |_extent|__number___|_____________|
3556: F2AB                ;                     also 's2'
3557: F2AB                ;                   
3558: F2AB                ;   On entry, register (C) contains 0ffh if this is a read
3559: F2AB                ; and thus we can not access unwritten disk space. Otherwise,
3560: F2AB                ; another extent will be opened (for writing) if required.
3561: F2AB                ;                   
3562: F2AB                POSITION:           
3563: F2AB     AF         	XRA	A	;set random i/o flag.
3564: F2AC     32CDF5     	STA	MODE           
3565: F2AF                ;                   
3566: F2AF                ;   Special entry (function #40). M/PM ?
3567: F2AF                ;                   
3568: F2AF                POSITN1:            
3569: F2AF     C5         	PUSH	B	;save read/write flag.
3570: F2B0     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3571: F2B3     EB         	XCHG               
3572: F2B4     212100     	LXI	H,33	;now get byte 'r0'.
3573: F2B7     19         	DAD	D              
3574: F2B8     7E         	MOV	A,M            
3575: F2B9     E67F       	ANI	7FH	;keep bits 0-6 for the record number to access.
3576: F2BB     F5         	PUSH	PSW           
3577: F2BC     7E         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3578: F2BD     17         	RAL                
3579: F2BE     23         	INX	H              
3580: F2BF     7E         	MOV	A,M            
3581: F2C0     17         	RAL                
3582: F2C1     E61F       	ANI	1FH	;and save this in bits 0-4 of (C).
3583: F2C3     4F         	MOV	C,A	;this is the extent byte.
3584: F2C4     7E         	MOV	A,M	;now get the extra extent byte.
3585: F2C5     1F         	RAR                
3586: F2C6     1F         	RAR                
3587: F2C7     1F         	RAR                
3588: F2C8     1F         	RAR                
3589: F2C9     E60F       	ANI	0FH            
3590: F2CB     47         	MOV	B,A	;and save it in (B).
3591: F2CC     F1         	POP	PSW	;get record number back to (A).
3592: F2CD     23         	INX	H	;check overflow byte 'r2'.
3593: F2CE     6E         	MOV	L,M            
3594: F2CF     2C         	INR	L              
3595: F2D0     2D         	DCR	L              
3596: F2D1     2E06       	MVI	L,6	;prepare for error.
3597: F2D3     C233F3     	JNZ	POSITN5	;out of disk space error.
3598: F2D6     212000     	LXI	H,32	;store record number into fcb.
3599: F2D9     19         	DAD	D              
3600: F2DA     77         	MOV	M,A            
3601: F2DB     210C00     	LXI	H,12	;and now check the extent byte.
3602: F2DE     19         	DAD	D              
3603: F2DF     79         	MOV	A,C            
3604: F2E0     96         	SUB	M	;same extent as before?
3605: F2E1     C2EFF2     	JNZ	POSITN2        
3606: F2E4     210E00     	LXI	H,14	;yes, check extra extent byte 's2' also.
3607: F2E7     19         	DAD	D              
3608: F2E8     78         	MOV	A,B            
3609: F2E9     96         	SUB	M              
3610: F2EA     E67F       	ANI	7FH            
3611: F2EC     CA27F3     	JZ	POSITN3;same, we are almost done then.
3612: F2EF                ;                   
3613: F2EF                ;  Get here when another extent is required.
3614: F2EF                ;                   
3615: F2EF                POSITN2:            
3616: F2EF     C5         	PUSH	B             
3617: F2F0     D5         	PUSH	D             
3618: F2F1     CD4AF0     	CALL	CLOSEIT	;close current extent.
3619: F2F4     D1         	POP	D              
3620: F2F5     C1         	POP	B              
3621: F2F6     2E03       	MVI	L,3	;prepare for error.
3622: F2F8     3A3FE8     	LDA	StatusBDOSReturn
3623: F2FB     3C         	INR	A              
3624: F2FC     CA2CF3     	JZ	POSITN4	;close error.
3625: F2FF     210C00     	LXI	H,12	;put desired extent into fcb now.
3626: F302     19         	DAD	D              
3627: F303     71         	MOV	M,C            
3628: F304     210E00     	LXI	H,14	;and store extra extent byte 's2'.
3629: F307     19         	DAD	D              
3630: F308     70         	MOV	M,B            
3631: F309     CDF9EF     	CALL	OPENIT	;try and get this extent.
3632: F30C     3A3FE8     	LDA	StatusBDOSReturn	;was it there?
3633: F30F     3C         	INR	A              
3634: F310     C227F3     	JNZ	POSITN3        
3635: F313     C1         	POP	B	;no. can we create a new one (writing?).
3636: F314     C5         	PUSH	B             
3637: F315     2E04       	MVI	L,4	;prepare for error.
3638: F317     0C         	INR	C              
3639: F318     CA2CF3     	JZ	POSITN4	;nope, reading unwritten space error.
3640: F31B     CDCCF0     	CALL	GetEmptyDirSlot;yes we can, try to find space.
3641: F31E     2E05       	MVI	L,5	;prepare for error.
3642: F320     3A3FE8     	LDA	StatusBDOSReturn
3643: F323     3C         	INR	A              
3644: F324     CA2CF3     	JZ	POSITN4	;out of space?
3645: F327                ;                   
3646: F327                ;   Normal return location. Clear error code and return.
3647: F327                ;                   
3648: F327                POSITN3:            
3649: F327     C1         	POP	B	;restore stack.
3650: F328     AF         	XRA	A	;and clear error code byte.
3651: F329     C35CEB     	JMP	SetStatusBDOS  
3652: F32C                ;                   
3653: F32C                ;   Error. Set the 's2' byte to indicate this (why?).
3654: F32C                ;                   
3655: F32C                POSITN4:            
3656: F32C     E5         	PUSH	H             
3657: F32D     CD72ED     	CALL	GetS2         
3658: F330     36C0       	MVI	M,0C0H         
3659: F332     E1         	POP	H              
3660: F333                ;                   
3661: F333                ;   Return with error code (presently in L).
3662: F333                ;                   
3663: F333                POSITN5:            
3664: F333     C1         	POP	B              
3665: F334     7D         	MOV	A,L	;get error code.
3666: F335     323FE8     	STA	StatusBDOSReturn
3667: F338     C381ED     	JMP	SetBit7InS2    
3668: F33B                ;                   
3669: F33B                ;   Read a random record.
3670: F33B                ;                   
3671: F33B                READRAN:            
3672: F33B     0EFF       	MVI	C,0FFH	;set 'read' status.
3673: F33D     CDABF2     	CALL	POSITION;position the file to proper record.
3674: F340     CC69F1     	CZ	RDSEQ1	;and read it as usual (if no errors).
3675: F343     C9         	RET                
3676: F344                ;                   
3677: F344                ;   Write to a random record.
3678: F344                ;                   
3679: F344                WRITERAN:           
3680: F344     0E00       	MVI	C,0	;set 'writing' flag.
3681: F346     CDABF2     	CALL	POSITION;position the file to proper record.
3682: F349     CCABF1     	CZ	WTSEQ1	;and write as usual (if no errors).
3683: F34C     C9         	RET                
3684: F34D                ;                   
3685: F34D                ;   Compute the random record number. Enter with (HL) pointing
3686: F34D                ; to a fcb an (DE) contains a relative location of a record
3687: F34D                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3688: F34D                ; byte, and (A) the 'r2' byte.
3689: F34D                ;                   
3690: F34D                ;   On return, the zero flag is set if the record is within
3691: F34D                ; bounds. Otherwise, an overflow occured.
3692: F34D                ;                   
3693: F34D                COMPRAND:           
3694: F34D     EB         	XCHG		;save fcb pointer in (DE).
3695: F34E     19         	DAD	D	;compute relative position of record #.
3696: F34F     4E         	MOV	C,M	;get record number into (BC).
3697: F350     0600       	MVI	B,0            
3698: F352     210C00     	LXI	H,12	;now get extent.
3699: F355     19         	DAD	D              
3700: F356     7E         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3701: F357     0F         	RRC		;move lower bit into bit 7.
3702: F358     E680       	ANI	80H	;and ignore all other bits.
3703: F35A     81         	ADD	C	;add to our record number.
3704: F35B     4F         	MOV	C,A            
3705: F35C     3E00       	MVI	A,0	;take care of any carry.
3706: F35E     88         	ADC	B              
3707: F35F     47         	MOV	B,A            
3708: F360     7E         	MOV	A,M	;now get the upper bits of extent into
3709: F361     0F         	RRC		;bit positions 0-3.
3710: F362     E60F       	ANI	0FH	;and ignore all others.
3711: F364     80         	ADD	B	;add this in to 'r1' byte.
3712: F365     47         	MOV	B,A            
3713: F366     210E00     	LXI	H,14	;get the 's2' byte (extra extent).
3714: F369     19         	DAD	D              
3715: F36A     7E         	MOV	A,M            
3716: F36B     87         	ADD	A	;and shift it left 4 bits (bits 4-7).
3717: F36C     87         	ADD	A              
3718: F36D     87         	ADD	A              
3719: F36E     87         	ADD	A              
3720: F36F     F5         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3721: F370     80         	ADD	B	;now add extra extent into 'r1'.
3722: F371     47         	MOV	B,A            
3723: F372     F5         	PUSH	PSW	;and save carry (overflow byte 'r2').
3724: F373     E1         	POP	H	;bit 0 of (L) is the overflow indicator.
3725: F374     7D         	MOV	A,L            
3726: F375     E1         	POP	H	;and same for first carry flag.
3727: F376     B5         	ORA	L	;either one of these set?
3728: F377     E601       	ANI	01H	;only check the carry flags.
3729: F379     C9         	RET                
3730: F37A                ;                   
3731: F37A                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3732: F37A                ; reflect the last record used for a random (or other) file.
3733: F37A                ; This reads the directory and looks at all extents computing
3734: F37A                ; the largerst record number for each and keeping the maximum
3735: F37A                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3736: F37A                ; maximum record number. This is used to compute the space used
3737: F37A                ; by a random file. 
3738: F37A                ;                   
3739: F37A                RANSIZE:            
3740: F37A     0E0C       	MVI	C,12	;look thru directory for first entry with
3741: F37C     CDBDEE     	CALL	FindFirst	;this name.
3742: F37F     2A3CE8     	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3743: F382     112100     	LXI	D,33           
3744: F385     19         	DAD	D              
3745: F386     E5         	PUSH	H             
3746: F387     72         	MOV	M,D	;note that (D)=0.
3747: F388     23         	INX	H              
3748: F389     72         	MOV	M,D            
3749: F38A     23         	INX	H              
3750: F38B     72         	MOV	M,D            
3751: F38C                RANSIZ1:            
3752: F38C     CDFEED     	CALL	CheckFilePosition;is there an extent to process?
3753: F38F     CAB4F3     	JZ	RANSIZ3	;no, we are done.
3754: F392     CD67ED     	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3755: F395     110F00     	LXI	D,15	;point to last record in extent.
3756: F398     CD4DF3     	CALL	COMPRAND;and compute random parameters.
3757: F39B     E1         	POP	H              
3758: F39C     E5         	PUSH	H	;now check these values against those
3759: F39D     5F         	MOV	E,A	;already in fcb.
3760: F39E     79         	MOV	A,C	;the carry flag will be set if those
3761: F39F     96         	SUB	M	;in the fcb represent a larger size than
3762: F3A0     23         	INX	H	;this extent does.
3763: F3A1     78         	MOV	A,B            
3764: F3A2     9E         	SBB	M              
3765: F3A3     23         	INX	H              
3766: F3A4     7B         	MOV	A,E            
3767: F3A5     9E         	SBB	M              
3768: F3A6     DAAEF3     	JC	RANSIZ2         
3769: F3A9     73         	MOV	M,E	;we found a larger (in size) extent.
3770: F3AA     2B         	DCX	H	;stuff these values into fcb.
3771: F3AB     70         	MOV	M,B            
3772: F3AC     2B         	DCX	H              
3773: F3AD     71         	MOV	M,C            
3774: F3AE                RANSIZ2:            
3775: F3AE     CDD2EE     	CALL	FindNext	;now get the next extent.
3776: F3B1     C38CF3     	JMP	RANSIZ1	;continue til all done.
3777: F3B4                RANSIZ3:            
3778: F3B4     E1         	POP	H	;we are done, restore the stack and
3779: F3B5     C9         	RET		;return.      
3780: F3B6                ;                   
3781: F3B6                ;   Function to return the random record position of a given
3782: F3B6                ; file which has been read in sequential mode up to now.
3783: F3B6                ;                   
3784: F3B6                fcSetRecordNumber:  
3785: F3B6     2A3CE8     	LHLD	ParamsDE	;point to fcb.
3786: F3B9     112000     	LXI	D,32	;and to last used record.
3787: F3BC     CD4DF3     	CALL	COMPRAND;compute random position.
3788: F3BF     212100     	LXI	H,33	;now stuff these values into fcb.
3789: F3C2     19         	DAD	D              
3790: F3C3     71         	MOV	M,C	;move 'r0'.
3791: F3C4     23         	INX	H              
3792: F3C5     70         	MOV	M,B	;and 'r1'. 
3793: F3C6     23         	INX	H              
3794: F3C7     77         	MOV	M,A	;and lastly 'r2'.
3795: F3C8     C9         	RET                
3796: F3C9                ;                   
3797: F3C9                ; This routine selects the drive specified in (CurrentDrive) and
3798: F3C9                ; updates the login vector and bitmap table if this drive was
3799: F3C9                ; not already active.
3800: F3C9                ;                   
3801: F3C9                LoginDrive:         
3802: F3C9     3AA2F5     	LDA		CurrentDrive		; get the Current Drive.
3803: F3CC     4F         	MOV		C,A					; Save current drive for later
3804: F3CD     2AA7F5     	LHLD	LoggedBitMap		; point at the "logged In" Bitmap.
3805: F3D0     CD0DED     	CALL	HLrightC			; Return with CurrentDrive's bit in L's lsb (byte 0)
3806: F3D3     E5         	PUSH	H					; Save it, so we will know if it is already active
3807: F3D4     EB         	XCHG               
3808: F3D5     CD7CEB     	CALL	SelectDisk			; select this drive to set up Disk Parameter Block.
3809: F3D8     CA6AEB     	JZ		SLCTERR				; If not valid then error exit outta here
3810: F3DB     E1         	POP	H						; retreive original state of the drive
3811: F3DC     7D         	MOV	A,L						; and put it into (A) 
3812: F3DD     1F         	RAR							; move bit 0 into the carry flag if it is set		
3813: F3DE     D8         	RC							; then return, because this drive has already been activated
3814: F3DF                				;Else  update the logged Bitmap to reflect this drive.
3815: F3DF     2AA7F5     	LHLD	LoggedBitMap		
3816: F3E2     4D         	MOV		C,L           
3817: F3E3     44         	MOV		B,H					; put the map into (BC)
3818: F3E4     CD4BF4     	CALL	SetBit				; Set it in the LoggedBitMap
3819: F3E7     22A7F5     	SHLD	LoggedBitMap		; and save the Bit map.
3820: F3EA                ;	JMP	BITMAP	;now update the bitmap.
3821: F3EA                ;-----------------------------------------------------------
3822: F3EA                ;                   
3823: F3EA                ;   Construct the FAT for the active
3824: F3EA                ; drive. If a file name starts with '$' and it is under the
3825: F3EA                ; current user number, then (StatusBDOSReturn) is set to minus 1. Otherwise
3826: F3EA                ; it is not set at all.
3827: F3EA                ;                   
3828: F3EA                BITMAP:             
3829: F3EA                								; compute size of allocation table. 1 bit for block,
3830: F3EA                								; 1 byte for 8 blocks, so size of FAT is:
3831: F3EA                								; DiskSize/8.
3832: F3EA     2ABEF5     	LHLD		DiskSize		; get maximum  Allocation Block number
3833: F3ED     0E03       	MVI			C,3				; 2 raised to 3rd power = 8
3834: F3EF     CD0DED     	CALL		HLrightC		;(HL)=(HL)/8.
3835: F3F2     23         	INX			H				;at lease 1 byte.
3836: F3F3     44         	MOV			B,H          
3837: F3F4     4D         	MOV			C,L				;set (BC) to the allocation table length.
3838: F3F5                ;                   
3839: F3F5                ;   Initialize the bitmap for this drive. Right now, the first
3840: F3F5                ; two bytes are specified by the disk parameter block. However
3841: F3F5                ; a patch could be entered here if it were necessary to setup
3842: F3F5                ; this table in a special mannor. For example, the bios could
3843: F3F5                ; determine locations of 'bad blocks' and set them as already
3844: F3F5                ; 'used' in the map.
3845: F3F5                ;                   
3846: F3F5     2AB7F5     	LHLD		FATpointer			;now zero out the File Allocation Table
3847: F3F8                BITMAP1:            
3848: F3F8     3600       	MVI			M,0					; put zero in vector
3849: F3FA     23         	INX			H					; point at next location
3850: F3FB     0B         	DCX			B					; count down
3851: F3FC     78         	MOV			A,B          
3852: F3FD     B1         	ORA			C					; equals zero if both (B) and (B) are Zero
3853: F3FE     C2F8F3     	JNZ			BITMAP1				; loop for more
3854: F401                					; allocation vector is now cleared
3855: F401     2AC2F5     	LHLD		DirectoryFAT0		; Point at initial space used by directory.
3856: F404     EB         	XCHG							; pre allocate the space, first 2 bits (0C000H)
3857: F405     2AB7F5     	LHLD		FATpointer			; and put this into map.
3858: F408     73         	MOV			M,E          
3859: F409     23         	INX			H            
3860: F40A     72         	MOV			M,D          
3861: F40B                ;                   
3862: F40B                ;   End of initialization portion.
3863: F40B                ;                   
3864: F40B     CDC4EB     	CALL		HomeDrive			; now home the drive, H=0,T=0,S=0
3865: F40E     2AABF5     	LHLD		FilePosInDirSegment
3866: F411     3603       	MVI			M,3					; force next directory request to read
3867: F413     23         	INX			H					; in a sector.
3868: F414     3600       	MVI			M,0          
3869: F416                	                   
3870: F416     CD07EE     	CALL		InitializeFilePosition	;clear initial file position also.
3871: F419                BITMAP2:            
3872: F419     0EFF       	MVI		C,0FFH				; Read next file name in directory
3873: F41B     CD0EEE     	CALL	GetNextEntry		; And set checksum byte.
3874: F41E                	                   
3875: F41E     CDFEED     	CALL	CheckFilePosition	; Is there another file?
3876: F421     C8         	RZ						; NO - return
3877: F422                	                   
3878: F422     CD67ED     	CALL	FCB2HL				; YES, get its address.
3879: F425     3EE5       	MVI		A,EmptyFileFlag
3880: F427     BE         	CMP		M					; Is it an empty file entry?
3881: F428     CA19F4     	JZ		BITMAP2				; YES - Go back for next entry
3882: F42B                	                   
3883: F42B     3AA1F5     	LDA		CurrentUser			; NO, Do we have the correct user number?
3884: F42E     BE         	CMP		M             
3885: F42F     C23DF4     	JNZ		BITMAP3				; NO -			
3886: F432     23         	INX		H					; YES -skip to first character in file name
3887: F433     7E         	MOV		A,M					; Does name start with a '$'?
3888: F434     D624       	SUI		DOLLAR				; Clear acc(if =) and test for equality at the same time
3889: F436     C23DF4     	JNZ		BITMAP3       
3890: F439     3D         	DCR		A					; Yes, set atatus to minus one.
3891: F43A     323FE8     	STA		StatusBDOSReturn	; set return status
3892: F43D                BITMAP3:            
3893: F43D                ;	MVI		C,1					;now set this file's space as used in bit map.
3894: F43D     3E01       	MVI		A,01H				; want to set the bit
3895: F43F     32A3F5     	STA		BitSetFlag			; Flag = 01, set the bit
3896: F442     CD71EE     	CALL	SetClearFATbits
3897: F445     CD95ED     	CALL	CHKNMBR				;keep (FilePosInDirSegment) in bounds.
3898: F448     C319F4     	JMP	BITMAP2        
3899: F44B                ;-----------------------------------------------------------
3900: F44B                ;                   
3901: F44B                ;  Routine to set a bit in a 16 bit value contained in (BC).
3902: F44B                ; The bit set depends on the current drive selection.
3903: F44B                ;                   
3904: F44B                SetBit:             
3905: F44B     3AA2F5     	LDA		CurrentDrive		; get active drive, a = 00, b = 02, c= 02, d = 03
3906: F44E     210100     	LXI		H,1					; Need a bit to move
3907: F451     3C         	INR		A					; Ensure at lest 1 test
3908: F452                SetBit1:            
3909: F452     3D         	DCR		A             
3910: F453     CA5AF4     	JZ		SetBit2				; a = 01, b = 02, c= 04, d = 08
3911: F456     29         	DAD		H             
3912: F457     C352F4     	JMP		SetBit1       
3913: F45A                SetBit2:	           
3914: F45A     79         	MOV		A,C					; or result with BC
3915: F45B     B5         	ORA		L             
3916: F45C     6F         	MOV		L,A					;low byte done, do high byte.
3917: F45D     78         	MOV		A,B           
3918: F45E     B4         	ORA		H             
3919: F45F     67         	MOV		H,A           
3920: F460     C9         	RET							; HL has the result
3921: F461                                    
3922: F461                ;                   
3923: F461                ;   Function to set the active disk number.
3924: F461                ;                   
3925: F461                fcSelectDisk:       
3926: F461     3A3EE8     	LDA	ParamE				;get parameter passed and see if this
3927: F464     21A2F5     	LXI	H,CurrentDrive		;represents a change in drives.
3928: F467     BE         	CMP	M              
3929: F468     C8         	RZ						; return the drive is already selected
3930: F469     77         	MOV	M,A					; It is a change in drives, so log it in.
3931: F46A     C3C9F3     	JMP	LoginDrive     
3932: F46D                ;                   
3933: F46D                ;   This is the 'auto disk select' routine. The firsst byte
3934: F46D                ; of the fcb is examined for a drive specification. If non
3935: F46D                ; zero then the drive will be selected and loged in.
3936: F46D                ;                   
3937: F46D                AutoSelect:         
3938: F46D     3EFF       	MVI		A,0FFH				;say 'auto-select activated'.
3939: F46F     32D5F5     	STA		AutoSelectActive
3940: F472     2A3CE8     	LHLD	ParamsDE			; get drive specified.
3941: F475     7E         	MOV		A,M					; (A) should be equal to currentDisk where:
3942: F476     E61F       	ANI		1FH					; (uuuudddd) where 'uuuu' is the user number;look at lower 5 bits.
3943: F478     3D         	DCR		A					; adjust for (1=A, 2=B) etc.
3944: F479     323EE8     	STA		ParamE				; and save for the select routine.
3945: F47C     FE1E       	CPI		1EH					; check for 'no change' condition (00 - 1).
3946: F47E     D291F4     	JNC		AutoSelect1			; yes, don't change.
3947: F481                	                   
3948: F481     3AA2F5     	LDA		CurrentDrive		; we must change
3949: F484     32D6F5     	STA		OldDrive			;  save currently active drive.
3950: F487     7E         	MOV		A,M					; and save first byte of fcb also.
3951: F488     32D7F5     	STA		AutoSelectFlag		; this must be non-zero.
3952: F48B     E6E0       	ANI		0E0H				; whats this for (bits 6,7 are used for
3953: F48D     77         	MOV		M,A					; something)? maybe User Number
3954: F48E     CD61F4     	CALL	fcSelectDisk		; select and log in this drive.
3955: F491                AutoSelect1:        
3956: F491     3AA1F5     	LDA		CurrentUser 		; move user number into fcb.
3957: F494     2A3CE8     	LHLD	ParamsDE			; (* upper half of first byte *)
3958: F497     B6         	ORA		M             
3959: F498     77         	MOV		M,A           
3960: F499     C9         	RET							; and return (all done).
3961: F49A                ;                   
3962: F49A                ;   Function to return the current cp/m version number.
3963: F49A                ;                   
3964: F49A                fcGetVersion:       
3965: F49A     3E22       	MVI	A,022h	;version 2.2
3966: F49C     C35CEB     	JMP	SetStatusBDOS  
3967: F49F                ;                   
3968: F49F                ;   Function (0D) to reset the disk system.
3969: F49F                ;                   
3970: F49F                fcResetDiskSystem:  
3971: F49F     210000     	LXI		H,0				; clear write protect status and log
3972: F4A2     22A5F5     	SHLD	ROBitMap		; clear all Read Only Bits
3973: F4A5     22A7F5     	SHLD	LoggedBitMap	; clear all logged in drives
3974: F4A8     AF         	XRA		A             
3975: F4A9     32A2F5     	STA		CurrentDrive	;select drive 'A'.
3976: F4AC     218000     	LXI		H,Pg0Buffer		;setup default dma address.
3977: F4AF     22A9F5     	SHLD	UsersDMA      
3978: F4B2     CDE3ED     	CALL	Set2UsersDMA	; Call BIOS to set DMA
3979: F4B5     C3C9F3     	JMP		LoginDrive		;now log in drive 'A'.
3980: F4B8                ;                   
3981: F4B8                ;   Function to open a specified file.
3982: F4B8                ;                   
3983: F4B8                fcOpenFile:         
3984: F4B8     CD7BED     	CALL	ClearS2	;clear 's2' byte.
3985: F4BB     CD6DF4     	CALL	AutoSelect	;select proper disk.
3986: F4BE     C3F9EF     	JMP	OPENIT	;and open the file.
3987: F4C1                ;                   
3988: F4C1                ;   Function to close a specified file.
3989: F4C1                ;                   
3990: F4C1                fcCloseFile:        
3991: F4C1     CD6DF4     	CALL	AutoSelect	;select proper disk.
3992: F4C4     C34AF0     	JMP	CLOSEIT	;and close the file.
3993: F4C7                ;                   
3994: F4C7                ;   Function to return the first occurence of a specified file
3995: F4C7                ; name. If the first byte of the fcb is '?' then the name will
3996: F4C7                ; not be checked (get the first entry no matter what).
3997: F4C7                ;                   
3998: F4C7                fcSearchForFirst:   
3999: F4C7     0E00       	MVI		C,0					; prepare for special search.
4000: F4C9     EB         	XCHG               
4001: F4CA     7E         	MOV		A,M					; is first byte a '?'?
4002: F4CB     FE3F       	CPI		QMARK				; is it '?'?
4003: F4CD     CADEF4     	JZ		fcSearchForFirst1	; yes, just get very first entry (zero length match).
4004: F4D0     CDC9EC     	CALL	SETEXT				; get the extension byte from fcb.
4005: F4D3     7E         	MOV		A,M					; is it '?'? if yes, then we want
4006: F4D4     FE3F       	CPI		QMARK				; '?'	;an entry with a specific 's2' byte.
4007: F4D6     C47BED     	CNZ		ClearS2				; otherwise, look for a zero 's2' byte.
4008: F4D9     CD6DF4     	CALL	AutoSelect			; select proper drive.
4009: F4DC     0E0F       	MVI		C,15				; compare bytes 0-14 in fcb (12&13 excluded).
4010: F4DE                fcSearchForFirst1:  
4011: F4DE     CDBDEE     	CALL	FindFirst			; find an entry and then move it into
4012: F4E1     C3F2ED     	JMP		MOVEDIR				; the users dma space.
4013: F4E4                ;                   
4014: F4E4                ;   Function to return the next occurence of a file name.
4015: F4E4                ;                   
4016: F4E4                fcSearchForNext:    
4017: F4E4     2AD0F5     	LHLD	SaveFCB				; restore pointers. note that no
4018: F4E7     223CE8     	SHLD	ParamsDE			; other dbos calls are allowed.
4019: F4EA     CD6DF4     	CALL	AutoSelect			; no error will be returned, but the
4020: F4ED     CDD2EE     	CALL	FindNext			; results will be wrong.
4021: F4F0     C3F2ED     	JMP		MOVEDIR       
4022: F4F3                ;                   
4023: F4F3                ;   Function to delete a file by name.
4024: F4F3                ;                   
4025: F4F3                fcDeleteFile:       
4026: F4F3     CD6DF4     	CALL	AutoSelect		; select proper drive.
4027: F4F6     CD41EF     	CALL	EraseFile		; erase the file.
4028: F4F9     C3A6EE     	JMP		STSTATUS		; set status and return.
4029: F4FC                ;                   
4030: F4FC                ;   Function to execute a sequential read of the specified
4031: F4FC                ; record number.    
4032: F4FC                ;                   
4033: F4FC                fcReadSequential:   
4034: F4FC     CD6DF4     	CALL	AutoSelect	;select proper drive then read.
4035: F4FF     C364F1     	JMP	RDSEQ          
4036: F502                ;                   
4037: F502                ;   Function to write the net sequential record.
4038: F502                ;                   
4039: F502                fcWriteSequential:  
4040: F502     CD6DF4     	CALL	AutoSelect	;select proper drive then write.
4041: F505     C3A6F1     	JMP	WTSEQ          
4042: F508                ;                   
4043: F508                ;   Create a file function.
4044: F508                ;                   
4045: F508                fcCreateFile:       
4046: F508     CD7BED     	CALL	ClearS2				; clear the 's2' byte ( extents counter hi byte).
4047: F50B     CD6DF4     	CALL	AutoSelect			; select proper drive and get the next
4048: F50E     C3CCF0     	JMP		GetEmptyDirSlot			; empty directory space.
4049: F511                ;                   
4050: F511                ;   Function to rename a file.
4051: F511                ;                   
4052: F511                fcRenameFile:       
4053: F511     CD6DF4     	CALL	AutoSelect	;select proper drive and then switch
4054: F514     CDBEEF     	CALL	CHGNAMES;file names.
4055: F517     C3A6EE     	JMP	STSTATUS       
4056: F51A                ;                   
4057: F51A                ;   Function to return the logged in Bit map.
4058: F51A                ;                   
4059: F51A                fcGetActiveDisks:   
4060: F51A     2AA7F5     	LHLD	LoggedBitMap  
4061: F51D     C345F5     	JMP	GETPRM1        
4062: F520                ;                   
4063: F520                ;   Function to return the current disk assignment.
4064: F520                ;                   
4065: F520                fcGetCurrentDisk:   
4066: F520     3AA2F5     	LDA	CurrentDrive   
4067: F523     C35CEB     	JMP	SetStatusBDOS  
4068: F526                ;                   
4069: F526                ;   Function to set the dma address.
4070: F526                ;                   
4071: F526                fcSetDMA:           
4072: F526     EB         	XCHG               
4073: F527     22A9F5     	SHLD	UsersDMA	;save in our space and then get to
4074: F52A     C3E3ED     	JMP	Set2UsersDMA	;the bios with this also.
4075: F52D                ;                   
4076: F52D                ;   Function to return the allocation vector.
4077: F52D                ;                   
4078: F52D                fcGetFATtable:      
4079: F52D     2AB7F5     	LHLD	FATpointer    
4080: F530     C345F5     	JMP	GETPRM1        
4081: F533                ;                   
4082: F533                ;   Function to return the read-only status vector.
4083: F533                ;                   
4084: F533                fcGetROdisks:       
4085: F533     2AA5F5     	LHLD	ROBitMap      
4086: F536     C345F5     	JMP	GETPRM1        
4087: F539                ;                   
4088: F539                ;   Function to set the file attributes (read-only, system).
4089: F539                ;                   
4090: F539                fcSetFileAttributes:
4091: F539     CD6DF4     	CALL	AutoSelect	;select proper drive then save attributes.
4092: F53C     CDE3EF     	CALL	SAVEATTR      
4093: F53F     C3A6EE     	JMP	STSTATUS       
4094: F542                ;                   
4095: F542                ;   Function to return the address of the disk parameter block
4096: F542                ; for the current drive.
4097: F542                ;                   
4098: F542                fcGetDPB:           
4099: F542     2AB3F5     	LHLD	DiskParamBlock
4100: F545                GETPRM1:            
4101: F545     223FE8     	SHLD	StatusBDOSReturn
4102: F548     C9         	RET                
4103: F549                ;                   
4104: F549                ;   Function to get or set the user number. If (E) was (FF)
4105: F549                ; then this is a request to return the current user number.
4106: F549                ; Else set the user number from (E).
4107: F549                ;                   
4108: F549                fcGetUser:          
4109: F549     3A3EE8     	LDA			ParamE			; get controlling parameter.
4110: F54C     FEFF       	CPI			0FFH			; want to get user number?
4111: F54E     C257F5     	JNZ			SetUser			; No, then set it
4112: F551     3AA1F5     	LDA			CurrentUser		; yes, just return it in A
4113: F554     C35CEB     	JMP			SetStatusBDOS	; exit while setting return status
4114: F557                	                   
4115: F557                SetUser:            
4116: F557     E61F       	ANI			1FH				; no,just keep the low bits (000X XXXX)
4117: F559     32A1F5     	STA			CurrentUser		; and save in Current user
4118: F55C     C9         	RET                
4119: F55D                ;                   
4120: F55D                ;   Function to read a random record from a file.
4121: F55D                ;                   
4122: F55D                fcReadRandom:       
4123: F55D     CD6DF4     	CALL	AutoSelect	;select proper drive and read.
4124: F560     C33BF3     	JMP	READRAN        
4125: F563                ;                   
4126: F563                ;   Function to compute the file size for random files.
4127: F563                ;                   
4128: F563                fcWriteRandom:      
4129: F563     CD6DF4     	CALL	AutoSelect	;select proper drive and write.
4130: F566     C344F3     	JMP	WRITERAN       
4131: F569                ;                   
4132: F569                ;   Function to compute the size of a random file.
4133: F569                ;                   
4134: F569                fcGetFileSize:      
4135: F569     CD6DF4     	CALL	AutoSelect	;select proper drive and check file length
4136: F56C     C37AF3     	JMP	RANSIZE        
4137: F56F                ;                   
4138: F56F                ;   Function #37. This allows a program to log off any drives.
4139: F56F                ; On entry, set (DE) to contain a word with bits set for those
4140: F56F                ; drives that are to be logged off. The log-in vector and the
4141: F56F                ; write protect vector will be updated. This must be a M/PM
4142: F56F                ; special function. 
4143: F56F                ;                   
4144: F56F                fcResetDrive:       
4145: F56F     2A3CE8     	LHLD	ParamsDE	;get drives to log off.
4146: F572     7D         	MOV	A,L	;for each bit that is set, we want
4147: F573     2F         	CMA		;to clear that bit in (LoggedBitMap)
4148: F574     5F         	MOV	E,A	;and (ROBitMap).
4149: F575     7C         	MOV	A,H            
4150: F576     2F         	CMA                
4151: F577     2AA7F5     	LHLD	LoggedBitMap	;reset the login Bit map.
4152: F57A     A4         	ANA	H              
4153: F57B     57         	MOV	D,A            
4154: F57C     7D         	MOV	A,L            
4155: F57D     A3         	ANA	E              
4156: F57E     5F         	MOV	E,A            
4157: F57F     2AA5F5     	LHLD	ROBitMap      
4158: F582     EB         	XCHG               
4159: F583     22A7F5     	SHLD	LoggedBitMap	;and save.
4160: F586     7D         	MOV	A,L	;now do the write protect vector.
4161: F587     A3         	ANA	E              
4162: F588     6F         	MOV	L,A            
4163: F589     7C         	MOV	A,H            
4164: F58A     A2         	ANA	D              
4165: F58B     67         	MOV	H,A            
4166: F58C     22A5F5     	SHLD	ROBitMap	;and save. all done.
4167: F58F     C9         	RET                
4168: F590                ;                   
4169: F590                ;   Get here to return to the user.
4170: F590                ;                   
4171: F590                                    
4172: F590                ;                   
4173: F590                ;   Function #40. This is a special entry to do random i/o.
4174: F590                ; For the case where we are writing to unused disk space, this
4175: F590                ; space will be zeroed out first. This must be a M/PM special
4176: F590                ; purpose function, because why would any normal program even
4177: F590                ; care about the previous contents of a sector about to be
4178: F590                ; written over.     
4179: F590                ;                   
4180: F590                fcWriteZeroFill:    
4181: F590     CD6DF4     	CALL	AutoSelect	;select proper drive.
4182: F593     3E02       	MVI	A,2	;use special write mode.
4183: F595     32CDF5     	STA	MODE           
4184: F598     0E00       	MVI	C,0	;set write indicator.
4185: F59A     CDAFF2     	CALL	POSITN1	;position the file.
4186: F59D     CCABF1     	CZ	WTSEQ1	;and write (if no errors).
4187: F5A0     C9         	RET                
4188: F5A1                                    
4189: F5A1                ;**************************************************************
4190: F5A1                ;*                  
4191: F5A1                ;*     BDOS data storage pool.
4192: F5A1                ;*                  
4193: F5A1                ;**************************************************************
4194: F5A1                                    
4195: F5A1     00         CurrentUser:			DB	0		; current user number.
4196: F5A2     00         CurrentDrive:			DB	0		; currently active drive.
4197: F5A3     00         BitSetFlag:				DB	0		; flag to set(01) or reset(00) bit in disk allocation table
4198: F5A4                                    
4199: F5A4                ;                   
4200: F5A4     E5         EmptyDir:				DB	EmptyFileFlag	; empty directory segment indicator.
4201: F5A5     0000       ROBitMap:				DW	0		; write protect status for all 16 drives.
4202: F5A7     0000       LoggedBitMap:			DW	0		; drive active word (1 bit per drive).
4203: F5A9     8000       UsersDMA:				DW	080H	;user's dma address (defaults to 80h).
4204: F5AB                ;                   
4205: F5AB                ;   Scratch areas from parameter block.
4206: F5AB                ;                   
4207: F5AB     0000       FilePosInDirSegment:			DW	0	; relative position within dir segment for file (0-3).
4208: F5AD     0000       LastTrackNumber:		DW	0	; last selected track number.
4209: F5AF     0000       LastSectorNumber:		DW	0	; last selected sector number.
4210: F5B1                ;                   
4211: F5B1                ;   Disk storage areas from parameter block.
4212: F5B1                ;                   
4213: F5B1                DirBuffSize				EQU	128	; buffer size
4214: F5B1     0000       DirBuffAddr:			DW	0	;address of directory buffer to use.
4215: F5B3     0000       DiskParamBlock:			DW	0	;contains address of disk parameter block.
4216: F5B5     0000       CHKVECT:				DW	0	;address of check vector.
4217: F5B7     0000       FATpointer:			DW	0	;address of allocation vector (bit map).
4218: F5B9                ;                   
4219: F5B9                ;   Disk Parameter block returned from the bios.
4220: F5B9                ;                   
4221: F5B9                LogicalSecSize			EQU	128	; Logical sector size
4222: F5B9     0000       SECTORS:				DW	0	;sectors per track from bios.
4223: F5BB     00         BLKSHFT:				DB	0	;block shift.
4224: F5BC     00         BLKMASK:				DB	0	;block mask.
4225: F5BD     00         EXTMASK:				DB	0	;extent mask.
4226: F5BE     0000       DiskSize:				DW	0	;disk size from bios (number of blocks-1).
4227: F5C0     0000       DrectorySize:			DW	0	;directory size, number of entries.
4228: F5C2     0000       DirectoryFAT0:			DW	0	;storage for first bytes of bit map (dir space used).
4229: F5C4     0000       DirectoryFAT1:			DW	0
4230: F5C6     0000       OFFSET:					DW	0	;first usable track number.
4231: F5C8     0000       XLATE:					DW	0	;sector translation table address.
4232: F5CA                ;                   
4233: F5CA                ;                   
4234: F5CA     00         CLOSEFLG:				DB	0	;close flag (=0ffh is extent written ok).
4235: F5CB     00         RDWRTFLG:				DB	0	;read/write flag (0ffh=read, 0=write).
4236: F5CC     00         FileFoundFlag:			DB	0	;filename found status (0=found first entry, -1 not found).
4237: F5CD     00         MODE:					DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4238: F5CE     00         RELBLOCK:				DB	0	;relative position within fcb of block number written.
4239: F5CF     00         CharCounter:			DB	0	;byte counter for directory name searches.
4240: F5D0     00000000   SaveFCB:				DW	0,0	;save space for address of fcb (for directory searches).
4241: F5D4     00         SmallDisk:				DB	0	;if =0 then disk is > 256 blocks long.
4242: F5D5     00         AutoSelectActive:		DB	0	;if non-zero, then auto select activated.
4243: F5D6     00         OldDrive:				DB	0	;on auto select, storage for previous drive.
4244: F5D7     00         AutoSelectFlag:			DB	0	;if non-zero, then auto select changed drives.
4245: F5D8     00         SAVNXT:					DB	0	;storage for next record number to access.
4246: F5D9     00         SAVEXT:					DB	0	;storage for extent number of file.
4247: F5DA     0000       SAVNREC:				DW	0	;storage for number of records in file.
4248: F5DC     0000       BlockNumber:			DW	0	;block number (physical sector) used within a file or logical sector.
4249: F5DE     0000       LOGSECT:				DW	0	;starting logical (128 byte) sector of block (physical sector).
4250: F5E0     00         FCBPosition:			DB	0	; relative position within buffer 0...3
4251: F5E1     0000       FilePosInDirectory:		DW	0	; files position within directory 0....DirSize.
4252: F5E3     0000       DirectoryRecord:		DW	0	; Directory record count. 0...DirSize/4
4253: F5E5                ;                   
4254: F5E5                ;   Disk directory buffer checksum bytes. One for each of the
4255: F5E5                ; 16 possible drives.
4256: F5E5                ;                   
4257: F5E5                CheckSumTable:      
4258: F5E5     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4259: F5F5                ;                   
4260: F5F5                ;   Extra space ?   
4261: F5F5                ;                   
4262: F5F5     00000000   	DB	0,0,0,0         
4263: F5F9                ;                   
4264: F5F9                ;**************************************************************
4265: F5F9                ;*                  
4266: F5F9                ;*        B I O S   J U M P   T A B L E
4267: F5F9                ;*                  
4268: F5F9                ;**************************************************************
4269: F5F9                ;                   
4270: F5F9                BIOSEntry	Equ	0F600H		; start of bios
4271: F5F9                                    
4272: F5F9                biosBoot			EQU		BIOSEntry + 000H	
4273: F5F9                fcSystemReset		EQU		BIOSEntry + 003H
4274: F5F9                biosConsoleStatus	EQU		BIOSEntry + 006H
4275: F5F9                biosConsoleIn		EQU		BIOSEntry + 009H
4276: F5F9                biosConsoleOut		EQU		BIOSEntry + 00CH
4277: F5F9                fcListOut			EQU		BIOSEntry + 00FH
4278: F5F9                fcPunchOut			EQU		BIOSEntry + 012H
4279: F5F9                biosReaderIn		EQU		BIOSEntry + 015H
4280: F5F9                biosHomeDisk		EQU		BIOSEntry + 018H
4281: F5F9                biosSelectDisk		EQU		BIOSEntry + 01BH
4282: F5F9                biosSetTrack		EQU		BIOSEntry + 01EH
4283: F5F9                biosSetSector		EQU		BIOSEntry + 021H
4284: F5F9                biosSetDMA			EQU		BIOSEntry + 024H
4285: F5F9                biosReadDisk		EQU		BIOSEntry + 027H
4286: F5F9                biosWriteDisk		EQU		BIOSEntry + 02AH
4287: F5F9                biosListStatus		EQU		BIOSEntry + 02DH
4288: F5F9                biosSectorTranslate	EQU		BIOSEntry + 030H
4289: F5F9                                    
4290: F5F9                ;*                  
4291: F5F9                ;******************   E N D   O F   C P / M   *****************
4292: F5F9                ;*                  
4293: F5F9                CodeEnd:            
4294: F5F9                		END               




                                    Xref


0000	0000	$                             		  1564,

2494	ED6D	ADDA2HL                       		  3432,
0506	E242	ADDATOHL                      		  0524,  0892,  1087,
0604	E2BA	AFN                           		  0612,
0610	E2C2	AFN1                          		  0608,
2531	ED88	ANYMOREFILES                  		  2546,  2592,  2882,
0050	002A	ASTRK                         		  0627,
0052	0040	ATSIGN                        		  1737,
3937	F46D	AUTOSELECT                    		  3985,  3991,  4008,  4019,  4026,  4034,  4040,  4047,  4053,  4091,  4123,  4129,  4135,  4181,
3955	F491	AUTOSELECT1                   		  3946,
4242	F5D5	AUTOSELECTACTIVE              		  1463,  1493,  3939,
4244	F5D7	AUTOSELECTFLAG                		  1462,  1498,  3951,

1759	E9FF	BACKUP                        		  1882,  1924,
1763	EA07	BACKUP1                       		  1760,
1378	E745	BADLOAD                       		  1375,
1569	E8EC	BADSCTR                       		  2151,
1601	E925	BADSEC                        		  1578,
1602	E930	BADSEL                        		  1585,
1570	E8EE	BADSLCT                       		  2047,
1407	E777	BATCHFCB                      		  0306,  0309,  0311,  0312,  0322,  0326,  0419,
1405	E776	BATCHFLAG                     		  0294,  0412,  0734,  1364,
1600	E921	BDOSDRV                       		  1613,
1448	E806	BDOSENTRY                     		
1599	E915	BDOSERR                       		  1614,
1492	E873	BDOSEXIT                      		  1464,
1505	E890	BDOSEXIT1                     		  1495,  1500,  1984,
1490	E873	BDOSSTACK                     		  1460,
4272	F600	BIOSBOOT                      		
4275	F609	BIOSCONSOLEIN                 		  1628,  1670,  1673,  1985,
4276	F60C	BIOSCONSOLEOUT                		  1696,  1762,  1765,  1980,
4274	F606	BIOSCONSOLESTATUS             		  1667,  1979,  1982,
4270	F600	BIOSENTRY                     		  4272,  4273,  4274,  4275,  4276,  4277,  4278,  4279,  4280,  4281,  4282,  4283,  4284,  4285,  4286,  4287,  4288,
4280	F618	BIOSHOMEDISK                  		  2126,
4287	F62D	BIOSLISTSTATUS                		
4285	F627	BIOSREADDISK                  		  2141,
4279	F615	BIOSREADERIN                  		  1967,
4288	F630	BIOSSECTORTRANSLATE           		  2250,
4281	F61B	BIOSSELECTDISK                		  2078,
4284	F624	BIOSSETDMA                    		  2633,
4283	F621	BIOSSETSECTOR                 		  2253,
4282	F61E	BIOSSETTRACK                  		  2230,
4286	F62A	BIOSWRITEDISK                 		  2147,
3828	F3EA	BITMAP                        		
3847	F3F8	BITMAP1                       		  3853,
3871	F419	BITMAP2                       		  3881,  3898,
3892	F43D	BITMAP3                       		  3885,  3889,
4197	F5A3	BITSETFLAG                    		  2759,  2959,  3895,
0039	0020	BLANK                         		  0118,  0448,  0472,  0498,  0642,  0694,  0835,  0862,  0937,  0991,  1000,  1003,  1245,  1259,  1275,  1335,  1392,  1655,  1709,  1748,  1761,  1779,
4224	F5BC	BLKMASK                       		  2338,  3485,
4223	F5BB	BLKSHFT                       		  2259,  2331,
4248	F5DC	BLOCKNUMBER                   		  2161,  2169,  2313,  2319,  2332,  2344,  3423,  3478,  3483,  3492,
0040	007B	BRACKETLEFT                   		  0284,
0041	007D	BRACKETRIGHT                  		
0026	0008	BS                            		  1653,  1716,  1764,  1827,

0051	005E	CARET                         		  1734,
0064	E000	CBASE                         		  0800,  0801,  1299,
1401	E776	CCPSTACK                      		  0723,  0747,
1416	E7BA	CDRIVE                        		  0266,  0274,  0302,  0329,  0421,  0548,  0738,  0762,  0907,  0920,  0923,  1265,
1418	E7BB	CHANGEDRIVEFLAG               		  0528,  0554,  0765,  0828,  0903,  0916,  1176,  1200,  1261,  1315,  1393,
2033	EB69	CHARBUF                       		  1623,  1664,  1679,
4239	F5CF	CHARCOUNTER                   		  2859,  2887,
2575	EDA7	CHECKDIR                      		  2697,
2647	EDFE	CHECKFILEPOSITION             		  2873,  2952,  3086,  3104,  3117,  3190,  3270,  3298,  3328,  3334,  3752,  3875,
2422	ED1A	CHECKSUM                      		  2582,
2426	ED20	CHECKSUM1                     		  2430,
4257	F5E5	CHECKSUMTABLE                 		  2576,  2585,
3085	EFCF	CHGNAM1                       		  3093,
3076	EFBE	CHGNAMES                      		  4054,
2318	ECA7	CHKBLK                        		  3374,  3402,
1646	E96F	CHKCHAR                       		  1634,  1731,
0382	E1BF	CHKCON                        		  0337,  1017,  1092,
2596	EDCD	CHKDIR1                       		  2589,
2545	ED95	CHKNMBR                       		  3287,  3897,
2466	ED4D	CHKROFL                       		  2954,  3088,
4216	F5B5	CHKVECT                       		  2583,
2707	EE39	CKBITMAP                      		  2756,  2992,  3021,
2744	EE5A	CKBMAP1                       		  2747,
1678	E99D	CKCON1                        		  1672,
1680	E9A0	CKCON2                        		  1666,
1663	E97E	CKCONSOL                      		  1693,  2013,
2468	ED50	CKROF1                        		  3396,
0709	E32B	CLEARBUF                      		  0066,
0588	E2A9	CLEARS1S2EX                   		  0577,  0584,
0590	E2AB	CLEARS1S2EX1                  		  0594,
2513	ED7B	CLEARS2                       		  3984,  4007,  4046,
0176	E0D7	CLOSE                         		  0327,  1152,
4234	F5CA	CLOSEFLG                      		  3252,  3296,  3311,
3178	F04A	CLOSEIT                       		  3297,  3618,  3992,
3199	F075	CLOSEIT1                      		  3235,
3208	F083	CLOSEIT2                      		  3206,
3213	F089	CLOSEIT3                      		  3210,
3217	F090	CLOSEIT4                      		  3202,
3231	F0A5	CLOSEIT5                      		  3216,
3250	F0BF	CLOSEIT6                      		  3242,
3254	F0C7	CLOSEIT7                      		  3215,  3224,  3229,
0746	E353	CMMND1                        		  0345,  0462,  1040,  1044,  1367,  1396,
0758	E369	CMMND2                        		  0742,
0024	0003	CNTRLC                        		  1580,  1674,  1944,
0025	0005	CNTRLE                        		  1852,
0031	0010	CNTRLP                        		  1862,
0032	0012	CNTRLR                        		  1893,
0033	0013	CNTRLS                        		  1671,
0034	0015	CNTRLU                        		  1886,
0035	0018	CNTRLX                        		  1873,
0036	001A	CNTRLZ                        		  1089,
4293	F5F9	CODEEND                       		
0062	E000	CODESTART                     		
0046	003A	COLON                         		  0482,  0544,  0977,  0982,
2308	EC9A	COMBLK                        		  3373,  3401,
1380	E74E	COMFILE                       		  1281,
0722	E32F	COMMAND                       		  0065,
0661	0006	COMMANDCOUNT                  		  0680,
0652	E2E9	COMMANDLIST                   		  0661,  0676,
0660	E301	COMMANDLISTEND                		  0661,
0651	0004	COMMANDSIZE                   		  0661,  0683,
0787	E392	COMMANDVECTOR                 		  0774,
3693	F34D	COMPRAND                      		  3756,  3787,
0522	E249	CONVERTFILENAME               		  1320,
0515	E247	CONVERTFIRSTNAME              		  0763,  0827,  0933,  1032,  1064,  1115,  1174,  1196,  1314,  1390,
0547	E272	CONVRT1                       		  0538,
0552	E279	CONVRT2                       		  0545,
0560	E27F	CONVRT3                       		  0550,
0562	E281	CONVRT4                       		
0565	E284	CONVRT7                       		  0569,
0030	000D	CR                            		  0110,  1647,  1786,  1822,  1955,
0235	E106	CREATE                        		  1122,
4196	F5A2	CURRENTDRIVE                  		  1611,  2076,  2439,  3802,  3905,  3927,  3948,  3975,  4066,
4195	F5A1	CURRENTUSER                   		  3883,  3956,  4112,  4117,
2031	EB67	CURSORPOSITION                		  1705,  1750,  1775,  1807,  1835,  1878,  1920,
2030	EB66	CURSORPOSITIONSTART           		  1776,  1808,  1858,  1877,

0018	005C	DEFAULTFCB                    		  1326,
0037	007F	DEL                           		  1706,  1840,
0411	E1DA	DELETEBATCHFILE               		  0344,  0351,  0461,
0201	E0EC	DELETEFILE                    		  0420,  1050,  1120,
2556	ED9E	DEMINUSHL2HL                  		  2579,  2677,
2060	EB72	DETOHL                        		  2105,  2110,  2642,  3067,  3129,
2062	EB73	DETOHL1                       		  2070,
4214	F5B1	DIRBUFFADDR                   		  2103,  2424,  2489,  2624,  2638,  3467,
4213	0080	DIRBUFFSIZE                   		  2423,  2641,  3147,
1981	EB3B	DIRC1                         		  1977,
0932	E448	DIRECT                        		  0788,
0941	E459	DIRECT1                       		  0945,
0947	E460	DIRECT2                       		  0938,
0952	E469	DIRECT3                       		  1020,
0980	E49D	DIRECT4                       		  0970,
0984	E4A5	DIRECT5                       		  0979,
0987	E4AA	DIRECT6                       		  1012,
1014	E4DC	DIRECT7                       		  1001,  1009,
1016	E4DD	DIRECT8                       		  0963,
1021	E4E9	DIRECT9                       		  0953,  1018,
4228	F5C2	DIRECTORYFAT0                 		  3855,
4229	F5C4	DIRECTORYFAT1                 		  2578,
4252	F5E3	DIRECTORYRECORD               		  2162,
2611	EDDD	DIRREAD                       		  2695,
2602	EDCF	DIRWRITE                      		  2961,  3070,
4215	F5B3	DISKPARAMBLOCK                		  2106,  4099,
1604	E93C	DISKRO                        		  1589,
0146	E0BA	DISKSELECT                    		  0305,  0331,  0418,  0422,  0739,  0910,  0924,  1267,  1366,
4226	F5BE	DISKSIZE                      		  2111,  2812,  3010,  3832,
1729	E9DA	DISPLAYACC                    		  1911,  1940,
0054	0024	DOLLAR                        		  1795,  3888,
2140	EBD5	DOREAD                        		  2613,  3378,
2146	EBDB	DOWRITE                       		  2606,  3482,  3502,
1002	E4C8	DRECT63                       		  0996,
1004	E4CA	DRECT65                       		  0992,
4227	F5C0	DRECTORYSIZE                  		  2455,  2672,

4200	F5A4	EMPTYDIR                      		  3266,
0057	00E5	EMPTYFILEFLAG                 		  2878,  2956,  3879,  4200,
1785	EA24	ENDOFLINETOCONSOLE            		  1610,  1773,  1856,
0056	0000	ENDOFMESSAGE                  		  0819,  1379,
0017	0005	ENTRY                         		  0096,  0142,  0149,  0155,  0203,  0209,  0244,  0256,  0355,  0384,  0388,  0396,  0407,
0154	E0C0	ENTRY1                        		  0164,  0178,  0185,  0191,  0237,
0208	E0F1	ENTRY2                        		  0218,  0231,
0043	003D	EQUALS                        		  0476,  1188,
2951	EF49	ERAFIL1                       		  2963,
1031	E4ED	ERASE                         		  0789,
1047	E510	ERASE1                        		  1034,
2947	EF41	ERASEFILE                     		  4027,
1577	E8F4	ERROR1                        		  1569,
1584	E900	ERROR2                        		  1570,
1588	E906	ERROR3                        		  1571,
1592	E90C	ERROR4                        		  1572,
1595	E90F	ERROR5                        		  1586,  1590,
0087	E087	ERRORMSGPOINTER               		  0445,  0533,
1230	E650	EXISTS                        		  1227,
0623	E2C9	EXPANDNAME                    		  0563,  0580,  0637,
0632	E2DA	EXPANDNAME1                   		  0628,
0635	E2DC	EXPANDNAME2                   		  0630,
2287	EC81	EXTBLK                        		  2312,  3412,
2298	EC94	EXTBLK1                       		  2294,
4225	F5BD	EXTMASK                       		  2377,  2839,  3309,
0889	E41C	EXTRACT                       		  0961,  0989,  0998,

4217	F5B7	FATPOINTER                    		  2741,  3846,  3857,  4079,
2488	ED67	FCB2HL                        		  2467,  2780,  2886,  2955,  3065,  3124,  3193,  3754,  3878,
1412	E798	FCBFROMCCP                    		  0170,  0171,  0196,  0223,  0523,  0682,  0831,  0902,  0935,  1049,  1118,  1125,  1141,  1151,  1181,  1182,  1210,  1214,  1244,  1258,  1273,  1293,  1318,  1323,  1325,  1327,  1391,
4250	F5E0	FCBPOSITION                   		  2490,  2690,
3051	EFA5	FCBSET                        		  3288,
3990	F4C1	FCCLOSEFILE                   		  1538,
1960	EB23	FCCONSOLEIN                   		  1522,
1743	E9EB	FCCONSOLEOUT                  		  1523,  1638,  1732,  1800,
1747	E9F1	FCCONSOLEOUT1                 		  1753,
2012	EB59	FCCONSOLESTATUSIN             		  1532,
1806	EA3C	FCCONSOLESTRINGIN             		  1531,  1880,  1890,
2004	EB53	FCCONSOLESTRINGOUT            		  1530,
4045	F508	FCCREATEFILE                  		  1544,
4025	F4F3	FCDELETEFILE                  		  1541,
1974	EB2F	FCDIRECTCONSOLEOUT            		  1527,
4059	F51A	FCGETACTIVEDISKS              		  1546,
4065	F520	FCGETCURRENTDISK              		  1547,
4098	F542	FCGETDPB                      		  1553,
4078	F52D	FCGETFATTABLE                 		  1549,
4134	F569	FCGETFILESIZE                 		  1557,
1990	EB48	FCGETIOBYTE                   		  1528,
4084	F533	FCGETRODISKS                  		  1551,
4108	F549	FCGETUSER                     		  1554,
3964	F49A	FCGETVERSION                  		  1533,
4277	F60F	FCLISTOUT                     		  1526,  1701,
3983	F4B8	FCOPENFILE                    		  1537,
4278	F612	FCPUNCHOUT                    		  1525,
1966	EB29	FCREADERIN                    		  1524,
4122	F55D	FCREADRANDOM                  		  1555,
4033	F4FC	FCREADSEQUENTIAL              		  1542,
4052	F511	FCRENAMEFILE                  		  1545,
3970	F49F	FCRESETDISKSYSTEM             		  1535,
4144	F56F	FCRESETDRIVE                  		  1559,
2020	EB5F	FCRETURN                      		  1560,  1561,
3998	F4C7	FCSEARCHFORFIRST              		  1539,
4010	F4DE	FCSEARCHFORFIRST1             		  4003,
4016	F4E4	FCSEARCHFORNEXT               		  1540,
3925	F461	FCSELECTDISK                  		  1504,  1536,  3954,
2448	ED35	FCSETDISKRO                   		  1550,  2594,
4071	F526	FCSETDMA                      		  1548,
4090	F539	FCSETFILEATTRIBUTES           		  1552,
1996	EB4E	FCSETIOBYTE                   		  1529,
3784	F3B6	FCSETRECORDNUMBER             		  1558,
4273	F603	FCSYSTEMRESET                 		  1521,
4128	F563	FCWRITERANDOM                 		  1556,
4039	F502	FCWRITESEQUENTIAL             		  1543,
4180	F590	FCWRITEZEROFILL               		  1562,
0029	000C	FF                            		
4236	F5CC	FILEFOUNDFLAG                 		  2828,  2858,  2929,
0815	E3BB	FILENOTFOUND                  		  0951,  1052,  1221,
4251	F5E1	FILEPOSINDIRECTORY            		  2158,  2532,  2648,  2660,  2674,  2676,  2680,  2926,  3181,  3182,
4207	F5AB	FILEPOSINDIRSEGMENT           		  2091,  2458,  2534,  3865,
1603	E937	FILERO                        		  1593,
0675	E301	FINDDOSCOMMAND                		  0768,
0678	E306	FINDDOSCOMMAND1               		  0704,
0684	E30F	FINDDOSCOMMAND2               		  0691,
0698	E322	FINDDOSCOMMAND3               		  0687,  0701,
0702	E327	FINDDOSCOMMAND4               		  0695,
2856	EEBD	FINDFIRST                     		  2950,  3079,  3102,  3116,  3189,  3269,  3327,  3741,  4011,
2870	EED2	FINDNEXT                      		  2907,  2914,  2962,  3092,  3109,  3775,  4020,
2885	EEEF	FINDNEXT1                     		  2879,
2890	EEF8	FINDNEXT2                     		  2924,
2909	EF18	FINDNEXT3                     		  2904,
2919	EF21	FINDNEXT4                     		  2897,  2901,  2908,
2925	EF28	FINDNEXT5                     		  2893,
2939	EF39	FINDNEXT6                     		  2874,  2884,
2985	EF68	FNDSPA1                       		  3026,  3045,
3009	EF79	FNDSPA2                       		  2988,
3031	EF94	FNDSPA3                       		  2994,  3023,
3042	EF9C	FNDSPA4                       		  3015,
2978	EF66	FNDSPACE                      		  3416,
1564	0028	FUNCTIONCOUNT                 		  1467,
1520	E89A	FUNCTIONVECTOR                		  1564,  1470,

1387	E751	GETBACK                       		  1023,  1053,  1090,  1093,  1100,  1163,  1216,  1222,  1229,  1377,
1389	E754	GETBACK1                      		  1248,  1263,  1268,
2262	EC68	GETBLK1                       		  2266,
2272	EC76	GETBLK2                       		  2277,
2278	EC7F	GETBLK3                       		  2274,
2258	EC61	GETBLOCK                      		  2309,  3405,
1622	E956	GETCHAR                       		  1633,  1818,
0826	E3C9	GETCMDNUMBER                  		  1113,  1240,
0833	E3D9	GETCMDNUMBER1                 		  0858,
0394	E1CD	GETCURRENTDISK                		  0749,  0761,  0973,
2437	ED27	GETDISKROSTATUS               		  2480,  3183,
1632	E961	GETECHO                       		  1961,
3262	F0CC	GETEMPTYDIRSLOT               		  3333,  3640,  4048,
0571	E28E	GETEXTENSION                  		  0567,
0578	E29B	GETEXTENSION1                 		  0575,
0582	E29F	GETEXTENSION4                 		  0586,
3279	F0EE	GETMT1                        		  3283,
3294	F102	GETNEXT                       		  3366,  3534,
2671	EE0E	GETNEXTENTRY                  		  2872,  3873,
4100	F545	GETPRM1                       		  4061,  4080,  4086,
2504	ED72	GETS2                         		  2514,  2521,  3185,  3523,  3657,
0254	E112	GETSETCURRENTUSER             		  0732,  1247,
0248	E110	GETUSR                        		  0261,
0049	003E	GRTTHAN                       		  0488,  0752,
3315	F12B	GTNEXT1                       		  3307,
3325	F136	GTNEXT2                       		  3313,
3337	F154	GTNEXT3                       		  3314,  3329,
3339	F157	GTNEXT4                       		  3336,
3347	F15E	GTNEXT5                       		  3321,  3332,  3335,

0798	E3A0	HALT                          		
0878	E413	HL2DE                         		  0321,  0884,  1184,  1329,
2404	ED0D	HLRIGHTC                      		  2160,  2441,  3805,  3834,
2406	ED0E	HLRIGHTC1                     		  2416,
2125	EBC4	HOMEDRIVE                     		  2864,  3864,

0077	E008	INBUFF                        		  0086,  0335,  0375,  1330,
0085	E085	INBUFFADDRESS                 		  0376,  0529,  0596,  1046,  1185,  1195,
0075	E007	INBUFFCOUNT                   		  0318,  0361,  0711,  0740,  1038,
0083	E085	INBUFFEND                     		  0074,
0073	E006	INBUFFSIZE                    		  0320,
0072	E006	INBUFFSTART                   		  0074,  0354,
2658	EE07	INITIALIZEFILEPOSITION        		  2678,  2863,  2940,  3870,
0293	E136	INPUTLINE                     		  0754,  1037,
0350	E193	INPUTLINECONSOLE              		  0296,  0308,  0314,  0328,
0360	E1A4	INPUTLINECONSOLE1             		  0338,
0363	E1A8	INPUTLINECONSOLE2             		  0372,
0373	E1B7	INPUTLINECONSOLE3             		  0367,
0015	0003	IOBYTE                        		  1991,  1997,
2025	EB60	IOERR1                        		  3348,  3384,  3400,
2148	EBDE	IORET                         		  2142,
2479	ED5D	ISDISKRO                      		  2948,  3077,  3263,  3394,
0467	E219	ISITVALIDCHARACTER            		  0566,  0583,  0624,

2051	EB6D	JUMPTOHL                      		  2152,  2475,  2483,

4209	F5AF	LASTSECTORNUMBER              		  2097,  2132,  2174,  2237,
4208	F5AD	LASTTRACKNUMBER               		  2094,  2128,  2179,  2232,
0048	003C	LESSTH                        		  0486,
0028	000A	LF                            		  0112,  1649,  1721,  1788,  1824,
4202	F5A7	LOGGEDBITMAP                  		  3804,  3815,  3819,  3973,  4060,  4151,  4159,
2330	ECAD	LOGICAL                       		  3376,  3450,
4221	0080	LOGICALSECSIZE                		  1076,  1137,  1297,  3364,  3399,
2333	ECB3	LOGICL1                       		  2336,
3801	F3C9	LOGINDRIVE                    		  3931,  3979,
4249	F5DE	LOGSECT                       		  2337,  3475,

0013	0040	MEM                           		  0061,
4237	F5CD	MODE                          		  2388,  3355,  3390,  3451,  3530,  3564,  4183,
0873	E411	MOVE3                         		  1282,
0273	E126	MOVECD                        		  0356,  1266,  1365,
2637	EDF2	MOVEDIR                       		  4012,  4021,
3160	F03C	MOVEWORD                      		  3218,  3220,

1420	E7BC	NBYTES                        		  1070,  1073,
1770	EA0C	NEWLINE                       		  1888,  1897,
1774	EA14	NEWLN1                        		  1781,
0494	E238	NEXTNONBLANKCHAR              		  0502,  0531,  1187,
0818	E3C1	NOFILE                        		  0816,
1164	E5D5	NOSPACE                       		  1159,

4230	F5C6	OFFSET                        		  2226,
4243	F5D6	OLDDRIVE                      		  1502,  3949,
0162	E0C8	OPEN                          		  0172,  0307,
0168	E0CD	OPENFCB                       		  1067,  1283,
3114	EFF9	OPENIT                        		  3631,  3986,
3119	F002	OPENIT1                       		  3338,
3148	F033	OPENIT2                       		  3144,  3146,
1688	E9A3	OUTCHAR                       		  1735,  1746,  1749,  1772,  1780,  1787,  1789,  1956,
1703	E9BD	OUTCHR1                       		  1691,
1720	E9D4	OUTCHR2                       		  1717,
2029	EB65	OUTPUTFLAG                    		  1689,  1836,  1917,  1922,  1925,

0640	E2E1	PADFIELD                      		  0576,  0625,  0644,
0860	E404	PADNUMBER                     		  0836,  0866,
1483	E83E	PARAME                        		  1455,  1503,  3926,  3944,  4109,
1482	E83C	PARAMSDE                      		  1452,  1478,  1496,  1809,  2288,  2350,  2359,  2505,  2861,  3062,  3080,  3126,  3149,  3196,  3264,  3267,  3272,  3300,  3395,  3425,  3570,  3742,  3785,  3940,  3957,  4018,  4145,
0045	002E	PERIOD                        		  0480,  0573,
0019	0080	PG0BUFFER                     		  0319,  0401,  0759,  0890,  1086,  1344,  1356,  3976,
0124	E0A4	PLINE                         		  0808,  0817,  1036,  1160,  1228,  1376,
0128	E0A9	PLINE2                        		  0136,  0336,
3562	F2AB	POSITION                      		  3673,  3681,
3568	F2AF	POSITN1                       		  4185,
3615	F2EF	POSITN2                       		  3605,
3648	F327	POSITN3                       		  3611,  3634,
3655	F32C	POSITN4                       		  3624,  3639,  3644,
3663	F333	POSITN5                       		  3597,
0053	0023	POUNDSN                       		  1771,
0093	E089	PRINT                         		  0102,  0134,  0453,  0459,  0751,  0753,  1091,
0100	E08F	PRINTB                        		  0111,  0113,  0119,  0976,  0978,  0983,  1005,
2032	EB68	PRINTERFLAG                   		  1699,  1865,
1608	E940	PRTERR                        		  1579,  1596,
1793	EA2E	PRTMESG                       		  1615,  1617,  1802,  2008,

0042	003F	QMARK                         		  0458,  0607,  0629,  0942,  2896,  4002,  4006,

3751	F38C	RANSIZ1                       		  3776,
3774	F3AE	RANSIZ2                       		  3768,
3777	F3B4	RANSIZ3                       		  3753,
3739	F37A	RANSIZE                       		  4136,
1814	EA4A	RDBUF1                        		  1832,  1844,  1870,  1951,
1895	EACB	RDBUF10                       		  1837,
1902	EAD3	RDBUF11                       		  1914,
1915	EAE5	RDBUF12                       		  1905,
1923	EAF4	RDBUF13                       		  1927,
1932	EB01	RDBUF14                       		  1894,
1936	EB04	RDBUF15                       		  1849,
1949	EB18	RDBUF16                       		  1946,
1952	EB1C	RDBUF17                       		  1823,  1825,
1817	EA4C	RDBUF2                        		  1859,  1919,  1928,
1839	EA71	RDBUF3                        		  1828,
1851	EA81	RDBUF4                        		  1841,
1861	EA92	RDBUF5                        		  1853,
1872	EAA3	RDBUF6                        		  1863,
1876	EAA9	RDBUF7                        		  1883,
1885	EABA	RDBUF8                        		  1874,
1892	EAC6	RDBUF9                        		  1887,
0809	E3B0	RDERR                         		  0807,
0806	E3AA	RDERROR                       		  1101,
0216	E0F6	RDREC                         		  0224,  0313,  1294,
3353	F164	RDSEQ                         		  4035,
3356	F169	RDSEQ1                        		  3674,
3372	F18E	RDSEQ2                        		  3363,
3383	F1A3	RDSEQ3                        		  3365,  3371,  3375,
4235	F5CB	RDWRTFLG                      		  3330,  3358,  3393,
0222	E0FB	READFCB                       		  1079,
3671	F33B	READRAN                       		  4124,
4238	F5CE	RELBLOCK                      		  3406,  3430,
0242	E10B	RENAM                         		  1215,
1173	E5DE	RENAME                        		  0792,
1192	E60D	RENAME1                       		  1189,
1207	E627	RENAME2                       		  1203,
1211	E62C	RENAME3                       		
1220	E63B	RENAME4                       		  1213,
1223	E641	RENAME5                       		  1191,  1197,  1206,
1226	E647	RENAME6                       		  1180,
0140	E0B5	RESETDISKSYSTEM               		  0733,
0915	E437	RESETDR                       		  1103,  1224,  1313,  1372,  1388,
4201	F5A5	ROBITMAP                      		  2438,  2449,  2454,  3972,  4085,  4157,  4166,
1571	E8F0	RODISK                        		  2482,
1572	E8F2	ROFILE                        		  2474,
1414	E7B9	RTNCODE                       		  0156,  0954,

2836	EEAC	SAMEXT                        		  2912,
3103	EFE8	SAVATR1                       		  3110,
1112	E57B	SAVE                          		  0791,
1131	E5A2	SAVE1                         		  1146,
1150	E5BF	SAVE2                         		  1134,
1158	E5C9	SAVE3                         		  1123,  1145,
1161	E5CF	SAVE4                         		  1154,
3100	EFE3	SAVEATTR                      		  4092,
4240	F5D0	SAVEFCB                       		  2862,  2875,  4017,
4246	F5D9	SAVEXT                        		  2271,  2379,
4247	F5DA	SAVNREC                       		  2261,  2340,  2372,  2394,  3360,  3368,  3398,  3504,  3540,
4245	F5D8	SAVNXT                        		  2375,  2398,  3361,  3505,
0183	E0DC	SEARCHFORFIRST                		  0197,
0189	E0E1	SEARCHFORNEXT                 		  1019,
4222	F5B9	SECTORS                       		  2108,  2192,  2204,
2075	EB7C	SELECTDISK                    		  3808,
2118	EBC0	SELECTDISK1                   		  2116,
0900	E425	SELECTDRIVE                   		  0934,  1048,  1066,  1117,  1178,  1279,
0047	003B	SEMIC                         		  0484,
0109	E095	SENDENDOFLINE                 		  0126,  0444,  0460,  0748,  0971,  1069,  1357,
2617	EDE3	SET2USERSDMA                  		  2607,  3493,  3978,  4074,
3904	F44B	SETBIT                        		  2453,  3818,
3908	F452	SETBIT1                       		  3912,
3913	F45A	SETBIT2                       		  3910,
2520	ED81	SETBIT7INS2                   		  3130,  3289,  3349,  3667,
2779	EE71	SETCLEARFATBITS               		  2960,  3896,
0260	E117	SETCURRENTDRIVE               		  0352,  1359,
2567	EDA5	SETDIR                        		  2603,
2623	EDE9	SETDIRDMA                     		  2604,  2612,  3474,
0405	E1D5	SETDMA                        		  0760,  1140,  1292,
2629	EDEC	SETDMA0                       		  2619,
2349	ECC9	SETEXT                        		  2376,  3120,  4004,
2785	EE7A	SETFL1                        		  2822,
2801	EE8B	SETFL2                        		  2793,
2808	EE91	SETFL3                        		  2799,
2818	EEA0	SETFL4                        		  2811,
2358	ECD1	SETHLDE                       		  2370,  2387,
2386	ECF5	SETNREC                       		  3379,  3533,  3544,
2018	EB5C	SETSTATUSBDOS                 		  1962,  1968,  1986,  1992,  2027,  2829,  2942,  3342,  3421,  3651,  3966,  4067,  4113,
4115	F557	SETUSER                       		  4111,
2046	EB6A	SLCTERR                       		  3809,
4241	F5D4	SMALLDISK                     		  2113,  2292,  2791,  3200,  3428,
0117	E09F	SPACETOCONSOLE                		  0981,  0985,  1011,
0195	E0E6	SRCHFCB                       		  0950,  1179,  1212,
1484	E83F	STATUSBDOSRETURN              		  1457,  1508,  2019,  2928,  3180,  3255,  3369,  3446,  3535,  3622,  3632,  3642,  3666,  3891,  4101,
2754	EE60	STBITMAP                      		  2817,
2769	EE6A	STBMAP1                       		  2772,  3034,
0400	E1D2	STDDMA                        		  1162,  1358,
2392	ED01	STNREC1                       		  2390,
2369	ECDE	STRDATA                       		  3340,  3359,  3397,
2827	EEA6	STSTATUS                      		  4028,  4055,  4093,
0443	E1F2	SYNERR                        		  0473,  0764,  0830,  0840,  0845,  0851,  0853,  0855,  0863,  1065,  1104,  1116,  1175,  1225,  1242,  1246,  1276,  1373,  1395,
0446	E1F8	SYNERR1                       		  0456,
0457	E20B	SYNERR2                       		  0449,  0451,

0027	0009	TAB                           		  1651,  1745,
0020	0100	TBASE                         		  1130,  1288,  1360,
0016	0004	TDRIVE                        		  0268,  0275,
2167	EBF4	TRACKSECTORFORBLOCK           		  3377,  3480,  3499,
2185	EC07	TRACKSECTORFORBLOCK1          		  2201,
2202	EC1D	TRACKSECTORFORBLOCK2          		  2190,  2215,
2220	EC32	TRACKSECTORFORBLOCK3          		  2206,  2211,
2157	EBE6	TRACKSECTORFORDIR             		  2694,  3069,
1063	E52B	TYPE                          		  0790,
1072	E542	TYPE1                         		  1094,
1074	E545	TYPE2                         		
1084	E555	TYPE3                         		  1077,
1098	E56E	TYPE4                         		  1081,
1102	E575	TYPE5                         		  1068,

1256	E673	UNKNOWN                       		  0767,  0794,
1374	E73C	UNKWN0                        		  1304,  1312,
1272	E68F	UNKWN1                        		  1260,
1277	E698	UNKWN2                        		
1289	E6AC	UNKWN3                        		  1305,
1309	E6CC	UNKWN4                        		  1295,
1331	E6FB	UNKWN5                        		  1338,
1342	E709	UNKWN6                        		  1334,  1336,
1345	E70E	UNKWN7                        		  1353,
1354	E71A	UNKWN8                        		  1349,
1371	E736	UNKWN9                        		  1284,
3059	EFA9	UPDATE                        		  3091,  3108,
3068	EFB8	UPDATE1                       		  3253,
0281	E12D	UPPER                         		  0369,
0044	005F	USCORE                        		  0478,  1190,
1239	E65C	USER                          		  0793,
4203	F5A9	USERSDMA                      		  2618,  2640,  3977,  4073,
1485	E841	USERSTACK                     		  1459,  1506,

3679	F344	WRITERAN                      		  4130,
0229	E101	WRTREC                        		  1142,
3388	F1A6	WTSEQ                         		  4041,
3391	F1AB	WTSEQ1                        		  3682,  4186,
3515	F27A	WTSEQ10                       		  3507,
3541	F2A6	WTSEQ11                       		  3538,
3543	F2A8	WTSEQ12                       		  3529,  3532,
3415	F1E3	WTSEQ2                        		  3409,
3422	F1F0	WTSEQ3                        		  3419,
3435	F20C	WTSEQ4                        		  3431,
3443	F214	WTSEQ5                        		  3434,
3445	F216	WTSEQ6                        		  3404,
3469	F234	WTSEQ7                        		  3473,
3477	F242	WTSEQ8                        		  3490,
3498	F263	WTSEQ9                        		  3454,  3465,
3527	F287	WTSEQ99                       		

4231	F5C8	XLATE                         		  2102,  2248,

1054	E520	YESNO                         		  1035,
