0001: 0000                                    
0002: 0000                ;**************************************************************
0003: 0000                ;*                  
0004: 0000                ;*             C P / M   version   2 . 2
0005: 0000                ;*                    Sourced from:
0006: 0000                ;*  Reconstructed from memory image on February 27, 1981
0007: 0000                ;*                by Clark A. Calkins
0008: 0000                ;*                  
0009: 0000                ;**************************************************************
0010: 0000                ;                   
0011: 0000                                    
0012: 0000                ;                   
0013: 0000                MEM	EQU	64	;for a 64k system 
0014: 0000                ;                   
0015: 0000                IOBYTE	EQU	3	;i/o definition byte.
0016: 0000                TDRIVE	EQU	4	;current drive name and user number.
0017: 0000                ENTRY	EQU	5	;entry point for the cp/m bdos.
0018: 0000                TFCB	EQU	5CH	;default file control block.
0019: 0000                Pg0Buffer	EQU	80H	;i/o buffer and command line storage.
0020: 0000                TBASE	EQU	100H	;transiant program storage area.
0021: 0000                ;                   
0022: 0000                ;   Set control character equates.
0023: 0000                ;                   
0024: 0000                CNTRLC	EQU	3	;control-c
0025: 0000                CNTRLE	EQU	05H	;control-e
0026: 0000                BS	EQU	08H	;backspace
0027: 0000                TAB	EQU	09H	;tab    
0028: 0000                LF	EQU	0AH	;line feed
0029: 0000                FF	EQU	0CH	;form feed
0030: 0000                CR	EQU	0DH	;carriage return
0031: 0000                CNTRLP	EQU	10H	;control-p
0032: 0000                CNTRLR	EQU	12H	;control-r
0033: 0000                CNTRLS	EQU	13H	;control-s
0034: 0000                CNTRLU	EQU	15H	;control-u
0035: 0000                CNTRLX	EQU	18H	;control-x
0036: 0000                CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
0037: 0000                DEL	EQU	7FH	;rubout 
0038: 0000                ;                   
0039: 0000                BLANK	EQU	020H	; Space/Blank
0040: 0000                BRACKETLEFT		EQU	07BH	; {
0041: 0000                BRACKETRIGHT	EQU	07DH	; }
0042: 0000                QMARK	EQU		03FH		; ?
0043: 0000                EQUALS	EQU		03DH		; =
0044: 0000                USCORE	EQU		05FH		; _
0045: 0000                PERIOD	EQU		02EH		; .
0046: 0000                COLON	EQU		03AH		; :
0047: 0000                SEMIC	EQU		03BH		; ;
0048: 0000                LESSTH	EQU		03CH		; <
0049: 0000                GRTTHAN	EQU		03EH		; >
0050: 0000                ASTRK	EQU		02AH		; *
0051: 0000                CARET	EQU		05EH		; ^
0052: 0000                ATSIGN	EQU		040H		; @
0053: 0000                POUNDSN	EQU		023H		; #
0054: 0000                DOLLAR	EQU		024H		; $
0055: 0000                                    
0056: 0000                ;                   
0057: 0000                ;   Set origin for CP/M
0058: 0000                ;                   
0059: 0000                	ORG	(MEM-8)*1024   
0060: E000                CodeStart:          
0061: E000                ;                   
0062: E000                CBASE:              
0063: E000     C35CE3     	JMP	COMMAND	;execute command processor (ccp).
0064: E003     C358E3     	JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
0065: E006                                    
0066: E006                ;                   
0067: E006                ;   Standard cp/m ccp input buffer. Format is (max length),
0068: E006                ; (actual length), (char #1), (char #2), (char #3), etc.
0069: E006                ;                   
0070: E006                INBUFF:             
0071: E006     7F         	DB	127	;length of input buffer.
0072: E007     00         	DB	0	;current length of contents.
0073: E008     434F50595249474854 	DB	'Copyright'     
0074: E011     203139373920284329204259204449474954414C205245534541524348202020202020 	DB	' 1979 (c) by Digital Research      '
0075: E034     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0076: E04B     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0077: E062     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0078: E079     000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0079: E088                INPOINT:            
0080: E088     08E0       	DW	INBUFF+2;input line pointer
0081: E08A                NAMEPNT:            
0082: E08A     0000       	DW	0	;input line pointer used for error message. Points to
0083: E08C                ;			;start of name in error.
0084: E08C                ;                   
0085: E08C                ;   Routine to print (A) on the console. All registers used.
0086: E08C                ;                   
0087: E08C                PRINT:              
0088: E08C     5F         	MOV	E,A	;setup bdos call.
0089: E08D     0E02       	MVI	C,2            
0090: E08F     C30500     	JMP	ENTRY          
0091: E092                ;                   
0092: E092                ;   Routine to print (A) on the console and to save (BC).
0093: E092                ;                   
0094: E092                PRINTB:             
0095: E092     C5         	PUSH	B             
0096: E093     CD8CE0     	CALL	PRINT         
0097: E096     C1         	POP	B              
0098: E097     C9         	RET                
0099: E098                ;                   
0100: E098                ;   Routine to send a carriage return, line feed combination
0101: E098                ; to the console.   
0102: E098                ;                   
0103: E098                CRLF:               
0104: E098     3E0D       	MVI	A,CR           
0105: E09A     CD92E0     	CALL	PRINTB        
0106: E09D     3E0A       	MVI	A,LF           
0107: E09F     C392E0     	JMP	PRINTB         
0108: E0A2                ;                   
0109: E0A2                ;   Routine to send one space to the console and save (BC).
0110: E0A2                ;                   
0111: E0A2                SPACE:              
0112: E0A2     3E20       	MVI	A,BLANK		; blank/Space
0113: E0A4     C392E0     	JMP	PRINTB         
0114: E0A7                ;                   
0115: E0A7                ;   Routine to print character string pointed to be (BC) on the
0116: E0A7                ; console. It must terminate with a null byte.
0117: E0A7                ;                   
0118: E0A7                PLINE:              
0119: E0A7     C5         	PUSH	B             
0120: E0A8     CD98E0     	CALL	CRLF          
0121: E0AB     E1         	POP	H              
0122: E0AC                PLINE2:             
0123: E0AC     7E         	MOV	A,M            
0124: E0AD     B7         	ORA	A              
0125: E0AE     C8         	RZ                 
0126: E0AF     23         	INX	H              
0127: E0B0     E5         	PUSH	H             
0128: E0B1     CD8CE0     	CALL	PRINT         
0129: E0B4     E1         	POP	H              
0130: E0B5     C3ACE0     	JMP	PLINE2         
0131: E0B8                ;                   
0132: E0B8                ;   Routine to reset the disk system.
0133: E0B8                ;                   
0134: E0B8                RESDSK:             
0135: E0B8     0E0D       	MVI			C,13         
0136: E0BA     C30500     	JMP			ENTRY        
0137: E0BD                ;                   
0138: E0BD                ;   Routine to select disk (A).
0139: E0BD                ;                   
0140: E0BD                DSKSEL:             
0141: E0BD     5F         	MOV	E,A            
0142: E0BE     0E0E       	MVI	C,14           
0143: E0C0     C30500     	JMP	ENTRY          
0144: E0C3                ;                   
0145: E0C3                ;   Routine to call bdos and save the return code. The zero
0146: E0C3                ; flag is set on a return of 0ffh.
0147: E0C3                ;                   
0148: E0C3                ENTRY1:             
0149: E0C3     CD0500     	CALL	ENTRY         
0150: E0C6     32EEE7     	STA	RTNCODE	;save return code.
0151: E0C9     3C         	INR	A	;set zero if 0ffh returned.
0152: E0CA     C9         	RET                
0153: E0CB                ;                   
0154: E0CB                ;   Routine to open a file. (DE) must point to the FCB.
0155: E0CB                ;                   
0156: E0CB                OPEN:               
0157: E0CB     0E0F       	MVI	C,15           
0158: E0CD     C3C3E0     	JMP	ENTRY1         
0159: E0D0                ;                   
0160: E0D0                ;   Routine to open file at (FCB).
0161: E0D0                ;                   
0162: E0D0                OPENFCB:            
0163: E0D0     AF         	XRA	A	;clear the record number byte at fcb+32
0164: E0D1     32EDE7     	STA	FCB+32         
0165: E0D4     11CDE7     	LXI	D,FCB          
0166: E0D7     C3CBE0     	JMP	OPEN           
0167: E0DA                ;                   
0168: E0DA                ;   Routine to close a file. (DE) points to FCB.
0169: E0DA                ;                   
0170: E0DA                CLOSE:              
0171: E0DA     0E10       	MVI	C,16           
0172: E0DC     C3C3E0     	JMP	ENTRY1         
0173: E0DF                ;                   
0174: E0DF                ;   Routine to search for the first file with ambigueous name
0175: E0DF                ; (DE).             
0176: E0DF                ;                   
0177: E0DF                SRCHFST:            
0178: E0DF     0E11       	MVI	C,17           
0179: E0E1     C3C3E0     	JMP	ENTRY1         
0180: E0E4                ;                   
0181: E0E4                ;   Search for the next ambigeous file name.
0182: E0E4                ;                   
0183: E0E4                SRCHNXT:            
0184: E0E4     0E12       	MVI	C,18           
0185: E0E6     C3C3E0     	JMP	ENTRY1         
0186: E0E9                ;                   
0187: E0E9                ;   Search for file at (FCB).
0188: E0E9                ;                   
0189: E0E9                SRCHFCB:            
0190: E0E9     11CDE7     	LXI	D,FCB          
0191: E0EC     C3DFE0     	JMP	SRCHFST        
0192: E0EF                ;                   
0193: E0EF                ;   Routine to delete a file pointed to by (DE).
0194: E0EF                ;                   
0195: E0EF                DELETE:             
0196: E0EF     0E13       	MVI	C,19           
0197: E0F1     C30500     	JMP	ENTRY          
0198: E0F4                ;                   
0199: E0F4                ;   Routine to call the bdos and set the zero flag if a zero
0200: E0F4                ; status is returned.
0201: E0F4                ;                   
0202: E0F4                ENTRY2:             
0203: E0F4     CD0500     	CALL	ENTRY         
0204: E0F7     B7         	ORA	A	;set zero flag if appropriate.
0205: E0F8     C9         	RET                
0206: E0F9                ;                   
0207: E0F9                ;   Routine to read the next record from a sequential file.
0208: E0F9                ; (DE) points to the FCB.
0209: E0F9                ;                   
0210: E0F9                RDREC:              
0211: E0F9     0E14       	MVI	C,20           
0212: E0FB     C3F4E0     	JMP	ENTRY2         
0213: E0FE                ;                   
0214: E0FE                ;   Routine to read file at (FCB).
0215: E0FE                ;                   
0216: E0FE                READFCB:            
0217: E0FE     11CDE7     	LXI	D,FCB          
0218: E101     C3F9E0     	JMP	RDREC          
0219: E104                ;                   
0220: E104                ;   Routine to write the next record of a sequential file.
0221: E104                ; (DE) points to the FCB.
0222: E104                ;                   
0223: E104                WRTREC:             
0224: E104     0E15       	MVI	C,21           
0225: E106     C3F4E0     	JMP	ENTRY2         
0226: E109                ;                   
0227: E109                ;   Routine to create the file pointed to by (DE).
0228: E109                ;                   
0229: E109                CREATE:             
0230: E109     0E16       	MVI	C,22           
0231: E10B     C3C3E0     	JMP	ENTRY1         
0232: E10E                ;                   
0233: E10E                ;   Routine to rename the file pointed to by (DE). Note that
0234: E10E                ; the new name starts at (DE+16).
0235: E10E                ;                   
0236: E10E                RENAM:              
0237: E10E     0E17       	MVI	C,23           
0238: E110     C30500     	JMP	ENTRY          
0239: E113                ;                   
0240: E113                ;   Get the current user code.
0241: E113                ;                   
0242: E113                GETUSR:             
0243: E113     1EFF       	MVI			E,0FFH			; make it get
0244: E115                ;                   
0245: E115                ;   Routine to get or set the current user code.
0246: E115                ; If (E) is FF then this is a GET, else it is a SET.
0247: E115                ;                   
0248: E115                GETSETUC:           
0249: E115     0E20       	MVI			C,32			; BDOS vector
0250: E117     C30500     	JMP	ENTRY          
0251: E11A                ;                   
0252: E11A                ;   Routine to set the current drive byte at (TDRIVE).
0253: E11A                ;                   
0254: E11A                SETCDRV:            
0255: E11A     CD13E1     	CALL	GETUSR	;get user number
0256: E11D     87         	ADD	A	;and shift into the upper 4 bits.
0257: E11E     87         	ADD	A              
0258: E11F     87         	ADD	A              
0259: E120     87         	ADD	A              
0260: E121     21EFE7     	LXI	H,CDRIVE;now add in the current drive number.
0261: E124     B6         	ORA	M              
0262: E125     320400     	STA	TDRIVE	;and save.
0263: E128     C9         	RET                
0264: E129                ;                   
0265: E129                ;   Move currently active drive down to (TDRIVE).
0266: E129                ;                   
0267: E129                MOVECD:             
0268: E129     3AEFE7     	LDA	CDRIVE         
0269: E12C     320400     	STA	TDRIVE         
0270: E12F     C9         	RET                
0271: E130                ;                   
0272: E130                ;   Routine to convert (A) into upper case ascii. Only letters
0273: E130                ; are affected.     
0274: E130                ;                   
0275: E130                UPPER:              
0276: E130     FE61       	CPI	061H	; 'a'	;check for letters in the range of 'a' to 'z'.
0277: E132     D8         	RC                 
0278: E133     FE7B       	CPI	BRACKETLEFT		;'{'
0279: E135     D0         	RNC                
0280: E136     E65F       	ANI	5FH	;convert it if found.
0281: E138     C9         	RET                
0282: E139                ;                   
0283: E139                ;   Routine to get a line of input. We must check to see if the
0284: E139                ; user is in (BATCH) mode. If so, then read the input from file
0285: E139                ; ($$$.SUB). At the end, reset to console input.
0286: E139                ;                   
0287: E139                GETINP:             
0288: E139     3AABE7     	LDA	BATCH	;if =0, then use console input.
0289: E13C     B7         	ORA	A              
0290: E13D     CA96E1     	JZ	GETINP1         
0291: E140                ;                   
0292: E140                ;   Use the submit file ($$$.sub) which is prepared by a
0293: E140                ; SUBMIT run. It must be on drive (A) and it will be deleted
0294: E140                ; if and error occures (like eof).
0295: E140                ;                   
0296: E140     3AEFE7     	LDA	CDRIVE	;select drive 0 if need be.
0297: E143     B7         	ORA	A              
0298: E144     3E00       	MVI	A,0	;always use drive A for submit.
0299: E146     C4BDE0     	CNZ	DSKSEL	;select it if required.
0300: E149     11ACE7     	LXI	D,BATCHFCB     
0301: E14C     CDCBE0     	CALL	OPEN	;look for it.
0302: E14F     CA96E1     	JZ	GETINP1	;if not there, use normal input.
0303: E152     3ABBE7     	LDA	BATCHFCB+15;get last record number+1.
0304: E155     3D         	DCR	A              
0305: E156     32CCE7     	STA	BATCHFCB+32    
0306: E159     11ACE7     	LXI	D,BATCHFCB     
0307: E15C     CDF9E0     	CALL	RDREC	;read last record.
0308: E15F     C296E1     	JNZ	GETINP1	;quit on end of file.
0309: E162                ;                   
0310: E162                ;   Move this record into input buffer.
0311: E162                ;                   
0312: E162     1107E0     	LXI	D,INBUFF+1     
0313: E165     218000     	LXI	H,Pg0Buffer	;data was read into buffer here.
0314: E168     0680       	MVI	B,128	;all 128 characters may be used.
0315: E16A     CD42E4     	CALL	HL2DE	;(HL) to (DE), (B) bytes.
0316: E16D     21BAE7     	LXI	H,BATCHFCB+14  
0317: E170     3600       	MVI	M,0	;zero out the 's2' byte.
0318: E172     23         	INX	H	;and decrement the record count.
0319: E173     35         	DCR	M              
0320: E174     11ACE7     	LXI	D,BATCHFCB;close the batch file now.
0321: E177     CDDAE0     	CALL	CLOSE         
0322: E17A     CA96E1     	JZ	GETINP1	;quit on an error.
0323: E17D     3AEFE7     	LDA	CDRIVE	;re-select previous drive if need be.
0324: E180     B7         	ORA	A              
0325: E181     C4BDE0     	CNZ	DSKSEL	;don't do needless selects.
0326: E184                ;                   
0327: E184                ;   Print line just read on console.
0328: E184                ;                   
0329: E184     2108E0     	LXI	H,INBUFF+2     
0330: E187     CDACE0     	CALL	PLINE2        
0331: E18A     CDC2E1     	CALL	CHKCON	;check console, quit on a key.
0332: E18D     CAA7E1     	JZ	GETINP2	;jump if no key is pressed.
0333: E190                ;                   
0334: E190                ;   Terminate the submit job on any keyboard input. Delete this
0335: E190                ; file such that it is not re-started and jump to normal keyboard
0336: E190                ; input section.    
0337: E190                ;                   
0338: E190     CDDDE1     	CALL	DELBATCH;delete the batch file.
0339: E193     C382E3     	JMP	CMMND1	;and restart command input.
0340: E196                ;                   
0341: E196                ;   Get here for normal keyboard input. Delete the submit file
0342: E196                ; incase there was one.
0343: E196                ;                   
0344: E196                GETINP1:            
0345: E196     CDDDE1     	CALL	DELBATCH;delete file ($$$.sub).
0346: E199     CD1AE1     	CALL	SETCDRV	;reset active disk.
0347: E19C     0E0A       	MVI	C,10	;get line from console device.
0348: E19E     1106E0     	LXI	D,INBUFF       
0349: E1A1     CD0500     	CALL	ENTRY         
0350: E1A4     CD29E1     	CALL	MOVECD	;reset current drive (again).
0351: E1A7                ;                   
0352: E1A7                ;   Convert input line to upper case.
0353: E1A7                ;                   
0354: E1A7                GETINP2:            
0355: E1A7     2107E0     	LXI	H,INBUFF+1     
0356: E1AA     46         	MOV	B,M	;(B)=character counter.
0357: E1AB                GETINP3:            
0358: E1AB     23         	INX	H              
0359: E1AC     78         	MOV	A,B	;end of the line?
0360: E1AD     B7         	ORA	A              
0361: E1AE     CABAE1     	JZ	GETINP4         
0362: E1B1     7E         	MOV	A,M	;convert to upper case.
0363: E1B2     CD30E1     	CALL	UPPER         
0364: E1B5     77         	MOV	M,A            
0365: E1B6     05         	DCR	B	;adjust character count.
0366: E1B7     C3ABE1     	JMP	GETINP3        
0367: E1BA                GETINP4:            
0368: E1BA     77         	MOV	M,A	;add trailing null.
0369: E1BB     2108E0     	LXI	H,INBUFF+2     
0370: E1BE     2288E0     	SHLD	INPOINT	;reset input line pointer.
0371: E1C1     C9         	RET                
0372: E1C2                ;                   
0373: E1C2                ;   Routine to check the console for a key pressed. The zero
0374: E1C2                ; flag is set is none, else the character is returned in (A).
0375: E1C2                ;                   
0376: E1C2                CHKCON:             
0377: E1C2     0E0B       	MVI	C,11	;check console.
0378: E1C4     CD0500     	CALL	ENTRY         
0379: E1C7     B7         	ORA	A              
0380: E1C8     C8         	RZ		;return if nothing.
0381: E1C9     0E01       	MVI	C,1	;else get character.
0382: E1CB     CD0500     	CALL	ENTRY         
0383: E1CE     B7         	ORA	A	;clear zero flag and return.
0384: E1CF     C9         	RET                
0385: E1D0                ;                   
0386: E1D0                ;   Routine to get the currently active drive number.
0387: E1D0                ;                   
0388: E1D0                GETDSK:             
0389: E1D0     0E19       	MVI	C,25           
0390: E1D2     C30500     	JMP	ENTRY          
0391: E1D5                ;                   
0392: E1D5                ;   Set the stabdard dma address.
0393: E1D5                ;                   
0394: E1D5                STDDMA:             
0395: E1D5     118000     	LXI	D,Pg0Buffer    
0396: E1D8                ;                   
0397: E1D8                ;   Routine to set the dma address to (DE).
0398: E1D8                ;                   
0399: E1D8                DMASET:             
0400: E1D8     0E1A       	MVI	C,26           
0401: E1DA     C30500     	JMP	ENTRY          
0402: E1DD                ;                   
0403: E1DD                ;  Delete the batch file created by SUBMIT.
0404: E1DD                ;                   
0405: E1DD                DELBATCH:           
0406: E1DD     21ABE7     LXI	H,BATCH	;is batch active?
0407: E1E0     7E         	MOV	A,M            
0408: E1E1     B7         	ORA	A              
0409: E1E2     C8         	RZ                 
0410: E1E3     3600       	MVI	M,0	;yes, de-activate it.
0411: E1E5     AF         	XRA	A              
0412: E1E6     CDBDE0     	CALL	DSKSEL	;select drive 0 for sure.
0413: E1E9     11ACE7     	LXI	D,BATCHFCB;and delete this file.
0414: E1EC     CDEFE0     	CALL	DELETE        
0415: E1EF     3AEFE7     	LDA	CDRIVE	;reset current drive.
0416: E1F2     C3BDE0     	JMP	DSKSEL         
0417: E1F5                ;                   
0418: E1F5                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0419: E1F5                ; the same or we halt....
0420: E1F5                ;                   
0421: E1F5                VERIFY:             
0422: E1F5     1128E3     	LXI	D,PATTRN1;these are the serial number bytes.
0423: E1F8     2100E8     	LXI	H,PATTRN2;ditto, but how could they be different?
0424: E1FB     0606       	MVI	B,6	;6 bytes each.
0425: E1FD                VERIFY1:            
0426: E1FD     1A         	LDAX	D             
0427: E1FE     BE         	CMP	M              
0428: E1FF     C2CFE3     	JNZ	HALT	;jump to halt routine.
0429: E202     13         	INX	D              
0430: E203     23         	INX	H              
0431: E204     05         	DCR	B              
0432: E205     C2FDE1     	JNZ	VERIFY1        
0433: E208     C9         	RET                
0434: E209                ;                   
0435: E209                ;   Print back file name with a '?' to indicate a syntax error.
0436: E209                ;                   
0437: E209                SYNERR:             
0438: E209     CD98E0     	CALL	CRLF	;end current line.
0439: E20C     2A8AE0     	LHLD	NAMEPNT	;this points to name in error.
0440: E20F                SYNERR1:            
0441: E20F     7E         	MOV	A,M	;print it until a space or null is found.
0442: E210     FE20       	CPI	BLANK		; Space 
0443: E212     CA22E2     	JZ	SYNERR2         
0444: E215     B7         	ORA	A              
0445: E216     CA22E2     	JZ	SYNERR2         
0446: E219     E5         	PUSH	H             
0447: E21A     CD8CE0     	CALL	PRINT         
0448: E21D     E1         	POP	H              
0449: E21E     23         	INX	H              
0450: E21F     C30FE2     	JMP	SYNERR1        
0451: E222                SYNERR2:            
0452: E222     3E3F       	MVI	A,QMARK		;add trailing '?'.
0453: E224     CD8CE0     	CALL	PRINT         
0454: E227     CD98E0     	CALL	CRLF          
0455: E22A     CDDDE1     	CALL	DELBATCH;delete any batch file.
0456: E22D     C382E3     	JMP	CMMND1	;and restart from console input.
0457: E230                ;                   
0458: E230                ;   Check character at (DE) for legal command input. Note that the
0459: E230                ; zero flag is set if the character is a delimiter.
0460: E230                ;                   
0461: E230                CHECK:              
0462: E230     1A         	LDAX	D             
0463: E231     B7         	ORA	A              
0464: E232     C8         	RZ                 
0465: E233     FE20       	CPI	BLANK	;control characters are not legal here.
0466: E235     DA09E2     	JC	SYNERR          
0467: E238     C8         	RZ		;check for valid delimiter.
0468: E239     FE3D       	CPI	EQUALS		; '='  
0469: E23B     C8         	RZ                 
0470: E23C     FE5F       	CPI	USCORE		; '_'  
0471: E23E     C8         	RZ                 
0472: E23F     FE2E       	CPI	PERIOD		; '.'  
0473: E241     C8         	RZ                 
0474: E242     FE3A       	CPI	COLON		; ':'   
0475: E244     C8         	RZ                 
0476: E245     FE3B       	CPI	SEMIC		; ';'   
0477: E247     C8         	RZ                 
0478: E248     FE3C       	CPI	LESSTH		; '<'  
0479: E24A     C8         	RZ                 
0480: E24B     FE3E       	CPI	GRTTHAN		; '>' 
0481: E24D     C8         	RZ                 
0482: E24E     C9         	RET                
0483: E24F                ;                   
0484: E24F                ;   Get the next non-blank character from (DE).
0485: E24F                ;                   
0486: E24F                NONBLANK:           
0487: E24F     1A         LDAX	D              
0488: E250     B7         	ORA	A	;string ends with a null.
0489: E251     C8         	RZ                 
0490: E252     FE20       	CPI	BLANK          
0491: E254     C0         	RNZ                
0492: E255     13         	INX	D              
0493: E256     C34FE2     	JMP	NONBLANK       
0494: E259                ;                   
0495: E259                ;   Add (HL)=(HL)+(A)
0496: E259                ;                   
0497: E259                ADDHL:              
0498: E259     85         	ADD	L              
0499: E25A     6F         	MOV	L,A            
0500: E25B     D0         	RNC	;take care of any carry.
0501: E25C     24         	INR	H              
0502: E25D     C9         	RET                
0503: E25E                ;                   
0504: E25E                ;   Convert the first name in (FCB).
0505: E25E                ;                   
0506: E25E                CONVFST:            
0507: E25E     3E00       	MVI	A,0            
0508: E260                ;                   
0509: E260                ;   Format a file name (convert * to '?', etc.). On return,
0510: E260                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0511: E260                ; the position within the fcb for the name (either 0 or 16).
0512: E260                ;                   
0513: E260                CONVERT:            
0514: E260     21CDE7     	LXI	H,FCB          
0515: E263     CD59E2     	CALL	ADDHL         
0516: E266     E5         	PUSH	H             
0517: E267     E5         	PUSH	H             
0518: E268     AF         	XRA	A              
0519: E269     32F0E7     	STA	CHGDRV	;initialize drive change flag.
0520: E26C     2A88E0     	LHLD	INPOINT	;set (HL) as pointer into input line.
0521: E26F     EB         	XCHG               
0522: E270     CD4FE2     	CALL	NONBLANK;get next non-blank character.
0523: E273     EB         	XCHG               
0524: E274     228AE0     	SHLD	NAMEPNT	;save pointer here for any error message.
0525: E277     EB         	XCHG               
0526: E278     E1         	POP	H              
0527: E279     1A         	LDAX	D	;get first character.
0528: E27A     B7         	ORA	A              
0529: E27B     CA89E2     	JZ	CONVRT1         
0530: E27E     DE40       	SBI	040H		;'A'-1	;might be a drive name, convert to binary.
0531: E280     47         	MOV	B,A	;and save. 
0532: E281     13         	INX	D	;check next character for a ':'.
0533: E282     1A         	LDAX	D             
0534: E283     FE3A       	CPI	COLON		;':'    
0535: E285     CA90E2     	JZ	CONVRT2         
0536: E288     1B         	DCX	D	;nope, move pointer back to the start of the line.
0537: E289                CONVRT1:            
0538: E289     3AEFE7     	LDA	CDRIVE         
0539: E28C     77         	MOV	M,A            
0540: E28D     C396E2     	JMP	CONVRT3        
0541: E290                CONVRT2:            
0542: E290     78         	MOV	A,B            
0543: E291     32F0E7     	STA	CHGDRV	;set change in drives flag.
0544: E294     70         	MOV	M,B            
0545: E295     13         	INX	D              
0546: E296                ;                   
0547: E296                ;   Convert the basic file name.
0548: E296                ;                   
0549: E296                CONVRT3:            
0550: E296     0608       	MVI	B,08H          
0551: E298                CONVRT4:            
0552: E298     CD30E2     	CALL	CHECK         
0553: E29B     CAB9E2     	JZ	CONVRT8         
0554: E29E     23         	INX	H              
0555: E29F     FE2A       	CPI	ASTRK		; '*'	;note that an '*' will fill the remaining
0556: E2A1     C2A9E2     	JNZ	CONVRT5	;field with '?'.
0557: E2A4     363F       	MVI	M,QMARK		; '?' 
0558: E2A6     C3ABE2     	JMP	CONVRT6        
0559: E2A9                CONVRT5:            
0560: E2A9     77         	MOV	M,A            
0561: E2AA     13         	INX	D              
0562: E2AB                CONVRT6:            
0563: E2AB     05         	DCR	B              
0564: E2AC     C298E2     	JNZ	CONVRT4        
0565: E2AF                CONVRT7:            
0566: E2AF     CD30E2     	CALL	CHECK	;get next delimiter.
0567: E2B2     CAC0E2     	JZ	GETEXT          
0568: E2B5     13         	INX	D              
0569: E2B6     C3AFE2     	JMP	CONVRT7        
0570: E2B9                CONVRT8:            
0571: E2B9     23         	INX	H	;blank fill the file name.
0572: E2BA     3620       	MVI	M,BLANK        
0573: E2BC     05         	DCR	B              
0574: E2BD     C2B9E2     	JNZ	CONVRT8        
0575: E2C0                ;                   
0576: E2C0                ;   Get the extension and convert it.
0577: E2C0                ;                   
0578: E2C0                GETEXT:             
0579: E2C0     0603       	MVI	B,03H          
0580: E2C2     FE2E       	CPI	PERIOD		; '.'  
0581: E2C4     C2E9E2     	JNZ	GETEXT5        
0582: E2C7     13         	INX	D              
0583: E2C8                GETEXT1:            
0584: E2C8     CD30E2     	CALL	CHECK         
0585: E2CB     CAE9E2     	JZ	GETEXT5         
0586: E2CE     23         	INX	H              
0587: E2CF     FE2A       	CPI	ASTRK		; '*'   
0588: E2D1     C2D9E2     	JNZ	GETEXT2        
0589: E2D4     363F       	MVI	M,QMARK		;'?'  
0590: E2D6     C3DBE2     	JMP	GETEXT3        
0591: E2D9                GETEXT2:            
0592: E2D9     77         	MOV	M,A            
0593: E2DA     13         	INX	D              
0594: E2DB                GETEXT3:            
0595: E2DB     05         	DCR	B              
0596: E2DC     C2C8E2     	JNZ	GETEXT1        
0597: E2DF                GETEXT4:            
0598: E2DF     CD30E2     	CALL	CHECK         
0599: E2E2     CAF0E2     	JZ	GETEXT6         
0600: E2E5     13         	INX	D              
0601: E2E6     C3DFE2     	JMP	GETEXT4        
0602: E2E9                GETEXT5:            
0603: E2E9     23         	INX	H              
0604: E2EA     3620       	MVI	M,BLANK        
0605: E2EC     05         	DCR	B              
0606: E2ED     C2E9E2     	JNZ	GETEXT5        
0607: E2F0                GETEXT6:            
0608: E2F0     0603       	MVI	B,3            
0609: E2F2                GETEXT7:            
0610: E2F2     23         	INX	H              
0611: E2F3     3600       	MVI	M,0            
0612: E2F5     05         	DCR	B              
0613: E2F6     C2F2E2     	JNZ	GETEXT7        
0614: E2F9     EB         	XCHG               
0615: E2FA     2288E0     	SHLD	INPOINT	;save input line pointer.
0616: E2FD     E1         	POP	H              
0617: E2FE                ;                   
0618: E2FE                ;   Check to see if this is an ambigeous file name specification.
0619: E2FE                ; Set the (A) register to non zero if it is.
0620: E2FE                ;                   
0621: E2FE     010B00     	LXI	B,11	;set name length.
0622: E301                GETEXT8:            
0623: E301     23         	INX	H              
0624: E302     7E         	MOV	A,M            
0625: E303     FE3F       	CPI	QMARK		; '?'	;any question marks?
0626: E305     C209E3     	JNZ	GETEXT9        
0627: E308     04         	INR	B	;count them. 
0628: E309                GETEXT9:            
0629: E309     0D         	DCR	C              
0630: E30A     C201E3     	JNZ	GETEXT8        
0631: E30D     78         	MOV	A,B            
0632: E30E     B7         	ORA	A              
0633: E30F     C9         	RET                
0634: E310                ;                   
0635: E310                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0636: E310                ;                   
0637: E310                NUMCMDS	EQU	6	;number of commands
0638: E310                CMDTBL:             
0639: E310     44495220   	DB	'DIR '          
0640: E314     45524120   	DB	'ERA '          
0641: E318     54595045   	DB	'TYPE'          
0642: E31C     53415645   	DB	'SAVE'          
0643: E320     52454E20   	DB	'REN '          
0644: E324     55534552   	DB	'USER'          
0645: E328                ;                   
0646: E328                ;   The following six bytes must agree with those at (PATTRN2)
0647: E328                ; or cp/m will HALT. Why?
0648: E328                ;                   
0649: E328                PATTRN1:            
0650: E328     001600000000 	DB	0,22,0,0,0,0;(* serial number bytes *).
0651: E32E                ;                   
0652: E32E                ;   Search the command table for a match with what has just
0653: E32E                ; been entered. If a match is found, then we jump to the
0654: E32E                ; proper section. Else jump to (UNKNOWN).
0655: E32E                ; On return, the (C) register is set to the command number
0656: E32E                ; that matched (or NUMCMDS+1 if no match).
0657: E32E                ;                   
0658: E32E                SEARCH:             
0659: E32E     2110E3     	LXI	H,CMDTBL       
0660: E331     0E00       	MVI	C,0            
0661: E333                SEARCH1:            
0662: E333     79         	MOV	A,C            
0663: E334     FE06       	CPI	NUMCMDS	;this commands exists.
0664: E336     D0         	RNC                
0665: E337     11CEE7     	LXI	D,FCB+1	;check this one.
0666: E33A     0604       	MVI	B,4	;max command length.
0667: E33C                SEARCH2:            
0668: E33C     1A         	LDAX	D             
0669: E33D     BE         	CMP	M              
0670: E33E     C24FE3     	JNZ	SEARCH3	;not a match.
0671: E341     13         	INX	D              
0672: E342     23         	INX	H              
0673: E343     05         	DCR	B              
0674: E344     C23CE3     	JNZ	SEARCH2        
0675: E347     1A         	LDAX	D	;allow a 3 character command to match.
0676: E348     FE20       	CPI	BLANK          
0677: E34A     C254E3     	JNZ	SEARCH4        
0678: E34D     79         	MOV	A,C	;set return register for this command.
0679: E34E     C9         	RET                
0680: E34F                SEARCH3:            
0681: E34F     23         	INX	H              
0682: E350     05         	DCR	B              
0683: E351     C24FE3     	JNZ	SEARCH3        
0684: E354                SEARCH4:            
0685: E354     0C         	INR	C              
0686: E355     C333E3     	JMP	SEARCH1        
0687: E358                ;                   
0688: E358                ;   Set the input buffer to empty and then start the command
0689: E358                ; processor (ccp).  
0690: E358                ;                   
0691: E358                CLEARBUF:           
0692: E358     AF         XRA	A               
0693: E359     3207E0     	STA	INBUFF+1;second byte is actual length.
0694: E35C                ;                   
0695: E35C                ;**************************************************************
0696: E35C                ;*                  
0697: E35C                ;*                  
0698: E35C                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0699: E35C                ;*                  
0700: E35C                ;                   
0701: E35C                ;   On entry (C) points at Current disk & user (defaultDisk 0004)
0702: E35C                ;**************************************************************
0703: E35C                ;*                  
0704: E35C                COMMAND:            
0705: E35C     31ABE7     	LXI			SP,CCPStack				; Use dedicated stack space.
0706: E35F     C5         	PUSH		B						; (C) should be equal to currentDisk where:
0707: E360     79         	MOV			A,C						; (uuuudddd) where 'uuuu' is the user number
0708: E361     1F         	RAR									; and 'dddd' is the drive number.
0709: E362     1F         	RAR                
0710: E363     1F         	RAR                
0711: E364     1F         	RAR                
0712: E365     E60F       	ANI			0FH						; isolate the user number.
0713: E367     5F         	MOV			E,A						; put into E for call
0714: E368     CD15E1     	CALL	GETSETUC					; to the current user
0715: E36B     CDB8E0     	CALL	RESDSK						;reset the disk system.
0716: E36E     32ABE7     	STA	BATCH	;clear batch mode flag.
0717: E371     C1         	POP	B              
0718: E372     79         	MOV	A,C            
0719: E373     E60F       	ANI	0FH	;isolate the drive number.
0720: E375     32EFE7     	STA	CDRIVE	;and save.
0721: E378     CDBDE0     	CALL	DSKSEL	;...and select.
0722: E37B     3A07E0     	LDA	INBUFF+1       
0723: E37E     B7         	ORA	A	;anything in input buffer already?
0724: E37F     C298E3     	JNZ	CMMND2	;yes, we just process it.
0725: E382                ;                   
0726: E382                ;   Entry point to get a command line from the console.
0727: E382                ;                   
0728: E382                CMMND1:             
0729: E382     31ABE7     	LXI	SP,CCPStack;set stack straight.
0730: E385     CD98E0     	CALL	CRLF	;start a new line on the screen.
0731: E388     CDD0E1     	CALL	GETDSK	;get current drive.
0732: E38B     C661       	ADI	061H		; 'a'    
0733: E38D     CD8CE0     	CALL	PRINT	;print current drive.
0734: E390     3E3E       	MVI	A,GRTTHAN	; '>'
0735: E392     CD8CE0     	CALL	PRINT	;and add prompt.
0736: E395     CD39E1     	CALL	GETINP	;get line from user.
0737: E398                ;                   
0738: E398                ;   Process command line here.
0739: E398                ;                   
0740: E398                CMMND2:             
0741: E398     118000     	LXI	D,Pg0Buffer    
0742: E39B     CDD8E1     	CALL	DMASET	;set standard dma address.
0743: E39E     CDD0E1     	CALL	GETDSK        
0744: E3A1     32EFE7     	STA	CDRIVE	;set current drive.
0745: E3A4     CD5EE2     	CALL	CONVFST	;convert name typed in.
0746: E3A7     C409E2     	CNZ	SYNERR	;wild cards are not allowed.
0747: E3AA     3AF0E7     	LDA	CHGDRV	;if a change in drives was indicated,
0748: E3AD     B7         	ORA	A	;then treat this as an unknown command
0749: E3AE     C2A5E6     	JNZ	UNKNOWN	;which gets executed.
0750: E3B1     CD2EE3     	CALL	SEARCH	;else search command table for a match.
0751: E3B4                ;                   
0752: E3B4                ;   Note that an unknown command returns
0753: E3B4                ; with (A) pointing to the last address
0754: E3B4                ; in our table which is (UNKNOWN).
0755: E3B4                ;                   
0756: E3B4     21C1E3     	LXI	H,CMDADR;now, look thru our address table for command (A).
0757: E3B7     5F         	MOV	E,A	;set (DE) to command number.
0758: E3B8     1600       	MVI	D,0            
0759: E3BA     19         	DAD	D              
0760: E3BB     19         	DAD	D	;(HL)=(CMDADR)+2*(command number).
0761: E3BC     7E         	MOV	A,M	;now pick out this address.
0762: E3BD     23         	INX	H              
0763: E3BE     66         	MOV	H,M            
0764: E3BF     6F         	MOV	L,A            
0765: E3C0     E9         	PCHL		;now execute it.
0766: E3C1                ;                   
0767: E3C1                ;   CP/M command address table.
0768: E3C1                ;                   
0769: E3C1                CMDADR:             
0770: E3C1     77E41FE55DE5ADE5 	DW	DIRECT,ERASE,TYPE,SAVE
0771: E3C9     10E68EE6A5E6 	DW	RENAME,USER,UNKNOWN
0772: E3CF                ;                   
0773: E3CF                ;   Halt the system. Reason for this is unknown at present.
0774: E3CF                ;                   
0775: E3CF                HALT:               
0776: E3CF     21F376     	LXI	H,76F3H	;'DI HLT' instructions.
0777: E3D2     2200E0     	SHLD	CBASE         
0778: E3D5     2100E0     	LXI	H,CBASE        
0779: E3D8     E9         	PCHL               
0780: E3D9                ;                   
0781: E3D9                ;   Read error while TYPEing a file.
0782: E3D9                ;                   
0783: E3D9                RDERROR:            
0784: E3D9     01DFE3     	LXI	B,RDERR        
0785: E3DC     C3A7E0     	JMP	PLINE          
0786: E3DF                RDERR:              
0787: E3DF     52454144204552524F5200 	DB	'Read error',0  
0788: E3EA                ;                   
0789: E3EA                ;   Required file was not located.
0790: E3EA                ;                   
0791: E3EA                                    
0792: E3EA                NONE:               
0793: E3EA     01F0E3     	LXI	B,NOFILE       
0794: E3ED     C3A7E0     	JMP	PLINE          
0795: E3F0                NOFILE:             
0796: E3F0     4E4F2046494C4500 	DB	'No file',0     
0797: E3F8                ;                   
0798: E3F8                ;   Decode a command of the form 'A>filename number{ filename}.
0799: E3F8                ; Note that a drive specifier is not allowed on the first file
0800: E3F8                ; name. On return, the number is in register (A). Any error
0801: E3F8                ; causes 'filename?' to be printed and the command is aborted.
0802: E3F8                ;                   
0803: E3F8                DECODE:             
0804: E3F8     CD5EE2     	CALL	CONVFST	;convert filename.
0805: E3FB     3AF0E7     	LDA	CHGDRV	;do not allow a drive to be specified.
0806: E3FE     B7         	ORA	A              
0807: E3FF     C209E2     	JNZ	SYNERR         
0808: E402     21CEE7     	LXI	H,FCB+1	;convert number now.
0809: E405     010B00     	LXI	B,11	;(B)=sum register, (C)=max digit count.
0810: E408                DECODE1:            
0811: E408     7E         	MOV	A,M            
0812: E409     FE20       	CPI	BLANK	;a space terminates the numeral.
0813: E40B     CA33E4     	JZ	DECODE3         
0814: E40E     23         	INX	H              
0815: E40F     D630       	SUI	030H		 ;'0'	make binary from ascii. ZERO ????
0816: E411     FE0A       	CPI	10	;legal digit?
0817: E413     D209E2     	JNC	SYNERR         
0818: E416     57         	MOV	D,A	;yes, save it in (D).
0819: E417     78         	MOV	A,B	;compute (B)=(B)*10 and check for overflow.
0820: E418     E6E0       	ANI	0E0H           
0821: E41A     C209E2     	JNZ	SYNERR         
0822: E41D     78         	MOV	A,B            
0823: E41E     07         	RLC                
0824: E41F     07         	RLC                
0825: E420     07         	RLC	;(A)=(B)*8     
0826: E421     80         	ADD	B	;.......*9   
0827: E422     DA09E2     	JC	SYNERR          
0828: E425     80         	ADD	B	;.......*10  
0829: E426     DA09E2     	JC	SYNERR          
0830: E429     82         	ADD	D	;add in new digit now.
0831: E42A                DECODE2:            
0832: E42A     DA09E2     	JC	SYNERR          
0833: E42D     47         	MOV	B,A	;and save result.
0834: E42E     0D         	DCR	C	;only look at 11 digits.
0835: E42F     C208E4     	JNZ	DECODE1        
0836: E432     C9         	RET                
0837: E433                DECODE3:            
0838: E433     7E         	MOV	A,M	;spaces must follow (why?).
0839: E434     FE20       	CPI	BLANK          
0840: E436     C209E2     	JNZ	SYNERR         
0841: E439     23         	INX	H              
0842: E43A                DECODE4:            
0843: E43A     0D         	DCR	C              
0844: E43B     C233E4     	JNZ	DECODE3        
0845: E43E     78         	MOV	A,B	;set (A)=the numeric value entered.
0846: E43F     C9         	RET                
0847: E440                ;                   
0848: E440                ;   Move 3 bytes from (HL) to (DE). Note that there is only
0849: E440                ; one reference to this at (A2D5h).
0850: E440                ;                   
0851: E440                MOVE3:              
0852: E440     0603       	MVI	B,3            
0853: E442                ;                   
0854: E442                ;   Move (B) bytes from (HL) to (DE).
0855: E442                ;                   
0856: E442                HL2DE:              
0857: E442     7E         	MOV	A,M            
0858: E443     12         	STAX	D             
0859: E444     23         	INX	H              
0860: E445     13         	INX	D              
0861: E446     05         	DCR	B              
0862: E447     C242E4     	JNZ	HL2DE          
0863: E44A     C9         	RET                
0864: E44B                ;                   
0865: E44B                ;   Compute (HL)=(Pg0Buffer)+(A)+(C) and get the byte that's here.
0866: E44B                ;                   
0867: E44B                EXTRACT:            
0868: E44B     218000     	LXI	H,Pg0Buffer    
0869: E44E     81         	ADD	C              
0870: E44F     CD59E2     	CALL	ADDHL         
0871: E452     7E         	MOV	A,M            
0872: E453     C9         	RET                
0873: E454                ;                   
0874: E454                ;  Check drive specified. If it means a change, then the new
0875: E454                ; drive will be selected. In any case, the drive byte of the
0876: E454                ; fcb will be set to null (means use current drive).
0877: E454                ;                   
0878: E454                DSELECT:            
0879: E454     AF         	XRA	A	;null out first byte of fcb.
0880: E455     32CDE7     	STA	FCB            
0881: E458     3AF0E7     	LDA	CHGDRV	;a drive change indicated?
0882: E45B     B7         	ORA	A              
0883: E45C     C8         	RZ                 
0884: E45D     3D         	DCR	A	;yes, is it the same as the current drive?
0885: E45E     21EFE7     	LXI	H,CDRIVE       
0886: E461     BE         	CMP	M              
0887: E462     C8         	RZ                 
0888: E463     C3BDE0     	JMP	DSKSEL	;no. Select it then.
0889: E466                ;                   
0890: E466                ;   Check the drive selection and reset it to the previous
0891: E466                ; drive if it was changed for the preceeding command.
0892: E466                ;                   
0893: E466                RESETDR:            
0894: E466     3AF0E7     	LDA	CHGDRV	;drive change indicated?
0895: E469     B7         	ORA	A              
0896: E46A     C8         	RZ                 
0897: E46B     3D         	DCR	A	;yes, was it a different drive?
0898: E46C     21EFE7     	LXI	H,CDRIVE       
0899: E46F     BE         	CMP	M              
0900: E470     C8         	RZ                 
0901: E471     3AEFE7     	LDA	CDRIVE	;yes, re-select our old drive.
0902: E474     C3BDE0     	JMP	DSKSEL         
0903: E477                ;                   
0904: E477                ;**************************************************************
0905: E477                ;*                  
0906: E477                ;*           D I R E C T O R Y   C O M M A N D
0907: E477                ;*                  
0908: E477                ;**************************************************************
0909: E477                ;                   
0910: E477                DIRECT:             
0911: E477     CD5EE2     	CALL	CONVFST	;convert file name.
0912: E47A     CD54E4     	CALL	DSELECT	;select indicated drive.
0913: E47D     21CEE7     	LXI	H,FCB+1	;was any file indicated?
0914: E480     7E         	MOV	A,M            
0915: E481     FE20       	CPI	BLANK          
0916: E483     C28FE4     	JNZ	DIRECT2        
0917: E486     060B       	MVI	B,11	;no. Fill field with '?' - same as *.*.
0918: E488                DIRECT1:            
0919: E488     363F       	MVI	M,QMARK		; '?' 
0920: E48A     23         	INX	H              
0921: E48B     05         	DCR	B              
0922: E48C     C288E4     	JNZ	DIRECT1        
0923: E48F                DIRECT2:            
0924: E48F     1E00       	MVI	E,0	;set initial cursor position.
0925: E491     D5         	PUSH	D             
0926: E492     CDE9E0     	CALL	SRCHFCB	;get first file name.
0927: E495     CCEAE3     	CZ	NONE	;none found at all?
0928: E498                DIRECT3:            
0929: E498     CA1BE5     	JZ	DIRECT9	;terminate if no more names.
0930: E49B     3AEEE7     	LDA	RTNCODE	;get file's position in segment (0-3).
0931: E49E     0F         	RRC                
0932: E49F     0F         	RRC                
0933: E4A0     0F         	RRC                
0934: E4A1     E660       	ANI	60H	;(A)=position*32
0935: E4A3     4F         	MOV	C,A            
0936: E4A4     3E0A       	MVI	A,10           
0937: E4A6     CD4BE4     	CALL	EXTRACT	;extract the tenth entry in fcb.
0938: E4A9     17         	RAL		;check system file status bit.
0939: E4AA     DA0FE5     	JC	DIRECT8	;we don't list them.
0940: E4AD     D1         	POP	D              
0941: E4AE     7B         	MOV	A,E	;bump name count.
0942: E4AF     1C         	INR	E              
0943: E4B0     D5         	PUSH	D             
0944: E4B1     E603       	ANI	03H	;at end of line?
0945: E4B3     F5         	PUSH	PSW           
0946: E4B4     C2CCE4     	JNZ	DIRECT4        
0947: E4B7     CD98E0     	CALL	CRLF	;yes, end this line and start another.
0948: E4BA     C5         	PUSH	B             
0949: E4BB     CDD0E1     	CALL	GETDSK	;start line with ('A:').
0950: E4BE     C1         	POP	B              
0951: E4BF     C641       	ADI	041H	; 'A'     
0952: E4C1     CD92E0     	CALL	PRINTB        
0953: E4C4     3E3A       	MVI	A, COLON		; ':'
0954: E4C6     CD92E0     	CALL	PRINTB        
0955: E4C9     C3D4E4     	JMP	DIRECT5        
0956: E4CC                DIRECT4:            
0957: E4CC     CDA2E0     	CALL	SPACE	;add seperator between file names.
0958: E4CF     3E3A       	MVI	A, COLON	;':'  
0959: E4D1     CD92E0     	CALL	PRINTB        
0960: E4D4                DIRECT5:            
0961: E4D4     CDA2E0     	CALL	SPACE         
0962: E4D7     0601       	MVI	B,1	;'extract' each file name character at a time.
0963: E4D9                DIRECT6:            
0964: E4D9     78         	MOV	A,B            
0965: E4DA     CD4BE4     	CALL	EXTRACT       
0966: E4DD     E67F       	ANI	7FH	;strip bit 7 (status bit).
0967: E4DF     FE20       	CPI	BLANK	;are we at the end of the name?
0968: E4E1     C2F9E4     	JNZ	DRECT65        
0969: E4E4     F1         	POP	PSW	;yes, don't print spaces at the end of a line.
0970: E4E5     F5         	PUSH	PSW           
0971: E4E6     FE03       	CPI	3              
0972: E4E8     C2F7E4     	JNZ	DRECT63        
0973: E4EB     3E09       	MVI	A,9	;first check for no extension.
0974: E4ED     CD4BE4     	CALL	EXTRACT       
0975: E4F0     E67F       	ANI	7FH            
0976: E4F2     FE20       	CPI	BLANK          
0977: E4F4     CA0EE5     	JZ	DIRECT7	;don't print spaces.
0978: E4F7                DRECT63:            
0979: E4F7     3E20       	MVI	A,BLANK	;else print them.
0980: E4F9                DRECT65:            
0981: E4F9     CD92E0     	CALL	PRINTB        
0982: E4FC     04         	INR	B	;bump to next character psoition.
0983: E4FD     78         	MOV	A,B            
0984: E4FE     FE0C       	CPI	12	;end of the name?
0985: E500     D20EE5     	JNC	DIRECT7        
0986: E503     FE09       	CPI	9	;nope, starting extension?
0987: E505     C2D9E4     	JNZ	DIRECT6        
0988: E508     CDA2E0     	CALL	SPACE	;yes, add seperating space.
0989: E50B     C3D9E4     	JMP	DIRECT6        
0990: E50E                DIRECT7:            
0991: E50E     F1         	POP	PSW	;get the next file name.
0992: E50F                DIRECT8:            
0993: E50F     CDC2E1     	CALL	CHKCON	;first check console, quit on anything.
0994: E512     C21BE5     	JNZ	DIRECT9        
0995: E515     CDE4E0     	CALL	SRCHNXT	;get next name.
0996: E518     C398E4     	JMP	DIRECT3	;and continue with our list.
0997: E51B                DIRECT9:            
0998: E51B     D1         	POP	D	;restore the stack and return to command level.
0999: E51C     C386E7     	JMP	GETBACK        
1000: E51F                ;                   
1001: E51F                ;**************************************************************
1002: E51F                ;*                  
1003: E51F                ;*                E R A S E   C O M M A N D
1004: E51F                ;*                  
1005: E51F                ;**************************************************************
1006: E51F                ;                   
1007: E51F                ERASE:              
1008: E51F     CD5EE2     	CALL	CONVFST	;convert file name.
1009: E522     FE0B       	CPI	11	;was '*.*' entered?
1010: E524     C242E5     	JNZ	ERASE1         
1011: E527     0152E5     	LXI	B,YESNO	;yes, ask for confirmation.
1012: E52A     CDA7E0     	CALL	PLINE         
1013: E52D     CD39E1     	CALL	GETINP        
1014: E530     2107E0     	LXI	H,INBUFF+1     
1015: E533     35         	DCR	M	;must be exactly 'y'.
1016: E534     C282E3     	JNZ	CMMND1         
1017: E537     23         	INX	H              
1018: E538     7E         	MOV	A,M            
1019: E539     FE59       	CPI	059H	; 'Y'     
1020: E53B     C282E3     	JNZ	CMMND1         
1021: E53E     23         	INX	H              
1022: E53F     2288E0     	SHLD	INPOINT	;save input line pointer.
1023: E542                ERASE1:             
1024: E542     CD54E4     	CALL	DSELECT	;select desired disk.
1025: E545     11CDE7     	LXI	D,FCB          
1026: E548     CDEFE0     	CALL	DELETE	;delete the file.
1027: E54B     3C         	INR	A              
1028: E54C     CCEAE3     	CZ	NONE	;not there?
1029: E54F     C386E7     	JMP	GETBACK	;return to command level now.
1030: E552                YESNO:              
1031: E552     414C4C2028592F4E293F00 	DB	'All (y/n)?',0  
1032: E55D                ;                   
1033: E55D                ;**************************************************************
1034: E55D                ;*                  
1035: E55D                ;*            T Y P E   C O M M A N D
1036: E55D                ;*                  
1037: E55D                ;**************************************************************
1038: E55D                ;                   
1039: E55D                TYPE:               
1040: E55D     CD5EE2     	CALL	CONVFST	;convert file name.
1041: E560     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1042: E563     CD54E4     	CALL	DSELECT	;select indicated drive.
1043: E566     CDD0E0     	CALL	OPENFCB	;open the file.
1044: E569     CAA7E5     	JZ	TYPE5	;not there?
1045: E56C     CD98E0     	CALL	CRLF	;ok, start a new line on the screen.
1046: E56F     21F1E7     	LXI	H,NBYTES;initialize byte counter.
1047: E572     36FF       	MVI	M,0FFH	;set to read first sector.
1048: E574                TYPE1:              
1049: E574     21F1E7     	LXI	H,NBYTES       
1050: E577                TYPE2:              
1051: E577     7E         	MOV	A,M	;have we written the entire sector?
1052: E578     FE80       	CPI	128            
1053: E57A     DA87E5     	JC	TYPE3           
1054: E57D     E5         	PUSH	H	;yes, read in the next one.
1055: E57E     CDFEE0     	CALL	READFCB       
1056: E581     E1         	POP	H              
1057: E582     C2A0E5     	JNZ	TYPE4	;end or error?
1058: E585     AF         	XRA	A	;ok, clear byte counter.
1059: E586     77         	MOV	M,A            
1060: E587                TYPE3:              
1061: E587     34         	INR	M	;count this byte.
1062: E588     218000     	LXI	H,Pg0Buffer	;and get the (A)th one from the buffer (Pg0Buffer).
1063: E58B     CD59E2     	CALL	ADDHL         
1064: E58E     7E         	MOV	A,M            
1065: E58F     FE1A       	CPI	CNTRLZ	;end of file mark?
1066: E591     CA86E7     	JZ	GETBACK         
1067: E594     CD8CE0     	CALL	PRINT	;no, print it.
1068: E597     CDC2E1     	CALL	CHKCON	;check console, quit if anything ready.
1069: E59A     C286E7     	JNZ	GETBACK        
1070: E59D     C374E5     	JMP	TYPE1          
1071: E5A0                ;                   
1072: E5A0                ;   Get here on an end of file or read error.
1073: E5A0                ;                   
1074: E5A0                TYPE4:              
1075: E5A0     3D         	DCR	A	;read error? 
1076: E5A1     CA86E7     	JZ	GETBACK         
1077: E5A4     CDD9E3     	CALL	RDERROR	;yes, print message.
1078: E5A7                TYPE5:              
1079: E5A7     CD66E4     	CALL	RESETDR	;and reset proper drive
1080: E5AA     C309E2     	JMP	SYNERR	;now print file name with problem.
1081: E5AD                ;                   
1082: E5AD                ;**************************************************************
1083: E5AD                ;*                  
1084: E5AD                ;*            S A V E   C O M M A N D
1085: E5AD                ;*                  
1086: E5AD                ;**************************************************************
1087: E5AD                ;                   
1088: E5AD                SAVE:               
1089: E5AD     CDF8E3     	CALL	DECODE	;get numeric number that follows SAVE.
1090: E5B0     F5         	PUSH	PSW	;save number of pages to write.
1091: E5B1     CD5EE2     	CALL	CONVFST	;convert file name.
1092: E5B4     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1093: E5B7     CD54E4     	CALL	DSELECT	;select specified drive.
1094: E5BA     11CDE7     	LXI	D,FCB	;now delete this file.
1095: E5BD     D5         	PUSH	D             
1096: E5BE     CDEFE0     	CALL	DELETE        
1097: E5C1     D1         	POP	D              
1098: E5C2     CD09E1     	CALL	CREATE	;and create it again.
1099: E5C5     CAFBE5     	JZ	SAVE3	;can't create?
1100: E5C8     AF         	XRA	A	;clear record number byte.
1101: E5C9     32EDE7     	STA	FCB+32         
1102: E5CC     F1         	POP	PSW	;convert pages to sectors.
1103: E5CD     6F         	MOV	L,A            
1104: E5CE     2600       	MVI	H,0            
1105: E5D0     29         	DAD	H	;(HL)=number of sectors to write.
1106: E5D1     110001     	LXI	D,TBASE	;and we start from here.
1107: E5D4                SAVE1:              
1108: E5D4     7C         	MOV	A,H	;done yet? 
1109: E5D5     B5         	ORA	L              
1110: E5D6     CAF1E5     	JZ	SAVE2           
1111: E5D9     2B         	DCX	H	;nope, count this and compute the start
1112: E5DA     E5         	PUSH	H	;of the next 128 byte sector.
1113: E5DB     218000     	LXI	H,128          
1114: E5DE     19         	DAD	D              
1115: E5DF     E5         	PUSH	H	;save it and set the transfer address.
1116: E5E0     CDD8E1     	CALL	DMASET        
1117: E5E3     11CDE7     	LXI	D,FCB	;write out this sector now.
1118: E5E6     CD04E1     	CALL	WRTREC        
1119: E5E9     D1         	POP	D	;reset (DE) to the start of the last sector.
1120: E5EA     E1         	POP	H	;restore sector count.
1121: E5EB     C2FBE5     	JNZ	SAVE3	;write error?
1122: E5EE     C3D4E5     	JMP	SAVE1          
1123: E5F1                ;                   
1124: E5F1                ;   Get here after writing all of the file.
1125: E5F1                ;                   
1126: E5F1                SAVE2:              
1127: E5F1     11CDE7     	LXI	D,FCB	;now close the file.
1128: E5F4     CDDAE0     	CALL	CLOSE         
1129: E5F7     3C         	INR	A	;did it close ok?
1130: E5F8     C201E6     	JNZ	SAVE4          
1131: E5FB                ;                   
1132: E5FB                ;   Print out error message (no space).
1133: E5FB                ;                   
1134: E5FB                SAVE3:              
1135: E5FB     0107E6     	LXI	B,NOSPACE      
1136: E5FE     CDA7E0     	CALL	PLINE         
1137: E601                SAVE4:              
1138: E601     CDD5E1     	CALL	STDDMA	;reset the standard dma address.
1139: E604     C386E7     	JMP	GETBACK        
1140: E607                NOSPACE:            
1141: E607     4E4F20535041434500 	DB	'No space',0    
1142: E610                ;                   
1143: E610                ;**************************************************************
1144: E610                ;*                  
1145: E610                ;*           R E N A M E   C O M M A N D
1146: E610                ;*                  
1147: E610                ;**************************************************************
1148: E610                ;                   
1149: E610                RENAME:             
1150: E610     CD5EE2     	CALL	CONVFST	;convert first file name.
1151: E613     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1152: E616     3AF0E7     	LDA	CHGDRV	;remember any change in drives specified.
1153: E619     F5         	PUSH	PSW           
1154: E61A     CD54E4     	CALL	DSELECT	;and select this drive.
1155: E61D     CDE9E0     	CALL	SRCHFCB	;is this file present?
1156: E620     C279E6     	JNZ	RENAME6	;yes, print error message.
1157: E623     21CDE7     	LXI	H,FCB	;yes, move this name into second slot.
1158: E626     11DDE7     	LXI	D,FCB+16       
1159: E629     0610       	MVI	B,16           
1160: E62B     CD42E4     	CALL	HL2DE         
1161: E62E     2A88E0     	LHLD	INPOINT	;get input pointer.
1162: E631     EB         	XCHG               
1163: E632     CD4FE2     	CALL	NONBLANK;get next non blank character.
1164: E635     FE3D       	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1165: E637     CA3FE6     	JZ	RENAME1         
1166: E63A     FE5F       	CPI	USCORE		; '_'  
1167: E63C     C273E6     	JNZ	RENAME5        
1168: E63F                RENAME1:            
1169: E63F     EB         	XCHG               
1170: E640     23         	INX	H	;ok, skip seperator.
1171: E641     2288E0     	SHLD	INPOINT	;save input line pointer.
1172: E644     CD5EE2     	CALL	CONVFST	;convert this second file name now.
1173: E647     C273E6     	JNZ	RENAME5	;again, no wild cards.
1174: E64A     F1         	POP	PSW	;if a drive was specified, then it
1175: E64B     47         	MOV	B,A	;must be the same as before.
1176: E64C     21F0E7     	LXI	H,CHGDRV       
1177: E64F     7E         	MOV	A,M            
1178: E650     B7         	ORA	A              
1179: E651     CA59E6     	JZ	RENAME2         
1180: E654     B8         	CMP	B              
1181: E655     70         	MOV	M,B            
1182: E656     C273E6     	JNZ	RENAME5	;they were different, error.
1183: E659                RENAME2:            
1184: E659     70         	MOV	M,B;	reset as per the first file specification.
1185: E65A     AF         	XRA	A              
1186: E65B     32CDE7     	STA	FCB	;clear the drive byte of the fcb.
1187: E65E                RENAME3:            
1188: E65E     CDE9E0     	CALL	SRCHFCB	;and go look for second file.
1189: E661     CA6DE6     	JZ	RENAME4	;doesn't exist?
1190: E664     11CDE7     	LXI	D,FCB          
1191: E667     CD0EE1     	CALL	RENAM	;ok, rename the file.
1192: E66A     C386E7     	JMP	GETBACK        
1193: E66D                ;                   
1194: E66D                ;   Process rename errors here.
1195: E66D                ;                   
1196: E66D                RENAME4:            
1197: E66D     CDEAE3     	CALL	NONE	;file not there.
1198: E670     C386E7     	JMP	GETBACK        
1199: E673                RENAME5:            
1200: E673     CD66E4     	CALL	RESETDR	;bad command format.
1201: E676     C309E2     	JMP	SYNERR         
1202: E679                RENAME6:            
1203: E679     0182E6     	LXI	B,EXISTS;destination file already exists.
1204: E67C     CDA7E0     	CALL	PLINE         
1205: E67F     C386E7     	JMP	GETBACK        
1206: E682                EXISTS:             
1207: E682     46494C452045584953545300 	DB	'File exists',0 
1208: E68E                ;                   
1209: E68E                ;**************************************************************
1210: E68E                ;*                  
1211: E68E                ;*             U S E R   C O M M A N D
1212: E68E                ;*                  
1213: E68E                ;**************************************************************
1214: E68E                ;                   
1215: E68E                USER:               
1216: E68E     CDF8E3     	CALL	DECODE	;get numeric value following command.
1217: E691     FE10       	CPI	16	;legal user number?
1218: E693     D209E2     	JNC	SYNERR         
1219: E696     5F         	MOV	E,A	;yes but is there anything else?
1220: E697     3ACEE7     	LDA	FCB+1          
1221: E69A     FE20       	CPI	BLANK          
1222: E69C     CA09E2     	JZ	SYNERR	;yes, that is not allowed.
1223: E69F     CD15E1     	CALL	GETSETUC;ok, set user code.
1224: E6A2     C389E7     	JMP	GETBACK1       
1225: E6A5                ;                   
1226: E6A5                ;**************************************************************
1227: E6A5                ;*                  
1228: E6A5                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1229: E6A5                ;*                  
1230: E6A5                ;**************************************************************
1231: E6A5                ;                   
1232: E6A5                UNKNOWN:            
1233: E6A5     CDF5E1     	CALL	VERIFY	;check for valid system (why?).
1234: E6A8     3ACEE7     	LDA	FCB+1	;anything to execute?
1235: E6AB     FE20       	CPI	BLANK          
1236: E6AD     C2C4E6     	JNZ	UNKWN1         
1237: E6B0     3AF0E7     	LDA	CHGDRV	;nope, only a drive change?
1238: E6B3     B7         	ORA	A              
1239: E6B4     CA89E7     	JZ	GETBACK1;neither???
1240: E6B7     3D         	DCR	A              
1241: E6B8     32EFE7     	STA	CDRIVE	;ok, store new drive.
1242: E6BB     CD29E1     	CALL	MOVECD	;set (TDRIVE) also.
1243: E6BE     CDBDE0     	CALL	DSKSEL	;and select this drive.
1244: E6C1     C389E7     	JMP	GETBACK1;then return.
1245: E6C4                ;                   
1246: E6C4                ;   Here a file name was typed. Prepare to execute it.
1247: E6C4                ;                   
1248: E6C4                UNKWN1:             
1249: E6C4     11D6E7     	LXI	D,FCB+9	;an extension specified?
1250: E6C7     1A         	LDAX	D             
1251: E6C8     FE20       	CPI	BLANK          
1252: E6CA     C209E2     	JNZ	SYNERR	;yes, not allowed.
1253: E6CD                UNKWN2:             
1254: E6CD     D5         	PUSH	D             
1255: E6CE     CD54E4     	CALL	DSELECT	;select specified drive.
1256: E6D1     D1         	POP	D              
1257: E6D2     2183E7     	LXI	H,COMFILE	;set the extension to 'COM'.
1258: E6D5     CD40E4     	CALL	MOVE3         
1259: E6D8     CDD0E0     	CALL	OPENFCB	;and open this file.
1260: E6DB     CA6BE7     	JZ	UNKWN9	;not present?
1261: E6DE                ;                   
1262: E6DE                ;   Load in the program.
1263: E6DE                ;                   
1264: E6DE     210001     	LXI	H,TBASE	;store the program starting here.
1265: E6E1                UNKWN3:             
1266: E6E1     E5         	PUSH	H             
1267: E6E2     EB         	XCHG               
1268: E6E3     CDD8E1     	CALL	DMASET	;set transfer address.
1269: E6E6     11CDE7     	LXI	D,FCB	;and read the next record.
1270: E6E9     CDF9E0     	CALL	RDREC         
1271: E6EC     C201E7     	JNZ	UNKWN4	;end of file or read error?
1272: E6EF     E1         	POP	H	;nope, bump pointer for next sector.
1273: E6F0     118000     	LXI	D,128          
1274: E6F3     19         	DAD	D              
1275: E6F4     1100E0     	LXI	D,CBASE	;enough room for the whole file?
1276: E6F7     7D         	MOV	A,L            
1277: E6F8     93         	SUB	E              
1278: E6F9     7C         	MOV	A,H            
1279: E6FA     9A         	SBB	D              
1280: E6FB     D271E7     	JNC	UNKWN0	;no, it can't fit.
1281: E6FE     C3E1E6     	JMP	UNKWN3         
1282: E701                ;                   
1283: E701                ;   Get here after finished reading.
1284: E701                ;                   
1285: E701                UNKWN4:             
1286: E701     E1         	POP	H              
1287: E702     3D         	DCR	A	;normal end of file?
1288: E703     C271E7     	JNZ	UNKWN0         
1289: E706     CD66E4     	CALL	RESETDR	;yes, reset previous drive.
1290: E709     CD5EE2     	CALL	CONVFST	;convert the first file name that follows
1291: E70C     21F0E7     	LXI	H,CHGDRV;command name.
1292: E70F     E5         	PUSH	H             
1293: E710     7E         	MOV	A,M	;set drive code in default fcb.
1294: E711     32CDE7     	STA	FCB            
1295: E714     3E10       	MVI	A,16	;put second name 16 bytes later.
1296: E716     CD60E2     	CALL	CONVERT	;convert second file name.
1297: E719     E1         	POP	H              
1298: E71A     7E         	MOV	A,M	;and set the drive for this second file.
1299: E71B     32DDE7     	STA	FCB+16         
1300: E71E     AF         	XRA	A	;clear record byte in fcb.
1301: E71F     32EDE7     	STA	FCB+32         
1302: E722     115C00     	LXI	D,TFCB	;move it into place at(005Ch).
1303: E725     21CDE7     	LXI	H,FCB          
1304: E728     0621       	MVI	B,33           
1305: E72A     CD42E4     	CALL	HL2DE         
1306: E72D     2108E0     	LXI	H,INBUFF+2;now move the remainder of the input
1307: E730                UNKWN5:             
1308: E730     7E         	MOV	A,M	;line down to (0080h). Look for a non blank.
1309: E731     B7         	ORA	A	;or a null.  
1310: E732     CA3EE7     	JZ	UNKWN6          
1311: E735     FE20       	CPI	BLANK          
1312: E737     CA3EE7     	JZ	UNKWN6          
1313: E73A     23         	INX	H              
1314: E73B     C330E7     	JMP	UNKWN5         
1315: E73E                ;                   
1316: E73E                ;   Do the line move now. It ends in a null byte.
1317: E73E                ;                   
1318: E73E                UNKWN6:             
1319: E73E     0600       	MVI	B,0	;keep a character count.
1320: E740     118100     	LXI	D,Pg0Buffer+1;data gets put here.
1321: E743                UNKWN7:             
1322: E743     7E         	MOV	A,M	;move it now.
1323: E744     12         	STAX	D             
1324: E745     B7         	ORA	A              
1325: E746     CA4FE7     	JZ	UNKWN8          
1326: E749     04         	INR	B              
1327: E74A     23         	INX	H              
1328: E74B     13         	INX	D              
1329: E74C     C343E7     	JMP	UNKWN7         
1330: E74F                UNKWN8:             
1331: E74F     78         	MOV	A,B	;now store the character count.
1332: E750     328000     	STA	Pg0Buffer      
1333: E753     CD98E0     	CALL	CRLF	;clean up the screen.
1334: E756     CDD5E1     	CALL	STDDMA	;set standard transfer address.
1335: E759     CD1AE1     	CALL	SETCDRV	;reset current drive.
1336: E75C     CD0001     	CALL	TBASE	;and execute the program.
1337: E75F                ;                   
1338: E75F                ;   Transiant programs return here (or reboot).
1339: E75F                ;                   
1340: E75F     31ABE7     	LXI	SP,BATCH	;set stack first off.
1341: E762     CD29E1     	CALL	MOVECD	;move current drive into place (TDRIVE).
1342: E765     CDBDE0     	CALL	DSKSEL	;and reselect it.
1343: E768     C382E3     	JMP	CMMND1	;back to comand mode.
1344: E76B                ;                   
1345: E76B                ;   Get here if some error occured.
1346: E76B                ;                   
1347: E76B                UNKWN9:             
1348: E76B     CD66E4     	CALL	RESETDR	;inproper format.
1349: E76E     C309E2     	JMP	SYNERR         
1350: E771                UNKWN0:             
1351: E771     017AE7     	LXI	B,BADLOAD;read error or won't fit.
1352: E774     CDA7E0     	CALL	PLINE         
1353: E777     C386E7     	JMP	GETBACK        
1354: E77A                BADLOAD:            
1355: E77A     424144204C4F414400 	DB	'Bad load',0    
1356: E783                COMFILE:            
1357: E783     434F4D     	DB	'COM'	;command file extension.
1358: E786                ;                   
1359: E786                ;   Get here to return to command level. We will reset the
1360: E786                ; previous active drive and then either return to command
1361: E786                ; level directly or print error message and then return.
1362: E786                ;                   
1363: E786                GETBACK:            
1364: E786     CD66E4     	CALL	RESETDR	;reset previous drive.
1365: E789                GETBACK1:           
1366: E789     CD5EE2     	CALL	CONVFST	;convert first name in (FCB).
1367: E78C     3ACEE7     	LDA	FCB+1	;if this was just a drive change request,
1368: E78F     D620       	SUI	BLANK	;make sure it was valid.
1369: E791     21F0E7     	LXI	H,CHGDRV       
1370: E794     B6         	ORA	M              
1371: E795     C209E2     	JNZ	SYNERR         
1372: E798     C382E3     	JMP	CMMND1	;ok, return to command level.
1373: E79B                ;                   
1374: E79B                ;   ccp stack area. 
1375: E79B                ;                   
1376: E79B     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1377: E7AB                CCPStack	EQU	$	;end of ccp stack area.
1378: E7AB                ;                   
1379: E7AB                ;   Batch (or SUBMIT) processing information storage.
1380: E7AB                ;                   
1381: E7AB                BATCH:              
1382: E7AB     00         	DB	0	;batch mode flag (0=not active).
1383: E7AC                BATCHFCB:           
1384: E7AC     002424242020202020535542000000000000000000000000000000000000000000 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1385: E7CD                ;                   
1386: E7CD                ;   File control block setup by the CCP.
1387: E7CD                ;                   
1388: E7CD                FCB:                
1389: E7CD     002020202020202020202020000000000020202020202020202020200000000000 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1390: E7EE                RTNCODE:            
1391: E7EE     00         	DB	0	;status returned from bdos call.
1392: E7EF                CDRIVE:             
1393: E7EF     00         	DB	0	;currently active drive.
1394: E7F0                CHGDRV:             
1395: E7F0     00         	DB	0	;change in drives flag (0=no change).
1396: E7F1                NBYTES:             
1397: E7F1     0000       	DW	0	;byte counter used by TYPE.
1398: E7F3                ;                   
1399: E7F3                ;   Room for expansion?
1400: E7F3                ;                   
1401: E7F3     00000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1402: E800                ;                   
1403: E800                ;   Note that the following six bytes must match those at
1404: E800                ; (PATTRN1) or cp/m will HALT. Why?
1405: E800                ;                   
1406: E800                PATTRN2:            
1407: E800     001600000000 	DB	0,22,0,0,0,0;(* serial number bytes *).
1408: E806                ;                   
1409: E806                ;**************************************************************
1410: E806                ;*                  
1411: E806                ;*                    B D O S   E N T R Y
1412: E806                ;*                  
1413: E806                ;**************************************************************
1414: E806                ;                   
1415: E806                ;   Entry into bdos.
1416: E806                ;			Parameters: (DE) or (E) are the parameters passed. The
1417: E806                ;						(C) - function number
1418: E806                ;	The user's stack is saved (UserStack) 
1419: E806                ;	BDOS uses its own stack  (BDOSstack)
1420: E806                ;	The Function number is checked
1421: E806                ;	The corect routine is calcualted using the FunctionVector and (C)
1422: E806                ;                   
1423: E806                BDOSEntry:          
1424: E806                ;	JMP	BDOSSetup     
1425: E806                ;BDOSSetup:         
1426: E806     EB         	XCHG						; Swap  (DE) and (HL). **23**
1427: E807     223CE8     	SHLD	ParamsDE			; Save (DE)
1428: E80A     EB         	XCHG						; Restore (DE) and (HL) to original values
1429: E80B     7B         	MOV		A,E	          
1430: E80C     323EE8     	STA		ParamE				; Save register (E) in particular.
1431: E80F     210000     	LXI		H,0           
1432: E812     223FE8     	SHLD	StatusBDOSReturn	;clear return status.
1433: E815     39         	DAD		SP            
1434: E816     2241E8     	SHLD	UserStack			; ave users stack pointer.
1435: E819     3173E8     	LXI		SP,BDOSstack		; nd set our own.
1436: E81C     AF         	XRA		A					; lear A for flags resets
1437: E81D     32DAF5     	STA		AutoSelectFlag		; lear auto select storage Flag
1438: E820     32D8F5     	STA		AutoSelectActive	; lear auto select Active Flag
1439: E823     2173E8     	LXI		H,BDOSExit			; et return address to BDOSExit routine
1440: E826     E5         	PUSH	H					; ut it on the stack
1441: E827     79         	MOV		A,C					; get function number and put into A.
1442: E828     FE29       	CPI		FunctionCount + 1	; valid function number?
1443: E82A     D0         	RNC							; Exit if not valid
1444: E82B     4B         	MOV		C,E					; keep single register function value in C.
1445: E82C     219AE8     	LXI		H,FunctionVector	; now look thru the function table.
1446: E82F     5F         	MOV		E,A           
1447: E830     1600       	MVI		D,0					;(DE)=function number.
1448: E832     19         	DAD		D             
1449: E833     19         	DAD		D					;(HL)=(start of table)+2*(function number).
1450: E834     5E         	MOV		E,M           
1451: E835     23         	INX		H             
1452: E836     56         	MOV		D,M					; now (DE)=address for this function.
1453: E837     2A3CE8     	LHLD	ParamsDE			; retrieve parameters.
1454: E83A     EB         	XCHG						;now (DE) has the original parameters.
1455: E83B     E9         	PCHL						;execute desired function.
1456: E83C                ;----------------------------------
1457: E83C     0000       ParamsDE:			DW	0	;(DE) parameters saved here on entry to BDOS.
1458: E83E     00         ParamE:				DB	0	;storage for register (E) on entry to bdos.
1459: E83F     0000       StatusBDOSReturn:	DW	0	;status returned from bdos function.
1460: E841     0000       UserStack:			DW	0	;save users stack pointer here.
1461: E843                ;                   
1462: E843                ;   Stack area for BDOS calls.
1463: E843                ;                   
1464: E843                					DS	030H        
1465: E873                BDOSstack	EQU	$	;end of stack area.
1466: E873                ;----------------------------------
1467: E873                BDOSExit:           
1468: E873     3AD8F5     	LDA	AutoSelectActive	;was auto select activated?
1469: E876     B7         	ORA	A              
1470: E877     CA90E8     	JZ	BDOSExit1       
1471: E87A     2A3CE8     	LHLD	ParamsDE	;yes, but was a change made?
1472: E87D     3600       	MVI	M,0	;(* reset first byte of fcb *)
1473: E87F     3ADAF5     	LDA	AutoSelectFlag 
1474: E882     B7         	ORA	A              
1475: E883     CA90E8     	JZ	BDOSExit1       
1476: E886     77         	MOV	M,A	;yes, reset first byte properly.
1477: E887     3AD9F5     	LDA	OLDDRV	;and get the old drive and select it.
1478: E88A     323EE8     	STA	ParamE         
1479: E88D     CD65F4     	CALL	SETDSK        
1480: E890                BDOSExit1:          
1481: E890     2A41E8     	LHLD		UserStack			;Get  the users stack pointer.
1482: E893     F9         	SPHL		             
1483: E894     2A3FE8     	LHLD		StatusBDOSReturn	;get return status.
1484: E897     7D         	MOV	A,L							;force version 1.4 compatability.
1485: E898     44         	MOV	B,H            
1486: E899     C9         	RET			;and go back to user.
1487: E89A                                    
1488: E89A                	                   
1489: E89A                	                   
1490: E89A                ;                   
1491: E89A                ;   BDOS function jump table.
1492: E89A                ;                   
1493: E89A                ;NFUNCTS	EQU	41	;number of functions in followin table.
1494: E89A                ;                   
1495: E89A                FunctionVector:     
1496: E89A     03F6       	DW	WBOOT	;0		Overall system and BDOS reset
1497: E89C     23EB       	DW	GETCON	;1		Read a byte from the console keyboard
1498: E89E     EBE9       	DW	OUTCON	;2		Write a byte to the console screen
1499: E8A0     29EB       	DW	GETRDR	;3		Read a byte from the logical reader device
1500: E8A2     12F6       	DW	PUNCH	;4		Write a byte to the logical punch device
1501: E8A4     0FF6       	DW	LIST	;5		Write a byte to the logical list device
1502: E8A6     2FEB       	DW	DIRCIO	;6		Direct console I/O (no CCP-style editing)
1503: E8A8     48EB       	DW	GETIOB	;7		Read the current setting of the IOBYTE
1504: E8AA     4EEB       	DW	SETIOB	;8		Set a new value of the IOBYTE
1505: E8AC     53EB       	DW	PRTSTR	;9		Send a "$"-terminated string to the console
1506: E8AE     3CEA       	DW	RDBUFF	;10		Read a string from the console into a buffer
1507: E8B0     59EB       	DW	GETCSTS	;11		Check if a console key is waiting to be read
1508: E8B2     9EF4       	DW	GETVER	;12		Return the CP/M version number
1509: E8B4                	                   
1510: E8B4     A3F4       	DW	RSTDSK		;13		Reset disk system
1511: E8B6     65F4       	DW	SETDSK		;14		Select specified logical disk drive
1512: E8B8     BCF4       	DW	OPENFIL		;15		Open specified file for reading/writing
1513: E8BA     C5F4       	DW	CLOSEFIL	;16		Close specified file after reading/writing
1514: E8BC     CBF4       	DW	GETFST		;17		Search file directory for first match with filename
1515: E8BE     E8F4       	DW	GETNXT		;18		Search file directory for next match with filename
1516: E8C0     F7F4       	DW	DELFILE		;19		Delete (erase) file
1517: E8C2     00F5       	DW	READSEQ		;20		Read the next "record" sequentially
1518: E8C4     06F5       	DW	WRTSEQ		;21		Write the next "record" sequentially
1519: E8C6     0CF5       	DW	FCREATE		;22		Create a new file with the specified name
1520: E8C8     15F5       	DW	RENFILE		;23		Rename a file to a new name
1521: E8CA     1EF5       	DW	GETLOG		;24		Indicate which logical disks are active
1522: E8CC     24F5       	DW	GETCRNT		;25		Return the current default disk drive number
1523: E8CE     2AF5       	DW	PUTDMA		;26		Set the DMA address (read/write address)
1524: E8D0     31F5       	DW	GETALOC		;27		Return the address of an allocation vector
1525: E8D2     3CED       	DW	WRTPRTD		;28		Return the address of an allocation vector
1526: E8D4     37F5       	DW	GETROV		;29		Indicate which disks are currently Read-Only status
1527: E8D6     3DF5       	DW	SETATTR		;30		Set specified file to System or Read-Only status
1528: E8D8     46F5       	DW	GETPARM		;31		Return address of disk parameter block (DPB)
1529: E8DA     4DF5       	DW	GETUSER		;32		Set/Get the current user number
1530: E8DC     61F5       	DW	RDRANDOM	;33		Set/Get the current user number
1531: E8DE     67F5       	DW	WTRANDOM	;34		Write a "record" randomly
1532: E8E0     6DF5       	DW	FILESIZE	;35		Return logical file size (even for random files)
1533: E8E2     C0F3       	DW	SETRAN		;36		Set record number for the next random read/write
1534: E8E4     73F5       	DW	LOGOFF		;37     
1535: E8E6     5FEB       	DW	Return			;38		Simple Return
1536: E8E8     5FEB       	DW	Return			;39		Simple Return
1537: E8EA     94F5       	DW	WTSPECL		;40		Write a "record" randomly with zero fill
1538: E8EC                	                   
1539: E8EC                FunctionCount	EQU	 ($ -FunctionVector)/2
1540: E8EC                                    
1541: E8EC                ;                   
1542: E8EC                ;   Bdos error table.
1543: E8EC                ;                   
1544: E8EC     F4E8       BADSCTR:	DW	ERROR1	;bad sector on read or write.
1545: E8EE     00E9       BADSLCT:	DW	ERROR2	;bad disk select.
1546: E8F0     06E9       RODISK:		DW	ERROR3	;disk is read only.
1547: E8F2     0CE9       ROFILE:		DW	ERROR4	;file is read only.
1548: E8F4                ;                   
1549: E8F4                ;                   
1550: E8F4                ;   Bdos error message section.
1551: E8F4                ;                   
1552: E8F4                ERROR1:             
1553: E8F4     2125E9     	LXI	H,BADSEC	;bad sector message.
1554: E8F7     CD40E9     	CALL	PRTERR	;print it and get a 1 char responce.
1555: E8FA     FE03       	CPI	CNTRLC	;re-boot request (control-c)?
1556: E8FC     CA0000     	JZ	0	;yes.         
1557: E8FF     C9         	RET		;no, return to retry i/o function.
1558: E900                ;                   
1559: E900                ERROR2:             
1560: E900     2130E9     	LXI	H,BADSEL	;bad drive selected.
1561: E903     C30FE9     	JMP	ERROR5         
1562: E906                ;                   
1563: E906                ERROR3:             
1564: E906     213CE9     	LXI	H,DISKRO	;disk is read only.
1565: E909     C30FE9     	JMP	ERROR5         
1566: E90C                ;                   
1567: E90C                ERROR4:             
1568: E90C     2137E9     	LXI	H,FILERO	;file is read only.
1569: E90F                ;                   
1570: E90F                ERROR5:             
1571: E90F     CD40E9     	CALL	PRTERR        
1572: E912     C30000     	JMP	0	;always reboot on these errors.
1573: E915                ;                   
1574: E915     42444F5320455252204F4E20 BDOSERR:	DB	'Bdos Err On '
1575: E921     203A2024   BDOSDRV:	DB	' : $'  
1576: E925     42414420534543544F5224 BADSEC:		DB	'Bad Sector$'
1577: E930     53454C45435424 BADSEL:		DB	'Select$'
1578: E937     46494C4520 FILERO:		DB	'File ' 
1579: E93C     522F4F24   DISKRO:		DB	'R/O$'  
1580: E940                ;                   
1581: E940                ;   Print bdos error message.
1582: E940                ;                   
1583: E940                PRTERR:             
1584: E940     E5         	PUSH	H	;save second message pointer.
1585: E941     CD24EA     	CALL	OUTCRLF	;send (cr)(lf).
1586: E944     3AA6F5     	LDA	CurrentDrive	;get Current Drive drive.
1587: E947     C641       	ADI	041H	; 'A'	;make ascii.
1588: E949     3221E9     	STA	BDOSDRV	;and put in message.
1589: E94C     0115E9     	LXI	B,BDOSERR;and print it.
1590: E94F     CD2EEA     	CALL	PRTMESG       
1591: E952     C1         	POP	B	;print second message line now.
1592: E953     CD2EEA     	CALL	PRTMESG       
1593: E956                ;                   
1594: E956                ;   Get an input character. We will check our 1 character
1595: E956                ; buffer first. This may be set by the console status routine.
1596: E956                ;                   
1597: E956                GETCHAR:            
1598: E956     2169EB     	LXI	H,CHARBUF;check character buffer.
1599: E959     7E         	MOV	A,M	;anything present already?
1600: E95A     3600       	MVI	M,0	;...either case clear it.
1601: E95C     B7         	ORA	A              
1602: E95D     C0         	RNZ		;yes, use it. 
1603: E95E     C309F6     	JMP	CONIN	;nope, go get a character responce.
1604: E961                ;                   
1605: E961                ;   Input and echo a character.
1606: E961                ;                   
1607: E961                GETECHO:            
1608: E961     CD56E9     	CALL	GETCHAR	;input a character.
1609: E964     CD6FE9     	CALL	CHKCHAR	;carriage control?
1610: E967     D8         	RC		;no, a regular control char so don't echo.
1611: E968     F5         	PUSH	PSW	;ok, save character now.
1612: E969     4F         	MOV	C,A            
1613: E96A     CDEBE9     	CALL	OUTCON	;and echo it.
1614: E96D     F1         	POP	PSW	;get character and return.
1615: E96E     C9         	RET                
1616: E96F                ;                   
1617: E96F                ;   Check character in (A). Set the zero flag on a carriage
1618: E96F                ; control character and the carry flag on any other control
1619: E96F                ; character.        
1620: E96F                ;                   
1621: E96F                CHKCHAR:            
1622: E96F     FE0D       	CPI	CR	;check for carriage return, line feed, backspace,
1623: E971     C8         	RZ		;or a tab.     
1624: E972     FE0A       	CPI	LF             
1625: E974     C8         	RZ                 
1626: E975     FE09       	CPI	TAB            
1627: E977     C8         	RZ                 
1628: E978     FE08       	CPI	BS             
1629: E97A     C8         	RZ                 
1630: E97B     FE20       	CPI	BLANK	;other control char? Set carry flag.
1631: E97D     C9         	RET                
1632: E97E                ;                   
1633: E97E                ;   Check the console during output. Halt on a control-s, then
1634: E97E                ; reboot on a control-c. If anything else is ready, clear the
1635: E97E                ; zero flag and return (the calling routine may want to do
1636: E97E                ; something).       
1637: E97E                ;                   
1638: E97E                CKCONSOL:           
1639: E97E     3A69EB     	LDA	CHARBUF	;check buffer.
1640: E981     B7         	ORA	A	;if anything, just return without checking.
1641: E982     C2A0E9     	JNZ	CKCON2         
1642: E985     CD06F6     	CALL	CONST	;nothing in buffer. Check console.
1643: E988     E601       	ANI	01H	;look at bit 0.
1644: E98A     C8         	RZ		;return if nothing.
1645: E98B     CD09F6     	CALL	CONIN	;ok, get it.
1646: E98E     FE13       	CPI	CNTRLS	;if not control-s, return with zero cleared.
1647: E990     C29DE9     	JNZ	CKCON1         
1648: E993     CD09F6     	CALL	CONIN	;halt processing until another char
1649: E996     FE03       	CPI	CNTRLC	;is typed. Control-c?
1650: E998     CA0000     	JZ	0	;yes, reboot now.
1651: E99B     AF         	XRA	A	;no, just pretend nothing was ever ready.
1652: E99C     C9         	RET                
1653: E99D                CKCON1:             
1654: E99D     3269EB     	STA	CHARBUF	;save character in buffer for later processing.
1655: E9A0                CKCON2:             
1656: E9A0     3E01       	MVI	A,1	;set (A) to non zero to mean something is ready.
1657: E9A2     C9         	RET                
1658: E9A3                ;                   
1659: E9A3                ;   Output (C) to the screen. If the printer flip-flop flag
1660: E9A3                ; is set, we will send character to printer also. The console
1661: E9A3                ; will be checked in the process.
1662: E9A3                ;                   
1663: E9A3                OUTCHAR:            
1664: E9A3     3A65EB     	LDA	OUTFLAG	;check output flag.
1665: E9A6     B7         	ORA	A	;anything and we won't generate output.
1666: E9A7     C2BDE9     	JNZ	OUTCHR1        
1667: E9AA     C5         	PUSH	B             
1668: E9AB     CD7EE9     	CALL	CKCONSOL;check console (we don't care whats there).
1669: E9AE     C1         	POP	B              
1670: E9AF     C5         	PUSH	B             
1671: E9B0     CD0CF6     	CALL	CONOUT	;output (C) to the screen.
1672: E9B3     C1         	POP	B              
1673: E9B4     C5         	PUSH	B             
1674: E9B5     3A68EB     	LDA	PRTFLAG	;check printer flip-flop flag.
1675: E9B8     B7         	ORA	A              
1676: E9B9     C40FF6     	CNZ	LIST	;print it also if non-zero.
1677: E9BC     C1         	POP	B              
1678: E9BD                OUTCHR1:            
1679: E9BD     79         	MOV	A,C	;update cursors position.
1680: E9BE     2167EB     	LXI	H,CURPOS       
1681: E9C1     FE7F       	CPI	DEL	;rubouts don't do anything here.
1682: E9C3     C8         	RZ                 
1683: E9C4     34         	INR	M	;bump line pointer.
1684: E9C5     FE20       	CPI	BLANK	;and return if a normal character.
1685: E9C7     D0         	RNC                
1686: E9C8     35         	DCR	M	;restore and check for the start of the line.
1687: E9C9     7E         	MOV	A,M            
1688: E9CA     B7         	ORA	A              
1689: E9CB     C8         	RZ		;ingnore control characters at the start of the line.
1690: E9CC     79         	MOV	A,C            
1691: E9CD     FE08       	CPI	BS	;is it a backspace?
1692: E9CF     C2D4E9     	JNZ	OUTCHR2        
1693: E9D2     35         	DCR	M	;yes, backup pointer.
1694: E9D3     C9         	RET                
1695: E9D4                OUTCHR2:            
1696: E9D4     FE0A       	CPI	LF	;is it a line feed?
1697: E9D6     C0         	RNZ		;ignore anything else.
1698: E9D7     3600       	MVI	M,0	;reset pointer to start of line.
1699: E9D9     C9         	RET                
1700: E9DA                ;                   
1701: E9DA                ;   Output (A) to the screen. If it is a control character
1702: E9DA                ; (other than carriage control), use ^x format.
1703: E9DA                ;                   
1704: E9DA                SHOWIT:             
1705: E9DA     79         	MOV	A,C            
1706: E9DB     CD6FE9     	CALL	CHKCHAR	;check character.
1707: E9DE     D2EBE9     	JNC	OUTCON	;not a control, use normal output.
1708: E9E1     F5         	PUSH	PSW           
1709: E9E2     0E5E       	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1710: E9E4     CDA3E9     	CALL	OUTCHAR       
1711: E9E7     F1         	POP	PSW            
1712: E9E8     F640       	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1713: E9EA     4F         	MOV	C,A            
1714: E9EB                ;                   
1715: E9EB                ;   Function to output (C) to the console device and expand tabs
1716: E9EB                ; if necessary.     
1717: E9EB                ;                   
1718: E9EB                OUTCON:             
1719: E9EB     79         	MOV	A,C            
1720: E9EC     FE09       	CPI	TAB	;is it a tab?
1721: E9EE     C2A3E9     	JNZ	OUTCHAR	;use regular output.
1722: E9F1                OUTCON1:            
1723: E9F1     0E20       	MVI	C,BLANK	;yes it is, use spaces instead.
1724: E9F3     CDA3E9     	CALL	OUTCHAR       
1725: E9F6     3A67EB     	LDA	CURPOS	;go until the cursor is at a multiple of 8
1726: E9F9                                    
1727: E9F9     E607       	ANI	07H	;position. 
1728: E9FB     C2F1E9     	JNZ	OUTCON1        
1729: E9FE     C9         	RET                
1730: E9FF                ;                   
1731: E9FF                ;   Echo a backspace character. Erase the prevoius character
1732: E9FF                ; on the screen.    
1733: E9FF                ;                   
1734: E9FF                BACKUP:             
1735: E9FF     CD07EA     	CALL	BACKUP1	;backup the screen 1 place.
1736: EA02     0E20       	MVI	C,BLANK	;then blank that character.
1737: EA04     CD0CF6     	CALL	CONOUT        
1738: EA07                BACKUP1:            
1739: EA07     0E08       	MVI	C,BS	;then back space once more.
1740: EA09     C30CF6     	JMP	CONOUT         
1741: EA0C                ;                   
1742: EA0C                ;   Signal a deleted line. Print a '#' at the end and start
1743: EA0C                ; over.             
1744: EA0C                ;                   
1745: EA0C                NEWLINE:            
1746: EA0C     0E23       	MVI	C, POUNDSN		; '#'
1747: EA0E     CDA3E9     	CALL	OUTCHAR	;print this.
1748: EA11     CD24EA     	CALL	OUTCRLF	;start new line.
1749: EA14                NEWLN1:             
1750: EA14     3A67EB     	LDA	CURPOS	;move the cursor to the starting position.
1751: EA17     2166EB     	LXI	H,STARTING     
1752: EA1A     BE         	CMP	M              
1753: EA1B     D0         	RNC		;there yet?   
1754: EA1C     0E20       	MVI	C,BLANK        
1755: EA1E     CDA3E9     	CALL	OUTCHAR	;nope, keep going.
1756: EA21     C314EA     	JMP	NEWLN1         
1757: EA24                ;                   
1758: EA24                ;   Output a (cr) (lf) to the console device (screen).
1759: EA24                ;                   
1760: EA24                OUTCRLF:            
1761: EA24     0E0D       	MVI	C,CR           
1762: EA26     CDA3E9     	CALL	OUTCHAR       
1763: EA29     0E0A       	MVI	C,LF           
1764: EA2B     C3A3E9     	JMP	OUTCHAR        
1765: EA2E                ;                   
1766: EA2E                ;   Print message pointed to by (BC). It will end with a '$'.
1767: EA2E                ;                   
1768: EA2E                PRTMESG:            
1769: EA2E     0A         	LDAX	B	;check for terminating character.
1770: EA2F     FE24       	CPI	DOLLAR		; '$'  
1771: EA31     C8         	RZ                 
1772: EA32     03         	INX	B              
1773: EA33     C5         	PUSH	B	;otherwise, bump pointer and print it.
1774: EA34     4F         	MOV	C,A            
1775: EA35     CDEBE9     	CALL	OUTCON        
1776: EA38     C1         	POP	B              
1777: EA39     C32EEA     	JMP	PRTMESG        
1778: EA3C                ;                   
1779: EA3C                ;   Function to execute a buffered read.
1780: EA3C                ;                   
1781: EA3C                RDBUFF:             
1782: EA3C     3A67EB     	LDA	CURPOS	;use present location as starting one.
1783: EA3F     3266EB     	STA	STARTING       
1784: EA42     2A3CE8     	LHLD	ParamsDE	;get the maximum buffer space.
1785: EA45     4E         	MOV	C,M            
1786: EA46     23         	INX	H	;point to first available space.
1787: EA47     E5         	PUSH	H	;and save.  
1788: EA48     0600       	MVI	B,0	;keep a character count.
1789: EA4A                RDBUF1:             
1790: EA4A     C5         	PUSH	B             
1791: EA4B     E5         	PUSH	H             
1792: EA4C                RDBUF2:             
1793: EA4C     CD56E9     	CALL	GETCHAR	;get the next input character.
1794: EA4F     E67F       	ANI	7FH	;strip bit 7.
1795: EA51     E1         	POP	H	;reset registers.
1796: EA52     C1         	POP	B              
1797: EA53     FE0D       	CPI	CR	;en of the line?
1798: EA55     CA1CEB     	JZ	RDBUF17         
1799: EA58     FE0A       	CPI	LF             
1800: EA5A     CA1CEB     	JZ	RDBUF17         
1801: EA5D     FE08       	CPI	BS	;how about a backspace?
1802: EA5F     C271EA     	JNZ	RDBUF3         
1803: EA62     78         	MOV	A,B	;yes, but ignore at the beginning of the line.
1804: EA63     B7         	ORA	A              
1805: EA64     CA4AEA     	JZ	RDBUF1          
1806: EA67     05         	DCR	B	;ok, update counter.
1807: EA68     3A67EB     	LDA	CURPOS	;if we backspace to the start of the line,
1808: EA6B     3265EB     	STA	OUTFLAG	;treat as a cancel (control-x).
1809: EA6E     C3CBEA     	JMP	RDBUF10        
1810: EA71                RDBUF3:             
1811: EA71     FE7F       	CPI	DEL	;user typed a rubout?
1812: EA73     C281EA     	JNZ	RDBUF4         
1813: EA76     78         	MOV	A,B	;ignore at the start of the line.
1814: EA77     B7         	ORA	A              
1815: EA78     CA4AEA     	JZ	RDBUF1          
1816: EA7B     7E         	MOV	A,M	;ok, echo the prevoius character.
1817: EA7C     05         	DCR	B	;and reset pointers (counters).
1818: EA7D     2B         	DCX	H              
1819: EA7E     C304EB     	JMP	RDBUF15        
1820: EA81                RDBUF4:             
1821: EA81     FE05       	CPI	CNTRLE	;physical end of line?
1822: EA83     C292EA     	JNZ	RDBUF5         
1823: EA86     C5         	PUSH	B	;yes, do it.
1824: EA87     E5         	PUSH	H             
1825: EA88     CD24EA     	CALL	OUTCRLF       
1826: EA8B     AF         	XRA	A	;and update starting position.
1827: EA8C     3266EB     	STA	STARTING       
1828: EA8F     C34CEA     	JMP	RDBUF2         
1829: EA92                RDBUF5:             
1830: EA92     FE10       	CPI	CNTRLP	;control-p?
1831: EA94     C2A3EA     	JNZ	RDBUF6         
1832: EA97     E5         	PUSH	H	;yes, flip the print flag filp-flop byte.
1833: EA98     2168EB     	LXI	H,PRTFLAG      
1834: EA9B     3E01       	MVI	A,1	;PRTFLAG=1-PRTFLAG
1835: EA9D     96         	SUB	M              
1836: EA9E     77         	MOV	M,A            
1837: EA9F     E1         	POP	H              
1838: EAA0     C34AEA     	JMP	RDBUF1         
1839: EAA3                RDBUF6:             
1840: EAA3     FE18       	CPI	CNTRLX	;control-x (cancel)?
1841: EAA5     C2BAEA     	JNZ	RDBUF8         
1842: EAA8     E1         	POP	H              
1843: EAA9                RDBUF7:             
1844: EAA9     3A66EB     	LDA	STARTING;yes, backup the cursor to here.
1845: EAAC     2167EB     	LXI	H,CURPOS       
1846: EAAF     BE         	CMP	M              
1847: EAB0     D23CEA     	JNC	RDBUFF	;done yet?
1848: EAB3     35         	DCR	M	;no, decrement pointer and output back up one space.
1849: EAB4     CDFFE9     	CALL	BACKUP        
1850: EAB7     C3A9EA     	JMP	RDBUF7         
1851: EABA                RDBUF8:             
1852: EABA     FE15       	CPI	CNTRLU	;cntrol-u (cancel line)?
1853: EABC     C2C6EA     	JNZ	RDBUF9         
1854: EABF     CD0CEA     	CALL	NEWLINE	;start a new line.
1855: EAC2     E1         	POP	H              
1856: EAC3     C33CEA     	JMP	RDBUFF         
1857: EAC6                RDBUF9:             
1858: EAC6     FE12       	CPI	CNTRLR	;control-r?
1859: EAC8     C201EB     	JNZ	RDBUF14        
1860: EACB                RDBUF10:            
1861: EACB     C5         	PUSH	B	;yes, start a new line and retype the old one.
1862: EACC     CD0CEA     	CALL	NEWLINE       
1863: EACF     C1         	POP	B              
1864: EAD0     E1         	POP	H              
1865: EAD1     E5         	PUSH	H             
1866: EAD2     C5         	PUSH	B             
1867: EAD3                RDBUF11:            
1868: EAD3     78         	MOV	A,B	;done whole line yet?
1869: EAD4     B7         	ORA	A              
1870: EAD5     CAE5EA     	JZ	RDBUF12         
1871: EAD8     23         	INX	H	;nope, get next character.
1872: EAD9     4E         	MOV	C,M            
1873: EADA     05         	DCR	B	;count it.   
1874: EADB     C5         	PUSH	B             
1875: EADC     E5         	PUSH	H             
1876: EADD     CDDAE9     	CALL	SHOWIT	;and display it.
1877: EAE0     E1         	POP	H              
1878: EAE1     C1         	POP	B              
1879: EAE2     C3D3EA     	JMP	RDBUF11        
1880: EAE5                RDBUF12:            
1881: EAE5     E5         	PUSH	H	;done with line. If we were displaying
1882: EAE6     3A65EB     	LDA	OUTFLAG	;then update cursor position.
1883: EAE9     B7         	ORA	A              
1884: EAEA     CA4CEA     	JZ	RDBUF2          
1885: EAED     2167EB     	LXI	H,CURPOS;because this line is shorter, we must
1886: EAF0     96         	SUB	M	;back up the cursor (not the screen however)
1887: EAF1     3265EB     	STA	OUTFLAG	;some number of positions.
1888: EAF4                RDBUF13:            
1889: EAF4     CDFFE9     	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1890: EAF7     2165EB     	LXI	H,OUTFLAG;zero, the screen will not be changed.
1891: EAFA     35         	DCR	M              
1892: EAFB     C2F4EA     	JNZ	RDBUF13        
1893: EAFE     C34CEA     	JMP	RDBUF2	;now just get the next character.
1894: EB01                ;                   
1895: EB01                ;   Just a normal character, put this in our buffer and echo.
1896: EB01                ;                   
1897: EB01                RDBUF14:            
1898: EB01     23         	INX	H              
1899: EB02     77         	MOV	M,A	;store character.
1900: EB03     04         	INR	B	;and count it.
1901: EB04                RDBUF15:            
1902: EB04     C5         	PUSH	B             
1903: EB05     E5         	PUSH	H             
1904: EB06     4F         	MOV	C,A	;echo it now.
1905: EB07     CDDAE9     	CALL	SHOWIT        
1906: EB0A     E1         	POP	H              
1907: EB0B     C1         	POP	B              
1908: EB0C     7E         	MOV	A,M	;was it an abort request?
1909: EB0D     FE03       	CPI	CNTRLC	;control-c abort?
1910: EB0F     78         	MOV	A,B            
1911: EB10     C218EB     	JNZ	RDBUF16        
1912: EB13     FE01       	CPI	1	;only if at start of line.
1913: EB15     CA0000     	JZ	0               
1914: EB18                RDBUF16:            
1915: EB18     B9         	CMP	C	;nope, have we filled the buffer?
1916: EB19     DA4AEA     	JC	RDBUF1          
1917: EB1C                RDBUF17:            
1918: EB1C     E1         	POP	H	;yes end the line and return.
1919: EB1D     70         	MOV	M,B            
1920: EB1E     0E0D       	MVI	C,CR           
1921: EB20     C3A3E9     	JMP	OUTCHAR	;output (cr) and return.
1922: EB23                ;                   
1923: EB23                ;   Function to get a character from the console device.
1924: EB23                ;                   
1925: EB23                GETCON:             
1926: EB23     CD61E9     	CALL	GETECHO	;get and echo.
1927: EB26     C35CEB     	JMP	SETSTAT	;save status and return.
1928: EB29                ;                   
1929: EB29                ;   Function to get a character from the tape reader device.
1930: EB29                ;                   
1931: EB29                GETRDR:             
1932: EB29     CD15F6     	CALL	READER	;get a character from reader, set status and return.
1933: EB2C     C35CEB     	JMP	SETSTAT        
1934: EB2F                ;                   
1935: EB2F                ;  Function to perform direct console i/o. If (C) contains (FF)
1936: EB2F                ; then this is an input request. If (C) contains (FE) then
1937: EB2F                ; this is a status request. Otherwise we are to output (C).
1938: EB2F                ;                   
1939: EB2F                DIRCIO:             
1940: EB2F     79         	MOV	A,C	;test for (FF).
1941: EB30     3C         	INR	A              
1942: EB31     CA3BEB     	JZ	DIRC1           
1943: EB34     3C         	INR	A	;test for (FE).
1944: EB35     CA06F6     	JZ	CONST           
1945: EB38     C30CF6     	JMP	CONOUT	;just output (C).
1946: EB3B                DIRC1:              
1947: EB3B     CD06F6     	CALL	CONST	;this is an input request.
1948: EB3E     B7         	ORA	A              
1949: EB3F     CA90E8     	JZ	BDOSExit1	;not ready? Just return (directly).
1950: EB42     CD09F6     	CALL	CONIN	;yes, get character.
1951: EB45     C35CEB     	JMP	SETSTAT	;set status and return.
1952: EB48                ;                   
1953: EB48                ;   Function to return the i/o byte.
1954: EB48                ;                   
1955: EB48                GETIOB:             
1956: EB48     3A0300     	LDA	IOBYTE         
1957: EB4B     C35CEB     	JMP	SETSTAT        
1958: EB4E                ;                   
1959: EB4E                ;   Function to set the i/o byte.
1960: EB4E                ;                   
1961: EB4E                SETIOB:             
1962: EB4E     210300     	LXI	H,IOBYTE       
1963: EB51     71         	MOV	M,C            
1964: EB52     C9         	RET                
1965: EB53                ;                   
1966: EB53                ;   Function to print the character string pointed to by (DE)
1967: EB53                ; on the console device. The string ends with a '$'.
1968: EB53                ;                   
1969: EB53                PRTSTR:             
1970: EB53     EB         	XCHG               
1971: EB54     4D         	MOV	C,L            
1972: EB55     44         	MOV	B,H	;now (BC) points to it.
1973: EB56     C32EEA     	JMP	PRTMESG        
1974: EB59                ;                   
1975: EB59                ;   Function to interigate the console device.
1976: EB59                ;                   
1977: EB59                GETCSTS:            
1978: EB59     CD7EE9     	CALL	CKCONSOL      
1979: EB5C                ;                   
1980: EB5C                ;   Get here to set the status and return to the cleanup
1981: EB5C                ; section. Then back to the user.
1982: EB5C                ;                   
1983: EB5C                SETSTAT:            
1984: EB5C     323FE8     	STA	StatusBDOSReturn
1985: EB5F                Return:             
1986: EB5F     C9         	RET                
1987: EB60                ;                   
1988: EB60                ;   Set the status to 1 (read or write error code).
1989: EB60                ;                   
1990: EB60                IOERR1:             
1991: EB60     3E01       	MVI	A,1            
1992: EB62     C35CEB     	JMP	SETSTAT        
1993: EB65                ;                   
1994: EB65     00         OUTFLAG:	DB	0	;output flag (non zero means no output).
1995: EB66     02         STARTING:	DB	2	;starting position for cursor.
1996: EB67     00         CURPOS:		DB	0	;cursor position (0=start of line).
1997: EB68     00         PRTFLAG:	DB	0	;printer flag (control-p toggle). List if non zero.
1998: EB69     00         CHARBUF:	DB	0	;single input character buffer.
1999: EB6A                ;                   
2000: EB6A                ;   Stack area for BDOS calls.
2001: EB6A                ;                   
2002: EB6A                                    
2003: EB6A                ;                   
2004: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2005: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2006: EB6A                ;BDOSstack	EQU	$	;end of stack area.
2007: EB6A                ;                   
2008: EB6A                ;                   
2009: EB6A                ;   Select error occured, jump to error routine.
2010: EB6A                ;                   
2011: EB6A                SLCTERR:            
2012: EB6A     21EEE8     	LXI	H,BADSLCT      
2013: EB6D                ;                   
2014: EB6D                ;   Jump to (HL) indirectly.
2015: EB6D                ;                   
2016: EB6D                JUMPHL:             
2017: EB6D     5E         	MOV	E,M            
2018: EB6E     23         	INX	H              
2019: EB6F     56         	MOV	D,M	;now (DE) contain the desired address.
2020: EB70     EB         	XCHG               
2021: EB71     E9         	PCHL               
2022: EB72                ;                   
2023: EB72                ;   Block move. (DE) to (HL), (C) bytes total.
2024: EB72                ;                   
2025: EB72                DE2HL:              
2026: EB72     0C         	INR	C	;is count down to zero?
2027: EB73                DE2HL1:             
2028: EB73     0D         	DCR	C              
2029: EB74     C8         	RZ		;yes, we are done.
2030: EB75     1A         	LDAX	D	;no, move one more byte.
2031: EB76     77         	MOV	M,A            
2032: EB77     13         	INX	D              
2033: EB78     23         	INX	H              
2034: EB79     C373EB     	JMP	DE2HL1	;and repeat.
2035: EB7C                ;                   
2036: EB7C                ;   Select the desired drive.
2037: EB7C                ;                   
2038: EB7C                SelectDisk:         
2039: EB7C     3AA6F5     	LDA		CurrentDrive	; get active disk.
2040: EB7F     4F         	MOV		C,A				; set up for Bios call, put disk in (C)
2041: EB80     CD1BF6     	CALL	SELDSK			; (BIOS CALL )select it.
2042: EB83     7C         	MOV	A,H					;	HL = 0000 if invalid
2043: EB84     B5         	ORA	L					; otherwise it points to the correct Disk Parameter Block
2044: EB85     C8         	RZ						; so, return if HL = 0000
2045: EB86                ;                   
2046: EB86                ;   Here, the BIOS returned the address of the parameter block
2047: EB86                ; in (HL). We will extract the necessary pointers and save them.
2048: EB86                ;                   
2049: EB86     5E         	MOV	E,M					; first word of DPB points to the drive's skew table
2050: EB87     23         	INX	H              
2051: EB88     56         	MOV	D,M					; Get it and put it into (DE)
2052: EB89     23         	INX	H					         
2053: EB8A     22AEF5     	SHLD	FilePosInDir	;save pointers to scratch areas.
2054: EB8D     23         	INX	H              
2055: EB8E     23         	INX	H              
2056: EB8F     22B0F5     	SHLD	LastTrackNumber	;ditto.
2057: EB92     23         	INX	H              
2058: EB93     23         	INX	H              
2059: EB94     22B2F5     	SHLD	LastSectorNumber	;ditto.
2060: EB97     23         	INX	H              
2061: EB98     23         	INX	H              
2062: EB99     EB         	XCHG		;now save the translation table address.
2063: EB9A     22CBF5     	SHLD	XLATE         
2064: EB9D     21B4F5     	LXI	H,DIRBUF	;put the next 8 bytes here.
2065: EBA0     0E08       	MVI	C,8	;they consist of the directory buffer
2066: EBA2     CD72EB     	CALL	DE2HL	;pointer, parameter block pointer,
2067: EBA5     2AB6F5     	LHLD	DISKPB	;check and allocation vectors.
2068: EBA8     EB         	XCHG               
2069: EBA9     21BCF5     	LXI	H,SECTORS	;move parameter block into our ram.
2070: EBAC     0E0F       	MVI	C,15	;it is 15 bytes long.
2071: EBAE     CD72EB     	CALL	DE2HL         
2072: EBB1     2AC1F5     	LHLD	DSKSIZE	;check disk size.
2073: EBB4     7C         	MOV	A,H	;more than 256 blocks on this?
2074: EBB5     21D7F5     	LXI	H,BIGDISK      
2075: EBB8     36FF       	MVI	M,0FFH	;set to samll.
2076: EBBA     B7         	ORA	A              
2077: EBBB     CAC0EB     	JZ	SelectDisk1     
2078: EBBE     3600       	MVI	M,0	;wrong, set to large.
2079: EBC0                SelectDisk1:        
2080: EBC0     3EFF       	MVI	A,0FFH	;clear the zero flag.
2081: EBC2     B7         	ORA	A              
2082: EBC3     C9         	RET                
2083: EBC4                ;                   
2084: EBC4                ;   Routine to home the disk track head and clear pointers.
2085: EBC4                ;                   
2086: EBC4                HOMEDRV:            
2087: EBC4     CD18F6     	CALL	HOME	;home the head.
2088: EBC7     AF         	XRA	A              
2089: EBC8     2AB0F5     	LHLD	LastTrackNumber;set our track pointer also.
2090: EBCB     77         	MOV	M,A            
2091: EBCC     23         	INX	H              
2092: EBCD     77         	MOV	M,A            
2093: EBCE     2AB2F5     	LHLD	LastSectorNumber;and our sector pointer.
2094: EBD1     77         	MOV	M,A            
2095: EBD2     23         	INX	H              
2096: EBD3     77         	MOV	M,A            
2097: EBD4     C9         	RET                
2098: EBD5                ;                   
2099: EBD5                ;   Do the actual disk read and check the error return status.
2100: EBD5                ;                   
2101: EBD5                DOREAD:             
2102: EBD5     CD27F6     	CALL	READ          
2103: EBD8     C3DEEB     	JMP	IORET          
2104: EBDB                ;                   
2105: EBDB                ;   Do the actual disk write and handle any bios error.
2106: EBDB                ;                   
2107: EBDB                DOWRITE:            
2108: EBDB     CD2AF6     	CALL	WRITE         
2109: EBDE                IORET:              
2110: EBDE     B7         	ORA	A              
2111: EBDF     C8         	RZ		;return unless an error occured.
2112: EBE0     21ECE8     	LXI	H,BADSCTR;bad read/write on this sector.
2113: EBE3     C36DEB     	JMP	JUMPHL         
2114: EBE6                ;                   
2115: EBE6                ;   Routine to select the track and sector that the desired
2116: EBE6                ; block number falls in.
2117: EBE6                ;                   
2118: EBE6                TRKSEC:             
2119: EBE6     2AE4F5     	LHLD	FILEPOS	;get position of last accessed file
2120: EBE9     0E02       	MVI	C,2	;in directory and compute sector #.
2121: EBEB     CD0DED     	CALL	SHIFTR	;sector #=file-position/4.
2122: EBEE     22DFF5     	SHLD	BLKNMBR	;save this as the block number of interest.
2123: EBF1     22E6F5     	SHLD	CKSUMTBL;what's it doing here too?
2124: EBF4                ;                   
2125: EBF4                ;   if the sector number has already been set (BLKNMBR), enter
2126: EBF4                ; at this point.    
2127: EBF4                ;                   
2128: EBF4                TRKSEC1:            
2129: EBF4     21DFF5     	LXI	H,BLKNMBR      
2130: EBF7     4E         	MOV	C,M	;move sector number into (BC).
2131: EBF8     23         	INX	H              
2132: EBF9     46         	MOV	B,M            
2133: EBFA     2AB2F5     	LHLD	LastSectorNumber;get current sector number and
2134: EBFD     5E         	MOV	E,M	;move this into (DE).
2135: EBFE     23         	INX	H              
2136: EBFF     56         	MOV	D,M            
2137: EC00     2AB0F5     	LHLD	LastTrackNumber;get current track number.
2138: EC03     7E         	MOV	A,M	;and this into (HL).
2139: EC04     23         	INX	H              
2140: EC05     66         	MOV	H,M            
2141: EC06     6F         	MOV	L,A            
2142: EC07                TRKSEC2:            
2143: EC07     79         	MOV	A,C	;is desired sector before current one?
2144: EC08     93         	SUB	E              
2145: EC09     78         	MOV	A,B            
2146: EC0A     9A         	SBB	D              
2147: EC0B     D21DEC     	JNC	TRKSEC3        
2148: EC0E     E5         	PUSH	H	;yes, decrement sectors by one track.
2149: EC0F     2ABCF5     	LHLD	SECTORS	;get sectors per track.
2150: EC12     7B         	MOV	A,E            
2151: EC13     95         	SUB	L              
2152: EC14     5F         	MOV	E,A            
2153: EC15     7A         	MOV	A,D            
2154: EC16     9C         	SBB	H              
2155: EC17     57         	MOV	D,A	;now we have backed up one full track.
2156: EC18     E1         	POP	H              
2157: EC19     2B         	DCX	H	;adjust track counter.
2158: EC1A     C307EC     	JMP	TRKSEC2        
2159: EC1D                TRKSEC3:            
2160: EC1D     E5         	PUSH	H	;desired sector is after current one.
2161: EC1E     2ABCF5     	LHLD	SECTORS	;get sectors per track.
2162: EC21     19         	DAD	D	;bump sector pointer to next track.
2163: EC22     DA32EC     	JC	TRKSEC4         
2164: EC25     79         	MOV	A,C	;is desired sector now before current one?
2165: EC26     95         	SUB	L              
2166: EC27     78         	MOV	A,B            
2167: EC28     9C         	SBB	H              
2168: EC29     DA32EC     	JC	TRKSEC4         
2169: EC2C     EB         	XCHG		;not yes, increment track counter
2170: EC2D     E1         	POP	H	;and continue until it is.
2171: EC2E     23         	INX	H              
2172: EC2F     C31DEC     	JMP	TRKSEC3        
2173: EC32                ;                   
2174: EC32                ;   here we have determined the track number that contains the
2175: EC32                ; desired sector.   
2176: EC32                ;                   
2177: EC32                TRKSEC4:            
2178: EC32     E1         	POP	H	;get track number (HL).
2179: EC33     C5         	PUSH	B             
2180: EC34     D5         	PUSH	D             
2181: EC35     E5         	PUSH	H             
2182: EC36     EB         	XCHG               
2183: EC37     2AC9F5     	LHLD	OFFSET	;adjust for first track offset.
2184: EC3A     19         	DAD	D              
2185: EC3B     44         	MOV	B,H            
2186: EC3C     4D         	MOV	C,L            
2187: EC3D     CD1EF6     	CALL	SETTRK	;select this track.
2188: EC40     D1         	POP	D	;reset current track pointer.
2189: EC41     2AB0F5     	LHLD	LastTrackNumber
2190: EC44     73         	MOV	M,E            
2191: EC45     23         	INX	H              
2192: EC46     72         	MOV	M,D            
2193: EC47     D1         	POP	D              
2194: EC48     2AB2F5     	LHLD	LastSectorNumber;reset the first sector on this track.
2195: EC4B     73         	MOV	M,E            
2196: EC4C     23         	INX	H              
2197: EC4D     72         	MOV	M,D            
2198: EC4E     C1         	POP	B              
2199: EC4F     79         	MOV	A,C	;now subtract the desired one.
2200: EC50     93         	SUB	E	;to make it relative (1-# sectors/track).
2201: EC51     4F         	MOV	C,A            
2202: EC52     78         	MOV	A,B            
2203: EC53     9A         	SBB	D              
2204: EC54     47         	MOV	B,A            
2205: EC55     2ACBF5     	LHLD	XLATE	;translate this sector according to this table.
2206: EC58     EB         	XCHG               
2207: EC59     CD30F6     	CALL	SECTRN	;let the bios translate it.
2208: EC5C     4D         	MOV	C,L            
2209: EC5D     44         	MOV	B,H            
2210: EC5E     C321F6     	JMP	SETSEC	;and select it.
2211: EC61                ;                   
2212: EC61                ;   Compute block number from record number (SAVNREC) and
2213: EC61                ; extent number (SAVEXT).
2214: EC61                ;                   
2215: EC61                GETBLOCK:           
2216: EC61     21BEF5     	LXI	H,BLKSHFT;get logical to physical conversion.
2217: EC64     4E         	MOV	C,M	;note that this is base 2 log of ratio.
2218: EC65     3ADDF5     	LDA	SAVNREC	;get record number.
2219: EC68                GETBLK1:            
2220: EC68     B7         	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2221: EC69     1F         	RAR                
2222: EC6A     0D         	DCR	C              
2223: EC6B     C268EC     	JNZ	GETBLK1        
2224: EC6E     47         	MOV	B,A	;save result in (B).
2225: EC6F     3E08       	MVI	A,8            
2226: EC71     96         	SUB	M              
2227: EC72     4F         	MOV	C,A	;compute (C)=8-BLKSHFT.
2228: EC73     3ADCF5     	LDA	SAVEXT         
2229: EC76                GETBLK2:            
2230: EC76     0D         	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2231: EC77     CA7FEC     	JZ	GETBLK3         
2232: EC7A     B7         	ORA	A              
2233: EC7B     17         	RAL                
2234: EC7C     C376EC     	JMP	GETBLK2        
2235: EC7F                GETBLK3:            
2236: EC7F     80         	ADD	B              
2237: EC80     C9         	RET                
2238: EC81                ;                   
2239: EC81                ;   Routine to extract the (BC) block byte from the fcb pointed
2240: EC81                ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2241: EC81                ; block numbers, else they are 8 bit numbers.
2242: EC81                ; Number is returned in (HL).
2243: EC81                ;                   
2244: EC81                EXTBLK:             
2245: EC81     2A3CE8     	LHLD	ParamsDE	;get fcb address.
2246: EC84     111000     	LXI	D,16	;block numbers start 16 bytes into fcb.
2247: EC87     19         	DAD	D              
2248: EC88     09         	DAD	B              
2249: EC89     3AD7F5     	LDA	BIGDISK	;are we using a big-disk?
2250: EC8C     B7         	ORA	A              
2251: EC8D     CA94EC     	JZ	EXTBLK1         
2252: EC90     6E         	MOV	L,M	;no, extract an 8 bit number from the fcb.
2253: EC91     2600       	MVI	H,0            
2254: EC93     C9         	RET                
2255: EC94                EXTBLK1:            
2256: EC94     09         	DAD	B	;yes, extract a 16 bit number.
2257: EC95     5E         	MOV	E,M            
2258: EC96     23         	INX	H              
2259: EC97     56         	MOV	D,M            
2260: EC98     EB         	XCHG		;return in (HL).
2261: EC99     C9         	RET                
2262: EC9A                ;                   
2263: EC9A                ;   Compute block number.
2264: EC9A                ;                   
2265: EC9A                COMBLK:             
2266: EC9A     CD61EC     	CALL	GETBLOCK      
2267: EC9D     4F         	MOV	C,A            
2268: EC9E     0600       	MVI	B,0            
2269: ECA0     CD81EC     	CALL	EXTBLK        
2270: ECA3     22DFF5     	SHLD	BLKNMBR       
2271: ECA6     C9         	RET                
2272: ECA7                ;                   
2273: ECA7                ;   Check for a zero block number (unused).
2274: ECA7                ;                   
2275: ECA7                CHKBLK:             
2276: ECA7     2ADFF5     	LHLD	BLKNMBR       
2277: ECAA     7D         	MOV	A,L	;is it zero?
2278: ECAB     B4         	ORA	H              
2279: ECAC     C9         	RET                
2280: ECAD                ;                   
2281: ECAD                ;   Adjust physical block (BLKNMBR) and convert to logical
2282: ECAD                ; sector (LOGSECT). This is the starting sector of this block.
2283: ECAD                ; The actual sector of interest is then added to this and the
2284: ECAD                ; resulting sector number is stored back in (BLKNMBR). This
2285: ECAD                ; will still have to be adjusted for the track number.
2286: ECAD                ;                   
2287: ECAD                LOGICAL:            
2288: ECAD     3ABEF5     	LDA	BLKSHFT	;get log2(physical/logical sectors).
2289: ECB0     2ADFF5     	LHLD	BLKNMBR	;get physical sector desired.
2290: ECB3                LOGICL1:            
2291: ECB3     29         	DAD	H	;compute logical sector number.
2292: ECB4     3D         	DCR	A	;note logical sectors are 128 bytes long.
2293: ECB5     C2B3EC     	JNZ	LOGICL1        
2294: ECB8     22E1F5     	SHLD	LOGSECT	;save logical sector.
2295: ECBB     3ABFF5     	LDA	BLKMASK	;get block mask.
2296: ECBE     4F         	MOV	C,A            
2297: ECBF     3ADDF5     	LDA	SAVNREC	;get next sector to access.
2298: ECC2     A1         	ANA	C	;extract the relative position within physical block.
2299: ECC3     B5         	ORA	L	;and add it too logical sector.
2300: ECC4     6F         	MOV	L,A            
2301: ECC5     22DFF5     	SHLD	BLKNMBR	;and store.
2302: ECC8     C9         	RET                
2303: ECC9                ;                   
2304: ECC9                ;   Set (HL) to point to extent byte in fcb.
2305: ECC9                ;                   
2306: ECC9                SETEXT:             
2307: ECC9     2A3CE8     	LHLD	ParamsDE      
2308: ECCC     110C00     	LXI	D,12	;it is the twelth byte.
2309: ECCF     19         	DAD	D              
2310: ECD0     C9         	RET                
2311: ECD1                ;                   
2312: ECD1                ;   Set (HL) to point to record count byte in fcb and (DE) to
2313: ECD1                ; next record number byte.
2314: ECD1                ;                   
2315: ECD1                SETHLDE:            
2316: ECD1     2A3CE8     	LHLD	ParamsDE      
2317: ECD4     110F00     	LXI	D,15	;record count byte (#15).
2318: ECD7     19         	DAD	D              
2319: ECD8     EB         	XCHG               
2320: ECD9     211100     	LXI	H,17	;next record number (#32).
2321: ECDC     19         	DAD	D              
2322: ECDD     C9         	RET                
2323: ECDE                ;                   
2324: ECDE                ;   Save current file data from fcb.
2325: ECDE                ;                   
2326: ECDE                STRDATA:            
2327: ECDE     CDD1EC     	CALL	SETHLDE       
2328: ECE1     7E         	MOV	A,M	;get and store record count byte.
2329: ECE2     32DDF5     	STA	SAVNREC        
2330: ECE5     EB         	XCHG               
2331: ECE6     7E         	MOV	A,M	;get and store next record number byte.
2332: ECE7     32DBF5     	STA	SAVNXT         
2333: ECEA     CDC9EC     	CALL	SETEXT	;point to extent byte.
2334: ECED     3AC0F5     	LDA	EXTMASK	;get extent mask.
2335: ECF0     A6         	ANA	M              
2336: ECF1     32DCF5     	STA	SAVEXT	;and save extent here.
2337: ECF4     C9         	RET                
2338: ECF5                ;                   
2339: ECF5                ;   Set the next record to access. If (MODE) is set to 2, then
2340: ECF5                ; the last record byte (SAVNREC) has the correct number to access.
2341: ECF5                ; For sequential access, (MODE) will be equal to 1.
2342: ECF5                ;                   
2343: ECF5                SETNREC:            
2344: ECF5     CDD1EC     	CALL	SETHLDE       
2345: ECF8     3AD0F5     	LDA	MODE	;get sequential flag (=1).
2346: ECFB     FE02       	CPI	2	;a 2 indicates that no adder is needed.
2347: ECFD     C201ED     	JNZ	STNREC1        
2348: ED00     AF         	XRA	A	;clear adder (random access?).
2349: ED01                STNREC1:            
2350: ED01     4F         	MOV	C,A            
2351: ED02     3ADDF5     	LDA	SAVNREC	;get last record number.
2352: ED05     81         	ADD	C	;increment record count.
2353: ED06     77         	MOV	M,A	;and set fcb's next record byte.
2354: ED07     EB         	XCHG               
2355: ED08     3ADBF5     	LDA	SAVNXT	;get next record byte from storage.
2356: ED0B     77         	MOV	M,A	;and put this into fcb as number of records used.
2357: ED0C     C9         	RET                
2358: ED0D                ;                   
2359: ED0D                ;   Shift HL right (C) bits.
2360: ED0D                ;                   
2361: ED0D                SHIFTR:             
2362: ED0D     0C         	INR		C			; minor adjustment
2363: ED0E                SHIFTR1:            
2364: ED0E     0D         	DCR		C			; count down
2365: ED0F     C8         	RZ					; exit if done
2366: ED10     7C         	MOV		A,H			; get the hi byte
2367: ED11     B7         	ORA		A			; reset carry bit
2368: ED12     1F         	RAR					; rotate right thru carry
2369: ED13     67         	MOV		H,A			; return new hi byte
2370: ED14     7D         	MOV		A,L			; get lo byte
2371: ED15     1F         	RAR					; rotate right thru carry
2372: ED16     6F         	MOV		L,A			; return new lo byte
2373: ED17     C30EED     	JMP		SHIFTR1		; keep doing it
2374: ED1A                ;                   
2375: ED1A                ;   Compute the check-sum for the directory buffer. Return
2376: ED1A                ; integer sum in (A).
2377: ED1A                ;                   
2378: ED1A                CHECKSUM:           
2379: ED1A     0E80       	MVI	C,128	;length of buffer.
2380: ED1C     2AB4F5     	LHLD	DIRBUF	;get its location.
2381: ED1F     AF         	XRA	A	;clear summation byte.
2382: ED20                CHKSUM1:            
2383: ED20     86         	ADD	M	;and compute sum ignoring carries.
2384: ED21     23         	INX	H              
2385: ED22     0D         	DCR	C              
2386: ED23     C220ED     	JNZ	CHKSUM1        
2387: ED26     C9         	RET                
2388: ED27                ;                   
2389: ED27                ;   Shift (HL) left (C) bits.
2390: ED27                ;                   
2391: ED27                SHIFTL:             
2392: ED27     0C         	INR	C              
2393: ED28                SHIFTL1:            
2394: ED28     0D         	DCR	C              
2395: ED29     C8         	RZ                 
2396: ED2A     29         	DAD	H	;shift left 1 bit.
2397: ED2B     C328ED     	JMP	SHIFTL1        
2398: ED2E                                    
2399: ED2E                ;                   
2400: ED2E                ;   Extract the write protect status bit for the current drive.
2401: ED2E                ; The result is returned in (A), bit 0.
2402: ED2E                ;                   
2403: ED2E                GETWPRT:            
2404: ED2E     2AA8F5     	LHLD	ROBitMap	;get Read Only Bit Map
2405: ED31     3AA6F5     	LDA	CurrentDrive	;which drive is current?
2406: ED34     4F         	MOV	C,A            
2407: ED35     CD0DED     	CALL	SHIFTR	;shift status such that bit 0 is the
2408: ED38     7D         	MOV	A,L	;one of interest for this drive.
2409: ED39     E601       	ANI	01H	;and isolate it.
2410: ED3B     C9         	RET                
2411: ED3C                ;                   
2412: ED3C                ;   Function to write protect the current disk.
2413: ED3C                ;                   
2414: ED3C                WRTPRTD:            
2415: ED3C     21A8F5     	LXI	H,ROBitMap	;point to Read Only Bit Map
2416: ED3F     4E         	MOV	C,M	;set (BC) equal to the status.
2417: ED40     23         	INX	H              
2418: ED41     46         	MOV	B,M            
2419: ED42     CD52F4     	CALL	SETBIT	;and set this bit according to current drive.
2420: ED45     22A8F5     	SHLD	ROBitMap	;then save.
2421: ED48     2AC3F5     	LHLD	DIRSIZE	;now save directory size limit.
2422: ED4B     23         	INX	H	;remember the last one.
2423: ED4C     EB         	XCHG               
2424: ED4D     2AAEF5     	LHLD	FilePosInDir;and store it here.
2425: ED50     73         	MOV	M,E	;put low byte.
2426: ED51     23         	INX	H              
2427: ED52     72         	MOV	M,D	;then high byte.
2428: ED53     C9         	RET                
2429: ED54                ;                   
2430: ED54                ;   Check for a read only file.
2431: ED54                ;                   
2432: ED54                CHKROFL:            
2433: ED54     CD6EED     	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2434: ED57                CKROF1:             
2435: ED57     110900     	LXI	D,9	;look at bit 7 of the ninth byte.
2436: ED5A     19         	DAD	D              
2437: ED5B     7E         	MOV	A,M            
2438: ED5C     17         	RAL                
2439: ED5D     D0         	RNC		;return if ok.
2440: ED5E     21F2E8     	LXI	H,ROFILE;else, print error message and terminate.
2441: ED61     C36DEB     	JMP	JUMPHL         
2442: ED64                ;                   
2443: ED64                ;   Check the write protect status of the active disk.
2444: ED64                ;                   
2445: ED64                CHKWPRT:            
2446: ED64     CD2EED     	CALL	GETWPRT       
2447: ED67     C8         	RZ		;return if ok. 
2448: ED68     21F0E8     	LXI	H,RODISK;else print message and terminate.
2449: ED6B     C36DEB     	JMP	JUMPHL         
2450: ED6E                ;                   
2451: ED6E                ;   Routine to set (HL) pointing to the proper entry in the
2452: ED6E                ; directory buffer. 
2453: ED6E                ;                   
2454: ED6E                FCB2HL:             
2455: ED6E     2AB4F5     	LHLD	DIRBUF	;get address of buffer.
2456: ED71     3AE3F5     	LDA	FCBPOS	;relative position of file.
2457: ED74                ;                   
2458: ED74                ;   Routine to add (A) to (HL).
2459: ED74                ;                   
2460: ED74                ADDA2HL:            
2461: ED74     85         	ADD	L              
2462: ED75     6F         	MOV	L,A            
2463: ED76     D0         	RNC                
2464: ED77     24         	INR	H	;take care of any carry.
2465: ED78     C9         	RET                
2466: ED79                ;                   
2467: ED79                ;   Routine to get the 's2' byte from the fcb supplied in
2468: ED79                ; the initial parameter specification.
2469: ED79                ;                   
2470: ED79                GETS2:              
2471: ED79     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
2472: ED7C     110E00     	LXI	D,14	;relative position of 's2'.
2473: ED7F     19         	DAD	D              
2474: ED80     7E         	MOV	A,M	;extract this byte.
2475: ED81     C9         	RET                
2476: ED82                ;                   
2477: ED82                ;   Clear the 's2' byte in the fcb.
2478: ED82                ;                   
2479: ED82                CLEARS2:            
2480: ED82     CD79ED     	CALL	GETS2	;this sets (HL) pointing to it.
2481: ED85     3600       	MVI	M,0	;now clear it.
2482: ED87     C9         	RET                
2483: ED88                ;                   
2484: ED88                ;   Set bit 7 in the 's2' byte of the fcb.
2485: ED88                ;                   
2486: ED88                SETS2B7:            
2487: ED88     CD79ED     	CALL	GETS2	;get the byte.
2488: ED8B     F680       	ORI	80H	;and set bit 7.
2489: ED8D     77         	MOV	M,A	;then store.
2490: ED8E     C9         	RET                
2491: ED8F                ;                   
2492: ED8F                ;   Compare (FILEPOS) with (FilePosInDir) and set flags based on
2493: ED8F                ; the difference. This checks to see if there are more file
2494: ED8F                ; names in the directory. We are at (FILEPOS) and there are
2495: ED8F                ; (FilePosInDir) of them to check.
2496: ED8F                ;                   
2497: ED8F                MOREFLS:            
2498: ED8F     2AE4F5     	LHLD	FILEPOS	;we are here.
2499: ED92     EB         	XCHG               
2500: ED93     2AAEF5     	LHLD	FilePosInDir;and don't go past here.
2501: ED96     7B         	MOV	A,E	;compute difference but don't keep.
2502: ED97     96         	SUB	M              
2503: ED98     23         	INX	H              
2504: ED99     7A         	MOV	A,D            
2505: ED9A     9E         	SBB	M	;set carry if no more names.
2506: ED9B     C9         	RET                
2507: ED9C                ;                   
2508: ED9C                ;   Call this routine to prevent (FilePosInDir) from being greater
2509: ED9C                ; than (FILEPOS).   
2510: ED9C                ;                   
2511: ED9C                CHKNMBR:            
2512: ED9C     CD8FED     	CALL	MOREFLS	;FilePosInDir too big?
2513: ED9F     D8         	RC                 
2514: EDA0     13         	INX	D	;yes, reset it to (FILEPOS).
2515: EDA1     72         	MOV	M,D            
2516: EDA2     2B         	DCX	H              
2517: EDA3     73         	MOV	M,E            
2518: EDA4     C9         	RET                
2519: EDA5                ;                   
2520: EDA5                ;   Compute (HL)=(DE)-(HL)
2521: EDA5                ;                   
2522: EDA5                SUBHL:              
2523: EDA5     7B         	MOV	A,E	;compute difference.
2524: EDA6     95         	SUB	L              
2525: EDA7     6F         	MOV	L,A	;store low byte.
2526: EDA8     7A         	MOV	A,D            
2527: EDA9     9C         	SBB	H              
2528: EDAA     67         	MOV	H,A	;and then high byte.
2529: EDAB     C9         	RET                
2530: EDAC                ;                   
2531: EDAC                ;   Set the directory checksum byte.
2532: EDAC                ;                   
2533: EDAC                SETDIR:             
2534: EDAC     0EFF       	MVI	C,0FFH         
2535: EDAE                ;                   
2536: EDAE                ;   Routine to set or compare the directory checksum byte. If
2537: EDAE                ; (C)=0ffh, then this will set the checksum byte. Else the byte
2538: EDAE                ; will be checked. If the check fails (the disk has been changed),
2539: EDAE                ; then this disk will be write protected.
2540: EDAE                ;                   
2541: EDAE                CHECKDIR:           
2542: EDAE     2AE6F5     	LHLD	CKSUMTBL      
2543: EDB1     EB         	XCHG               
2544: EDB2     2AC7F5     	LHLD	ALLOC1        
2545: EDB5     CDA5ED     	CALL	SUBHL         
2546: EDB8     D0         	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2547: EDB9     C5         	PUSH	B             
2548: EDBA     CD1AED     	CALL	CHECKSUM;else compute checksum.
2549: EDBD     2AB8F5     	LHLD	CHKVECT	;get address of checksum table.
2550: EDC0     EB         	XCHG               
2551: EDC1     2AE6F5     	LHLD	CKSUMTBL      
2552: EDC4     19         	DAD	D	;set (HL) to point to byte for this drive.
2553: EDC5     C1         	POP	B              
2554: EDC6     0C         	INR	C	;set or check ?
2555: EDC7     CAD4ED     	JZ	CHKDIR1         
2556: EDCA     BE         	CMP	M	;check them. 
2557: EDCB     C8         	RZ		;return if they are the same.
2558: EDCC     CD8FED     	CALL	MOREFLS	;not the same, do we care?
2559: EDCF     D0         	RNC                
2560: EDD0     CD3CED     	CALL	WRTPRTD	;yes, mark this as write protected.
2561: EDD3     C9         	RET                
2562: EDD4                CHKDIR1:            
2563: EDD4     77         	MOV	M,A	;just set the byte.
2564: EDD5     C9         	RET                
2565: EDD6                ;                   
2566: EDD6                ;   Do a write to the directory of the current disk.
2567: EDD6                ;                   
2568: EDD6                DIRWRITE:           
2569: EDD6     CDACED     	CALL	SETDIR			;set checksum byte.
2570: EDD9     CDF0ED     	CALL	SetDirDMA		;set directory dma address.
2571: EDDC     0E01       	MVI		C,1				;tell the bios to actually write.
2572: EDDE     CDDBEB     	CALL	DOWRITE			;then do the write.
2573: EDE1     C3EAED     	JMP		Set2UsersDMA  
2574: EDE4                ;                   
2575: EDE4                ;   Read from the directory.
2576: EDE4                ;                   
2577: EDE4                DIRREAD:            
2578: EDE4     CDF0ED     	CALL	SetDirDMA	;set the directory dma address.
2579: EDE7     CDD5EB     	CALL	DOREAD	;and read it.
2580: EDEA                ;                   
2581: EDEA                ;   Routine to set the dma address to the users choice.
2582: EDEA                ;                   
2583: EDEA                Set2UsersDMA:       
2584: EDEA     21ACF5     	LXI		H,UsersDMA		;reset the default dma address and return.
2585: EDED     C3F3ED     	JMP		SetDMA0       
2586: EDF0                ;                   
2587: EDF0                ;   Routine to set the dma address for directory work.
2588: EDF0                ;                   
2589: EDF0                SetDirDMA:          
2590: EDF0     21B4F5     	LXI		H,DIRBUF      
2591: EDF3                ;                   
2592: EDF3                ;   Set the dma address. On entry, (HL) points to
2593: EDF3                ; word containing the desired dma address.
2594: EDF3                ;                   
2595: EDF3                SetDMA0:            
2596: EDF3     4E         	MOV		C,M           
2597: EDF4     23         	INX		H             
2598: EDF5     46         	MOV		B,M			;setup (BC) and go to the bios to set it.
2599: EDF6     C324F6     	JMP		SETDMA        
2600: EDF9                ;                   
2601: EDF9                ;   Move the directory buffer into user's dma space.
2602: EDF9                ;                   
2603: EDF9                MOVEDIR:            
2604: EDF9     2AB4F5     	LHLD	DIRBUF	;buffer is located here, and
2605: EDFC     EB         	XCHG               
2606: EDFD     2AACF5     	LHLD	UsersDMA; put it here.
2607: EE00     0E80       	MVI	C,128	;this is its length.
2608: EE02     C372EB     	JMP	DE2HL	;move it now and return.
2609: EE05                ;                   
2610: EE05                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2611: EE05                ;                   
2612: EE05                CKFILPOS:           
2613: EE05     21E4F5     	LXI	H,FILEPOS      
2614: EE08     7E         	MOV	A,M            
2615: EE09     23         	INX	H              
2616: EE0A     BE         	CMP	M	;are both bytes the same?
2617: EE0B     C0         	RNZ                
2618: EE0C     3C         	INR	A	;yes, but are they each 0ffh?
2619: EE0D     C9         	RET                
2620: EE0E                ;                   
2621: EE0E                ;   Set location (FILEPOS) to 0ffffh.
2622: EE0E                ;                   
2623: EE0E                STFILPOS:           
2624: EE0E     210000     	LXI	H,0FFFFH       
2625: EE11     22E4F5     	SHLD	FILEPOS       
2626: EE14     C9         	RET                
2627: EE15                ;                   
2628: EE15                ;   Move on to the next file position within the current
2629: EE15                ; directory buffer. If no more exist, set pointer to 0ffffh
2630: EE15                ; and the calling routine will check for this. Enter with (C)
2631: EE15                ; equal to 0ffh to cause the checksum byte to be set, else we
2632: EE15                ; will check this disk and set write protect if checksums are
2633: EE15                ; not the same (applies only if another directory sector must
2634: EE15                ; be read).         
2635: EE15                ;                   
2636: EE15                NXENTRY:            
2637: EE15     2AC3F5     	LHLD	DIRSIZE	;get directory entry size limit.
2638: EE18     EB         	XCHG               
2639: EE19     2AE4F5     	LHLD	FILEPOS	;get current count.
2640: EE1C     23         	INX	H	;go on to the next one.
2641: EE1D     22E4F5     	SHLD	FILEPOS       
2642: EE20     CDA5ED     	CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
2643: EE23     D229EE     	JNC	NXENT1	;is there more room left?
2644: EE26     C30EEE     	JMP	STFILPOS;no. Set this flag and return.
2645: EE29                NXENT1:             
2646: EE29     3AE4F5     	LDA	FILEPOS	;get file position within directory.
2647: EE2C     E603       	ANI	03H	;only look within this sector (only 4 entries fit).
2648: EE2E     0605       	MVI	B,5	;convert to relative position (32 bytes each).
2649: EE30                NXENT2:             
2650: EE30     87         	ADD	A	;note that this is not efficient code.
2651: EE31     05         	DCR	B	;5 'ADD A's would be better.
2652: EE32     C230EE     	JNZ	NXENT2         
2653: EE35     32E3F5     	STA	FCBPOS	;save it as position of fcb.
2654: EE38     B7         	ORA	A              
2655: EE39     C0         	RNZ		;return if we are within buffer.
2656: EE3A     C5         	PUSH	B             
2657: EE3B     CDE6EB     	CALL	TRKSEC	;we need the next directory sector.
2658: EE3E     CDE4ED     	CALL	DIRREAD       
2659: EE41     C1         	POP	B              
2660: EE42     C3AEED     	JMP	CHECKDIR       
2661: EE45                ;                   
2662: EE45                ;   Routine to to get a bit from the disk space allocation
2663: EE45                ; map. It is returned in (A), bit position 0. On entry to here,
2664: EE45                ; set (BC) to the block number on the disk to check.
2665: EE45                ; On return, (D) will contain the original bit position for
2666: EE45                ; this block number and (HL) will point to the address for it.
2667: EE45                ;                   
2668: EE45                CKBITMAP:           
2669: EE45     79         	MOV	A,C	;determine bit number of interest.
2670: EE46     E607       	ANI	07H	;compute (D)=(E)=(C and 7)+1.
2671: EE48     3C         	INR	A              
2672: EE49     5F         	MOV	E,A	;save particular bit number.
2673: EE4A     57         	MOV	D,A            
2674: EE4B                ;                   
2675: EE4B                ;   compute (BC)=(BC)/8.
2676: EE4B                ;                   
2677: EE4B     79         	MOV	A,C            
2678: EE4C     0F         	RRC		;now shift right 3 bits.
2679: EE4D     0F         	RRC                
2680: EE4E     0F         	RRC                
2681: EE4F     E61F       	ANI	1FH	;and clear bits 7,6,5.
2682: EE51     4F         	MOV	C,A            
2683: EE52     78         	MOV	A,B            
2684: EE53     87         	ADD	A	;now shift (B) into bits 7,6,5.
2685: EE54     87         	ADD	A              
2686: EE55     87         	ADD	A              
2687: EE56     87         	ADD	A              
2688: EE57     87         	ADD	A              
2689: EE58     B1         	ORA	C	;and add in (C).
2690: EE59     4F         	MOV	C,A	;ok, (C) ha been completed.
2691: EE5A     78         	MOV	A,B	;is there a better way of doing this?
2692: EE5B     0F         	RRC                
2693: EE5C     0F         	RRC                
2694: EE5D     0F         	RRC                
2695: EE5E     E61F       	ANI	1FH            
2696: EE60     47         	MOV	B,A	;and now (B) is completed.
2697: EE61                ;                   
2698: EE61                ;   use this as an offset into the disk space allocation
2699: EE61                ; table.            
2700: EE61                ;                   
2701: EE61     2ABAF5     	LHLD	ALOCVECT      
2702: EE64     09         	DAD	B              
2703: EE65     7E         	MOV	A,M	;now get correct byte.
2704: EE66                CKBMAP1:            
2705: EE66     07         	RLC		;get correct bit into position 0.
2706: EE67     1D         	DCR	E              
2707: EE68     C266EE     	JNZ	CKBMAP1        
2708: EE6B     C9         	RET                
2709: EE6C                ;                   
2710: EE6C                ;   Set or clear the bit map such that block number (BC) will be marked
2711: EE6C                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2712: EE6C                ; 1 then it will be set (don't use anyother values).
2713: EE6C                ;                   
2714: EE6C                STBITMAP:           
2715: EE6C     D5         	PUSH	D             
2716: EE6D     CD45EE     	CALL	CKBITMAP;get the byte of interest.
2717: EE70     E6FE       	ANI	0FEH	;clear the affected bit.
2718: EE72     C1         	POP	B              
2719: EE73     B1         	ORA	C	;and now set it acording to (C).
2720: EE74                ;                   
2721: EE74                ;  entry to restore the original bit position and then store
2722: EE74                ; in table. (A) contains the value, (D) contains the bit
2723: EE74                ; position (1-8), and (HL) points to the address within the
2724: EE74                ; space allocation table for this byte.
2725: EE74                ;                   
2726: EE74                STBMAP1:            
2727: EE74     0F         	RRC		;restore original bit position.
2728: EE75     15         	DCR	D              
2729: EE76     C274EE     	JNZ	STBMAP1        
2730: EE79     77         	MOV	M,A	;and stor byte in table.
2731: EE7A     C9         	RET                
2732: EE7B                ;                   
2733: EE7B                ;   Set/clear space used bits in allocation map for this file.
2734: EE7B                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2735: EE7B                ;                   
2736: EE7B                SETFILE:            
2737: EE7B     CD6EED     	CALL	FCB2HL	;get address of fcb
2738: EE7E     111000     	LXI	D,16           
2739: EE81     19         	DAD	D	;get to block number bytes.
2740: EE82     C5         	PUSH	B             
2741: EE83     0E11       	MVI	C,17	;check all 17 bytes (max) of table.
2742: EE85                SETFL1:             
2743: EE85     D1         	POP	D              
2744: EE86     0D         	DCR	C	;done all bytes yet?
2745: EE87     C8         	RZ                 
2746: EE88     D5         	PUSH	D             
2747: EE89     3AD7F5     	LDA	BIGDISK	;check disk size for 16 bit block numbers.
2748: EE8C     B7         	ORA	A              
2749: EE8D     CA98EE     	JZ	SETFL2          
2750: EE90     C5         	PUSH	B	;only 8 bit numbers. set (BC) to this one.
2751: EE91     E5         	PUSH	H             
2752: EE92     4E         	MOV	C,M	;get low byte from table, always
2753: EE93     0600       	MVI	B,0	;set high byte to zero.
2754: EE95     C39EEE     	JMP	SETFL3         
2755: EE98                SETFL2:             
2756: EE98     0D         	DCR	C	;for 16 bit block numbers, adjust counter.
2757: EE99     C5         	PUSH	B             
2758: EE9A     4E         	MOV	C,M	;now get both the low and high bytes.
2759: EE9B     23         	INX	H              
2760: EE9C     46         	MOV	B,M            
2761: EE9D     E5         	PUSH	H             
2762: EE9E                SETFL3:             
2763: EE9E     79         	MOV	A,C	;block used?
2764: EE9F     B0         	ORA	B              
2765: EEA0     CAADEE     	JZ	SETFL4          
2766: EEA3     2AC1F5     	LHLD	DSKSIZE	;is this block number within the
2767: EEA6     7D         	MOV	A,L	;space on the disk?
2768: EEA7     91         	SUB	C              
2769: EEA8     7C         	MOV	A,H            
2770: EEA9     98         	SBB	B              
2771: EEAA     D46CEE     	CNC	STBITMAP;yes, set the proper bit.
2772: EEAD                SETFL4:             
2773: EEAD     E1         	POP	H	;point to next block number in fcb.
2774: EEAE     23         	INX	H              
2775: EEAF     C1         	POP	B              
2776: EEB0     C385EE     	JMP	SETFL1         
2777: EEB3                                    
2778: EEB3                ;                   
2779: EEB3                ;   Set the status (StatusBDOSReturn) and return.
2780: EEB3                ;                   
2781: EEB3                STSTATUS:           
2782: EEB3     3ACFF5     	LDA	FNDSTAT        
2783: EEB6     C35CEB     	JMP	SETSTAT        
2784: EEB9                ;                   
2785: EEB9                ;   Check extents in (A) and (C). Set the zero flag if they
2786: EEB9                ; are the same. The number of 16k chunks of disk space that
2787: EEB9                ; the directory extent covers is expressad is (EXTMASK+1).
2788: EEB9                ; No registers are modified.
2789: EEB9                ;                   
2790: EEB9                SAMEXT:             
2791: EEB9     C5         	PUSH	B             
2792: EEBA     F5         	PUSH	PSW           
2793: EEBB     3AC0F5     	LDA	EXTMASK	;get extent mask and use it to
2794: EEBE     2F         	CMA		;to compare both extent numbers.
2795: EEBF     47         	MOV	B,A	;save resulting mask here.
2796: EEC0     79         	MOV	A,C	;mask first extent and save in (C).
2797: EEC1     A0         	ANA	B              
2798: EEC2     4F         	MOV	C,A            
2799: EEC3     F1         	POP	PSW	;now mask second extent and compare
2800: EEC4     A0         	ANA	B	;with the first one.
2801: EEC5     91         	SUB	C              
2802: EEC6     E61F       	ANI	1FH	;(* only check buts 0-4 *)
2803: EEC8     C1         	POP	B	;the zero flag is set if they are the same.
2804: EEC9     C9         	RET		;restore (BC) and return.
2805: EECA                ;                   
2806: EECA                ;   Search for the first occurence of a file name. On entry,
2807: EECA                ; register (C) should contain the number of bytes of the fcb
2808: EECA                ; that must match.  
2809: EECA                ;                   
2810: EECA                FINDFST:            
2811: EECA     3EFF       	MVI	A,0FFH         
2812: EECC     32CFF5     	STA	FNDSTAT        
2813: EECF     21D2F5     	LXI	H,COUNTER;save character count.
2814: EED2     71         	MOV	M,C            
2815: EED3     2A3CE8     	LHLD	ParamsDE	;get filename to match.
2816: EED6     22D3F5     	SHLD	SAVEFCB	;and save.
2817: EED9     CD0EEE     	CALL	STFILPOS;clear initial file position (set to 0ffffh).
2818: EEDC     CDC4EB     	CALL	HOMEDRV	;home the drive.
2819: EEDF                ;                   
2820: EEDF                ;   Entry to locate the next occurence of a filename within the
2821: EEDF                ; directory. The disk is not expected to have been changed. If
2822: EEDF                ; it was, then it will be write protected.
2823: EEDF                ;                   
2824: EEDF                FINDNXT:            
2825: EEDF     0E00       	MVI	C,0	;write protect the disk if changed.
2826: EEE1     CD15EE     	CALL	NXENTRY	;get next filename entry in directory.
2827: EEE4     CD05EE     	CALL	CKFILPOS;is file position = 0ffffh?
2828: EEE7     CA46EF     	JZ	FNDNXT6	;yes, exit now then.
2829: EEEA     2AD3F5     	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2830: EEED     EB         	XCHG               
2831: EEEE     1A         	LDAX	D             
2832: EEEF     FEE5       	CPI	0E5H	;empty directory entry?
2833: EEF1     CAFCEE     	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2834: EEF4     D5         	PUSH	D             
2835: EEF5     CD8FED     	CALL	MOREFLS	;more files in directory?
2836: EEF8     D1         	POP	D              
2837: EEF9     D246EF     	JNC	FNDNXT6	;no more. Exit now.
2838: EEFC                FNDNXT1:            
2839: EEFC     CD6EED     	CALL	FCB2HL	;get address of this fcb in directory.
2840: EEFF     3AD2F5     	LDA	COUNTER	;get number of bytes (characters) to check.
2841: EF02     4F         	MOV	C,A            
2842: EF03     0600       	MVI	B,0	;initialize byte position counter.
2843: EF05                FNDNXT2:            
2844: EF05     79         	MOV	A,C	;are we done with the compare?
2845: EF06     B7         	ORA	A              
2846: EF07     CA35EF     	JZ	FNDNXT5         
2847: EF0A     1A         	LDAX	D	;no, check next byte.
2848: EF0B     FE3F       	CPI	QMARK		; '?'	;don't care about this character?
2849: EF0D     CA2EEF     	JZ	FNDNXT4         
2850: EF10     78         	MOV	A,B	;get bytes position in fcb.
2851: EF11     FE0D       	CPI	13	;don't care about the thirteenth byte either.
2852: EF13     CA2EEF     	JZ	FNDNXT4         
2853: EF16     FE0C       	CPI	12	;extent byte?
2854: EF18     1A         	LDAX	D             
2855: EF19     CA25EF     	JZ	FNDNXT3         
2856: EF1C     96         	SUB	M	;otherwise compare characters.
2857: EF1D     E67F       	ANI	7FH            
2858: EF1F     C2DFEE     	JNZ	FINDNXT	;not the same, check next entry.
2859: EF22     C32EEF     	JMP	FNDNXT4	;so far so good, keep checking.
2860: EF25                FNDNXT3:            
2861: EF25     C5         	PUSH	B	;check the extent byte here.
2862: EF26     4E         	MOV	C,M            
2863: EF27     CDB9EE     	CALL	SAMEXT        
2864: EF2A     C1         	POP	B              
2865: EF2B     C2DFEE     	JNZ	FINDNXT	;not the same, look some more.
2866: EF2E                ;                   
2867: EF2E                ;   So far the names compare. Bump pointers to the next byte
2868: EF2E                ; and continue until all (C) characters have been checked.
2869: EF2E                ;                   
2870: EF2E                FNDNXT4:            
2871: EF2E     13         	INX	D	;bump pointers.
2872: EF2F     23         	INX	H              
2873: EF30     04         	INR	B              
2874: EF31     0D         	DCR	C	;adjust character counter.
2875: EF32     C305EF     	JMP	FNDNXT2        
2876: EF35                FNDNXT5:            
2877: EF35     3AE4F5     	LDA	FILEPOS	;return the position of this entry.
2878: EF38     E603       	ANI	03H            
2879: EF3A     323FE8     	STA	StatusBDOSReturn
2880: EF3D     21CFF5     	LXI	H,FNDSTAT      
2881: EF40     7E         	MOV	A,M            
2882: EF41     17         	RAL                
2883: EF42     D0         	RNC                
2884: EF43     AF         	XRA	A              
2885: EF44     77         	MOV	M,A            
2886: EF45     C9         	RET                
2887: EF46                ;                   
2888: EF46                ;   Filename was not found. Set appropriate status.
2889: EF46                ;                   
2890: EF46                FNDNXT6:            
2891: EF46     CD0EEE     	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2892: EF49     3EFF       	MVI	A,0FFH	;say not located.
2893: EF4B     C35CEB     	JMP	SETSTAT        
2894: EF4E                ;                   
2895: EF4E                ;   Erase files from the directory. Only the first byte of the
2896: EF4E                ; fcb will be affected. It is set to (E5).
2897: EF4E                ;                   
2898: EF4E                ERAFILE:            
2899: EF4E     CD64ED     	CALL	CHKWPRT	;is disk write protected?
2900: EF51     0E0C       	MVI	C,12	;only compare file names.
2901: EF53     CDCAEE     	CALL	FINDFST	;get first file name.
2902: EF56                ERAFIL1:            
2903: EF56     CD05EE     	CALL	CKFILPOS;any found?
2904: EF59     C8         	RZ		;nope, we must be done.
2905: EF5A     CD54ED     	CALL	CHKROFL	;is file read only?
2906: EF5D     CD6EED     	CALL	FCB2HL	;nope, get address of fcb and
2907: EF60     36E5       	MVI	M,0E5H	;set first byte to 'empty'.
2908: EF62     0E00       	MVI	C,0	;clear the space from the bit map.
2909: EF64     CD7BEE     	CALL	SETFILE       
2910: EF67     CDD6ED     	CALL	DIRWRITE;now write the directory sector back out.
2911: EF6A     CDDFEE     	CALL	FINDNXT	;find the next file name.
2912: EF6D     C356EF     	JMP	ERAFIL1	;and repeat process.
2913: EF70                ;                   
2914: EF70                ;   Look through the space allocation map (bit map) for the
2915: EF70                ; next available block. Start searching at block number (BC-1).
2916: EF70                ; The search procedure is to look for an empty block that is
2917: EF70                ; before the starting block. If not empty, look at a later
2918: EF70                ; block number. In this way, we return the closest empty block
2919: EF70                ; on either side of the 'target' block number. This will speed
2920: EF70                ; access on random devices. For serial devices, this should be
2921: EF70                ; changed to look in the forward direction first and then start
2922: EF70                ; at the front and search some more.
2923: EF70                ;                   
2924: EF70                ;   On return, (DE)= block number that is empty and (HL) =0
2925: EF70                ; if no empry block was found.
2926: EF70                ;                   
2927: EF70                FNDSPACE:           
2928: EF70     50         	MOV	D,B	;set (DE) as the block that is checked.
2929: EF71     59         	MOV	E,C            
2930: EF72                ;                   
2931: EF72                ;   Look before target block. Registers (BC) are used as the lower
2932: EF72                ; pointer and (DE) as the upper pointer.
2933: EF72                ;                   
2934: EF72                FNDSPA1:            
2935: EF72     79         	MOV	A,C	;is block 0 specified?
2936: EF73     B0         	ORA	B              
2937: EF74     CA83EF     	JZ	FNDSPA2         
2938: EF77     0B         	DCX	B	;nope, check previous block.
2939: EF78     D5         	PUSH	D             
2940: EF79     C5         	PUSH	B             
2941: EF7A     CD45EE     	CALL	CKBITMAP      
2942: EF7D     1F         	RAR		;is this block empty?
2943: EF7E     D29EEF     	JNC	FNDSPA3	;yes. use this.
2944: EF81                ;                   
2945: EF81                ;   Note that the above logic gets the first block that it finds
2946: EF81                ; that is empty. Thus a file could be written 'backward' making
2947: EF81                ; it very slow to access. This could be changed to look for the
2948: EF81                ; first empty block and then continue until the start of this
2949: EF81                ; empty space is located and then used that starting block.
2950: EF81                ; This should help speed up access to some files especially on
2951: EF81                ; a well used disk with lots of fairly small 'holes'.
2952: EF81                ;                   
2953: EF81     C1         	POP	B	;nope, check some more.
2954: EF82     D1         	POP	D              
2955: EF83                ;                   
2956: EF83                ;   Now look after target block.
2957: EF83                ;                   
2958: EF83                FNDSPA2:            
2959: EF83     2AC1F5     	LHLD	DSKSIZE	;is block (DE) within disk limits?
2960: EF86     7B         	MOV	A,E            
2961: EF87     95         	SUB	L              
2962: EF88     7A         	MOV	A,D            
2963: EF89     9C         	SBB	H              
2964: EF8A     D2A6EF     	JNC	FNDSPA4        
2965: EF8D     13         	INX	D	;yes, move on to next one.
2966: EF8E     C5         	PUSH	B             
2967: EF8F     D5         	PUSH	D             
2968: EF90     42         	MOV	B,D            
2969: EF91     4B         	MOV	C,E            
2970: EF92     CD45EE     	CALL	CKBITMAP;check it.
2971: EF95     1F         	RAR		;empty?       
2972: EF96     D29EEF     	JNC	FNDSPA3        
2973: EF99     D1         	POP	D	;nope, continue searching.
2974: EF9A     C1         	POP	B              
2975: EF9B     C372EF     	JMP	FNDSPA1        
2976: EF9E                ;                   
2977: EF9E                ;   Empty block found. Set it as used and return with (HL)
2978: EF9E                ; pointing to it (true?).
2979: EF9E                ;                   
2980: EF9E                FNDSPA3:            
2981: EF9E     17         	RAL		;reset byte.  
2982: EF9F     3C         	INR	A	;and set bit 0.
2983: EFA0     CD74EE     	CALL	STBMAP1	;update bit map.
2984: EFA3     E1         	POP	H	;set return registers.
2985: EFA4     D1         	POP	D              
2986: EFA5     C9         	RET                
2987: EFA6                ;                   
2988: EFA6                ;   Free block was not found. If (BC) is not zero, then we have
2989: EFA6                ; not checked all of the disk space.
2990: EFA6                ;                   
2991: EFA6                FNDSPA4:            
2992: EFA6     79         	MOV	A,C            
2993: EFA7     B0         	ORA	B              
2994: EFA8     C272EF     	JNZ	FNDSPA1        
2995: EFAB     210000     	LXI	H,0	;set 'not found' status.
2996: EFAE     C9         	RET                
2997: EFAF                ;                   
2998: EFAF                ;   Move a complete fcb entry into the directory and write it.
2999: EFAF                ;                   
3000: EFAF                FCBSET:             
3001: EFAF     0E00       	MVI	C,0            
3002: EFB1     1E20       	MVI	E,32	;length of each entry.
3003: EFB3                ;                   
3004: EFB3                ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3005: EFB3                ; fcb in directory starting at relative byte (C). This updated
3006: EFB3                ; directory buffer is then written to the disk.
3007: EFB3                ;                   
3008: EFB3                UPDATE:             
3009: EFB3     D5         	PUSH	D             
3010: EFB4     0600       	MVI	B,0	;set (BC) to relative byte position.
3011: EFB6     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3012: EFB9     09         	DAD	B	;compute starting byte.
3013: EFBA     EB         	XCHG               
3014: EFBB     CD6EED     	CALL	FCB2HL	;get address of fcb to update in directory.
3015: EFBE     C1         	POP	B	;set (C) to number of bytes to change.
3016: EFBF     CD72EB     	CALL	DE2HL         
3017: EFC2                UPDATE1:            
3018: EFC2     CDE6EB     	CALL	TRKSEC	;determine the track and sector affected.
3019: EFC5     C3D6ED     	JMP	DIRWRITE	;then write this sector out.
3020: EFC8                ;                   
3021: EFC8                ;   Routine to change the name of all files on the disk with a
3022: EFC8                ; specified name. The fcb contains the current name as the
3023: EFC8                ; first 12 characters and the new name 16 bytes into the fcb.
3024: EFC8                ;                   
3025: EFC8                CHGNAMES:           
3026: EFC8     CD64ED     	CALL	CHKWPRT	;check for a write protected disk.
3027: EFCB     0E0C       	MVI	C,12	;match first 12 bytes of fcb only.
3028: EFCD     CDCAEE     	CALL	FINDFST	;get first name.
3029: EFD0     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3030: EFD3     7E         	MOV	A,M	;get user number.
3031: EFD4     111000     	LXI	D,16	;move over to desired name.
3032: EFD7     19         	DAD	D              
3033: EFD8     77         	MOV	M,A	;keep same user number.
3034: EFD9                CHGNAM1:            
3035: EFD9     CD05EE     	CALL	CKFILPOS;any matching file found?
3036: EFDC     C8         	RZ		;no, we must be done.
3037: EFDD     CD54ED     	CALL	CHKROFL	;check for read only file.
3038: EFE0     0E10       	MVI	C,16	;start 16 bytes into fcb.
3039: EFE2     1E0C       	MVI	E,12	;and update the first 12 bytes of directory.
3040: EFE4     CDB3EF     	CALL	UPDATE        
3041: EFE7     CDDFEE     	CALL	FINDNXT	;get te next file name.
3042: EFEA     C3D9EF     	JMP	CHGNAM1	;and continue.
3043: EFED                ;                   
3044: EFED                ;   Update a files attributes. The procedure is to search for
3045: EFED                ; every file with the same name as shown in fcb (ignoring bit 7)
3046: EFED                ; and then to update it (which includes bit 7). No other changes
3047: EFED                ; are made.         
3048: EFED                ;                   
3049: EFED                SAVEATTR:           
3050: EFED     0E0C       	MVI	C,12	;match first 12 bytes.
3051: EFEF     CDCAEE     	CALL	FINDFST	;look for first filename.
3052: EFF2                SAVATR1:            
3053: EFF2     CD05EE     	CALL	CKFILPOS;was one found?
3054: EFF5     C8         	RZ		;nope, we must be done.
3055: EFF6     0E00       	MVI	C,0	;yes, update the first 12 bytes now.
3056: EFF8     1E0C       	MVI	E,12           
3057: EFFA     CDB3EF     	CALL	UPDATE	;update filename and write directory.
3058: EFFD     CDDFEE     	CALL	FINDNXT	;and get the next file.
3059: F000     C3F2EF     	JMP	SAVATR1	;then continue until done.
3060: F003                ;                   
3061: F003                ;  Open a file (name specified in fcb).
3062: F003                ;                   
3063: F003                OPENIT:             
3064: F003     0E0F       	MVI	C,15	;compare the first 15 bytes.
3065: F005     CDCAEE     	CALL	FINDFST	;get the first one in directory.
3066: F008     CD05EE     	CALL	CKFILPOS;any at all?
3067: F00B     C8         	RZ                 
3068: F00C                OPENIT1:            
3069: F00C     CDC9EC     	CALL	SETEXT	;point to extent byte within users fcb.
3070: F00F     7E         	MOV	A,M	;and get it.
3071: F010     F5         	PUSH	PSW	;save it and address.
3072: F011     E5         	PUSH	H             
3073: F012     CD6EED     	CALL	FCB2HL	;point to fcb in directory.
3074: F015     EB         	XCHG               
3075: F016     2A3CE8     	LHLD	ParamsDE	;this is the users copy.
3076: F019     0E20       	MVI	C,32	;move it into users space.
3077: F01B     D5         	PUSH	D             
3078: F01C     CD72EB     	CALL	DE2HL         
3079: F01F     CD88ED     	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
3080: F022     D1         	POP	D	;now get the extent byte from this fcb.
3081: F023     210C00     	LXI	H,12           
3082: F026     19         	DAD	D              
3083: F027     4E         	MOV	C,M	;into (C). 
3084: F028     210F00     	LXI	H,15	;now get the record count byte into (B).
3085: F02B     19         	DAD	D              
3086: F02C     46         	MOV	B,M            
3087: F02D     E1         	POP	H	;keep the same extent as the user had originally.
3088: F02E     F1         	POP	PSW            
3089: F02F     77         	MOV	M,A            
3090: F030     79         	MOV	A,C	;is it the same as in the directory fcb?
3091: F031     BE         	CMP	M              
3092: F032     78         	MOV	A,B	;if yes, then use the same record count.
3093: F033     CA3DF0     	JZ	OPENIT2         
3094: F036     3E00       	MVI	A,0	;if the user specified an extent greater than
3095: F038     DA3DF0     	JC	OPENIT2	;the one in the directory, then set record count to 0.
3096: F03B     3E80       	MVI	A,128	;otherwise set to maximum.
3097: F03D                OPENIT2:            
3098: F03D     2A3CE8     	LHLD	ParamsDE	;set record count in users fcb to (A).
3099: F040     110F00     	LXI	D,15           
3100: F043     19         	DAD	D	;compute relative position.
3101: F044     77         	MOV	M,A	;and set the record count.
3102: F045     C9         	RET                
3103: F046                ;                   
3104: F046                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3105: F046                ; point to a zero value (16 bit).
3106: F046                ;   Return with zero flag set it (DE) was moved. Registers (DE)
3107: F046                ; and (HL) are not changed. However (A) is.
3108: F046                ;                   
3109: F046                MOVEWORD:           
3110: F046     7E         	MOV	A,M	;check for a zero word.
3111: F047     23         	INX	H              
3112: F048     B6         	ORA	M	;both bytes zero?
3113: F049     2B         	DCX	H              
3114: F04A     C0         	RNZ		;nope, just return.
3115: F04B     1A         	LDAX	D	;yes, move two bytes from (DE) into
3116: F04C     77         	MOV	M,A	;this zero space.
3117: F04D     13         	INX	D              
3118: F04E     23         	INX	H              
3119: F04F     1A         	LDAX	D             
3120: F050     77         	MOV	M,A            
3121: F051     1B         	DCX	D	;don't disturb these registers.
3122: F052     2B         	DCX	H              
3123: F053     C9         	RET                
3124: F054                ;                   
3125: F054                ;   Get here to close a file specified by (fcb).
3126: F054                ;                   
3127: F054                CLOSEIT:            
3128: F054     AF         	XRA	A	;clear status and file position bytes.
3129: F055     323FE8     	STA	StatusBDOSReturn
3130: F058     32E4F5     	STA	FILEPOS        
3131: F05B     32E5F5     	STA	FILEPOS+1      
3132: F05E     CD2EED     	CALL	GETWPRT	;get write protect bit for this drive.
3133: F061     C0         	RNZ		;just return if it is set.
3134: F062     CD79ED     	CALL	GETS2	;else get the 's2' byte.
3135: F065     E680       	ANI	80H	;and look at bit 7 (file unmodified?).
3136: F067     C0         	RNZ		;just return if set.
3137: F068     0E0F       	MVI	C,15	;else look up this file in directory.
3138: F06A     CDCAEE     	CALL	FINDFST       
3139: F06D     CD05EE     	CALL	CKFILPOS;was it found?
3140: F070     C8         	RZ		;just return if not.
3141: F071     011000     	LXI	B,16	;set (HL) pointing to records used section.
3142: F074     CD6EED     	CALL	FCB2HL        
3143: F077     09         	DAD	B              
3144: F078     EB         	XCHG               
3145: F079     2A3CE8     	LHLD	ParamsDE	;do the same for users specified fcb.
3146: F07C     09         	DAD	B              
3147: F07D     0E10       	MVI	C,16	;this many bytes are present in this extent.
3148: F07F                CLOSEIT1:           
3149: F07F     3AD7F5     	LDA	BIGDISK	;8 or 16 bit record numbers?
3150: F082     B7         	ORA	A              
3151: F083     CA9AF0     	JZ	CLOSEIT4        
3152: F086     7E         	MOV	A,M	;just 8 bit. Get one from users fcb.
3153: F087     B7         	ORA	A              
3154: F088     1A         	LDAX	D	;now get one from directory fcb.
3155: F089     C28DF0     	JNZ	CLOSEIT2       
3156: F08C     77         	MOV	M,A	;users byte was zero. Update from directory.
3157: F08D                CLOSEIT2:           
3158: F08D     B7         	ORA	A              
3159: F08E     C293F0     	JNZ	CLOSEIT3       
3160: F091     7E         	MOV	A,M	;directories byte was zero, update from users fcb.
3161: F092     12         	STAX	D             
3162: F093                CLOSEIT3:           
3163: F093     BE         	CMP	M	;if neither one of these bytes were zero,
3164: F094     C2D1F0     	JNZ	CLOSEIT7	;then close error if they are not the same.
3165: F097     C3AFF0     	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3166: F09A                CLOSEIT4:           
3167: F09A     CD46F0     	CALL	MOVEWORD;update users fcb if it is zero.
3168: F09D     EB         	XCHG               
3169: F09E     CD46F0     	CALL	MOVEWORD;update directories fcb if it is zero.
3170: F0A1     EB         	XCHG               
3171: F0A2     1A         	LDAX	D	;if these two values are no different,
3172: F0A3     BE         	CMP	M	;then a close error occured.
3173: F0A4     C2D1F0     	JNZ	CLOSEIT7       
3174: F0A7     13         	INX	D	;check second byte.
3175: F0A8     23         	INX	H              
3176: F0A9     1A         	LDAX	D             
3177: F0AA     BE         	CMP	M              
3178: F0AB     C2D1F0     	JNZ	CLOSEIT7       
3179: F0AE     0D         	DCR	C	;remember 16 bit values.
3180: F0AF                CLOSEIT5:           
3181: F0AF     13         	INX	D	;bump to next item in table.
3182: F0B0     23         	INX	H              
3183: F0B1     0D         	DCR	C	;there are 16 entries only.
3184: F0B2     C27FF0     	JNZ	CLOSEIT1;continue if more to do.
3185: F0B5     01ECFF     	LXI	B,0FFECH;backup 20 places (extent byte).
3186: F0B8     09         	DAD	B              
3187: F0B9     EB         	XCHG               
3188: F0BA     09         	DAD	B              
3189: F0BB     1A         	LDAX	D             
3190: F0BC     BE         	CMP	M	;directory's extent already greater than the
3191: F0BD     DAC9F0     	JC	CLOSEIT6	;users extent?
3192: F0C0     77         	MOV	M,A	;no, update directory extent.
3193: F0C1     010300     	LXI	B,3	;and update the record count byte in
3194: F0C4     09         	DAD	B	;directories fcb.
3195: F0C5     EB         	XCHG               
3196: F0C6     09         	DAD	B              
3197: F0C7     7E         	MOV	A,M	;get from user.
3198: F0C8     12         	STAX	D	;and put in directory.
3199: F0C9                CLOSEIT6:           
3200: F0C9     3EFF       	MVI	A,0FFH	;set 'was open and is now closed' byte.
3201: F0CB     32CDF5     	STA	CLOSEFLG       
3202: F0CE     C3C2EF     	JMP	UPDATE1	;update the directory now.
3203: F0D1                CLOSEIT7:           
3204: F0D1     213FE8     	LXI	H,StatusBDOSReturn;set return status and then return.
3205: F0D4     35         	DCR	M              
3206: F0D5     C9         	RET                
3207: F0D6                ;                   
3208: F0D6                ;   Routine to get the next empty space in the directory. It
3209: F0D6                ; will then be cleared for use.
3210: F0D6                ;                   
3211: F0D6                GETEMPTY:           
3212: F0D6     CD64ED     	CALL	CHKWPRT	;make sure disk is not write protected.
3213: F0D9     2A3CE8     	LHLD	ParamsDE	;save current parameters (fcb).
3214: F0DC     E5         	PUSH	H             
3215: F0DD     21A7F5     	LXI	H,EMPTYFCB;use special one for empty space.
3216: F0E0     223CE8     	SHLD	ParamsDE      
3217: F0E3     0E01       	MVI	C,1	;search for first empty spot in directory.
3218: F0E5     CDCAEE     	CALL	FINDFST	;(* only check first byte *)
3219: F0E8     CD05EE     	CALL	CKFILPOS;none?
3220: F0EB     E1         	POP	H              
3221: F0EC     223CE8     	SHLD	ParamsDE	;restore original fcb address.
3222: F0EF     C8         	RZ		;return if no more space.
3223: F0F0     EB         	XCHG               
3224: F0F1     210F00     	LXI	H,15	;point to number of records for this file.
3225: F0F4     19         	DAD	D              
3226: F0F5     0E11       	MVI	C,17	;and clear all of this space.
3227: F0F7     AF         	XRA	A              
3228: F0F8                GETMT1:             
3229: F0F8     77         	MOV	M,A            
3230: F0F9     23         	INX	H              
3231: F0FA     0D         	DCR	C              
3232: F0FB     C2F8F0     	JNZ	GETMT1         
3233: F0FE     210D00     	LXI	H,13	;clear the 's1' byte also.
3234: F101     19         	DAD	D              
3235: F102     77         	MOV	M,A            
3236: F103     CD9CED     	CALL	CHKNMBR	;keep (FilePosInDir) within bounds.
3237: F106     CDAFEF     	CALL	FCBSET	;write out this fcb entry to directory.
3238: F109     C388ED     	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
3239: F10C                ;                   
3240: F10C                ;   Routine to close the current extent and open the next one
3241: F10C                ; for reading.      
3242: F10C                ;                   
3243: F10C                GETNEXT:            
3244: F10C     AF         	XRA	A              
3245: F10D     32CDF5     	STA	CLOSEFLG;clear close flag.
3246: F110     CD54F0     	CALL	CLOSEIT	;close this extent.
3247: F113     CD05EE     	CALL	CKFILPOS      
3248: F116     C8         	RZ		;not there???  
3249: F117     2A3CE8     	LHLD	ParamsDE	;get extent byte.
3250: F11A     010C00     	LXI	B,12           
3251: F11D     09         	DAD	B              
3252: F11E     7E         	MOV	A,M	;and increment it.
3253: F11F     3C         	INR	A              
3254: F120     E61F       	ANI	1FH	;keep within range 0-31.
3255: F122     77         	MOV	M,A            
3256: F123     CA35F1     	JZ	GTNEXT1	;overflow?
3257: F126     47         	MOV	B,A	;mask extent byte.
3258: F127     3AC0F5     	LDA	EXTMASK        
3259: F12A     A0         	ANA	B              
3260: F12B     21CDF5     	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3261: F12E     A6         	ANA	M              
3262: F12F     CA40F1     	JZ	GTNEXT2	;if zero, we must read in next extent.
3263: F132     C35EF1     	JMP	GTNEXT3	;else, it is already in memory.
3264: F135                GTNEXT1:            
3265: F135     010200     	LXI	B,2	;Point to the 's2' byte.
3266: F138     09         	DAD	B              
3267: F139     34         	INR	M	;and bump it.
3268: F13A     7E         	MOV	A,M	;too many extents?
3269: F13B     E60F       	ANI	0FH            
3270: F13D     CA68F1     	JZ	GTNEXT5	;yes, set error code.
3271: F140                ;                   
3272: F140                ;   Get here to open the next extent.
3273: F140                ;                   
3274: F140                GTNEXT2:            
3275: F140     0E0F       	MVI	C,15	;set to check first 15 bytes of fcb.
3276: F142     CDCAEE     	CALL	FINDFST	;find the first one.
3277: F145     CD05EE     	CALL	CKFILPOS;none available?
3278: F148     C25EF1     	JNZ	GTNEXT3        
3279: F14B     3ACEF5     	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3280: F14E     3C         	INR	A	;0ffh means reading (so not possible).
3281: F14F     CA68F1     	JZ	GTNEXT5	;or an error.
3282: F152     CDD6F0     	CALL	GETEMPTY;we are writing, get an empty entry.
3283: F155     CD05EE     	CALL	CKFILPOS;none?
3284: F158     CA68F1     	JZ	GTNEXT5	;error if true.
3285: F15B     C361F1     	JMP	GTNEXT4	;else we are almost done.
3286: F15E                GTNEXT3:            
3287: F15E     CD0CF0     	CALL	OPENIT1	;open this extent.
3288: F161                GTNEXT4:            
3289: F161     CDDEEC     	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3290: F164     AF         	XRA	A	;clear status and return.
3291: F165     C35CEB     	JMP	SETSTAT        
3292: F168                ;                   
3293: F168                ;   Error in extending the file. Too many extents were needed
3294: F168                ; or not enough space on the disk.
3295: F168                ;                   
3296: F168                GTNEXT5:            
3297: F168     CD60EB     	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3298: F16B     C388ED     	JMP	SETS2B7	;so this is not written on a close.
3299: F16E                ;                   
3300: F16E                ;   Read a sequential file.
3301: F16E                ;                   
3302: F16E                RDSEQ:              
3303: F16E     3E01       	MVI	A,1	;set sequential access mode.
3304: F170     32D0F5     	STA	MODE           
3305: F173                RDSEQ1:             
3306: F173     3EFF       	MVI	A,0FFH	;don't allow reading unwritten space.
3307: F175     32CEF5     	STA	RDWRTFLG       
3308: F178     CDDEEC     	CALL	STRDATA	;put rec# and ext# into fcb.
3309: F17B     3ADDF5     	LDA	SAVNREC	;get next record to read.
3310: F17E     21DBF5     	LXI	H,SAVNXT;get number of records in extent.
3311: F181     BE         	CMP	M	;within this extent?
3312: F182     DA98F1     	JC	RDSEQ2          
3313: F185     FE80       	CPI	128	;no. Is this extent fully used?
3314: F187     C2ADF1     	JNZ	RDSEQ3	;no. End-of-file.
3315: F18A     CD0CF1     	CALL	GETNEXT	;yes, open the next one.
3316: F18D     AF         	XRA	A	;reset next record to read.
3317: F18E     32DDF5     	STA	SAVNREC        
3318: F191     3A3FE8     	LDA	StatusBDOSReturn	;check on open, successful?
3319: F194     B7         	ORA	A              
3320: F195     C2ADF1     	JNZ	RDSEQ3	;no, error.
3321: F198                RDSEQ2:             
3322: F198     CD9AEC     	CALL	COMBLK	;ok. compute block number to read.
3323: F19B     CDA7EC     	CALL	CHKBLK	;check it. Within bounds?
3324: F19E     CAADF1     	JZ	RDSEQ3	;no, error.
3325: F1A1     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
3326: F1A4     CDF4EB     	CALL	TRKSEC1	;set the track and sector for this block #.
3327: F1A7     CDD5EB     	CALL	DOREAD	;and read it.
3328: F1AA     C3F5EC     	JMP	SETNREC	;and set the next record to be accessed.
3329: F1AD                ;                   
3330: F1AD                ;   Read error occured. Set status and return.
3331: F1AD                ;                   
3332: F1AD                RDSEQ3:             
3333: F1AD     C360EB     	JMP	IOERR1         
3334: F1B0                ;                   
3335: F1B0                ;   Write the next sequential record.
3336: F1B0                ;                   
3337: F1B0                WTSEQ:              
3338: F1B0     3E01       	MVI	A,1	;set sequential access mode.
3339: F1B2     32D0F5     	STA	MODE           
3340: F1B5                WTSEQ1:             
3341: F1B5     3E00       	MVI	A,0	;allow an addition empty extent to be opened.
3342: F1B7     32CEF5     	STA	RDWRTFLG       
3343: F1BA     CD64ED     	CALL	CHKWPRT	;check write protect status.
3344: F1BD     2A3CE8     	LHLD	ParamsDE      
3345: F1C0     CD57ED     	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3346: F1C3     CDDEEC     	CALL	STRDATA	;put updated data into fcb.
3347: F1C6     3ADDF5     	LDA	SAVNREC	;get record number to write.
3348: F1C9     FE80       	CPI	128	;within range?
3349: F1CB     D260EB     	JNC	IOERR1	;no, error(?).
3350: F1CE     CD9AEC     	CALL	COMBLK	;compute block number.
3351: F1D1     CDA7EC     	CALL	CHKBLK	;check number.
3352: F1D4     0E00       	MVI	C,0	;is there one to write to?
3353: F1D6     C220F2     	JNZ	WTSEQ6	;yes, go do it.
3354: F1D9     CD61EC     	CALL	GETBLOCK;get next block number within fcb to use.
3355: F1DC     32D1F5     	STA	RELBLOCK;and save.
3356: F1DF     010000     	LXI	B,0	;start looking for space from the start
3357: F1E2     B7         	ORA	A	;if none allocated as yet.
3358: F1E3     CAEDF1     	JZ	WTSEQ2          
3359: F1E6     4F         	MOV	C,A	;extract previous block number from fcb
3360: F1E7     0B         	DCX	B	;so we can be closest to it.
3361: F1E8     CD81EC     	CALL	EXTBLK        
3362: F1EB     44         	MOV	B,H            
3363: F1EC     4D         	MOV	C,L            
3364: F1ED                WTSEQ2:             
3365: F1ED     CD70EF     	CALL	FNDSPACE;find the next empty block nearest number (BC).
3366: F1F0     7D         	MOV	A,L	;check for a zero number.
3367: F1F1     B4         	ORA	H              
3368: F1F2     C2FAF1     	JNZ	WTSEQ3         
3369: F1F5     3E02       	MVI	A,2	;no more space?
3370: F1F7     C35CEB     	JMP	SETSTAT        
3371: F1FA                WTSEQ3:             
3372: F1FA     22DFF5     	SHLD	BLKNMBR	;save block number to access.
3373: F1FD     EB         	XCHG		;put block number into (DE).
3374: F1FE     2A3CE8     	LHLD	ParamsDE	;now we must update the fcb for this
3375: F201     011000     	LXI	B,16	;newly allocated block.
3376: F204     09         	DAD	B              
3377: F205     3AD7F5     	LDA	BIGDISK	;8 or 16 bit block numbers?
3378: F208     B7         	ORA	A              
3379: F209     3AD1F5     	LDA	RELBLOCK	;(* update this entry *)
3380: F20C     CA16F2     	JZ	WTSEQ4	;zero means 16 bit ones.
3381: F20F     CD74ED     	CALL	ADDA2HL	;(HL)=(HL)+(A)
3382: F212     73         	MOV	M,E	;store new block number.
3383: F213     C31EF2     	JMP	WTSEQ5         
3384: F216                WTSEQ4:             
3385: F216     4F         	MOV	C,A	;compute spot in this 16 bit table.
3386: F217     0600       	MVI	B,0            
3387: F219     09         	DAD	B              
3388: F21A     09         	DAD	B              
3389: F21B     73         	MOV	M,E	;stuff block number (DE) there.
3390: F21C     23         	INX	H              
3391: F21D     72         	MOV	M,D            
3392: F21E                WTSEQ5:             
3393: F21E     0E02       	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3394: F220                WTSEQ6:             
3395: F220     3A3FE8     	LDA	StatusBDOSReturn	;are we ok so far?
3396: F223     B7         	ORA	A              
3397: F224     C0         	RNZ                
3398: F225     C5         	PUSH	B	;yes, save write flag for bios (register C).
3399: F226     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3400: F229     3AD0F5     	LDA	MODE	;get access mode flag (1=sequential,
3401: F22C     3D         	DCR	A	;0=random, 2=special?).
3402: F22D     3D         	DCR	A              
3403: F22E     C26DF2     	JNZ	WTSEQ9         
3404: F231                ;                   
3405: F231                ;   Special random i/o from function #40. Maybe for M/PM, but the
3406: F231                ; current block, if it has not been written to, will be zeroed
3407: F231                ; out and then written (reason?).
3408: F231                ;                   
3409: F231     C1         	POP	B              
3410: F232     C5         	PUSH	B             
3411: F233     79         	MOV	A,C	;get write status flag (2=writing unused space).
3412: F234     3D         	DCR	A              
3413: F235     3D         	DCR	A              
3414: F236     C26DF2     	JNZ	WTSEQ9         
3415: F239     E5         	PUSH	H             
3416: F23A     2AB4F5     	LHLD	DIRBUF	;zero out the directory buffer.
3417: F23D     57         	MOV	D,A	;note that (A) is zero here.
3418: F23E                WTSEQ7:             
3419: F23E     77         	MOV	M,A            
3420: F23F     23         	INX	H              
3421: F240     14         	INR	D	;do 128 bytes.
3422: F241     F23EF2     	JP	WTSEQ7          
3423: F244     CDF0ED     	CALL	SetDirDMA	;tell the bios the dma address for directory access.
3424: F247     2AE1F5     	LHLD	LOGSECT	;get sector that starts current block.
3425: F24A     0E02       	MVI	C,2	;set 'writing to unused space' flag.
3426: F24C                WTSEQ8:             
3427: F24C     22DFF5     	SHLD	BLKNMBR	;save sector to write.
3428: F24F     C5         	PUSH	B             
3429: F250     CDF4EB     	CALL	TRKSEC1	;determine its track and sector numbers.
3430: F253     C1         	POP	B              
3431: F254     CDDBEB     	CALL	DOWRITE	;now write out 128 bytes of zeros.
3432: F257     2ADFF5     	LHLD	BLKNMBR	;get sector number.
3433: F25A     0E00       	MVI	C,0	;set normal write flag.
3434: F25C     3ABFF5     	LDA	BLKMASK	;determine if we have written the entire
3435: F25F     47         	MOV	B,A	;physical block.
3436: F260     A5         	ANA	L              
3437: F261     B8         	CMP	B              
3438: F262     23         	INX	H	;prepare for the next one.
3439: F263     C24CF2     	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3440: F266     E1         	POP	H	;reset next sector number.
3441: F267     22DFF5     	SHLD	BLKNMBR       
3442: F26A     CDEAED     	CALL	Set2UsersDMA	;and reset dma address.
3443: F26D                ;                   
3444: F26D                ;   Normal disk write. Set the desired track and sector then
3445: F26D                ; do the actual write.
3446: F26D                ;                   
3447: F26D                WTSEQ9:             
3448: F26D     CDF4EB     	CALL	TRKSEC1	;determine track and sector for this write.
3449: F270     C1         	POP	B	;get write status flag.
3450: F271     C5         	PUSH	B             
3451: F272     CDDBEB     	CALL	DOWRITE	;and write this out.
3452: F275     C1         	POP	B              
3453: F276     3ADDF5     	LDA	SAVNREC	;get number of records in file.
3454: F279     21DBF5     	LXI	H,SAVNXT;get last record written.
3455: F27C     BE         	CMP	M              
3456: F27D     DA84F2     	JC	WTSEQ10         
3457: F280     77         	MOV	M,A	;we have to update record count.
3458: F281     34         	INR	M              
3459: F282     0E02       	MVI	C,2            
3460: F284                ;                   
3461: F284                ;*   This area has been patched to correct disk update problem
3462: F284                ;* when using blocking and de-blocking in the BIOS.
3463: F284                ;                   
3464: F284                WTSEQ10:            
3465: F284     00         	NOP		;was 'dcr c'  
3466: F285     00         	NOP		;was 'dcr c'  
3467: F286     210000     	LXI	H,0	;was 'jnz wtseq99'
3468: F289                ;                   
3469: F289                ; *   End of patch. 
3470: F289                ;                   
3471: F289     F5         	PUSH	PSW           
3472: F28A     CD79ED     	CALL	GETS2	;set 'extent written to' flag.
3473: F28D     E67F       	ANI	7FH	;(* clear bit 7 *)
3474: F28F     77         	MOV	M,A            
3475: F290     F1         	POP	PSW	;get record count for this extent.
3476: F291                WTSEQ99:            
3477: F291     FE7F       	CPI	127	;is it full?
3478: F293     C2B2F2     	JNZ	WTSEQ12        
3479: F296     3AD0F5     	LDA	MODE	;yes, are we in sequential mode?
3480: F299     FE01       	CPI	1              
3481: F29B     C2B2F2     	JNZ	WTSEQ12        
3482: F29E     CDF5EC     	CALL	SETNREC	;yes, set next record number.
3483: F2A1     CD0CF1     	CALL	GETNEXT	;and get next empty space in directory.
3484: F2A4     213FE8     	LXI	H,StatusBDOSReturn;ok?
3485: F2A7     7E         	MOV	A,M            
3486: F2A8     B7         	ORA	A              
3487: F2A9     C2B0F2     	JNZ	WTSEQ11        
3488: F2AC     3D         	DCR	A	;yes, set record count to -1.
3489: F2AD     32DDF5     	STA	SAVNREC        
3490: F2B0                WTSEQ11:            
3491: F2B0     3600       	MVI	M,0	;clear status.
3492: F2B2                WTSEQ12:            
3493: F2B2     C3F5EC     	JMP	SETNREC	;set next record to access.
3494: F2B5                ;                   
3495: F2B5                ;   For random i/o, set the fcb for the desired record number
3496: F2B5                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3497: F2B5                ; used as follows:  
3498: F2B5                ;                   
3499: F2B5                ;       fcb+35            fcb+34            fcb+33
3500: F2B5                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3501: F2B5                ;  |7             0 | 7             0 | 7             0|
3502: F2B5                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3503: F2B5                ;  |    overflow   | | extra |  extent   |   record #  |
3504: F2B5                ;  | ______________| |_extent|__number___|_____________|
3505: F2B5                ;                     also 's2'
3506: F2B5                ;                   
3507: F2B5                ;   On entry, register (C) contains 0ffh if this is a read
3508: F2B5                ; and thus we can not access unwritten disk space. Otherwise,
3509: F2B5                ; another extent will be opened (for writing) if required.
3510: F2B5                ;                   
3511: F2B5                POSITION:           
3512: F2B5     AF         	XRA	A	;set random i/o flag.
3513: F2B6     32D0F5     	STA	MODE           
3514: F2B9                ;                   
3515: F2B9                ;   Special entry (function #40). M/PM ?
3516: F2B9                ;                   
3517: F2B9                POSITN1:            
3518: F2B9     C5         	PUSH	B	;save read/write flag.
3519: F2BA     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3520: F2BD     EB         	XCHG               
3521: F2BE     212100     	LXI	H,33	;now get byte 'r0'.
3522: F2C1     19         	DAD	D              
3523: F2C2     7E         	MOV	A,M            
3524: F2C3     E67F       	ANI	7FH	;keep bits 0-6 for the record number to access.
3525: F2C5     F5         	PUSH	PSW           
3526: F2C6     7E         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3527: F2C7     17         	RAL                
3528: F2C8     23         	INX	H              
3529: F2C9     7E         	MOV	A,M            
3530: F2CA     17         	RAL                
3531: F2CB     E61F       	ANI	1FH	;and save this in bits 0-4 of (C).
3532: F2CD     4F         	MOV	C,A	;this is the extent byte.
3533: F2CE     7E         	MOV	A,M	;now get the extra extent byte.
3534: F2CF     1F         	RAR                
3535: F2D0     1F         	RAR                
3536: F2D1     1F         	RAR                
3537: F2D2     1F         	RAR                
3538: F2D3     E60F       	ANI	0FH            
3539: F2D5     47         	MOV	B,A	;and save it in (B).
3540: F2D6     F1         	POP	PSW	;get record number back to (A).
3541: F2D7     23         	INX	H	;check overflow byte 'r2'.
3542: F2D8     6E         	MOV	L,M            
3543: F2D9     2C         	INR	L              
3544: F2DA     2D         	DCR	L              
3545: F2DB     2E06       	MVI	L,6	;prepare for error.
3546: F2DD     C23DF3     	JNZ	POSITN5	;out of disk space error.
3547: F2E0     212000     	LXI	H,32	;store record number into fcb.
3548: F2E3     19         	DAD	D              
3549: F2E4     77         	MOV	M,A            
3550: F2E5     210C00     	LXI	H,12	;and now check the extent byte.
3551: F2E8     19         	DAD	D              
3552: F2E9     79         	MOV	A,C            
3553: F2EA     96         	SUB	M	;same extent as before?
3554: F2EB     C2F9F2     	JNZ	POSITN2        
3555: F2EE     210E00     	LXI	H,14	;yes, check extra extent byte 's2' also.
3556: F2F1     19         	DAD	D              
3557: F2F2     78         	MOV	A,B            
3558: F2F3     96         	SUB	M              
3559: F2F4     E67F       	ANI	7FH            
3560: F2F6     CA31F3     	JZ	POSITN3;same, we are almost done then.
3561: F2F9                ;                   
3562: F2F9                ;  Get here when another extent is required.
3563: F2F9                ;                   
3564: F2F9                POSITN2:            
3565: F2F9     C5         	PUSH	B             
3566: F2FA     D5         	PUSH	D             
3567: F2FB     CD54F0     	CALL	CLOSEIT	;close current extent.
3568: F2FE     D1         	POP	D              
3569: F2FF     C1         	POP	B              
3570: F300     2E03       	MVI	L,3	;prepare for error.
3571: F302     3A3FE8     	LDA	StatusBDOSReturn
3572: F305     3C         	INR	A              
3573: F306     CA36F3     	JZ	POSITN4	;close error.
3574: F309     210C00     	LXI	H,12	;put desired extent into fcb now.
3575: F30C     19         	DAD	D              
3576: F30D     71         	MOV	M,C            
3577: F30E     210E00     	LXI	H,14	;and store extra extent byte 's2'.
3578: F311     19         	DAD	D              
3579: F312     70         	MOV	M,B            
3580: F313     CD03F0     	CALL	OPENIT	;try and get this extent.
3581: F316     3A3FE8     	LDA	StatusBDOSReturn	;was it there?
3582: F319     3C         	INR	A              
3583: F31A     C231F3     	JNZ	POSITN3        
3584: F31D     C1         	POP	B	;no. can we create a new one (writing?).
3585: F31E     C5         	PUSH	B             
3586: F31F     2E04       	MVI	L,4	;prepare for error.
3587: F321     0C         	INR	C              
3588: F322     CA36F3     	JZ	POSITN4	;nope, reading unwritten space error.
3589: F325     CDD6F0     	CALL	GETEMPTY;yes we can, try to find space.
3590: F328     2E05       	MVI	L,5	;prepare for error.
3591: F32A     3A3FE8     	LDA	StatusBDOSReturn
3592: F32D     3C         	INR	A              
3593: F32E     CA36F3     	JZ	POSITN4	;out of space?
3594: F331                ;                   
3595: F331                ;   Normal return location. Clear error code and return.
3596: F331                ;                   
3597: F331                POSITN3:            
3598: F331     C1         	POP	B	;restore stack.
3599: F332     AF         	XRA	A	;and clear error code byte.
3600: F333     C35CEB     	JMP	SETSTAT        
3601: F336                ;                   
3602: F336                ;   Error. Set the 's2' byte to indicate this (why?).
3603: F336                ;                   
3604: F336                POSITN4:            
3605: F336     E5         	PUSH	H             
3606: F337     CD79ED     	CALL	GETS2         
3607: F33A     36C0       	MVI	M,0C0H         
3608: F33C     E1         	POP	H              
3609: F33D                ;                   
3610: F33D                ;   Return with error code (presently in L).
3611: F33D                ;                   
3612: F33D                POSITN5:            
3613: F33D     C1         	POP	B              
3614: F33E     7D         	MOV	A,L	;get error code.
3615: F33F     323FE8     	STA	StatusBDOSReturn
3616: F342     C388ED     	JMP	SETS2B7        
3617: F345                ;                   
3618: F345                ;   Read a random record.
3619: F345                ;                   
3620: F345                READRAN:            
3621: F345     0EFF       	MVI	C,0FFH	;set 'read' status.
3622: F347     CDB5F2     	CALL	POSITION;position the file to proper record.
3623: F34A     CC73F1     	CZ	RDSEQ1	;and read it as usual (if no errors).
3624: F34D     C9         	RET                
3625: F34E                ;                   
3626: F34E                ;   Write to a random record.
3627: F34E                ;                   
3628: F34E                WRITERAN:           
3629: F34E     0E00       	MVI	C,0	;set 'writing' flag.
3630: F350     CDB5F2     	CALL	POSITION;position the file to proper record.
3631: F353     CCB5F1     	CZ	WTSEQ1	;and write as usual (if no errors).
3632: F356     C9         	RET                
3633: F357                ;                   
3634: F357                ;   Compute the random record number. Enter with (HL) pointing
3635: F357                ; to a fcb an (DE) contains a relative location of a record
3636: F357                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3637: F357                ; byte, and (A) the 'r2' byte.
3638: F357                ;                   
3639: F357                ;   On return, the zero flag is set if the record is within
3640: F357                ; bounds. Otherwise, an overflow occured.
3641: F357                ;                   
3642: F357                COMPRAND:           
3643: F357     EB         	XCHG		;save fcb pointer in (DE).
3644: F358     19         	DAD	D	;compute relative position of record #.
3645: F359     4E         	MOV	C,M	;get record number into (BC).
3646: F35A     0600       	MVI	B,0            
3647: F35C     210C00     	LXI	H,12	;now get extent.
3648: F35F     19         	DAD	D              
3649: F360     7E         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3650: F361     0F         	RRC		;move lower bit into bit 7.
3651: F362     E680       	ANI	80H	;and ignore all other bits.
3652: F364     81         	ADD	C	;add to our record number.
3653: F365     4F         	MOV	C,A            
3654: F366     3E00       	MVI	A,0	;take care of any carry.
3655: F368     88         	ADC	B              
3656: F369     47         	MOV	B,A            
3657: F36A     7E         	MOV	A,M	;now get the upper bits of extent into
3658: F36B     0F         	RRC		;bit positions 0-3.
3659: F36C     E60F       	ANI	0FH	;and ignore all others.
3660: F36E     80         	ADD	B	;add this in to 'r1' byte.
3661: F36F     47         	MOV	B,A            
3662: F370     210E00     	LXI	H,14	;get the 's2' byte (extra extent).
3663: F373     19         	DAD	D              
3664: F374     7E         	MOV	A,M            
3665: F375     87         	ADD	A	;and shift it left 4 bits (bits 4-7).
3666: F376     87         	ADD	A              
3667: F377     87         	ADD	A              
3668: F378     87         	ADD	A              
3669: F379     F5         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3670: F37A     80         	ADD	B	;now add extra extent into 'r1'.
3671: F37B     47         	MOV	B,A            
3672: F37C     F5         	PUSH	PSW	;and save carry (overflow byte 'r2').
3673: F37D     E1         	POP	H	;bit 0 of (L) is the overflow indicator.
3674: F37E     7D         	MOV	A,L            
3675: F37F     E1         	POP	H	;and same for first carry flag.
3676: F380     B5         	ORA	L	;either one of these set?
3677: F381     E601       	ANI	01H	;only check the carry flags.
3678: F383     C9         	RET                
3679: F384                ;                   
3680: F384                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3681: F384                ; reflect the last record used for a random (or other) file.
3682: F384                ; This reads the directory and looks at all extents computing
3683: F384                ; the largerst record number for each and keeping the maximum
3684: F384                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3685: F384                ; maximum record number. This is used to compute the space used
3686: F384                ; by a random file. 
3687: F384                ;                   
3688: F384                RANSIZE:            
3689: F384     0E0C       	MVI	C,12	;look thru directory for first entry with
3690: F386     CDCAEE     	CALL	FINDFST	;this name.
3691: F389     2A3CE8     	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3692: F38C     112100     	LXI	D,33           
3693: F38F     19         	DAD	D              
3694: F390     E5         	PUSH	H             
3695: F391     72         	MOV	M,D	;note that (D)=0.
3696: F392     23         	INX	H              
3697: F393     72         	MOV	M,D            
3698: F394     23         	INX	H              
3699: F395     72         	MOV	M,D            
3700: F396                RANSIZ1:            
3701: F396     CD05EE     	CALL	CKFILPOS;is there an extent to process?
3702: F399     CABEF3     	JZ	RANSIZ3	;no, we are done.
3703: F39C     CD6EED     	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3704: F39F     110F00     	LXI	D,15	;point to last record in extent.
3705: F3A2     CD57F3     	CALL	COMPRAND;and compute random parameters.
3706: F3A5     E1         	POP	H              
3707: F3A6     E5         	PUSH	H	;now check these values against those
3708: F3A7     5F         	MOV	E,A	;already in fcb.
3709: F3A8     79         	MOV	A,C	;the carry flag will be set if those
3710: F3A9     96         	SUB	M	;in the fcb represent a larger size than
3711: F3AA     23         	INX	H	;this extent does.
3712: F3AB     78         	MOV	A,B            
3713: F3AC     9E         	SBB	M              
3714: F3AD     23         	INX	H              
3715: F3AE     7B         	MOV	A,E            
3716: F3AF     9E         	SBB	M              
3717: F3B0     DAB8F3     	JC	RANSIZ2         
3718: F3B3     73         	MOV	M,E	;we found a larger (in size) extent.
3719: F3B4     2B         	DCX	H	;stuff these values into fcb.
3720: F3B5     70         	MOV	M,B            
3721: F3B6     2B         	DCX	H              
3722: F3B7     71         	MOV	M,C            
3723: F3B8                RANSIZ2:            
3724: F3B8     CDDFEE     	CALL	FINDNXT	;now get the next extent.
3725: F3BB     C396F3     	JMP	RANSIZ1	;continue til all done.
3726: F3BE                RANSIZ3:            
3727: F3BE     E1         	POP	H	;we are done, restore the stack and
3728: F3BF     C9         	RET		;return.      
3729: F3C0                ;                   
3730: F3C0                ;   Function to return the random record position of a given
3731: F3C0                ; file which has been read in sequential mode up to now.
3732: F3C0                ;                   
3733: F3C0                SETRAN:             
3734: F3C0     2A3CE8     	LHLD	ParamsDE	;point to fcb.
3735: F3C3     112000     	LXI	D,32	;and to last used record.
3736: F3C6     CD57F3     	CALL	COMPRAND;compute random position.
3737: F3C9     212100     	LXI	H,33	;now stuff these values into fcb.
3738: F3CC     19         	DAD	D              
3739: F3CD     71         	MOV	M,C	;move 'r0'.
3740: F3CE     23         	INX	H              
3741: F3CF     70         	MOV	M,B	;and 'r1'. 
3742: F3D0     23         	INX	H              
3743: F3D1     77         	MOV	M,A	;and lastly 'r2'.
3744: F3D2     C9         	RET                
3745: F3D3                ;                   
3746: F3D3                ; This routine selects the drive specified in (CurrentDrive) and
3747: F3D3                ; updates the login vector and bitmap table if this drive was
3748: F3D3                ; not already active.
3749: F3D3                ;                   
3750: F3D3                LoginDrive:         
3751: F3D3     2AAAF5     	LHLD	LoggedBitMap		; point at the "logged In" Bitmap.
3752: F3D6     3AA6F5     	LDA		CurrentDrive		; get the Subject Drive.
3753: F3D9     4F         	MOV		C,A					; Save current drive
3754: F3DA     CD0DED     	CALL	SHIFTR				; Return with CurrentDrive's bit in L's lsb (byte 0)
3755: F3DD     E5         	PUSH	H					; Save it, so we will know if it is already active
3756: F3DE     EB         	XCHG               
3757: F3DF     CD7CEB     	CALL	SelectDisk			; select this drive (in BIOS).
3758: F3E2     CA6AEB     	JZ		SLCTERR				; If not valid then error exit outta here
3759: F3E5     E1         	POP	H						; retreive original state of the drive
3760: F3E6     7D         	MOV	A,L						; and put it into (A) 
3761: F3E7     1F         	RAR							; move the lsb (bit 0) into the carry flag		
3762: F3E8     D8         	RC							; if its set then this drive has already been activated
3763: F3E9                							;No, then update the logged Bitmap to reflect this drive.
3764: F3E9     2AAAF5     	LHLD	LoggedBitMap		
3765: F3EC     4D         	MOV		C,L           
3766: F3ED     44         	MOV		B,H					; put the map into (BC)
3767: F3EE     CD52F4     	CALL	SETBIT				; Set it in the LoggedBitMap
3768: F3F1     22AAF5     	SHLD	LoggedBitMap		; and save the Bit map.
3769: F3F4                ;	JMP	BITMAP	;now update the bitmap.
3770: F3F4                ;-----------------------------------------------------------
3771: F3F4                ;                   
3772: F3F4                ;   Construct the space used allocation bit map for the active
3773: F3F4                ; drive. If a file name starts with '$' and it is under the
3774: F3F4                ; current user number, then (StatusBDOSReturn) is set to minus 1. Otherwise
3775: F3F4                ; it is not set at all.
3776: F3F4                ;                   
3777: F3F4                BITMAP:             
3778: F3F4     2AC1F5     	LHLD		DSKSIZE		;compute size of allocation table.
3779: F3F7     0E03       	MVI			C,3			; 2 raised to 3rd power = 8
3780: F3F9     CD0DED     	CALL		SHIFTR		;(HL)=(HL)/8.
3781: F3FC     23         	INX			H			;at lease 1 byte.
3782: F3FD     44         	MOV			B,H          
3783: F3FE     4D         	MOV			C,L	;set (BC) to the allocation table length.
3784: F3FF                ;                   
3785: F3FF                ;   Initialize the bitmap for this drive. Right now, the first
3786: F3FF                ; two bytes are specified by the disk parameter block. However
3787: F3FF                ; a patch could be entered here if it were necessary to setup
3788: F3FF                ; this table in a special mannor. For example, the bios could
3789: F3FF                ; determine locations of 'bad blocks' and set them as already
3790: F3FF                ; 'used' in the map.
3791: F3FF                ;                   
3792: F3FF     2ABAF5     	LHLD		ALOCVECT	;now zero out the table now.
3793: F402                BITMAP1:            
3794: F402     3600       	MVI			M,0			; put zero in vector
3795: F404     23         	INX			H			; point at next locatio
3796: F405     0B         	DCX			B			; count down
3797: F406     78         	MOV			A,B          
3798: F407     B1         	ORA			C			; equals zero if both (B) and (B) are Zero
3799: F408     C202F4     	JNZ			BITMAP1		; loop for more
3800: F40B     2AC5F5     	LHLD		ALLOC0		;get initial space used by directory.
3801: F40E     EB         	XCHG               
3802: F40F     2ABAF5     	LHLD	ALOCVECT;and put this into map.
3803: F412     73         	MOV	M,E            
3804: F413     23         	INX	H              
3805: F414     72         	MOV	M,D            
3806: F415                ;                   
3807: F415                ;   End of initialization portion.
3808: F415                ;                   
3809: F415     CDC4EB     	CALL	HOMEDRV	;now home the drive.
3810: F418     2AAEF5     	LHLD	FilePosInDir  
3811: F41B     3603       	MVI	M,3	;force next directory request to read
3812: F41D     23         	INX	H	;in a sector.
3813: F41E     3600       	MVI	M,0            
3814: F420     CD0EEE     	CALL	STFILPOS;clear initial file position also.
3815: F423                BITMAP2:            
3816: F423     0EFF       	MVI	C,0FFH	;read next file name in directory
3817: F425     CD15EE     	CALL	NXENTRY	;and set checksum byte.
3818: F428     CD05EE     	CALL	CKFILPOS;is there another file?
3819: F42B     C8         	RZ                 
3820: F42C     CD6EED     	CALL	FCB2HL	;yes, get its address.
3821: F42F     3EE5       	MVI	A,0E5H         
3822: F431     BE         	CMP	M	;empty file entry?
3823: F432     CA23F4     	JZ	BITMAP2         
3824: F435     3AA5F5     	LDA	CurrentUser;no, correct user number?
3825: F438     BE         	CMP	M              
3826: F439     C247F4     	JNZ	BITMAP3        
3827: F43C     23         	INX	H              
3828: F43D     7E         	MOV	A,M	;yes, does name start with a '$'?
3829: F43E     D624       	SUI	DOLLAR		; '$'  
3830: F440     C247F4     	JNZ	BITMAP3        
3831: F443     3D         	DCR	A	;yes, set atatus to minus one.
3832: F444     323FE8     	STA	StatusBDOSReturn
3833: F447                BITMAP3:            
3834: F447     0E01       	MVI	C,1	;now set this file's space as used in bit map.
3835: F449     CD7BEE     	CALL	SETFILE       
3836: F44C     CD9CED     	CALL	CHKNMBR	;keep (FilePosInDir) in bounds.
3837: F44F     C323F4     	JMP	BITMAP2        
3838: F452                ;-----------------------------------------------------------
3839: F452                ;                   
3840: F452                ;  Routine to set a bit in a 16 bit value contained in (BC).
3841: F452                ; The bit set depends on the current drive selection.
3842: F452                ;                   
3843: F452                SETBIT:             
3844: F452     C5         	PUSH	B					;save original bit (BC)
3845: F453     3AA6F5     	LDA		CurrentDrive		;get active drive.
3846: F456     4F         	MOV		C,A           
3847: F457     210100     	LXI		H,1           
3848: F45A     CD27ED     	CALL	SHIFTL				;shift bit into place for Drive bit .
3849: F45D     C1         	POP		B					;now 'or' this with the original word.
3850: F45E     79         	MOV		A,C           
3851: F45F     B5         	ORA		L             
3852: F460     6F         	MOV		L,A					;low byte done, do high byte.
3853: F461     78         	MOV		A,B           
3854: F462     B4         	ORA		H             
3855: F463     67         	MOV		H,A           
3856: F464     C9         	RET							; HL has the result
3857: F465                ;                   
3858: F465                ;   Function to set the active disk number.
3859: F465                ;                   
3860: F465                SETDSK:             
3861: F465     3A3EE8     	LDA	ParamE	;get parameter passed and see if this
3862: F468     21A6F5     	LXI	H,CurrentDrive;represents a change in drives.
3863: F46B     BE         	CMP	M              
3864: F46C     C8         	RZ                 
3865: F46D     77         	MOV	M,A	;yes it does, log it in.
3866: F46E     C3D3F3     	JMP	LoginDrive     
3867: F471                ;                   
3868: F471                ;   This is the 'auto disk select' routine. The firsst byte
3869: F471                ; of the fcb is examined for a drive specification. If non
3870: F471                ; zero then the drive will be selected and loged in.
3871: F471                ;                   
3872: F471                AUTOSEL:            
3873: F471     3EFF       	MVI	A,0FFH	;say 'auto-select activated'.
3874: F473     32D8F5     	STA	AutoSelectActive
3875: F476     2A3CE8     	LHLD	ParamsDE	;get drive specified.
3876: F479     7E         	MOV	A,M            
3877: F47A     E61F       	ANI	1FH	;look at lower 5 bits.
3878: F47C     3D         	DCR	A	;adjust for (1=A, 2=B) etc.
3879: F47D     323EE8     	STA	ParamE	;and save for the select routine.
3880: F480     FE1E       	CPI	1EH	;check for 'no change' condition.
3881: F482     D295F4     	JNC	AUTOSL1	;yes, don't change.
3882: F485     3AA6F5     	LDA	CurrentDrive	;we must change, save currently active
3883: F488     32D9F5     	STA	OLDDRV	;drive. 
3884: F48B     7E         	MOV	A,M	;and save first byte of fcb also.
3885: F48C     32DAF5     	STA	AutoSelectFlag;this must be non-zero.
3886: F48F     E6E0       	ANI	0E0H	;whats this for (bits 6,7 are used for
3887: F491     77         	MOV	M,A	;something)?
3888: F492     CD65F4     	CALL	SETDSK	;select and log in this drive.
3889: F495                AUTOSL1:            
3890: F495     3AA5F5     	LDA	CurrentUser;move user number into fcb.
3891: F498     2A3CE8     	LHLD	ParamsDE	;(* upper half of first byte *)
3892: F49B     B6         	ORA	M              
3893: F49C     77         	MOV	M,A            
3894: F49D     C9         	RET		;and return (all done).
3895: F49E                ;                   
3896: F49E                ;   Function to return the current cp/m version number.
3897: F49E                ;                   
3898: F49E                GETVER:             
3899: F49E     3E22       	MVI	A,022h	;version 2.2
3900: F4A0     C35CEB     	JMP	SETSTAT        
3901: F4A3                ;                   
3902: F4A3                ;   Function (0D) to reset the disk system.
3903: F4A3                ;                   
3904: F4A3                RSTDSK:             
3905: F4A3     210000     	LXI		H,0				; clear write protect status and log
3906: F4A6     22A8F5     	SHLD	ROBitMap		; clear All Read Only Bits
3907: F4A9     22AAF5     	SHLD	LoggedBitMap	; clear all logged in drives
3908: F4AC     AF         	XRA		A             
3909: F4AD     32A6F5     	STA		CurrentDrive	;select drive 'A'.
3910: F4B0     218000     	LXI		H,Pg0Buffer		;setup default dma address.
3911: F4B3     22ACF5     	SHLD	UsersDMA      
3912: F4B6     CDEAED     	CALL	Set2UsersDMA	; Call BIOS to set DMAA 
3913: F4B9     C3D3F3     	JMP		LoginDrive		;now log in drive 'A'.
3914: F4BC                ;                   
3915: F4BC                ;   Function to open a specified file.
3916: F4BC                ;                   
3917: F4BC                OPENFIL:            
3918: F4BC     CD82ED     	CALL	CLEARS2	;clear 's2' byte.
3919: F4BF     CD71F4     	CALL	AUTOSEL	;select proper disk.
3920: F4C2     C303F0     	JMP	OPENIT	;and open the file.
3921: F4C5                ;                   
3922: F4C5                ;   Function to close a specified file.
3923: F4C5                ;                   
3924: F4C5                CLOSEFIL:           
3925: F4C5     CD71F4     	CALL	AUTOSEL	;select proper disk.
3926: F4C8     C354F0     	JMP	CLOSEIT	;and close the file.
3927: F4CB                ;                   
3928: F4CB                ;   Function to return the first occurence of a specified file
3929: F4CB                ; name. If the first byte of the fcb is '?' then the name will
3930: F4CB                ; not be checked (get the first entry no matter what).
3931: F4CB                ;                   
3932: F4CB                GETFST:             
3933: F4CB     0E00       	MVI	C,0	;prepare for special search.
3934: F4CD     EB         	XCHG               
3935: F4CE     7E         	MOV	A,M	;is first byte a '?'?
3936: F4CF     FE3F       	CPI	QMARK		;'?'    
3937: F4D1     CAE2F4     	JZ	GETFST1	;yes, just get very first entry (zero length match).
3938: F4D4     CDC9EC     	CALL	SETEXT	;get the extension byte from fcb.
3939: F4D7     7E         	MOV	A,M	;is it '?'? if yes, then we want
3940: F4D8     FE3F       	CPI	QMARK		; '?'	;an entry with a specific 's2' byte.
3941: F4DA     C482ED     	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
3942: F4DD     CD71F4     	CALL	AUTOSEL	;select proper drive.
3943: F4E0     0E0F       	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
3944: F4E2                GETFST1:            
3945: F4E2     CDCAEE     	CALL	FINDFST	;find an entry and then move it into
3946: F4E5     C3F9ED     	JMP	MOVEDIR	;the users dma space.
3947: F4E8                ;                   
3948: F4E8                ;   Function to return the next occurence of a file name.
3949: F4E8                ;                   
3950: F4E8                GETNXT:             
3951: F4E8     2AD3F5     	LHLD	SAVEFCB	;restore pointers. note that no
3952: F4EB     223CE8     	SHLD	ParamsDE	;other dbos calls are allowed.
3953: F4EE     CD71F4     	CALL	AUTOSEL	;no error will be returned, but the
3954: F4F1     CDDFEE     	CALL	FINDNXT	;results will be wrong.
3955: F4F4     C3F9ED     	JMP	MOVEDIR        
3956: F4F7                ;                   
3957: F4F7                ;   Function to delete a file by name.
3958: F4F7                ;                   
3959: F4F7                DELFILE:            
3960: F4F7     CD71F4     	CALL	AUTOSEL	;select proper drive.
3961: F4FA     CD4EEF     	CALL	ERAFILE	;erase the file.
3962: F4FD     C3B3EE     	JMP	STSTATUS;set status and return.
3963: F500                ;                   
3964: F500                ;   Function to execute a sequential read of the specified
3965: F500                ; record number.    
3966: F500                ;                   
3967: F500                READSEQ:            
3968: F500     CD71F4     	CALL	AUTOSEL	;select proper drive then read.
3969: F503     C36EF1     	JMP	RDSEQ          
3970: F506                ;                   
3971: F506                ;   Function to write the net sequential record.
3972: F506                ;                   
3973: F506                WRTSEQ:             
3974: F506     CD71F4     	CALL	AUTOSEL	;select proper drive then write.
3975: F509     C3B0F1     	JMP	WTSEQ          
3976: F50C                ;                   
3977: F50C                ;   Create a file function.
3978: F50C                ;                   
3979: F50C                FCREATE:            
3980: F50C     CD82ED     	CALL	CLEARS2	;clear the 's2' byte on all creates.
3981: F50F     CD71F4     	CALL	AUTOSEL	;select proper drive and get the next
3982: F512     C3D6F0     	JMP	GETEMPTY;empty directory space.
3983: F515                ;                   
3984: F515                ;   Function to rename a file.
3985: F515                ;                   
3986: F515                RENFILE:            
3987: F515     CD71F4     	CALL	AUTOSEL	;select proper drive and then switch
3988: F518     CDC8EF     	CALL	CHGNAMES;file names.
3989: F51B     C3B3EE     	JMP	STSTATUS       
3990: F51E                ;                   
3991: F51E                ;   Function to return the logged in Bit map.
3992: F51E                ;                   
3993: F51E                GETLOG:             
3994: F51E     2AAAF5     	LHLD	LoggedBitMap  
3995: F521     C349F5     	JMP	GETPRM1        
3996: F524                ;                   
3997: F524                ;   Function to return the current disk assignment.
3998: F524                ;                   
3999: F524                GETCRNT:            
4000: F524     3AA6F5     	LDA	CurrentDrive   
4001: F527     C35CEB     	JMP	SETSTAT        
4002: F52A                ;                   
4003: F52A                ;   Function to set the dma address.
4004: F52A                ;                   
4005: F52A                PUTDMA:             
4006: F52A     EB         	XCHG               
4007: F52B     22ACF5     	SHLD	UsersDMA	;save in our space and then get to
4008: F52E     C3EAED     	JMP	Set2UsersDMA	;the bios with this also.
4009: F531                ;                   
4010: F531                ;   Function to return the allocation vector.
4011: F531                ;                   
4012: F531                GETALOC:            
4013: F531     2ABAF5     	LHLD	ALOCVECT      
4014: F534     C349F5     	JMP	GETPRM1        
4015: F537                ;                   
4016: F537                ;   Function to return the read-only status vector.
4017: F537                ;                   
4018: F537                GETROV:             
4019: F537     2AA8F5     	LHLD	ROBitMap      
4020: F53A     C349F5     	JMP	GETPRM1        
4021: F53D                ;                   
4022: F53D                ;   Function to set the file attributes (read-only, system).
4023: F53D                ;                   
4024: F53D                SETATTR:            
4025: F53D     CD71F4     	CALL	AUTOSEL	;select proper drive then save attributes.
4026: F540     CDEDEF     	CALL	SAVEATTR      
4027: F543     C3B3EE     	JMP	STSTATUS       
4028: F546                ;                   
4029: F546                ;   Function to return the address of the disk parameter block
4030: F546                ; for the current drive.
4031: F546                ;                   
4032: F546                GETPARM:            
4033: F546     2AB6F5     	LHLD	DISKPB        
4034: F549                GETPRM1:            
4035: F549     223FE8     	SHLD	StatusBDOSReturn
4036: F54C     C9         	RET                
4037: F54D                ;                   
4038: F54D                ;   Function to get or set the user number. If (E) was (FF)
4039: F54D                ; then this is a request to return the current user number.
4040: F54D                ; Else set the user number from (E).
4041: F54D                ;                   
4042: F54D                GETUSER:            
4043: F54D     3A3EE8     	LDA			ParamE			; get parameter.
4044: F550     FEFF       	CPI			0FFH			; want to get user number?
4045: F552     C25BF5     	JNZ			SETUSER			; No, then set it
4046: F555     3AA5F5     	LDA			CurrentUser		;yes, just return it in A
4047: F558     C35CEB     	JMP			SETSTAT			; exit while setting return status
4048: F55B                	                   
4049: F55B                SETUSER:            
4050: F55B     E61F       	ANI			1FH				;no,just keep the low bits (000X XXXX)
4051: F55D     32A5F5     	STA			CurrentUser		;and save in Current user
4052: F560     C9         	RET                
4053: F561                ;                   
4054: F561                ;   Function to read a random record from a file.
4055: F561                ;                   
4056: F561                RDRANDOM:           
4057: F561     CD71F4     	CALL	AUTOSEL	;select proper drive and read.
4058: F564     C345F3     	JMP	READRAN        
4059: F567                ;                   
4060: F567                ;   Function to compute the file size for random files.
4061: F567                ;                   
4062: F567                WTRANDOM:           
4063: F567     CD71F4     	CALL	AUTOSEL	;select proper drive and write.
4064: F56A     C34EF3     	JMP	WRITERAN       
4065: F56D                ;                   
4066: F56D                ;   Function to compute the size of a random file.
4067: F56D                ;                   
4068: F56D                FILESIZE:           
4069: F56D     CD71F4     	CALL	AUTOSEL	;select proper drive and check file length
4070: F570     C384F3     	JMP	RANSIZE        
4071: F573                ;                   
4072: F573                ;   Function #37. This allows a program to log off any drives.
4073: F573                ; On entry, set (DE) to contain a word with bits set for those
4074: F573                ; drives that are to be logged off. The log-in vector and the
4075: F573                ; write protect vector will be updated. This must be a M/PM
4076: F573                ; special function. 
4077: F573                ;                   
4078: F573                LOGOFF:             
4079: F573     2A3CE8     	LHLD	ParamsDE	;get drives to log off.
4080: F576     7D         	MOV	A,L	;for each bit that is set, we want
4081: F577     2F         	CMA		;to clear that bit in (LoggedBitMap)
4082: F578     5F         	MOV	E,A	;and (ROBitMap).
4083: F579     7C         	MOV	A,H            
4084: F57A     2F         	CMA                
4085: F57B     2AAAF5     	LHLD	LoggedBitMap	;reset the login Bit map.
4086: F57E     A4         	ANA	H              
4087: F57F     57         	MOV	D,A            
4088: F580     7D         	MOV	A,L            
4089: F581     A3         	ANA	E              
4090: F582     5F         	MOV	E,A            
4091: F583     2AA8F5     	LHLD	ROBitMap      
4092: F586     EB         	XCHG               
4093: F587     22AAF5     	SHLD	LoggedBitMap	;and save.
4094: F58A     7D         	MOV	A,L	;now do the write protect vector.
4095: F58B     A3         	ANA	E              
4096: F58C     6F         	MOV	L,A            
4097: F58D     7C         	MOV	A,H            
4098: F58E     A2         	ANA	D              
4099: F58F     67         	MOV	H,A            
4100: F590     22A8F5     	SHLD	ROBitMap	;and save. all done.
4101: F593     C9         	RET                
4102: F594                ;                   
4103: F594                ;   Get here to return to the user.
4104: F594                ;                   
4105: F594                                    
4106: F594                ;                   
4107: F594                ;   Function #40. This is a special entry to do random i/o.
4108: F594                ; For the case where we are writing to unused disk space, this
4109: F594                ; space will be zeroed out first. This must be a M/PM special
4110: F594                ; purpose function, because why would any normal program even
4111: F594                ; care about the previous contents of a sector about to be
4112: F594                ; written over.     
4113: F594                ;                   
4114: F594                WTSPECL:            
4115: F594     CD71F4     	CALL	AUTOSEL	;select proper drive.
4116: F597     3E02       	MVI	A,2	;use special write mode.
4117: F599     32D0F5     	STA	MODE           
4118: F59C     0E00       	MVI	C,0	;set write indicator.
4119: F59E     CDB9F2     	CALL	POSITN1	;position the file.
4120: F5A1     CCB5F1     	CZ	WTSEQ1	;and write (if no errors).
4121: F5A4     C9         	RET                
4122: F5A5                                    
4123: F5A5                ;**************************************************************
4124: F5A5                ;*                  
4125: F5A5                ;*     BDOS data storage pool.
4126: F5A5                ;*                  
4127: F5A5                ;**************************************************************
4128: F5A5                                    
4129: F5A5     00         CurrentUser:			DB	0	;current user number.
4130: F5A6     00         CurrentDrive:			DB	0	;currently active drive.
4131: F5A7                                    
4132: F5A7                ;                   
4133: F5A7     E5         EMPTYFCB:				DB	0E5H	;empty directory segment indicator.
4134: F5A8     0000       ROBitMap:				DW	0	;write protect status for all 16 drives.
4135: F5AA     0000       LoggedBitMap:			DW	0	;drive active word (1 bit per drive).
4136: F5AC     8000       UsersDMA:				DW	080H	;user's dma address (defaults to 80h).
4137: F5AE                ;                   
4138: F5AE                ;   Scratch areas from parameter block.
4139: F5AE                ;                   
4140: F5AE     0000       FilePosInDir:			DW	0	;relative position within dir segment for file (0-3).
4141: F5B0     0000       LastTrackNumber:		DW	0	;last selected track number.
4142: F5B2     0000       LastSectorNumber:		DW	0	;last selected sector number.
4143: F5B4                ;                   
4144: F5B4                ;   Disk storage areas from parameter block.
4145: F5B4                ;                   
4146: F5B4     0000       DIRBUF:					DW	0	;address of directory buffer to use.
4147: F5B6     0000       DISKPB:					DW	0	;contains address of disk parameter block.
4148: F5B8     0000       CHKVECT:				DW	0	;address of check vector.
4149: F5BA     0000       ALOCVECT:				DW	0	;address of allocation vector (bit map).
4150: F5BC                ;                   
4151: F5BC                ;   Parameter block returned from the bios.
4152: F5BC                ;                   
4153: F5BC     0000       SECTORS:				DW	0	;sectors per track from bios.
4154: F5BE     00         BLKSHFT:				DB	0	;block shift.
4155: F5BF     00         BLKMASK:				DB	0	;block mask.
4156: F5C0     00         EXTMASK:				DB	0	;extent mask.
4157: F5C1     0000       DSKSIZE:				DW	0	;disk size from bios (number of blocks-1).
4158: F5C3     0000       DIRSIZE:				DW	0	;directory size.
4159: F5C5     0000       ALLOC0:					DW	0	;storage for first bytes of bit map (dir space used).
4160: F5C7     0000       ALLOC1:					DW	0    
4161: F5C9     0000       OFFSET:					DW	0	;first usable track number.
4162: F5CB     0000       XLATE:					DW	0	;sector translation table address.
4163: F5CD                ;                   
4164: F5CD                ;                   
4165: F5CD     00         CLOSEFLG:				DB	0	;close flag (=0ffh is extent written ok).
4166: F5CE     00         RDWRTFLG:				DB	0	;read/write flag (0ffh=read, 0=write).
4167: F5CF     00         FNDSTAT:				DB	0	;filename found status (0=found first entry).
4168: F5D0     00         MODE:					DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4169: F5D1     00         RELBLOCK:				DB	0	;relative position within fcb of block number written.
4170: F5D2     00         COUNTER:				DB	0	;byte counter for directory name searches.
4171: F5D3     00000000   SAVEFCB:				DW	0,0	;save space for address of fcb (for directory searches).
4172: F5D7     00         BIGDISK:				DB	0	;if =0 then disk is > 256 blocks long.
4173: F5D8     00         AutoSelectActive:		DB	0	;if non-zero, then auto select activated.
4174: F5D9     00         OLDDRV:					DB	0	;on auto select, storage for previous drive.
4175: F5DA     00         AutoSelectFlag:			DB	0	;if non-zero, then auto select changed drives.
4176: F5DB     00         SAVNXT:					DB	0	;storage for next record number to access.
4177: F5DC     00         SAVEXT:					DB	0	;storage for extent number of file.
4178: F5DD     0000       SAVNREC:				DW	0	;storage for number of records in file.
4179: F5DF     0000       BLKNMBR:				DW	0	;block number (physical sector) used within a file or logical sector.
4180: F5E1     0000       LOGSECT:				DW	0	;starting logical (128 byte) sector of block (physical sector).
4181: F5E3     00         FCBPOS:					DB	0	;relative position within buffer for fcb of file of interest.
4182: F5E4     0000       FILEPOS:				DW	0	;files position within directory (0 to max entries -1).
4183: F5E6                ;                   
4184: F5E6                ;   Disk directory buffer checksum bytes. One for each of the
4185: F5E6                ; 16 possible drives.
4186: F5E6                ;                   
4187: F5E6                CKSUMTBL:           
4188: F5E6     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4189: F5F6                ;                   
4190: F5F6                ;   Extra space ?   
4191: F5F6                ;                   
4192: F5F6     00000000   	DB	0,0,0,0         
4193: F5FA                ;                   
4194: F5FA                ;**************************************************************
4195: F5FA                ;*                  
4196: F5FA                ;*        B I O S   J U M P   T A B L E
4197: F5FA                ;*                  
4198: F5FA                ;**************************************************************
4199: F5FA                ;                   
4200: F5FA                BIOSEntry	Equ	0F600H		; start of bios
4201: F5FA                                    
4202: F5FA                BOOT	EQU		BIOSEntry + 000H	
4203: F5FA                WBOOT	EQU		BIOSEntry + 003H
4204: F5FA                CONST	EQU		BIOSEntry + 006H
4205: F5FA                CONIN	EQU		BIOSEntry + 009H
4206: F5FA                CONOUT	EQU		BIOSEntry + 00CH
4207: F5FA                LIST	EQU		BIOSEntry + 00FH
4208: F5FA                PUNCH	EQU		BIOSEntry + 012H
4209: F5FA                READER	EQU		BIOSEntry + 015H
4210: F5FA                HOME	EQU		BIOSEntry + 018H
4211: F5FA                SELDSK	EQU		BIOSEntry + 01BH
4212: F5FA                SETTRK	EQU		BIOSEntry + 01EH
4213: F5FA                SETSEC	EQU		BIOSEntry + 021H
4214: F5FA                SETDMA	EQU		BIOSEntry + 024H
4215: F5FA                READ	EQU		BIOSEntry + 027H
4216: F5FA                WRITE	EQU		BIOSEntry + 02AH
4217: F5FA                PRSTAT	EQU		BIOSEntry + 02DH
4218: F5FA                SECTRN	EQU		BIOSEntry + 030H
4219: F5FA                                    
4220: F5FA                ;BOOT:	JMP	BIOSEntry + 000H	
4221: F5FA                ;WBOOT:	JMP	BIOSEntry + 003H
4222: F5FA                ;CONST:	JMP	BIOSEntry + 006H
4223: F5FA                ;CONIN:	JMP	BIOSEntry + 009H
4224: F5FA                ;CONOUT:	JMP	BIOSEntry + 00CH
4225: F5FA                ;LIST:	JMP	BIOSEntry + 00FH
4226: F5FA                ;PUNCH:	JMP	BIOSEntry + 012H
4227: F5FA                ;READER:	JMP	BIOSEntry + 015H
4228: F5FA                ;HOME:	JMP	BIOSEntry + 018H
4229: F5FA                ;SELDSK:	JMP	BIOSEntry + 01BH
4230: F5FA                ;SETTRK:	JMP	BIOSEntry + 01EH
4231: F5FA                ;SETSEC:	JMP	BIOSEntry + 021H
4232: F5FA                ;SETDMA:	JMP	BIOSEntry + 024H
4233: F5FA                ;READ:	JMP	BIOSEntry + 027H
4234: F5FA                ;WRITE:	JMP	BIOSEntry + 02AH
4235: F5FA                ;PRSTAT:	JMP	BIOSEntry + 02DH
4236: F5FA                ;SECTRN:	JMP	BIOSEntry + 030H
4237: F5FA                ;                   
4238: F5FA                ;*                  
4239: F5FA                ;******************   E N D   O F   C P / M   *****************
4240: F5FA                ;*                  
4241: F5FA                CodeEnd:            
4242: F5FA                		END               




                                    Xref


0000	0000	$                             		  1539,

2460	ED74	ADDA2HL                       		  3381,
0497	E259	ADDHL                         		  0515,  0870,  1063,
4159	F5C5	ALLOC0                        		  3800,
4160	F5C7	ALLOC1                        		  2544,
4149	F5BA	ALOCVECT                      		  2701,  3792,  3802,  4013,
0050	002A	ASTRK                         		  0555,  0587,
0052	0040	ATSIGN                        		  1712,
3872	F471	AUTOSEL                       		  3919,  3925,  3942,  3953,  3960,  3968,  3974,  3981,  3987,  4025,  4057,  4063,  4069,  4115,
4173	F5D8	AUTOSELECTACTIVE              		  1438,  1468,  3874,
4175	F5DA	AUTOSELECTFLAG                		  1437,  1473,  3885,
3889	F495	AUTOSL1                       		  3881,

1734	E9FF	BACKUP                        		  1849,  1889,
1738	EA07	BACKUP1                       		  1735,
1354	E77A	BADLOAD                       		  1351,
1544	E8EC	BADSCTR                       		  2112,
1576	E925	BADSEC                        		  1553,
1577	E930	BADSEL                        		  1560,
1545	E8EE	BADSLCT                       		  2012,
1381	E7AB	BATCH                         		  0288,  0406,  0716,  1340,
1383	E7AC	BATCHFCB                      		  0300,  0303,  0305,  0306,  0316,  0320,  0413,
1575	E921	BDOSDRV                       		  1588,
1423	E806	BDOSENTRY                     		
1574	E915	BDOSERR                       		  1589,
1467	E873	BDOSEXIT                      		  1439,
1480	E890	BDOSEXIT1                     		  1470,  1475,  1949,
1465	E873	BDOSSTACK                     		  1435,
4172	F5D7	BIGDISK                       		  2074,  2249,  2747,  3149,  3377,
4200	F600	BIOSENTRY                     		  4202,  4203,  4204,  4205,  4206,  4207,  4208,  4209,  4210,  4211,  4212,  4213,  4214,  4215,  4216,  4217,  4218,
3777	F3F4	BITMAP                        		
3793	F402	BITMAP1                       		  3799,
3815	F423	BITMAP2                       		  3823,  3837,
3833	F447	BITMAP3                       		  3826,  3830,
0039	0020	BLANK                         		  0112,  0442,  0465,  0490,  0572,  0604,  0676,  0812,  0839,  0915,  0967,  0976,  0979,  1221,  1235,  1251,  1311,  1368,  1630,  1684,  1723,  1736,  1754,
4155	F5BF	BLKMASK                       		  2295,  3434,
4179	F5DF	BLKNMBR                       		  2122,  2129,  2270,  2276,  2289,  2301,  3372,  3427,  3432,  3441,
4154	F5BE	BLKSHFT                       		  2216,  2288,
4202	F600	BOOT                          		
0040	007B	BRACKETLEFT                   		  0278,
0041	007D	BRACKETRIGHT                  		
0026	0008	BS                            		  1628,  1691,  1739,  1801,

0051	005E	CARET                         		  1709,
0062	E000	CBASE                         		  0777,  0778,  1275,
1377	E7AB	CCPSTACK                      		  0705,  0729,
1392	E7EF	CDRIVE                        		  0260,  0268,  0296,  0323,  0415,  0538,  0720,  0744,  0885,  0898,  0901,  1241,
1998	EB69	CHARBUF                       		  1598,  1639,  1654,
0461	E230	CHECK                         		  0552,  0566,  0584,  0598,
2541	EDAE	CHECKDIR                      		  2660,
2378	ED1A	CHECKSUM                      		  2548,
1394	E7F0	CHGDRV                        		  0519,  0543,  0747,  0805,  0881,  0894,  1152,  1176,  1237,  1291,  1369,
3034	EFD9	CHGNAM1                       		  3042,
3025	EFC8	CHGNAMES                      		  3988,
2275	ECA7	CHKBLK                        		  3323,  3351,
1621	E96F	CHKCHAR                       		  1609,  1706,
0376	E1C2	CHKCON                        		  0331,  0993,  1068,
2562	EDD4	CHKDIR1                       		  2555,
2511	ED9C	CHKNMBR                       		  3236,  3836,
2432	ED54	CHKROFL                       		  2905,  3037,
2382	ED20	CHKSUM1                       		  2386,
4148	F5B8	CHKVECT                       		  2549,
2445	ED64	CHKWPRT                       		  2899,  3026,  3212,  3343,
2668	EE45	CKBITMAP                      		  2716,  2941,  2970,
2704	EE66	CKBMAP1                       		  2707,
1653	E99D	CKCON1                        		  1647,
1655	E9A0	CKCON2                        		  1641,
1638	E97E	CKCONSOL                      		  1668,  1978,
2612	EE05	CKFILPOS                      		  2827,  2903,  3035,  3053,  3066,  3139,  3219,  3247,  3277,  3283,  3701,  3818,
2434	ED57	CKROF1                        		  3345,
4187	F5E6	CKSUMTBL                      		  2123,  2542,  2551,
0691	E358	CLEARBUF                      		  0064,
2479	ED82	CLEARS2                       		  3918,  3941,  3980,
0170	E0DA	CLOSE                         		  0321,  1128,
3924	F4C5	CLOSEFIL                      		  1513,
4165	F5CD	CLOSEFLG                      		  3201,  3245,  3260,
3127	F054	CLOSEIT                       		  3246,  3567,  3926,
3148	F07F	CLOSEIT1                      		  3184,
3157	F08D	CLOSEIT2                      		  3155,
3162	F093	CLOSEIT3                      		  3159,
3166	F09A	CLOSEIT4                      		  3151,
3180	F0AF	CLOSEIT5                      		  3165,
3199	F0C9	CLOSEIT6                      		  3191,
3203	F0D1	CLOSEIT7                      		  3164,  3173,  3178,
0769	E3C1	CMDADR                        		  0756,
0638	E310	CMDTBL                        		  0659,
0728	E382	CMMND1                        		  0339,  0456,  1016,  1020,  1343,  1372,
0740	E398	CMMND2                        		  0724,
0024	0003	CNTRLC                        		  1555,  1649,  1909,
0025	0005	CNTRLE                        		  1821,
0031	0010	CNTRLP                        		  1830,
0032	0012	CNTRLR                        		  1858,
0033	0013	CNTRLS                        		  1646,
0034	0015	CNTRLU                        		  1852,
0035	0018	CNTRLX                        		  1840,
0036	001A	CNTRLZ                        		  1065,
4241	F5FA	CODEEND                       		
0060	E000	CODESTART                     		
0046	003A	COLON                         		  0474,  0534,  0953,  0958,
2265	EC9A	COMBLK                        		  3322,  3350,
1356	E783	COMFILE                       		  1257,
0704	E35C	COMMAND                       		  0063,
3642	F357	COMPRAND                      		  3705,  3736,
4205	F609	CONIN                         		  1603,  1645,  1648,  1950,
4206	F60C	CONOUT                        		  1671,  1737,  1740,  1945,
4204	F606	CONST                         		  1642,  1944,  1947,
0513	E260	CONVERT                       		  1296,
0506	E25E	CONVFST                       		  0745,  0804,  0911,  1008,  1040,  1091,  1150,  1172,  1290,  1366,
0537	E289	CONVRT1                       		  0529,
0541	E290	CONVRT2                       		  0535,
0549	E296	CONVRT3                       		  0540,
0551	E298	CONVRT4                       		  0564,
0559	E2A9	CONVRT5                       		  0556,
0562	E2AB	CONVRT6                       		  0558,
0565	E2AF	CONVRT7                       		  0569,
0570	E2B9	CONVRT8                       		  0553,  0574,
4170	F5D2	COUNTER                       		  2813,  2840,
0030	000D	CR                            		  0104,  1622,  1761,  1797,  1920,
0229	E109	CREATE                        		  1098,
0103	E098	CRLF                          		  0120,  0438,  0454,  0730,  0947,  1045,  1333,
1996	EB67	CURPOS                        		  1680,  1725,  1750,  1782,  1807,  1845,  1885,
4130	F5A6	CURRENTDRIVE                  		  1586,  2039,  2405,  3752,  3845,  3862,  3882,  3909,  4000,
4129	F5A5	CURRENTUSER                   		  3824,  3890,  4046,  4051,

2025	EB72	DE2HL                         		  2066,  2071,  2608,  3016,  3078,
2027	EB73	DE2HL1                        		  2034,
0803	E3F8	DECODE                        		  1089,  1216,
0810	E408	DECODE1                       		  0835,
0831	E42A	DECODE2                       		
0837	E433	DECODE3                       		  0813,  0844,
0842	E43A	DECODE4                       		
0037	007F	DEL                           		  1681,  1811,
0405	E1DD	DELBATCH                      		  0338,  0345,  0455,
0195	E0EF	DELETE                        		  0414,  1026,  1096,
3959	F4F7	DELFILE                       		  1516,
4146	F5B4	DIRBUF                        		  2064,  2380,  2455,  2590,  2604,  3416,
1946	EB3B	DIRC1                         		  1942,
1939	EB2F	DIRCIO                        		  1502,
0910	E477	DIRECT                        		  0770,
0918	E488	DIRECT1                       		  0922,
0923	E48F	DIRECT2                       		  0916,
0928	E498	DIRECT3                       		  0996,
0956	E4CC	DIRECT4                       		  0946,
0960	E4D4	DIRECT5                       		  0955,
0963	E4D9	DIRECT6                       		  0987,  0989,
0990	E50E	DIRECT7                       		  0977,  0985,
0992	E50F	DIRECT8                       		  0939,
0997	E51B	DIRECT9                       		  0929,  0994,
2577	EDE4	DIRREAD                       		  2658,
4158	F5C3	DIRSIZE                       		  2421,  2637,
2568	EDD6	DIRWRITE                      		  2910,  3019,
4147	F5B6	DISKPB                        		  2067,  4033,
1579	E93C	DISKRO                        		  1564,
0399	E1D8	DMASET                        		  0742,  1116,  1268,
0054	0024	DOLLAR                        		  1770,  3829,
2101	EBD5	DOREAD                        		  2579,  3327,
2107	EBDB	DOWRITE                       		  2572,  3431,  3451,
0978	E4F7	DRECT63                       		  0972,
0980	E4F9	DRECT65                       		  0968,
0878	E454	DSELECT                       		  0912,  1024,  1042,  1093,  1154,  1255,
0140	E0BD	DSKSEL                        		  0299,  0325,  0412,  0416,  0721,  0888,  0902,  1243,  1342,
4157	F5C1	DSKSIZE                       		  2072,  2766,  2959,  3778,

4133	F5A7	EMPTYFCB                      		  3215,
0017	0005	ENTRY                         		  0090,  0136,  0143,  0149,  0197,  0203,  0238,  0250,  0349,  0378,  0382,  0390,  0401,
0148	E0C3	ENTRY1                        		  0158,  0172,  0179,  0185,  0231,
0202	E0F4	ENTRY2                        		  0212,  0225,
0043	003D	EQUALS                        		  0468,  1164,
2902	EF56	ERAFIL1                       		  2912,
2898	EF4E	ERAFILE                       		  3961,
1007	E51F	ERASE                         		  0770,
1023	E542	ERASE1                        		  1010,
1552	E8F4	ERROR1                        		  1544,
1559	E900	ERROR2                        		  1545,
1563	E906	ERROR3                        		  1546,
1567	E90C	ERROR4                        		  1547,
1570	E90F	ERROR5                        		  1561,  1565,
1206	E682	EXISTS                        		  1203,
2244	EC81	EXTBLK                        		  2269,  3361,
2255	EC94	EXTBLK1                       		  2251,
4156	F5C0	EXTMASK                       		  2334,  2793,  3258,
0867	E44B	EXTRACT                       		  0937,  0965,  0974,

1388	E7CD	FCB                           		  0164,  0165,  0190,  0217,  0514,  0665,  0808,  0880,  0913,  1025,  1094,  1101,  1117,  1127,  1157,  1158,  1186,  1190,  1220,  1234,  1249,  1269,  1294,  1299,  1301,  1303,  1367,
2454	ED6E	FCB2HL                        		  2433,  2737,  2839,  2906,  3014,  3073,  3142,  3703,  3820,
4181	F5E3	FCBPOS                        		  2456,  2653,
3000	EFAF	FCBSET                        		  3237,
3979	F50C	FCREATE                       		  1519,
0029	000C	FF                            		
4182	F5E4	FILEPOS                       		  2119,  2498,  2613,  2625,  2639,  2641,  2646,  2877,  3130,  3131,
4140	F5AE	FILEPOSINDIR                  		  2053,  2424,  2500,  3810,
1578	E937	FILERO                        		  1568,
4068	F56D	FILESIZE                      		  1532,
2810	EECA	FINDFST                       		  2901,  3028,  3051,  3065,  3138,  3218,  3276,  3690,  3945,
2824	EEDF	FINDNXT                       		  2858,  2865,  2911,  3041,  3058,  3724,  3954,
2838	EEFC	FNDNXT1                       		  2833,
2843	EF05	FNDNXT2                       		  2875,
2860	EF25	FNDNXT3                       		  2855,
2870	EF2E	FNDNXT4                       		  2849,  2852,  2859,
2876	EF35	FNDNXT5                       		  2846,
2890	EF46	FNDNXT6                       		  2828,  2837,
2934	EF72	FNDSPA1                       		  2975,  2994,
2958	EF83	FNDSPA2                       		  2937,
2980	EF9E	FNDSPA3                       		  2943,  2972,
2991	EFA6	FNDSPA4                       		  2964,
2927	EF70	FNDSPACE                      		  3365,
4167	F5CF	FNDSTAT                       		  2782,  2812,  2880,
1539	0028	FUNCTIONCOUNT                 		  1442,
1495	E89A	FUNCTIONVECTOR                		  1539,  1445,

4012	F531	GETALOC                       		  1524,
1363	E786	GETBACK                       		  0999,  1029,  1066,  1069,  1076,  1139,  1192,  1198,  1205,  1353,
1365	E789	GETBACK1                      		  1224,  1239,  1244,
2219	EC68	GETBLK1                       		  2223,
2229	EC76	GETBLK2                       		  2234,
2235	EC7F	GETBLK3                       		  2231,
2215	EC61	GETBLOCK                      		  2266,  3354,
1597	E956	GETCHAR                       		  1608,  1793,
1925	EB23	GETCON                        		  1497,
3999	F524	GETCRNT                       		  1522,
1977	EB59	GETCSTS                       		  1507,
0388	E1D0	GETDSK                        		  0731,  0743,  0949,
1607	E961	GETECHO                       		  1926,
3211	F0D6	GETEMPTY                      		  3282,  3589,  3982,
0578	E2C0	GETEXT                        		  0567,
0583	E2C8	GETEXT1                       		  0596,
0591	E2D9	GETEXT2                       		  0588,
0594	E2DB	GETEXT3                       		  0590,
0597	E2DF	GETEXT4                       		  0601,
0602	E2E9	GETEXT5                       		  0581,  0585,  0606,
0607	E2F0	GETEXT6                       		  0599,
0609	E2F2	GETEXT7                       		  0613,
0622	E301	GETEXT8                       		  0630,
0628	E309	GETEXT9                       		  0626,
3932	F4CB	GETFST                        		  1514,
3944	F4E2	GETFST1                       		  3937,
0287	E139	GETINP                        		  0736,  1013,
0344	E196	GETINP1                       		  0290,  0302,  0308,  0322,
0354	E1A7	GETINP2                       		  0332,
0357	E1AB	GETINP3                       		  0366,
0367	E1BA	GETINP4                       		  0361,
1955	EB48	GETIOB                        		  1503,
3993	F51E	GETLOG                        		  1521,
3228	F0F8	GETMT1                        		  3232,
3243	F10C	GETNEXT                       		  3315,  3483,
3950	F4E8	GETNXT                        		  1515,
4032	F546	GETPARM                       		  1528,
4034	F549	GETPRM1                       		  3995,  4014,  4020,
1931	EB29	GETRDR                        		  1499,
4018	F537	GETROV                        		  1526,
2470	ED79	GETS2                         		  2480,  2487,  3134,  3472,  3606,
0248	E115	GETSETUC                      		  0714,  1223,
4042	F54D	GETUSER                       		  1529,
0242	E113	GETUSR                        		  0255,
3898	F49E	GETVER                        		  1508,
2403	ED2E	GETWPRT                       		  2446,  3132,
0049	003E	GRTTHAN                       		  0480,  0734,
3264	F135	GTNEXT1                       		  3256,
3274	F140	GTNEXT2                       		  3262,
3286	F15E	GTNEXT3                       		  3263,  3278,
3288	F161	GTNEXT4                       		  3285,
3296	F168	GTNEXT5                       		  3270,  3281,  3284,

0775	E3CF	HALT                          		  0428,
0856	E442	HL2DE                         		  0315,  0862,  1160,  1305,
4210	F618	HOME                          		  2087,
2086	EBC4	HOMEDRV                       		  2818,  3809,

0070	E006	INBUFF                        		  0080,  0312,  0329,  0348,  0355,  0369,  0693,  0722,  1014,  1306,
0079	E088	INPOINT                       		  0370,  0520,  0615,  1022,  1161,  1171,
0015	0003	IOBYTE                        		  1956,  1962,
1990	EB60	IOERR1                        		  3297,  3333,  3349,
2109	EBDE	IORET                         		  2103,

2016	EB6D	JUMPHL                        		  2113,  2441,  2449,

4142	F5B2	LASTSECTORNUMBER              		  2059,  2093,  2133,  2194,
4141	F5B0	LASTTRACKNUMBER               		  2056,  2089,  2137,  2189,
0048	003C	LESSTH                        		  0478,
0028	000A	LF                            		  0106,  1624,  1696,  1763,  1799,
4207	F60F	LIST                          		  1501,  1676,
4135	F5AA	LOGGEDBITMAP                  		  3751,  3764,  3768,  3907,  3994,  4085,  4093,
2287	ECAD	LOGICAL                       		  3325,  3399,
2290	ECB3	LOGICL1                       		  2293,
3750	F3D3	LOGINDRIVE                    		  3866,  3913,
4078	F573	LOGOFF                        		  1534,
4180	F5E1	LOGSECT                       		  2294,  3424,

0013	0040	MEM                           		  0059,
4168	F5D0	MODE                          		  2345,  3304,  3339,  3400,  3479,  3513,  4117,
2497	ED8F	MOREFLS                       		  2512,  2558,  2835,
0851	E440	MOVE3                         		  1258,
0267	E129	MOVECD                        		  0350,  1242,  1341,
2603	EDF9	MOVEDIR                       		  3946,  3955,
3109	F046	MOVEWORD                      		  3167,  3169,

0081	E08A	NAMEPNT                       		  0439,  0524,
1396	E7F1	NBYTES                        		  1046,  1049,
1745	EA0C	NEWLINE                       		  1854,  1862,
1749	EA14	NEWLN1                        		  1756,
0795	E3F0	NOFILE                        		  0793,
0486	E24F	NONBLANK                      		  0493,  0522,  1163,
0792	E3EA	NONE                          		  0927,  1028,  1197,
1140	E607	NOSPACE                       		  1135,
0637	0006	NUMCMDS                       		  0663,
2645	EE29	NXENT1                        		  2643,
2649	EE30	NXENT2                        		  2652,
2636	EE15	NXENTRY                       		  2826,  3817,

4161	F5C9	OFFSET                        		  2183,
4174	F5D9	OLDDRV                        		  1477,  3883,
0156	E0CB	OPEN                          		  0166,  0301,
0162	E0D0	OPENFCB                       		  1043,  1259,
3917	F4BC	OPENFIL                       		  1512,
3063	F003	OPENIT                        		  3580,  3920,
3068	F00C	OPENIT1                       		  3287,
3097	F03D	OPENIT2                       		  3093,  3095,
1663	E9A3	OUTCHAR                       		  1710,  1721,  1724,  1747,  1755,  1762,  1764,  1921,
1678	E9BD	OUTCHR1                       		  1666,
1695	E9D4	OUTCHR2                       		  1692,
1718	E9EB	OUTCON                        		  1498,  1613,  1707,  1775,
1722	E9F1	OUTCON1                       		  1728,
1760	EA24	OUTCRLF                       		  1585,  1748,  1825,
1994	EB65	OUTFLAG                       		  1664,  1808,  1882,  1887,  1890,

1458	E83E	PARAME                        		  1430,  1478,  3861,  3879,  4043,
1457	E83C	PARAMSDE                      		  1427,  1453,  1471,  1784,  2245,  2307,  2316,  2471,  2815,  3011,  3029,  3075,  3098,  3145,  3213,  3216,  3221,  3249,  3344,  3374,  3519,  3691,  3734,  3875,  3891,  3952,  4079,
0649	E328	PATTRN1                       		  0422,
1406	E800	PATTRN2                       		  0423,
0045	002E	PERIOD                        		  0472,  0580,
0019	0080	PG0BUFFER                     		  0313,  0395,  0741,  0868,  1062,  1320,  1332,  3910,
0118	E0A7	PLINE                         		  0785,  0794,  1012,  1136,  1204,  1352,
0122	E0AC	PLINE2                        		  0130,  0330,
3511	F2B5	POSITION                      		  3622,  3630,
3517	F2B9	POSITN1                       		  4119,
3564	F2F9	POSITN2                       		  3554,
3597	F331	POSITN3                       		  3560,  3583,
3604	F336	POSITN4                       		  3573,  3588,  3593,
3612	F33D	POSITN5                       		  3546,
0053	0023	POUNDSN                       		  1746,
0087	E08C	PRINT                         		  0096,  0128,  0447,  0453,  0733,  0735,  1067,
0094	E092	PRINTB                        		  0105,  0107,  0113,  0952,  0954,  0959,  0981,
4217	F62D	PRSTAT                        		
1583	E940	PRTERR                        		  1554,  1571,
1997	EB68	PRTFLAG                       		  1674,  1833,
1768	EA2E	PRTMESG                       		  1590,  1592,  1777,  1973,
1969	EB53	PRTSTR                        		  1505,
4208	F612	PUNCH                         		  1500,
4005	F52A	PUTDMA                        		  1523,

0042	003F	QMARK                         		  0452,  0557,  0589,  0625,  0919,  2848,  3936,  3940,

3700	F396	RANSIZ1                       		  3725,
3723	F3B8	RANSIZ2                       		  3717,
3726	F3BE	RANSIZ3                       		  3702,
3688	F384	RANSIZE                       		  4070,
1789	EA4A	RDBUF1                        		  1805,  1815,  1838,  1916,
1860	EACB	RDBUF10                       		  1809,
1867	EAD3	RDBUF11                       		  1879,
1880	EAE5	RDBUF12                       		  1870,
1888	EAF4	RDBUF13                       		  1892,
1897	EB01	RDBUF14                       		  1859,
1901	EB04	RDBUF15                       		  1819,
1914	EB18	RDBUF16                       		  1911,
1917	EB1C	RDBUF17                       		  1798,  1800,
1792	EA4C	RDBUF2                        		  1828,  1884,  1893,
1810	EA71	RDBUF3                        		  1802,
1820	EA81	RDBUF4                        		  1812,
1829	EA92	RDBUF5                        		  1822,
1839	EAA3	RDBUF6                        		  1831,
1843	EAA9	RDBUF7                        		  1850,
1851	EABA	RDBUF8                        		  1841,
1857	EAC6	RDBUF9                        		  1853,
1781	EA3C	RDBUFF                        		  1506,  1847,  1856,
0786	E3DF	RDERR                         		  0784,
0783	E3D9	RDERROR                       		  1077,
4056	F561	RDRANDOM                      		  1530,
0210	E0F9	RDREC                         		  0218,  0307,  1270,
3302	F16E	RDSEQ                         		  3969,
3305	F173	RDSEQ1                        		  3623,
3321	F198	RDSEQ2                        		  3312,
3332	F1AD	RDSEQ3                        		  3314,  3320,  3324,
4166	F5CE	RDWRTFLG                      		  3279,  3307,  3342,
4215	F627	READ                          		  2102,
4209	F615	READER                        		  1932,
0216	E0FE	READFCB                       		  1055,
3620	F345	READRAN                       		  4058,
3967	F500	READSEQ                       		  1517,
4169	F5D1	RELBLOCK                      		  3355,  3379,
0236	E10E	RENAM                         		  1191,
1149	E610	RENAME                        		  0771,
1168	E63F	RENAME1                       		  1165,
1183	E659	RENAME2                       		  1179,
1187	E65E	RENAME3                       		
1196	E66D	RENAME4                       		  1189,
1199	E673	RENAME5                       		  1167,  1173,  1182,
1202	E679	RENAME6                       		  1156,
3986	F515	RENFILE                       		  1520,
0134	E0B8	RESDSK                        		  0715,
0893	E466	RESETDR                       		  1079,  1200,  1289,  1348,  1364,
1985	EB5F	RETURN                        		  1535,  1536,
4134	F5A8	ROBITMAP                      		  2404,  2415,  2420,  3906,  4019,  4091,  4100,
1546	E8F0	RODISK                        		  2448,
1547	E8F2	ROFILE                        		  2440,
3904	F4A3	RSTDSK                        		  1510,
1390	E7EE	RTNCODE                       		  0150,  0930,

2790	EEB9	SAMEXT                        		  2863,
3052	EFF2	SAVATR1                       		  3059,
1088	E5AD	SAVE                          		  0770,
1107	E5D4	SAVE1                         		  1122,
1126	E5F1	SAVE2                         		  1110,
1134	E5FB	SAVE3                         		  1099,  1121,
1137	E601	SAVE4                         		  1130,
3049	EFED	SAVEATTR                      		  4026,
4171	F5D3	SAVEFCB                       		  2816,  2829,  3951,
4177	F5DC	SAVEXT                        		  2228,  2336,
4178	F5DD	SAVNREC                       		  2218,  2297,  2329,  2351,  3309,  3317,  3347,  3453,  3489,
4176	F5DB	SAVNXT                        		  2332,  2355,  3310,  3454,
0658	E32E	SEARCH                        		  0750,
0661	E333	SEARCH1                       		  0686,
0667	E33C	SEARCH2                       		  0674,
0680	E34F	SEARCH3                       		  0670,  0683,
0684	E354	SEARCH4                       		  0677,
4153	F5BC	SECTORS                       		  2069,  2149,  2161,
4218	F630	SECTRN                        		  2207,
4211	F61B	SELDSK                        		  2041,
2038	EB7C	SELECTDISK                    		  3757,
2079	EBC0	SELECTDISK1                   		  2077,
0047	003B	SEMIC                         		  0476,
2583	EDEA	SET2USERSDMA                  		  2573,  3442,  3912,  4008,
4024	F53D	SETATTR                       		  1527,
3843	F452	SETBIT                        		  2419,  3767,
0254	E11A	SETCDRV                       		  0346,  1335,
2533	EDAC	SETDIR                        		  2569,
2589	EDF0	SETDIRDMA                     		  2570,  2578,  3423,
4214	F624	SETDMA                        		  2599,
2595	EDF3	SETDMA0                       		  2585,
3860	F465	SETDSK                        		  1479,  1511,  3888,
2306	ECC9	SETEXT                        		  2333,  3069,  3938,
2736	EE7B	SETFILE                       		  2909,  3835,
2742	EE85	SETFL1                        		  2776,
2755	EE98	SETFL2                        		  2749,
2762	EE9E	SETFL3                        		  2754,
2772	EEAD	SETFL4                        		  2765,
2315	ECD1	SETHLDE                       		  2327,  2344,
1961	EB4E	SETIOB                        		  1504,
2343	ECF5	SETNREC                       		  3328,  3482,  3493,
3733	F3C0	SETRAN                        		  1533,
2486	ED88	SETS2B7                       		  3079,  3238,  3298,  3616,
4213	F621	SETSEC                        		  2210,
1983	EB5C	SETSTAT                       		  1927,  1933,  1951,  1957,  1992,  2783,  2893,  3291,  3370,  3600,  3900,  4001,  4047,
4212	F61E	SETTRK                        		  2187,
4049	F55B	SETUSER                       		  4045,
2391	ED27	SHIFTL                        		  3848,
2393	ED28	SHIFTL1                       		  2397,
2361	ED0D	SHIFTR                        		  2121,  2407,  3754,  3780,
2363	ED0E	SHIFTR1                       		  2373,
1704	E9DA	SHOWIT                        		  1876,  1905,
2011	EB6A	SLCTERR                       		  3758,
0111	E0A2	SPACE                         		  0957,  0961,  0988,
0189	E0E9	SRCHFCB                       		  0926,  1155,  1188,
0177	E0DF	SRCHFST                       		  0191,
0183	E0E4	SRCHNXT                       		  0995,
1995	EB66	STARTING                      		  1751,  1783,  1827,  1844,
1459	E83F	STATUSBDOSRETURN              		  1432,  1483,  1984,  2879,  3129,  3204,  3318,  3395,  3484,  3571,  3581,  3591,  3615,  3832,  4035,
2714	EE6C	STBITMAP                      		  2771,
2726	EE74	STBMAP1                       		  2729,  2983,
0394	E1D5	STDDMA                        		  1138,  1334,
2623	EE0E	STFILPOS                      		  2644,  2817,  2891,  3814,
2349	ED01	STNREC1                       		  2347,
2326	ECDE	STRDATA                       		  3289,  3308,  3346,
2781	EEB3	STSTATUS                      		  3962,  3989,  4027,
2522	EDA5	SUBHL                         		  2545,  2642,
0437	E209	SYNERR                        		  0466,  0746,  0807,  0817,  0821,  0827,  0829,  0832,  0840,  1041,  1080,  1092,  1151,  1201,  1218,  1222,  1252,  1349,  1371,
0440	E20F	SYNERR1                       		  0450,
0451	E222	SYNERR2                       		  0443,  0445,

0027	0009	TAB                           		  1626,  1720,
0020	0100	TBASE                         		  1106,  1264,  1336,
0016	0004	TDRIVE                        		  0262,  0269,
0018	005C	TFCB                          		  1302,
2118	EBE6	TRKSEC                        		  2657,  3018,
2128	EBF4	TRKSEC1                       		  3326,  3429,  3448,
2142	EC07	TRKSEC2                       		  2158,
2159	EC1D	TRKSEC3                       		  2147,  2172,
2177	EC32	TRKSEC4                       		  2163,  2168,
1039	E55D	TYPE                          		  0770,
1048	E574	TYPE1                         		  1070,
1050	E577	TYPE2                         		
1060	E587	TYPE3                         		  1053,
1074	E5A0	TYPE4                         		  1057,
1078	E5A7	TYPE5                         		  1044,

1232	E6A5	UNKNOWN                       		  0749,  0771,
1350	E771	UNKWN0                        		  1280,  1288,
1248	E6C4	UNKWN1                        		  1236,
1253	E6CD	UNKWN2                        		
1265	E6E1	UNKWN3                        		  1281,
1285	E701	UNKWN4                        		  1271,
1307	E730	UNKWN5                        		  1314,
1318	E73E	UNKWN6                        		  1310,  1312,
1321	E743	UNKWN7                        		  1329,
1330	E74F	UNKWN8                        		  1325,
1347	E76B	UNKWN9                        		  1260,
3008	EFB3	UPDATE                        		  3040,  3057,
3017	EFC2	UPDATE1                       		  3202,
0275	E130	UPPER                         		  0363,
0044	005F	USCORE                        		  0470,  1166,
1215	E68E	USER                          		  0771,
4136	F5AC	USERSDMA                      		  2584,  2606,  3911,  4007,
1460	E841	USERSTACK                     		  1434,  1481,

0421	E1F5	VERIFY                        		  1233,
0425	E1FD	VERIFY1                       		  0432,

4203	F603	WBOOT                         		  1496,
4216	F62A	WRITE                         		  2108,
3628	F34E	WRITERAN                      		  4064,
2414	ED3C	WRTPRTD                       		  1525,  2560,
0223	E104	WRTREC                        		  1118,
3973	F506	WRTSEQ                        		  1518,
4062	F567	WTRANDOM                      		  1531,
3337	F1B0	WTSEQ                         		  3975,
3340	F1B5	WTSEQ1                        		  3631,  4120,
3464	F284	WTSEQ10                       		  3456,
3490	F2B0	WTSEQ11                       		  3487,
3492	F2B2	WTSEQ12                       		  3478,  3481,
3364	F1ED	WTSEQ2                        		  3358,
3371	F1FA	WTSEQ3                        		  3368,
3384	F216	WTSEQ4                        		  3380,
3392	F21E	WTSEQ5                        		  3383,
3394	F220	WTSEQ6                        		  3353,
3418	F23E	WTSEQ7                        		  3422,
3426	F24C	WTSEQ8                        		  3439,
3447	F26D	WTSEQ9                        		  3403,  3414,
3476	F291	WTSEQ99                       		
4114	F594	WTSPECL                       		  1537,

4162	F5CB	XLATE                         		  2063,  2205,

1030	E552	YESNO                         		  1011,
