0001: 0000                                    
0002: 0000                ;**************************************************************
0003: 0000                ;*                  
0004: 0000                ;*             C P / M   version   2 . 2
0005: 0000                ;*                    Sourced from:
0006: 0000                ;*  Reconstructed from memory image on February 27, 1981
0007: 0000                ;*                by Clark A. Calkins
0008: 0000                ;*                  
0009: 0000                ;**************************************************************
0010: 0000                ;                   
0011: 0000                                    
0012: 0000                ;                   
0013: 0000                MEM			EQU		64			;for a 64k system 
0014: 0000                ;                   
0015: 0000                IOBYTE		EQU		3			;i/o definition byte.
0016: 0000                TDRIVE		EQU		4			;current drive name and user number.
0017: 0000                ENTRY		EQU		5			;entry point for the cp/m bdos.
0018: 0000                TFCB		EQU		5CH			;default file control block.
0019: 0000                Pg0Buffer	EQU		80H			;i/o buffer and command line storage.
0020: 0000                TBASE		EQU		100H		;transiant program storage area.
0021: 0000                ;                   
0022: 0000                ;   Set control character equates.
0023: 0000                ;                   
0024: 0000                CNTRLC		EQU		03H			;control-c
0025: 0000                CNTRLE		EQU		05H			;control-e
0026: 0000                BS			EQU		08H			;backspace
0027: 0000                TAB			EQU		09H			;tab
0028: 0000                LF			EQU		0AH			;line feed
0029: 0000                FF			EQU		0CH			;form feed
0030: 0000                CR			EQU		0DH			;carriage return
0031: 0000                CNTRLP		EQU		10H			;control-p
0032: 0000                CNTRLR		EQU		12H			;control-r
0033: 0000                CNTRLS		EQU		13H			;control-s
0034: 0000                CNTRLU		EQU		15H			;control-u
0035: 0000                CNTRLX		EQU		18H			;control-x
0036: 0000                CNTRLZ		EQU		1AH			;control-z (end-of-file mark)
0037: 0000                DEL			EQU		7FH			;rubout
0038: 0000                ;                   
0039: 0000                BLANK		EQU		020H		; Space/Blank
0040: 0000                BRACKETLEFT		EQU	07BH		; {
0041: 0000                BRACKETRIGHT	EQU	07DH		; }
0042: 0000                QMARK		EQU		03FH		; ?
0043: 0000                EQUALS		EQU		03DH		; =
0044: 0000                USCORE		EQU		05FH		; _
0045: 0000                PERIOD		EQU		02EH		; .
0046: 0000                COLON		EQU		03AH		; :
0047: 0000                SEMIC		EQU		03BH		; ;
0048: 0000                LESSTH		EQU		03CH		; <
0049: 0000                GRTTHAN		EQU		03EH		; >
0050: 0000                ASTRK		EQU		02AH		; *
0051: 0000                CARET		EQU		05EH		; ^
0052: 0000                ATSIGN		EQU		040H		; @
0053: 0000                POUNDSN		EQU		023H		; #
0054: 0000                DOLLAR		EQU		024H		; $
0055: 0000                                    
0056: 0000                ;                   
0057: 0000                ;   Set origin for CP/M
0058: 0000                ;                   
0059: 0000                	ORG	(MEM-8)*1024   
0060: E000                CodeStart:          
0061: E000                ;                   
0062: E000                CBASE:              
0063: E000     C332E3     		JMP		COMMAND		;execute command processor (ccp).
0064: E003     C32EE3     		JMP		CLEARBUF	;entry to empty input buffer before starting ccp.
0065: E006                                    
0066: E006                ;                   
0067: E006                ;   Standard cp/m ccp input buffer. Format is (max length),
0068: E006                ; (actual length), (char #1), (char #2), (char #3), etc.
0069: E006                ;                   
0070: E006                INBUFF:             
0071: E006     7F         		DB		127			;length of input buffer.
0072: E007     00         		DB		0			;current length of contents.
0073: E008     434F50595249474854 		DB		'Copyright'   
0074: E011     203139373920284329204259204449474954414C205245534541524348202020202020 		DB		' 1979 (c) by Digital Research      '
0075: E034     0000000000000000000000000000000000000000000000 		DB		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0076: E04B     0000000000000000000000000000000000000000000000 		DB		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0077: E062     0000000000000000000000000000000000000000000000 		DB		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0078: E079     000000000000000000000000000000 		DB		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0079: E088                INPOINT:            
0080: E088     08E0       		DW		INBUFF+2	;input line pointer
0081: E08A                NAMEPNT:            
0082: E08A     0000       		DW		0			;input line pointer used for error message. Points to
0083: E08C                ;			;start of name in error.
0084: E08C                ;                   
0085: E08C                ;   Routine to print (A) on the console. All registers used.
0086: E08C                ;                   
0087: E08C                PRINT:              
0088: E08C     5F         	MOV		E,A			;setup bdos call.
0089: E08D     0E02       	MVI		C,2           
0090: E08F     C30500     	JMP		ENTRY         
0091: E092                ;                   
0092: E092                ;   Routine to print (A) on the console and to save (BC).
0093: E092                ;                   
0094: E092                PRINTB:             
0095: E092     C5         	PUSH	B             
0096: E093     CD8CE0     	CALL	PRINT         
0097: E096     C1         	POP		B             
0098: E097     C9         	RET                
0099: E098                ;                   
0100: E098                ;   Routine to send a carriage return, line feed combination
0101: E098                ; to the console.   
0102: E098                ;                   
0103: E098                CRLF:               
0104: E098     3E0D       	MVI		A,CR          
0105: E09A     CD92E0     	CALL	PRINTB        
0106: E09D     3E0A       	MVI		A,LF          
0107: E09F     C392E0     	JMP		PRINTB        
0108: E0A2                ;                   
0109: E0A2                ;   Routine to send one space to the console and save (BC).
0110: E0A2                ;                   
0111: E0A2                SPACE:              
0112: E0A2     3E20       	MVI		A,BLANK		; blank/Space
0113: E0A4     C392E0     	JMP		PRINTB        
0114: E0A7                ;                   
0115: E0A7                ;   Routine to print character string pointed to be (BC) on the
0116: E0A7                ; console. It must terminate with a null byte.
0117: E0A7                ;                   
0118: E0A7                PLINE:              
0119: E0A7     C5         	PUSH	B             
0120: E0A8     CD98E0     	CALL	CRLF          
0121: E0AB     E1         	POP		H             
0122: E0AC                PLINE2:             
0123: E0AC     7E         	MOV		A,M           
0124: E0AD     B7         	ORA		A             
0125: E0AE     C8         	RZ                 
0126: E0AF     23         	INX		H             
0127: E0B0     E5         	PUSH	H             
0128: E0B1     CD8CE0     	CALL	PRINT         
0129: E0B4     E1         	POP		H             
0130: E0B5     C3ACE0     	JMP		PLINE2        
0131: E0B8                ;                   
0132: E0B8                ;   Routine to reset the disk system.
0133: E0B8                ;                   
0134: E0B8                RESDSK:             
0135: E0B8     0E0D       	MVI		C,13          
0136: E0BA     C30500     	JMP		ENTRY         
0137: E0BD                ;                   
0138: E0BD                ;   Routine to select disk (A).
0139: E0BD                ;                   
0140: E0BD                DSKSEL:             
0141: E0BD     5F         	MOV		E,A           
0142: E0BE     0E0E       	MVI		C,14          
0143: E0C0     C30500     	JMP		ENTRY         
0144: E0C3                ;                   
0145: E0C3                ;   Routine to call bdos and save the return code. The zero
0146: E0C3                ; flag is set on a return of 0ffh.
0147: E0C3                ;                   
0148: E0C3                ENTRY1:             
0149: E0C3     CD0500     	CALL	ENTRY         
0150: E0C6     32C1E7     	STA		RTNCODE		;save return code.
0151: E0C9     3C         	INR		A			;set zero if 0ffh returned.
0152: E0CA     C9         	RET                
0153: E0CB                ;                   
0154: E0CB                ;   Routine to open a file. (DE) must point to the FCB.
0155: E0CB                ;                   
0156: E0CB                OPEN:               
0157: E0CB     0E0F       	MVI		C,15          
0158: E0CD     C3C3E0     	JMP		ENTRY1        
0159: E0D0                ;                   
0160: E0D0                ;   Routine to open file at (FCB).
0161: E0D0                ;                   
0162: E0D0                OPENFCB:            
0163: E0D0     AF         	XRA		A		;clear the record number byte at fcb+32
0164: E0D1     32C0E7     	STA		FCB+32        
0165: E0D4     11A0E7     	LXI		D,FCB         
0166: E0D7     C3CBE0     	JMP		OPEN          
0167: E0DA                ;                   
0168: E0DA                ;   Routine to close a file. (DE) points to FCB.
0169: E0DA                ;                   
0170: E0DA                CLOSE:              
0171: E0DA     0E10       	MVI		C,16          
0172: E0DC     C3C3E0     	JMP		ENTRY1        
0173: E0DF                ;                   
0174: E0DF                ;   Routine to search for the first file with ambigueous name
0175: E0DF                ; (DE).             
0176: E0DF                ;                   
0177: E0DF                SRCHFST:            
0178: E0DF     0E11       	MVI		C,17          
0179: E0E1     C3C3E0     	JMP		ENTRY1        
0180: E0E4                ;                   
0181: E0E4                ;   Search for the next ambigeous file name.
0182: E0E4                ;                   
0183: E0E4                SRCHNXT:            
0184: E0E4     0E12       	MVI		C,18          
0185: E0E6     C3C3E0     	JMP		ENTRY1        
0186: E0E9                ;                   
0187: E0E9                ;   Search for file at (FCB).
0188: E0E9                ;                   
0189: E0E9                SRCHFCB:            
0190: E0E9     11A0E7     	LXI		D,FCB         
0191: E0EC     C3DFE0     	JMP		SRCHFST       
0192: E0EF                ;                   
0193: E0EF                ;   Routine to delete a file pointed to by (DE).
0194: E0EF                ;                   
0195: E0EF                DELETE:             
0196: E0EF     0E13       	MVI		C,19          
0197: E0F1     C30500     	JMP		ENTRY         
0198: E0F4                ;                   
0199: E0F4                ;   Routine to call the bdos and set the zero flag if a zero
0200: E0F4                ; status is returned.
0201: E0F4                ;                   
0202: E0F4                ENTRY2:             
0203: E0F4     CD0500     	CALL	ENTRY         
0204: E0F7     B7         	ORA		A		;set zero flag if appropriate.
0205: E0F8     C9         	RET                
0206: E0F9                ;                   
0207: E0F9                ;   Routine to read the next record from a sequential file.
0208: E0F9                ; (DE) points to the FCB.
0209: E0F9                ;                   
0210: E0F9                RDREC:              
0211: E0F9     0E14       	MVI		C,20          
0212: E0FB     C3F4E0     	JMP		ENTRY2        
0213: E0FE                ;                   
0214: E0FE                ;   Routine to read file at (FCB).
0215: E0FE                ;                   
0216: E0FE                READFCB:            
0217: E0FE     11A0E7     	LXI		D,FCB         
0218: E101     C3F9E0     	JMP		RDREC         
0219: E104                ;                   
0220: E104                ;   Routine to write the next record of a sequential file.
0221: E104                ; (DE) points to the FCB.
0222: E104                ;                   
0223: E104                WRTREC:             
0224: E104     0E15       	MVI		C,21          
0225: E106     C3F4E0     	JMP		ENTRY2        
0226: E109                ;                   
0227: E109                ;   Routine to create the file pointed to by (DE).
0228: E109                ;                   
0229: E109                CREATE:             
0230: E109     0E16       	MVI		C,22          
0231: E10B     C3C3E0     	JMP		ENTRY1        
0232: E10E                ;                   
0233: E10E                ;   Routine to rename the file pointed to by (DE). Note that
0234: E10E                ; the new name starts at (DE+16).
0235: E10E                ;                   
0236: E10E                RENAM:              
0237: E10E     0E17       	MVI		C,23          
0238: E110     C30500     	JMP		ENTRY         
0239: E113                ;                   
0240: E113                ;   Get the current user code.
0241: E113                ;                   
0242: E113                GETUSR:             
0243: E113     1EFF       	MVI		E,0FFH			; make it get
0244: E115                ;                   
0245: E115                ;   Routine to get or set the current user code.
0246: E115                ; If (E) is FF then this is a GET, else it is a SET.
0247: E115                ;                   
0248: E115                GETSETUC:           
0249: E115     0E20       	MVI		C,32			; BDOS vector
0250: E117     C30500     	JMP		ENTRY         
0251: E11A                ;                   
0252: E11A                ;   Routine to set the current drive byte at (TDRIVE).
0253: E11A                ;                   
0254: E11A                SETCDRV:            
0255: E11A     CD13E1     	CALL	GETUSR			;get user number
0256: E11D     87         	ADD		A				;and shift into the upper 4 bits.
0257: E11E     87         	ADD		A             
0258: E11F     87         	ADD		A             
0259: E120     87         	ADD		A             
0260: E121     21C2E7     	LXI		H,CDRIVE		;now add in the current drive number.
0261: E124     B6         	ORA		M             
0262: E125     320400     	STA		TDRIVE			;and save.
0263: E128     C9         	RET                
0264: E129                ;                   
0265: E129                ;   Move currently active drive down to (TDRIVE).
0266: E129                ;                   
0267: E129                MOVECD:             
0268: E129     3AC2E7     	LDA		CDRIVE        
0269: E12C     320400     	STA		TDRIVE        
0270: E12F     C9         	RET                
0271: E130                ;                   
0272: E130                ;   Routine to convert (A) into upper case ascii. Only letters
0273: E130                ; are affected.     
0274: E130                ;                   
0275: E130                UPPER:              
0276: E130     FE61       	CPI		061H			; 'a'	;check for letters in the range of 'a' to 'z'.
0277: E132     D8         	RC                 
0278: E133     FE7B       	CPI		BRACKETLEFT		;'{'
0279: E135     D0         	RNC                
0280: E136     E65F       	ANI		5FH				;convert it if found.
0281: E138     C9         	RET                
0282: E139                ;                   
0283: E139                ;   Routine to get a line of input. We must check to see if the
0284: E139                ; user is in (BATCH) mode. If so, then read the input from file
0285: E139                ; ($$$.SUB). At the end, reset to console input.
0286: E139                ;                   
0287: E139                GETINP:             
0288: E139     3A7EE7     	LDA		BATCH			;if =0, then use console input.
0289: E13C     B7         	ORA		A             
0290: E13D     CA96E1     	JZ		GETINP1        
0291: E140                ;                   
0292: E140                ;   Use the submit file ($$$.sub) which is prepared by a
0293: E140                ; SUBMIT run. It must be on drive (A) and it will be deleted
0294: E140                ; if and error occures (like eof).
0295: E140                ;                   
0296: E140     3AC2E7     	LDA		CDRIVE		;select drive 0 if need be.
0297: E143     B7         	ORA		A             
0298: E144     3E00       	MVI		A,0			;always use drive A for submit.
0299: E146     C4BDE0     	CNZ		DSKSEL		;select it if required.
0300: E149     117FE7     	LXI		D,BATCHFCB    
0301: E14C     CDCBE0     	CALL	OPEN		;look for it.
0302: E14F     CA96E1     	JZ		GETINP1		;if not there, use normal input.
0303: E152     3A8EE7     	LDA		BATCHFCB+15	;get last record number+1.
0304: E155     3D         	DCR		A             
0305: E156     329FE7     	STA		BATCHFCB+32   
0306: E159     117FE7     	LXI		D,BATCHFCB    
0307: E15C     CDF9E0     	CALL	RDREC		;read last record.
0308: E15F     C296E1     	JNZ		GETINP1		;quit on end of file.
0309: E162                ;                   
0310: E162                ;   Move this record into input buffer.
0311: E162                ;                   
0312: E162     1107E0     	LXI		D,INBUFF+1    
0313: E165     218000     	LXI		H,Pg0Buffer	;data was read into buffer here.
0314: E168     0680       	MVI		B,128		;all 128 characters may be used.
0315: E16A     CD18E4     	CALL	HL2DE		;(HL) to (DE), (B) bytes.
0316: E16D     218DE7     	LXI		H,BATCHFCB+14 
0317: E170     3600       	MVI		M,0			;zero out the 's2' byte.
0318: E172     23         	INX		H			;and decrement the record count.
0319: E173     35         	DCR		M             
0320: E174     117FE7     	LXI		D,BATCHFCB	;close the batch file now.
0321: E177     CDDAE0     	CALL	CLOSE         
0322: E17A     CA96E1     	JZ		GETINP1		;quit on an error.
0323: E17D     3AC2E7     	LDA		CDRIVE		;re-select previous drive if need be.
0324: E180     B7         	ORA		A             
0325: E181     C4BDE0     	CNZ		DSKSEL		;don't do needless selects.
0326: E184                ;                   
0327: E184                ;   Print line just read on console.
0328: E184                ;                   
0329: E184     2108E0     	LXI		H,INBUFF+2    
0330: E187     CDACE0     	CALL	PLINE2        
0331: E18A     CDC2E1     	CALL	CHKCON		;check console, quit on a key.
0332: E18D     CAA7E1     	JZ		GETINP2		;jump if no key is pressed.
0333: E190                ;                   
0334: E190                ;   Terminate the submit job on any keyboard input. Delete this
0335: E190                ; file such that it is not re-started and jump to normal keyboard
0336: E190                ; input section.    
0337: E190                ;                   
0338: E190     CDDDE1     	CALL	DELBATCH	;delete the batch file.
0339: E193     C358E3     	JMP		CMMND1		;and restart command input.
0340: E196                ;                   
0341: E196                ;   Get here for normal keyboard input. Delete the submit file
0342: E196                ; incase there was one.
0343: E196                ;                   
0344: E196                GETINP1:            
0345: E196     CDDDE1     	CALL	DELBATCH	;delete file ($$$.sub).
0346: E199     CD1AE1     	CALL	SETCDRV		;reset active disk.
0347: E19C     0E0A       	MVI		C,10		;get line from console device.
0348: E19E     1106E0     	LXI		D,INBUFF      
0349: E1A1     CD0500     	CALL	ENTRY         
0350: E1A4     CD29E1     	CALL	MOVECD		;reset current drive (again).
0351: E1A7                ;                   
0352: E1A7                ;   Convert input line to upper case.
0353: E1A7                ;                   
0354: E1A7                GETINP2:            
0355: E1A7     2107E0     	LXI		H,INBUFF+1    
0356: E1AA     46         	MOV		B,M			;(B)=character counter.
0357: E1AB                GETINP3:            
0358: E1AB     23         	INX		H             
0359: E1AC     78         	MOV		A,B			;end of the line?
0360: E1AD     B7         	ORA		A             
0361: E1AE     CABAE1     	JZ		GETINP4        
0362: E1B1     7E         	MOV		A,M			;convert to upper case.
0363: E1B2     CD30E1     	CALL	UPPER         
0364: E1B5     77         	MOV		M,A           
0365: E1B6     05         	DCR		B			;adjust character count.
0366: E1B7     C3ABE1     	JMP		GETINP3       
0367: E1BA                GETINP4:            
0368: E1BA     77         	MOV		M,A			;add trailing null.
0369: E1BB     2108E0     	LXI		H,INBUFF+2    
0370: E1BE     2288E0     	SHLD	INPOINT		;reset input line pointer.
0371: E1C1     C9         	RET                
0372: E1C2                ;                   
0373: E1C2                ;   Routine to check the console for a key pressed. The zero
0374: E1C2                ; flag is set is none, else the character is returned in (A).
0375: E1C2                ;                   
0376: E1C2                CHKCON:             
0377: E1C2     0E0B       	MVI		C,11		;check console.
0378: E1C4     CD0500     	CALL	ENTRY         
0379: E1C7     B7         	ORA		A             
0380: E1C8     C8         	RZ					;return if nothing.
0381: E1C9     0E01       	MVI		C,1			;else get character.
0382: E1CB     CD0500     	CALL	ENTRY         
0383: E1CE     B7         	ORA		A			;clear zero flag and return.
0384: E1CF     C9         	RET                
0385: E1D0                ;                   
0386: E1D0                ;   Routine to get the currently active drive number.
0387: E1D0                ;                   
0388: E1D0                GETDSK:             
0389: E1D0     0E19       	MVI		C,25          
0390: E1D2     C30500     	JMP		ENTRY         
0391: E1D5                ;                   
0392: E1D5                ;   Set the stabdard dma address.
0393: E1D5                ;                   
0394: E1D5                STDDMA:             
0395: E1D5     118000     	LXI		D,Pg0Buffer   
0396: E1D8                ;                   
0397: E1D8                ;   Routine to set the dma address to (DE).
0398: E1D8                ;                   
0399: E1D8                DMASET:             
0400: E1D8     0E1A       	MVI		C,26          
0401: E1DA     C30500     	JMP		ENTRY         
0402: E1DD                ;                   
0403: E1DD                ;  Delete the batch file created by SUBMIT.
0404: E1DD                ;                   
0405: E1DD                DELBATCH:           
0406: E1DD     217EE7     	LXI		H,BATCH			;is batch active?
0407: E1E0     7E         	MOV		A,M           
0408: E1E1     B7         	ORA		A             
0409: E1E2     C8         	RZ                 
0410: E1E3     3600       	MVI		M,0				;yes, de-activate it.
0411: E1E5     AF         	XRA		A             
0412: E1E6     CDBDE0     	CALL	DSKSEL			;select drive 0 for sure.
0413: E1E9     117FE7     	LXI		D,BATCHFCB		;and delete this file.
0414: E1EC     CDEFE0     	CALL	DELETE        
0415: E1EF     3AC2E7     	LDA		CDRIVE			;reset current drive.
0416: E1F2     C3BDE0     	JMP		DSKSEL        
0417: E1F5                ;                   
0418: E1F5                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0419: E1F5                ; the same or we halt....
0420: E1F5                ;                   
0421: E1F5                ;VERIFY:            
0422: E1F5                ;	LXI		D,PATTRN1		;these are the serial number bytes.
0423: E1F5                ;	LXI		H,PATTRN2		;ditto, but how could they be different?
0424: E1F5                ;	MVI		B,6				;6 bytes each.
0425: E1F5                ;VERIFY1:           
0426: E1F5                ;	LDAX	D            
0427: E1F5                ;	CMP		M            
0428: E1F5                ;	JNZ		HALT			;jump to halt routine.
0429: E1F5                ;	INX		D            
0430: E1F5                ;	INX		H            
0431: E1F5                ;	DCR		B            
0432: E1F5                ;	JNZ		VERIFY1      
0433: E1F5                ;	RET               
0434: E1F5                ;                   
0435: E1F5                ;   Print back file name with a '?' to indicate a syntax error.
0436: E1F5                ;                   
0437: E1F5                SYNERR:             
0438: E1F5     CD98E0     	CALL	CRLF	;end current line.
0439: E1F8     2A8AE0     	LHLD	NAMEPNT	;this points to name in error.
0440: E1FB                SYNERR1:            
0441: E1FB     7E         	MOV	A,M	;print it until a space or null is found.
0442: E1FC     FE20       	CPI	BLANK		; Space 
0443: E1FE     CA0EE2     	JZ	SYNERR2         
0444: E201     B7         	ORA	A              
0445: E202     CA0EE2     	JZ	SYNERR2         
0446: E205     E5         	PUSH	H             
0447: E206     CD8CE0     	CALL	PRINT         
0448: E209     E1         	POP	H              
0449: E20A     23         	INX	H              
0450: E20B     C3FBE1     	JMP	SYNERR1        
0451: E20E                SYNERR2:            
0452: E20E     3E3F       	MVI	A,QMARK		;add trailing '?'.
0453: E210     CD8CE0     	CALL	PRINT         
0454: E213     CD98E0     	CALL	CRLF          
0455: E216     CDDDE1     	CALL	DELBATCH;delete any batch file.
0456: E219     C358E3     	JMP	CMMND1	;and restart from console input.
0457: E21C                ;                   
0458: E21C                ;   Check character at (DE) for legal command input. Note that the
0459: E21C                ; zero flag is set if the character is a delimiter.
0460: E21C                ;                   
0461: E21C                CHECK:              
0462: E21C     1A         	LDAX	D			; Grab the character
0463: E21D     B7         	ORA		A             
0464: E21E     C8         	RZ					; Exit, its a Null (00)
0465: E21F                	                   
0466: E21F     FE20       	CPI		BLANK		; Is  less than 020H - controls character
0467: E221     DAF5E1     	JC		SYNERR		; Yes,  Syntax error - exit CCP
0468: E224     C8         	RZ					; Exit because Space is valid delimiter.
0469: E225                	                   
0470: E225     FE3D       	CPI	EQUALS			; '=' 
0471: E227     C8         	RZ                 
0472: E228     FE5F       	CPI	USCORE			; '_' 
0473: E22A     C8         	RZ                 
0474: E22B     FE2E       	CPI	PERIOD			; '.' 
0475: E22D     C8         	RZ                 
0476: E22E     FE3A       	CPI	COLON			; ':'  
0477: E230     C8         	RZ                 
0478: E231     FE3B       	CPI	SEMIC			; ';'  
0479: E233     C8         	RZ                 
0480: E234     FE3C       	CPI	LESSTH			; '<' 
0481: E236     C8         	RZ                 
0482: E237     FE3E       	CPI	GRTTHAN			; '>'
0483: E239     C8         	RZ                 
0484: E23A     C9         	RET					; Character is legal, but not a delimiter
0485: E23B                ;                   
0486: E23B                ;   Get the next non-blank character from (DE).
0487: E23B                ;                   
0488: E23B                NONBLANK:           
0489: E23B     1A         	LDAX	D			; get the next character
0490: E23C     B7         	ORA		A			;Since string ends with a null.
0491: E23D     C8         	RZ					; we return here if its 00
0492: E23E     FE20       	CPI		BLANK		; Is it a space?
0493: E240     C0         	RNZ					; No, then we have the next non-space char
0494: E241                	                   
0495: E241     13         	INX		D			; since it a space we need to look at the next character
0496: E242     C33BE2     	JMP		NONBLANK      
0497: E245                ;                   
0498: E245                ;   Add (HL)=(HL)+(A)
0499: E245                ;                   
0500: E245                ADDHL:              
0501: E245     85         	ADD		L             
0502: E246     6F         	MOV		L,A           
0503: E247     D0         	RNC					;take care of any carry.
0504: E248     24         	INR		H             
0505: E249     C9         	RET                
0506: E24A                ;                   
0507: E24A                ;   Convert the first name in (FCB).
0508: E24A                ;                   
0509: E24A                CONVFST:            
0510: E24A     3E00       	MVI	A,0		; set up index for first filename
0511: E24C                ;                   
0512: E24C                ;   Format a file name (convert * to '?', etc.). On return,
0513: E24C                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0514: E24C                ; the position within the fcb for the name (either 0 or 16).
0515: E24C                ;                   
0516: E24C                CONVERT:            
0517: E24C     21A0E7     	LXI		H,FCB		; point at FCB setup by CCP
0518: E24F     CD45E2     	CALL	ADDHL		; now pointing at correct FCB
0519: E252     E5         	PUSH	H			; save    
0520: E253     E5         	PUSH	H             
0521: E254     AF         	XRA		A             
0522: E255     32C3E7     	STA		CHGDRV		; initialize drive change flag - no change.
0523: E258     2A88E0     	LHLD	INPOINT		; set (HL) as pointer into input line.
0524: E25B     EB         	XCHG				; put line pointer in DE for call
0525: E25C     CD3BE2     	CALL	NONBLANK	; return the next non-blank character in A
0526: E25F     EB         	XCHG				; put line buffer pointer in HL for now
0527: E260     228AE0     	SHLD	NAMEPNT		; save pointer here for any error message.
0528: E263     EB         	XCHG				; put line buffer pointer back in DE
0529: E264     E1         	POP		H			; retreive the CCP created FCB
0530: E265     1A         	LDAX	D			; get first character.
0531: E266     B7         	ORA		A			; is it a null 00 ?
0532: E267     CA75E2     	JZ		CONVRT1		; Yes, this FCB is empty (no argument)
0533: E26A                	                   
0534: E26A     DE40       	SBI		040H		; 'A'-1	;might be a drive name, convert to binary.
0535: E26C     47         	MOV		B,A			; and save in case its a drive specifier.
0536: E26D     13         	INX		D			; get the next character 
0537: E26E     1A         	LDAX	D             
0538: E26F     FE3A       	CPI		COLON		; is it ':'
0539: E271     CA7CE2     	JZ		CONVRT2		; Yes, then we have a drive specification
0540: E274     1B         	DCX		D			; No, move pointer back to the start of the line.
0541: E275                CONVRT1:            
0542: E275     3AC2E7     	LDA		CDRIVE		; get current drive
0543: E278     77         	MOV		M,A			; put into the CCP FCB
0544: E279     C382E2     	JMP		CONVRT3       
0545: E27C                CONVRT2:            
0546: E27C     78         	MOV		A,B			; get the saved drive number
0547: E27D     32C3E7     	STA		CHGDRV		; set change in drives flag.
0548: E280     70         	MOV		M,B			; put new drive number in FCB
0549: E281     13         	INX		D			; point past drive number
0550: E282                ;                   
0551: E282                ;   Convert the basic file name.
0552: E282                ;                   
0553: E282                CONVRT3:            
0554: E282     0608       	MVI		B,08H		; File name size
0555: E284                CONVRT4:            
0556: E284     CDCCE2     	CALL	DECODENAME	; Expand all 8 characters in name
0557: E287                ;	CALL	CHECK		; Legal input character ?
0558: E287                ;	JZ		PADNAME		; its a delimiter, skip the rest of the filename
0559: E287                ;	INX		H            
0560: E287                ;	CPI		ASTRK		; '*'	;note that an '*' will fill the remaining
0561: E287                ;	JNZ		CONVRT5		; otherwise move to the next character and process.
0562: E287                ;	                  
0563: E287                ;	MVI		M,QMARK		; '?'
0564: E287                ;	JMP		CONVRT6      
0565: E287                ;CONVRT5:				; move on to the next character
0566: E287                ;	MOV		M,A			; put character in FCB
0567: E287                ;	INX		D			; move to next character in input line buffer
0568: E287                ;CONVRT6:           
0569: E287                ;	DCR		B			; decrement counter
0570: E287                ;	JNZ		CONVRT4		; loop if not done with fileName
0571: E287                CONVRT7:            
0572: E287     CD1CE2     	CALL	CHECK		; Do we have a delimiter ?.
0573: E28A     CA91E2     	JZ		GETEXT		; Yes, process the extension
0574: E28D     13         	INX		D			; No, point a the next character
0575: E28E     C387E2     	JMP		CONVRT7		; and see if its a demiliter
0576: E291                ;PADNAME:           
0577: E291                ;	INX		H			; blank fill the remaining file name.
0578: E291                ;	MVI		M,BLANK		; store the blank
0579: E291                ;	DCR		B			; keep count
0580: E291                ;	JNZ		PADNAME		; loop till done
0581: E291                ;                   
0582: E291                ;   Get the extension and convert it.
0583: E291                ;                   
0584: E291                GETEXT:             
0585: E291     0603       	MVI		B,03H		; file extension size
0586: E293     FE2E       	CPI		PERIOD		; do we have the Period '.'
0587: E295                ;	JNZ		PADEXT		; No, Pad fill the extension
0588: E295     CA9EE2     	JZ		GETEXT1		; yes, process the extension
0589: E298     CDE4E2     	CALL	PADFIELD	; No, Pad fill the extension
0590: E29B     C3ACE2     	JMP		CLEAREXTENT	; process the stuff after the extension
0591: E29E                GETEXT1:            
0592: E29E     13         	INX		D			; get past the period
0593: E29F                :                   
0594: E29F     CDCCE2     	CALL	DECODENAME	; Expand all 3 characters in extension
0595: E2A2                ;	CALL	CHECK		; Legal input character ?		
0596: E2A2                ;	JZ		PADEXT		; its a delimiter, so pad the rest of the extension
0597: E2A2                ;	INX		H			; point at next spot in the CCP FCB
0598: E2A2                ;	CPI		ASTRK		; ; '*'	;note that an '*' will fill the remaining
0599: E2A2                ;	JNZ		GETEXT2		; otherwise move to the next character and process.
0600: E2A2                ;	                  
0601: E2A2                ;	MVI		M,QMARK		;'?'
0602: E2A2                ;	JMP		GETEXT3      
0603: E2A2                ;GETEXT2:				; move on to the next character
0604: E2A2                ;	MOV		M,A			; put character in FCB
0605: E2A2                ;	INX		D			; move to next character in input line buffer
0606: E2A2                ;GETEXT3:           
0607: E2A2                ;	DCR		B			; decrement counter
0608: E2A2                ;	JNZ		GETEXT1		; loop if not done with file extension
0609: E2A2                GETEXT4:            
0610: E2A2     CD1CE2     	CALL	CHECK		; Do we have a delimiter ?.
0611: E2A5     CAACE2     	JZ		CLEAREXTENT	; Yes, Clear the EX, S1 & S2
0612: E2A8     13         	INX		D			; No, point a the next character
0613: E2A9     C3A2E2     	JMP		GETEXT4		; and see if its a demiliter
0614: E2AC                	                   
0615: E2AC                ;PADEXT:            
0616: E2AC                ;	INX		H			; blank fill the remaining extension.
0617: E2AC                ;	MVI		M,BLANK		; store the blank
0618: E2AC                ;	DCR		B			; keep count
0619: E2AC                ;	JNZ		PADEXT		; loop till done
0620: E2AC                	                   
0621: E2AC                CLEAREXTENT:        
0622: E2AC     0603       	MVI		B,03H		; set count for clearing EX, S1 & S2
0623: E2AE                CLEAREXTENT1:       
0624: E2AE     23         	INX		H			; point at location in the CCP FCB
0625: E2AF     3600       	MVI		M,0			; initialize it
0626: E2B1     05         	DCR		B			; keep count
0627: E2B2     C2AEE2     	JNZ		CLEAREXTENT1	; loop til done
0628: E2B5     EB         	XCHG               
0629: E2B6     2288E0     	SHLD	INPOINT		; save current input line pointer.
0630: E2B9     E1         	POP		H			; point at correct CCP FCB
0631: E2BA                ;                   
0632: E2BA                ;   Check to see if this is an ambigeous file name specification.
0633: E2BA                ; Set the (A) register to non zero if it is.
0634: E2BA                ;                   
0635: E2BA                ;AFN - Ambiguous File Name
0636: E2BA     010B00     	LXI		B,11		; set name & Extension length .
0637: E2BD                AFN:                
0638: E2BD     23         	INX		H             
0639: E2BE     7E         	MOV		A,M           
0640: E2BF     FE3F       	CPI		QMARK		; '?'	;any question marks?
0641: E2C1     C2C5E2     	JNZ		AFN1          
0642: E2C4     04         	INR		B			; increment count
0643: E2C5                AFN1:               
0644: E2C5     0D         	DCR		C             
0645: E2C6     C2BDE2     	JNZ		AFN			; loop if not done
0646: E2C9     78         	MOV		A,B			; B has the question mark count 
0647: E2CA     B7         	ORA		A			; set the Z flag for calling routine
0648: E2CB     C9         	RET                
0649: E2CC                	                   
0650: E2CC                ;                   
0651: E2CC                ; DECODENAME -	expands the name/ext to all 8/3 characters by either padding with SPACES
0652: E2CC                ;				or, replaceing *'s with ?s for the remainder of the name/ext
0653: E2CC                ;                   
0654: E2CC                DECODENAME:         
0655: E2CC     CD1CE2     	CALL	CHECK		; Legal input character ?
0656: E2CF     CAE4E2     	JZ		PADFIELD	; its a delimiter, skip the rest of the name/ext 
0657: E2D2     23         	INX		HL            
0658: E2D3     FE2A       	CPI		ASTRK		; '*'	;note that an '*' will fill the remaining
0659: E2D5     C2DDE2     	JNZ		DECODENAME1	; otherwise move to the next character and process.
0660: E2D8     363F       	MVI		M,QMARK		; '?'
0661: E2DA     C3DFE2     	JMP		DECODENAME2   
0662: E2DD                DECODENAME1:        
0663: E2DD     77         	MOV		M,A			; put character in FCB
0664: E2DE     13         	INX		D			; move to next character in input line buffer
0665: E2DF                DECODENAME2:        
0666: E2DF     05         	DCR		B			; decrement counter
0667: E2E0     C2CCE2     	JNZ		DECODENAME	; loop if not done with fileName
0668: E2E3     C9         	RET					; exit when done!
0669: E2E4                	                   
0670: E2E4                PADFIELD:            
0671: E2E4     23         	INX		H			; blank fill the remaining file name.
0672: E2E5     3620       	MVI		M,BLANK		; store the blank
0673: E2E7     05         	DCR		B			; keep count
0674: E2E8     C2E4E2     	JNZ		PADFIELD		; loop till done
0675: E2EB     C9         	RET					; exit when done!
0676: E2EC                		                  
0677: E2EC                ;                   
0678: E2EC                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0679: E2EC                ;                   
0680: E2EC                NUMCMDS	EQU	6	;number of commands
0681: E2EC                CMDTBL:             
0682: E2EC     44495220   	DB	'DIR '		; 0     
0683: E2F0     45524120   	DB	'ERA '		; 1     
0684: E2F4     54595045   	DB	'TYPE'		; 2     
0685: E2F8     53415645   	DB	'SAVE'		; 3     
0686: E2FC     52454E20   	DB	'REN '		; 4     
0687: E300     55534552   	DB	'USER'		; 5     
0688: E304                	;Unknown		; 6      
0689: E304                ;                   
0690: E304                ;   The following six bytes must agree with those at (PATTRN2)
0691: E304                ; or cp/m will HALT. Why?
0692: E304                ;                   
0693: E304                ;PATTRN1:           
0694: E304                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
0695: E304                ;                   
0696: E304                ;   Search the command table for a match with what has just
0697: E304                ; been entered. If a match is found, then we jump to the
0698: E304                ; proper section. Else jump to (UNKNOWN).
0699: E304                ; On return, the (C) register is set to the command number
0700: E304                ; that matched (or NUMCMDS+1 if no match).
0701: E304                ;                   
0702: E304                SEARCH:             
0703: E304     21ECE2     	LXI	H,CMDTBL       
0704: E307     0E00       	MVI	C,0            
0705: E309                SEARCH1:            
0706: E309     79         	MOV	A,C            
0707: E30A     FE06       	CPI	NUMCMDS	;this commands exists.
0708: E30C     D0         	RNC                
0709: E30D     11A1E7     	LXI	D,FCB+1	;check this one.
0710: E310     0604       	MVI	B,4	;max command length.
0711: E312                SEARCH2:            
0712: E312     1A         	LDAX	D             
0713: E313     BE         	CMP	M              
0714: E314     C225E3     	JNZ	SEARCH3	;not a match.
0715: E317     13         	INX	D              
0716: E318     23         	INX	H              
0717: E319     05         	DCR	B              
0718: E31A     C212E3     	JNZ	SEARCH2        
0719: E31D     1A         	LDAX	D	;allow a 3 character command to match.
0720: E31E     FE20       	CPI	BLANK          
0721: E320     C22AE3     	JNZ	SEARCH4        
0722: E323     79         	MOV	A,C	;set return register for this command.
0723: E324     C9         	RET                
0724: E325                SEARCH3:            
0725: E325     23         	INX	H              
0726: E326     05         	DCR	B              
0727: E327     C225E3     	JNZ	SEARCH3        
0728: E32A                SEARCH4:            
0729: E32A     0C         	INR	C              
0730: E32B     C309E3     	JMP	SEARCH1        
0731: E32E                ;                   
0732: E32E                ;   Set the input buffer to empty and then start the command
0733: E32E                ; processor (ccp).  
0734: E32E                ;                   
0735: E32E                CLEARBUF:           
0736: E32E     AF         XRA	A               
0737: E32F     3207E0     	STA	INBUFF+1;second byte is actual length.
0738: E332                ;                   
0739: E332                ;**************************************************************
0740: E332                ;*                  
0741: E332                ;*                  
0742: E332                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0743: E332                ;*                  
0744: E332                ;                   
0745: E332                ;   On entry (C) points at Current disk & user (defaultDisk 0004)
0746: E332                ;**************************************************************
0747: E332                ;*                  
0748: E332                COMMAND:            
0749: E332     317EE7     	LXI			SP,CCPStack				; Use dedicated stack space.
0750: E335     C5         	PUSH		B						; (C) should be equal to currentDisk where:
0751: E336     79         	MOV			A,C						; (uuuudddd) where 'uuuu' is the user number
0752: E337     1F         	RAR									; and 'dddd' is the drive number.
0753: E338     1F         	RAR                
0754: E339     1F         	RAR                
0755: E33A     1F         	RAR                
0756: E33B     E60F       	ANI			0FH						; isolate the user number.
0757: E33D     5F         	MOV			E,A						; put into E for call
0758: E33E     CD15E1     	CALL	GETSETUC					; to the current user
0759: E341     CDB8E0     	CALL	RESDSK						;reset the disk system.
0760: E344     327EE7     	STA	BATCH	;clear batch mode flag.
0761: E347     C1         	POP	B              
0762: E348     79         	MOV	A,C            
0763: E349     E60F       	ANI	0FH	;isolate the drive number.
0764: E34B     32C2E7     	STA	CDRIVE	;and save.
0765: E34E     CDBDE0     	CALL	DSKSEL	;...and select.
0766: E351     3A07E0     	LDA	INBUFF+1       
0767: E354     B7         	ORA	A	;anything in input buffer already?
0768: E355     C26EE3     	JNZ	CMMND2	;yes, we just process it.
0769: E358                ;                   
0770: E358                ;   Entry point to get a command line from the console.
0771: E358                ;                   
0772: E358                CMMND1:             
0773: E358     317EE7     	LXI	SP,CCPStack;set stack straight.
0774: E35B     CD98E0     	CALL	CRLF	;start a new line on the screen.
0775: E35E     CDD0E1     	CALL	GETDSK	;get current drive.
0776: E361     C661       	ADI	061H		; 'a'    
0777: E363     CD8CE0     	CALL	PRINT	;print current drive.
0778: E366     3E3E       	MVI	A,GRTTHAN	; '>'
0779: E368     CD8CE0     	CALL	PRINT	;and add prompt.
0780: E36B     CD39E1     	CALL	GETINP	;get line from user.
0781: E36E                ;                   
0782: E36E                ;   Process command line here.
0783: E36E                ;                   
0784: E36E                CMMND2:             
0785: E36E     118000     	LXI	D,Pg0Buffer    
0786: E371     CDD8E1     	CALL	DMASET	;set standard dma address.
0787: E374     CDD0E1     	CALL	GETDSK        
0788: E377     32C2E7     	STA	CDRIVE	;set current drive.
0789: E37A     CD4AE2     	CALL	CONVFST	;convert name typed in.
0790: E37D     C4F5E1     	CNZ	SYNERR	;wild cards are not allowed.
0791: E380     3AC3E7     	LDA	CHGDRV	;if a change in drives was indicated,
0792: E383     B7         	ORA	A	;then treat this as an unknown command
0793: E384     C27BE6     	JNZ	UNKNOWN	;which gets executed.
0794: E387     CD04E3     	CALL	SEARCH	;else search command table for a match.
0795: E38A                ;                   
0796: E38A                ;   Note that an unknown command returns
0797: E38A                ; with (A) pointing to the last address
0798: E38A                ; in our table which is (UNKNOWN).
0799: E38A                ;                   
0800: E38A     2197E3     	LXI	H,CMDADR;now, look thru our address table for command (A).
0801: E38D     5F         	MOV	E,A	;set (DE) to command number.
0802: E38E     1600       	MVI	D,0            
0803: E390     19         	DAD	D              
0804: E391     19         	DAD	D	;(HL)=(CMDADR)+2*(command number).
0805: E392     7E         	MOV	A,M	;now pick out this address.
0806: E393     23         	INX	H              
0807: E394     66         	MOV	H,M            
0808: E395     6F         	MOV	L,A            
0809: E396     E9         	PCHL		;now execute it.
0810: E397                ;                   
0811: E397                ;   CP/M command address table.
0812: E397                ;                   
0813: E397                CMDADR:             
0814: E397     4DE4       	DW	DIRECT		; 0     
0815: E399     F5E4       	DW	ERASE		; 1      
0816: E39B     33E5       	DW	TYPE		; 2       
0817: E39D     83E5       	DW	SAVE		; 3       
0818: E39F     E6E5       	DW	RENAME		; 4     
0819: E3A1     64E6       	DW	USER		; 5       
0820: E3A3     7BE6       	DW	UNKNOWN		; 6    
0821: E3A5                ;                   
0822: E3A5                ;   Halt the system. Reason for this is unknown at present.
0823: E3A5                ;                   
0824: E3A5                HALT:               
0825: E3A5     21F376     	LXI	H,76F3H	;'DI HLT' instructions.
0826: E3A8     2200E0     	SHLD	CBASE         
0827: E3AB     2100E0     	LXI	H,CBASE        
0828: E3AE     E9         	PCHL               
0829: E3AF                ;                   
0830: E3AF                ;   Read error while TYPEing a file.
0831: E3AF                ;                   
0832: E3AF                RDERROR:            
0833: E3AF     01B5E3     	LXI	B,RDERR        
0834: E3B2     C3A7E0     	JMP	PLINE          
0835: E3B5                RDERR:              
0836: E3B5     52454144204552524F5200 	DB	'Read error',0  
0837: E3C0                ;                   
0838: E3C0                ;   Required file was not located.
0839: E3C0                ;                   
0840: E3C0                                    
0841: E3C0                NONE:               
0842: E3C0     01C6E3     	LXI	B,NOFILE       
0843: E3C3     C3A7E0     	JMP	PLINE          
0844: E3C6                NOFILE:             
0845: E3C6     4E4F2046494C4500 	DB	'No file',0     
0846: E3CE                ;                   
0847: E3CE                ;   Decode a command of the form 'A>filename number{ filename}.
0848: E3CE                ; Note that a drive specifier is not allowed on the first file
0849: E3CE                ; name. On return, the number is in register (A). Any error
0850: E3CE                ; causes 'filename?' to be printed and the command is aborted.
0851: E3CE                ;                   
0852: E3CE                DECODE:             
0853: E3CE     CD4AE2     	CALL	CONVFST		;convert first filename.
0854: E3D1     3AC3E7     	LDA		CHGDRV		;do not allow a drive to be specified.
0855: E3D4     B7         	ORA		A             
0856: E3D5     C2F5E1     	JNZ		SYNERR		; exit with a syntax error
0857: E3D8     21A1E7     	LXI		H,FCB+1		;convert number now.
0858: E3DB     010B00     	LXI		B,11		;(B)=sum register, (C)=max digit count.
0859: E3DE                DECODE1:            
0860: E3DE     7E         	MOV		A,M			; get the caracter from the CCP FCB
0861: E3DF     FE20       	CPI		BLANK		; a space terminates the numeral.
0862: E3E1     CA09E4     	JZ		PADNUMBER	; skip, the rest must be blanks
0863: E3E4     23         	INX		H			; bump pointer
0864: E3E5     D630       	SUI		030H  		; '0'	make binary from ascii. ZERO ????
0865: E3E7     FE0A       	CPI		10			; legal digit?
0866: E3E9     D2F5E1     	JNC		SYNERR		; exit with syntax error
0867: E3EC     57         	MOV		D,A			; yes, save the number in (D).
0868: E3ED                	;                  
0869: E3ED     78         	MOV		A,B			; compute (B)=(B)*10 and check for overflow.
0870: E3EE     E6E0       	ANI		0E0H          
0871: E3F0     C2F5E1     	JNZ		SYNERR		; Exit with math overflow error??
0872: E3F3     78         	MOV		A,B           
0873: E3F4     07         	RLC                
0874: E3F5     07         	RLC                
0875: E3F6     07         	RLC					;(A)=(B)*8 
0876: E3F7     80         	ADD		B			;.......*9
0877: E3F8     DAF5E1     	JC		SYNERR		; Exit with math overflow error??	
0878: E3FB     80         	ADD		B			;.......*10
0879: E3FC     DAF5E1     	JC		SYNERR		; Exit with math overflow error??
0880: E3FF     82         	ADD		D			;	add in new digit now.
0881: E400     DAF5E1     	JC		SYNERR		; Exit with math overflow error??
0882: E403     47         	MOV		B,A			;	and save result in B (subtotal)
0883: E404     0D         	DCR		C			;	only look at 11 digits.
0884: E405     C2DEE3     	JNZ		DECODE1       
0885: E408     C9         	RET					; return with value in (A)
0886: E409                PADNUMBER:          
0887: E409     7E         	MOV		A,M			; spaces must follow (why?).
0888: E40A     FE20       	CPI		BLANK		; is it a blank
0889: E40C     C2F5E1     	JNZ		SYNERR		; exit with syntax error
0890: E40F     23         	INX		H			; point at next
0891: E410     0D         	DCR		C             
0892: E411     C209E4     	JNZ		PADNUMBER	; loop till done
0893: E414     78         	MOV		A,B			;set (A)=the numeric value entered.
0894: E415     C9         	RET                
0895: E416                ;                   
0896: E416                ;   Move 3 bytes from (HL) to (DE). Note that there is only
0897: E416                ; one reference to this at (A2D5h).
0898: E416                ;                   
0899: E416                MOVE3:              
0900: E416     0603       	MVI	B,3            
0901: E418                ;                   
0902: E418                ;   Move (B) bytes from (HL) to (DE).
0903: E418                ;                   
0904: E418                HL2DE:              
0905: E418     7E         	MOV	A,M            
0906: E419     12         	STAX	D             
0907: E41A     23         	INX	H              
0908: E41B     13         	INX	D              
0909: E41C     05         	DCR	B              
0910: E41D     C218E4     	JNZ	HL2DE          
0911: E420     C9         	RET                
0912: E421                ;                   
0913: E421                ;   Compute (HL)=(Pg0Buffer)+(A)+(C) and get the byte that's here.
0914: E421                ;                   
0915: E421                EXTRACT:            
0916: E421     218000     	LXI	H,Pg0Buffer    
0917: E424     81         	ADD	C              
0918: E425     CD45E2     	CALL	ADDHL         
0919: E428     7E         	MOV	A,M            
0920: E429     C9         	RET                
0921: E42A                ;                   
0922: E42A                ;  Check drive specified. If it means a change, then the new
0923: E42A                ; drive will be selected. In any case, the drive byte of the
0924: E42A                ; fcb will be set to null (means use current drive).
0925: E42A                ;                   
0926: E42A                DSELECT:            
0927: E42A     AF         	XRA		A             
0928: E42B     32A0E7     	STA		FCB				; null out first byte of fcb.
0929: E42E     3AC3E7     	LDA		CHGDRV			; is a drive change indicated?
0930: E431     B7         	ORA		A             
0931: E432     C8         	RZ						; No, drive OK
0932: E433     3D         	DCR		A				; yes, is it the same as the current drive?
0933: E434     21C2E7     	LXI		H,CDRIVE      
0934: E437     BE         	CMP		M				; FCB drive number same as this?
0935: E438     C8         	RZ						; Yes, return 					
0936: E439     C3BDE0     	JMP		DSKSEL			;	no. Select it then.
0937: E43C                ;                   
0938: E43C                ;   Check the drive selection and reset it to the previous
0939: E43C                ; drive if it was changed for the preceeding command.
0940: E43C                ;                   
0941: E43C                RESETDR:            
0942: E43C     3AC3E7     	LDA	CHGDRV	;drive change indicated?
0943: E43F     B7         	ORA	A              
0944: E440     C8         	RZ                 
0945: E441     3D         	DCR	A	;yes, was it a different drive?
0946: E442     21C2E7     	LXI	H,CDRIVE       
0947: E445     BE         	CMP	M              
0948: E446     C8         	RZ                 
0949: E447     3AC2E7     	LDA	CDRIVE	;yes, re-select our old drive.
0950: E44A     C3BDE0     	JMP	DSKSEL         
0951: E44D                ;                   
0952: E44D                ;**************************************************************
0953: E44D                ;*                  
0954: E44D                ;*           D I R E C T O R Y   C O M M A N D
0955: E44D                ;*                  
0956: E44D                ;**************************************************************
0957: E44D                ;                   
0958: E44D                DIRECT:             
0959: E44D     CD4AE2     	CALL	CONVFST	;convert file name.
0960: E450     CD2AE4     	CALL	DSELECT	;select indicated drive.
0961: E453     21A1E7     	LXI	H,FCB+1	;was any file indicated?
0962: E456     7E         	MOV	A,M            
0963: E457     FE20       	CPI	BLANK          
0964: E459     C265E4     	JNZ	DIRECT2        
0965: E45C     060B       	MVI	B,11	;no. Fill field with '?' - same as *.*.
0966: E45E                DIRECT1:            
0967: E45E     363F       	MVI	M,QMARK		; '?' 
0968: E460     23         	INX	H              
0969: E461     05         	DCR	B              
0970: E462     C25EE4     	JNZ	DIRECT1        
0971: E465                DIRECT2:            
0972: E465     1E00       	MVI	E,0	;set initial cursor position.
0973: E467     D5         	PUSH	D             
0974: E468     CDE9E0     	CALL	SRCHFCB	;get first file name.
0975: E46B     CCC0E3     	CZ	NONE	;none found at all?
0976: E46E                DIRECT3:            
0977: E46E     CAF1E4     	JZ	DIRECT9	;terminate if no more names.
0978: E471     3AC1E7     	LDA	RTNCODE	;get file's position in segment (0-3).
0979: E474     0F         	RRC                
0980: E475     0F         	RRC                
0981: E476     0F         	RRC                
0982: E477     E660       	ANI	60H	;(A)=position*32
0983: E479     4F         	MOV	C,A            
0984: E47A     3E0A       	MVI	A,10           
0985: E47C     CD21E4     	CALL	EXTRACT	;extract the tenth entry in fcb.
0986: E47F     17         	RAL		;check system file status bit.
0987: E480     DAE5E4     	JC	DIRECT8	;we don't list them.
0988: E483     D1         	POP	D              
0989: E484     7B         	MOV	A,E	;bump name count.
0990: E485     1C         	INR	E              
0991: E486     D5         	PUSH	D             
0992: E487     E603       	ANI	03H	;at end of line?
0993: E489     F5         	PUSH	PSW           
0994: E48A     C2A2E4     	JNZ	DIRECT4        
0995: E48D     CD98E0     	CALL	CRLF	;yes, end this line and start another.
0996: E490     C5         	PUSH	B             
0997: E491     CDD0E1     	CALL	GETDSK	;start line with ('A:').
0998: E494     C1         	POP	B              
0999: E495     C641       	ADI	041H	; 'A'     
1000: E497     CD92E0     	CALL	PRINTB        
1001: E49A     3E3A       	MVI	A, COLON		; ':'
1002: E49C     CD92E0     	CALL	PRINTB        
1003: E49F     C3AAE4     	JMP	DIRECT5        
1004: E4A2                DIRECT4:            
1005: E4A2     CDA2E0     	CALL	SPACE	;add seperator between file names.
1006: E4A5     3E3A       	MVI	A, COLON	;':'  
1007: E4A7     CD92E0     	CALL	PRINTB        
1008: E4AA                DIRECT5:            
1009: E4AA     CDA2E0     	CALL	SPACE         
1010: E4AD     0601       	MVI	B,1	;'extract' each file name character at a time.
1011: E4AF                DIRECT6:            
1012: E4AF     78         	MOV	A,B            
1013: E4B0     CD21E4     	CALL	EXTRACT       
1014: E4B3     E67F       	ANI	7FH	;strip bit 7 (status bit).
1015: E4B5     FE20       	CPI	BLANK	;are we at the end of the name?
1016: E4B7     C2CFE4     	JNZ	DRECT65        
1017: E4BA     F1         	POP	PSW	;yes, don't print spaces at the end of a line.
1018: E4BB     F5         	PUSH	PSW           
1019: E4BC     FE03       	CPI	3              
1020: E4BE     C2CDE4     	JNZ	DRECT63        
1021: E4C1     3E09       	MVI	A,9	;first check for no extension.
1022: E4C3     CD21E4     	CALL	EXTRACT       
1023: E4C6     E67F       	ANI	7FH            
1024: E4C8     FE20       	CPI	BLANK          
1025: E4CA     CAE4E4     	JZ	DIRECT7	;don't print spaces.
1026: E4CD                DRECT63:            
1027: E4CD     3E20       	MVI	A,BLANK	;else print them.
1028: E4CF                DRECT65:            
1029: E4CF     CD92E0     	CALL	PRINTB        
1030: E4D2     04         	INR	B	;bump to next character psoition.
1031: E4D3     78         	MOV	A,B            
1032: E4D4     FE0C       	CPI	12	;end of the name?
1033: E4D6     D2E4E4     	JNC	DIRECT7        
1034: E4D9     FE09       	CPI	9	;nope, starting extension?
1035: E4DB     C2AFE4     	JNZ	DIRECT6        
1036: E4DE     CDA2E0     	CALL	SPACE	;yes, add seperating space.
1037: E4E1     C3AFE4     	JMP	DIRECT6        
1038: E4E4                DIRECT7:            
1039: E4E4     F1         	POP	PSW	;get the next file name.
1040: E4E5                DIRECT8:            
1041: E4E5     CDC2E1     	CALL	CHKCON	;first check console, quit on anything.
1042: E4E8     C2F1E4     	JNZ	DIRECT9        
1043: E4EB     CDE4E0     	CALL	SRCHNXT	;get next name.
1044: E4EE     C36EE4     	JMP	DIRECT3	;and continue with our list.
1045: E4F1                DIRECT9:            
1046: E4F1     D1         	POP	D	;restore the stack and return to command level.
1047: E4F2     C359E7     	JMP	GETBACK        
1048: E4F5                ;                   
1049: E4F5                ;**************************************************************
1050: E4F5                ;*                  
1051: E4F5                ;*                E R A S E   C O M M A N D
1052: E4F5                ;*                  
1053: E4F5                ;**************************************************************
1054: E4F5                ;                   
1055: E4F5                ERASE:              
1056: E4F5     CD4AE2     	CALL	CONVFST	;convert file name.
1057: E4F8     FE0B       	CPI	11	;was '*.*' entered?
1058: E4FA     C218E5     	JNZ	ERASE1         
1059: E4FD     0128E5     	LXI	B,YESNO	;yes, ask for confirmation.
1060: E500     CDA7E0     	CALL	PLINE         
1061: E503     CD39E1     	CALL	GETINP        
1062: E506     2107E0     	LXI	H,INBUFF+1     
1063: E509     35         	DCR	M	;must be exactly 'y'.
1064: E50A     C258E3     	JNZ	CMMND1         
1065: E50D     23         	INX	H              
1066: E50E     7E         	MOV	A,M            
1067: E50F     FE59       	CPI	059H	; 'Y'     
1068: E511     C258E3     	JNZ	CMMND1         
1069: E514     23         	INX	H              
1070: E515     2288E0     	SHLD	INPOINT	;save input line pointer.
1071: E518                ERASE1:             
1072: E518     CD2AE4     	CALL	DSELECT	;select desired disk.
1073: E51B     11A0E7     	LXI	D,FCB          
1074: E51E     CDEFE0     	CALL	DELETE	;delete the file.
1075: E521     3C         	INR	A              
1076: E522     CCC0E3     	CZ	NONE	;not there?
1077: E525     C359E7     	JMP	GETBACK	;return to command level now.
1078: E528                YESNO:              
1079: E528     414C4C2028592F4E293F00 	DB	'All (y/n)?',0  
1080: E533                ;                   
1081: E533                ;**************************************************************
1082: E533                ;*                  
1083: E533                ;*            T Y P E   C O M M A N D
1084: E533                ;*                  
1085: E533                ;**************************************************************
1086: E533                ;                   
1087: E533                TYPE:               
1088: E533     CD4AE2     	CALL	CONVFST	;convert file name.
1089: E536     C2F5E1     	JNZ	SYNERR	;wild cards not allowed.
1090: E539     CD2AE4     	CALL	DSELECT	;select indicated drive.
1091: E53C     CDD0E0     	CALL	OPENFCB	;open the file.
1092: E53F     CA7DE5     	JZ	TYPE5	;not there?
1093: E542     CD98E0     	CALL	CRLF	;ok, start a new line on the screen.
1094: E545     21C4E7     	LXI	H,NBYTES;initialize byte counter.
1095: E548     36FF       	MVI	M,0FFH	;set to read first sector.
1096: E54A                TYPE1:              
1097: E54A     21C4E7     	LXI	H,NBYTES       
1098: E54D                TYPE2:              
1099: E54D     7E         	MOV	A,M	;have we written the entire sector?
1100: E54E     FE80       	CPI	128            
1101: E550     DA5DE5     	JC	TYPE3           
1102: E553     E5         	PUSH	H	;yes, read in the next one.
1103: E554     CDFEE0     	CALL	READFCB       
1104: E557     E1         	POP	H              
1105: E558     C276E5     	JNZ	TYPE4	;end or error?
1106: E55B     AF         	XRA	A	;ok, clear byte counter.
1107: E55C     77         	MOV	M,A            
1108: E55D                TYPE3:              
1109: E55D     34         	INR	M	;count this byte.
1110: E55E     218000     	LXI	H,Pg0Buffer	;and get the (A)th one from the buffer (Pg0Buffer).
1111: E561     CD45E2     	CALL	ADDHL         
1112: E564     7E         	MOV	A,M            
1113: E565     FE1A       	CPI	CNTRLZ	;end of file mark?
1114: E567     CA59E7     	JZ	GETBACK         
1115: E56A     CD8CE0     	CALL	PRINT	;no, print it.
1116: E56D     CDC2E1     	CALL	CHKCON	;check console, quit if anything ready.
1117: E570     C259E7     	JNZ	GETBACK        
1118: E573     C34AE5     	JMP	TYPE1          
1119: E576                ;                   
1120: E576                ;   Get here on an end of file or read error.
1121: E576                ;                   
1122: E576                TYPE4:              
1123: E576     3D         	DCR	A	;read error? 
1124: E577     CA59E7     	JZ	GETBACK         
1125: E57A     CDAFE3     	CALL	RDERROR	;yes, print message.
1126: E57D                TYPE5:              
1127: E57D     CD3CE4     	CALL	RESETDR	;and reset proper drive
1128: E580     C3F5E1     	JMP	SYNERR	;now print file name with problem.
1129: E583                ;                   
1130: E583                ;**************************************************************
1131: E583                ;*                  
1132: E583                ;*            S A V E   C O M M A N D
1133: E583                ;*                  
1134: E583                ;**************************************************************
1135: E583                ;                   
1136: E583                SAVE:               
1137: E583     CDCEE3     	CALL	DECODE		; get numeric number that follows SAVE.
1138: E586     F5         	PUSH	PSW			; save number of pages to write.
1139: E587     CD4AE2     	CALL	CONVFST		; convert file name linepointer past the number.
1140: E58A     C2F5E1     	JNZ		SYNERR		; exit with syntax error -wild cards not allowed.
1141: E58D     CD2AE4     	CALL	DSELECT		; select specified drive.
1142: E590     11A0E7     	LXI		D,FCB		; now delete this file.
1143: E593     D5         	PUSH	D			; save the fcb
1144: E594     CDEFE0     	CALL	DELETE        
1145: E597     D1         	POP		D             
1146: E598     CD09E1     	CALL	CREATE		;and create it again.
1147: E59B     CAD1E5     	JZ		SAVE3		;can't create?
1148: E59E     AF         	XRA		A			;clear record number byte.
1149: E59F     32C0E7     	STA		FCB+32        
1150: E5A2     F1         	POP		PSW			;convert pages to sectors.
1151: E5A3     6F         	MOV		L,A           
1152: E5A4     2600       	MVI		H,0           
1153: E5A6     29         	DAD		H			;(HL)=number of sectors to write.
1154: E5A7     110001     	LXI		D,TBASE		;and we start from here.
1155: E5AA                SAVE1:              
1156: E5AA     7C         	MOV		A,H			;done yet?
1157: E5AB     B5         	ORA		L             
1158: E5AC     CAC7E5     	JZ		SAVE2          
1159: E5AF     2B         	DCX		H			;nope, count this and compute the start
1160: E5B0     E5         	PUSH	H			;of the next 128 byte sector.
1161: E5B1     218000     	LXI		H,128         
1162: E5B4     19         	DAD		D             
1163: E5B5     E5         	PUSH	H			;save it and set the transfer address.
1164: E5B6     CDD8E1     	CALL	DMASET        
1165: E5B9     11A0E7     	LXI		D,FCB		;write out this sector now.
1166: E5BC     CD04E1     	CALL	WRTREC        
1167: E5BF     D1         	POP		D			;reset (DE) to the start of the last sector.
1168: E5C0     E1         	POP		H			;restore sector count.
1169: E5C1     C2D1E5     	JNZ		SAVE3		;write error?
1170: E5C4     C3AAE5     	JMP		SAVE1         
1171: E5C7                ;                   
1172: E5C7                ;   Get here after writing all of the file.
1173: E5C7                ;                   
1174: E5C7                SAVE2:              
1175: E5C7     11A0E7     	LXI		D,FCB		;now close the file.
1176: E5CA     CDDAE0     	CALL	CLOSE         
1177: E5CD     3C         	INR		A			;did it close ok?
1178: E5CE     C2D7E5     	JNZ		SAVE4         
1179: E5D1                ;                   
1180: E5D1                ;   Print out error message (no space).
1181: E5D1                ;                   
1182: E5D1                SAVE3:              
1183: E5D1     01DDE5     	LXI		B,NOSPACE     
1184: E5D4     CDA7E0     	CALL	PLINE         
1185: E5D7                SAVE4:              
1186: E5D7     CDD5E1     	CALL	STDDMA		;reset the standard dma address.
1187: E5DA     C359E7     	JMP		GETBACK       
1188: E5DD                NOSPACE:            
1189: E5DD     4E4F20535041434500 	DB	'No space',0    
1190: E5E6                ;                   
1191: E5E6                ;**************************************************************
1192: E5E6                ;*                  
1193: E5E6                ;*           R E N A M E   C O M M A N D
1194: E5E6                ;*                  
1195: E5E6                ;**************************************************************
1196: E5E6                ;                   
1197: E5E6                RENAME:             
1198: E5E6     CD4AE2     	CALL	CONVFST	;convert first file name.
1199: E5E9     C2F5E1     	JNZ	SYNERR	;wild cards not allowed.
1200: E5EC     3AC3E7     	LDA	CHGDRV	;remember any change in drives specified.
1201: E5EF     F5         	PUSH	PSW           
1202: E5F0     CD2AE4     	CALL	DSELECT	;and select this drive.
1203: E5F3     CDE9E0     	CALL	SRCHFCB	;is this file present?
1204: E5F6     C24FE6     	JNZ	RENAME6	;yes, print error message.
1205: E5F9     21A0E7     	LXI	H,FCB	;yes, move this name into second slot.
1206: E5FC     11B0E7     	LXI	D,FCB+16       
1207: E5FF     0610       	MVI	B,16           
1208: E601     CD18E4     	CALL	HL2DE         
1209: E604     2A88E0     	LHLD	INPOINT	;get input pointer.
1210: E607     EB         	XCHG               
1211: E608     CD3BE2     	CALL	NONBLANK;get next non blank character.
1212: E60B     FE3D       	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1213: E60D     CA15E6     	JZ	RENAME1         
1214: E610     FE5F       	CPI	USCORE		; '_'  
1215: E612     C249E6     	JNZ	RENAME5        
1216: E615                RENAME1:            
1217: E615     EB         	XCHG               
1218: E616     23         	INX	H	;ok, skip seperator.
1219: E617     2288E0     	SHLD	INPOINT	;save input line pointer.
1220: E61A     CD4AE2     	CALL	CONVFST	;convert this second file name now.
1221: E61D     C249E6     	JNZ	RENAME5	;again, no wild cards.
1222: E620     F1         	POP	PSW	;if a drive was specified, then it
1223: E621     47         	MOV	B,A	;must be the same as before.
1224: E622     21C3E7     	LXI	H,CHGDRV       
1225: E625     7E         	MOV	A,M            
1226: E626     B7         	ORA	A              
1227: E627     CA2FE6     	JZ	RENAME2         
1228: E62A     B8         	CMP	B              
1229: E62B     70         	MOV	M,B            
1230: E62C     C249E6     	JNZ	RENAME5	;they were different, error.
1231: E62F                RENAME2:            
1232: E62F     70         	MOV	M,B;	reset as per the first file specification.
1233: E630     AF         	XRA	A              
1234: E631     32A0E7     	STA	FCB	;clear the drive byte of the fcb.
1235: E634                RENAME3:            
1236: E634     CDE9E0     	CALL	SRCHFCB	;and go look for second file.
1237: E637     CA43E6     	JZ	RENAME4	;doesn't exist?
1238: E63A     11A0E7     	LXI	D,FCB          
1239: E63D     CD0EE1     	CALL	RENAM	;ok, rename the file.
1240: E640     C359E7     	JMP	GETBACK        
1241: E643                ;                   
1242: E643                ;   Process rename errors here.
1243: E643                ;                   
1244: E643                RENAME4:            
1245: E643     CDC0E3     	CALL	NONE	;file not there.
1246: E646     C359E7     	JMP	GETBACK        
1247: E649                RENAME5:            
1248: E649     CD3CE4     	CALL	RESETDR	;bad command format.
1249: E64C     C3F5E1     	JMP	SYNERR         
1250: E64F                RENAME6:            
1251: E64F     0158E6     	LXI	B,EXISTS;destination file already exists.
1252: E652     CDA7E0     	CALL	PLINE         
1253: E655     C359E7     	JMP	GETBACK        
1254: E658                EXISTS:             
1255: E658     46494C452045584953545300 	DB	'File exists',0 
1256: E664                ;                   
1257: E664                ;**************************************************************
1258: E664                ;*                  
1259: E664                ;*             U S E R   C O M M A N D
1260: E664                ;*                  
1261: E664                ;**************************************************************
1262: E664                ;                   
1263: E664                USER:               
1264: E664     CDCEE3     	CALL	DECODE	;get numeric value following command.
1265: E667     FE10       	CPI	16	;legal user number?
1266: E669     D2F5E1     	JNC	SYNERR         
1267: E66C     5F         	MOV	E,A	;yes but is there anything else?
1268: E66D     3AA1E7     	LDA	FCB+1          
1269: E670     FE20       	CPI	BLANK          
1270: E672     CAF5E1     	JZ	SYNERR	;yes, that is not allowed.
1271: E675     CD15E1     	CALL	GETSETUC;ok, set user code.
1272: E678     C35CE7     	JMP	GETBACK1       
1273: E67B                ;                   
1274: E67B                ;**************************************************************
1275: E67B                ;*                  
1276: E67B                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1277: E67B                ;*                  
1278: E67B                ;**************************************************************
1279: E67B                ;                   
1280: E67B                UNKNOWN:            
1281: E67B                ;e68b	CALL	VERIFY	;check for valid system (why?).
1282: E67B     3AA1E7     	LDA		FCB+1		;anything to execute?
1283: E67E     FE20       	CPI		BLANK		; is it a Space?
1284: E680     C297E6     	JNZ		UNKWN1        
1285: E683     3AC3E7     	LDA		CHGDRV		; No, only a drive change?
1286: E686     B7         	ORA		A			; Is itEmpty (00)
1287: E687     CA5CE7     	JZ		GETBACK1	; Yes, get otta here?
1288: E68A     3D         	DCR		A             
1289: E68B     32C2E7     	STA	CDRIVE	;ok, store new drive.
1290: E68E     CD29E1     	CALL	MOVECD	;set (TDRIVE) also.
1291: E691     CDBDE0     	CALL	DSKSEL	;and select this drive.
1292: E694     C35CE7     	JMP	GETBACK1;then return.
1293: E697                ;                   
1294: E697                ;   Here a file name was typed. Prepare to execute it.
1295: E697                ;                   
1296: E697                UNKWN1:             
1297: E697     11A9E7     	LXI	D,FCB+9	;an extension specified?
1298: E69A     1A         	LDAX	D             
1299: E69B     FE20       	CPI	BLANK          
1300: E69D     C2F5E1     	JNZ	SYNERR	;yes, not allowed.
1301: E6A0                UNKWN2:             
1302: E6A0     D5         	PUSH	D             
1303: E6A1     CD2AE4     	CALL	DSELECT	;select specified drive.
1304: E6A4     D1         	POP	D              
1305: E6A5     2156E7     	LXI	H,COMFILE	;set the extension to 'COM'.
1306: E6A8     CD16E4     	CALL	MOVE3         
1307: E6AB     CDD0E0     	CALL	OPENFCB	;and open this file.
1308: E6AE     CA3EE7     	JZ	UNKWN9	;not present?
1309: E6B1                ;                   
1310: E6B1                ;   Load in the program.
1311: E6B1                ;                   
1312: E6B1     210001     	LXI	H,TBASE	;store the program starting here.
1313: E6B4                UNKWN3:             
1314: E6B4     E5         	PUSH	H             
1315: E6B5     EB         	XCHG               
1316: E6B6     CDD8E1     	CALL	DMASET	;set transfer address.
1317: E6B9     11A0E7     	LXI	D,FCB	;and read the next record.
1318: E6BC     CDF9E0     	CALL	RDREC         
1319: E6BF     C2D4E6     	JNZ	UNKWN4	;end of file or read error?
1320: E6C2     E1         	POP	H	;nope, bump pointer for next sector.
1321: E6C3     118000     	LXI	D,128          
1322: E6C6     19         	DAD	D              
1323: E6C7     1100E0     	LXI	D,CBASE	;enough room for the whole file?
1324: E6CA     7D         	MOV	A,L            
1325: E6CB     93         	SUB	E              
1326: E6CC     7C         	MOV	A,H            
1327: E6CD     9A         	SBB	D              
1328: E6CE     D244E7     	JNC	UNKWN0	;no, it can't fit.
1329: E6D1     C3B4E6     	JMP	UNKWN3         
1330: E6D4                ;                   
1331: E6D4                ;   Get here after finished reading.
1332: E6D4                ;                   
1333: E6D4                UNKWN4:             
1334: E6D4     E1         	POP	H              
1335: E6D5     3D         	DCR	A	;normal end of file?
1336: E6D6     C244E7     	JNZ	UNKWN0         
1337: E6D9     CD3CE4     	CALL	RESETDR	;yes, reset previous drive.
1338: E6DC     CD4AE2     	CALL	CONVFST	;convert the first file name that follows
1339: E6DF     21C3E7     	LXI	H,CHGDRV;command name.
1340: E6E2     E5         	PUSH	H             
1341: E6E3     7E         	MOV	A,M	;set drive code in default fcb.
1342: E6E4     32A0E7     	STA	FCB            
1343: E6E7     3E10       	MVI	A,16	;put second name 16 bytes later.
1344: E6E9     CD4CE2     	CALL	CONVERT	;convert second file name.
1345: E6EC     E1         	POP	H              
1346: E6ED     7E         	MOV	A,M	;and set the drive for this second file.
1347: E6EE     32B0E7     	STA	FCB+16         
1348: E6F1     AF         	XRA	A	;clear record byte in fcb.
1349: E6F2     32C0E7     	STA	FCB+32         
1350: E6F5     115C00     	LXI	D,TFCB	;move it into place at(005Ch).
1351: E6F8     21A0E7     	LXI	H,FCB          
1352: E6FB     0621       	MVI	B,33           
1353: E6FD     CD18E4     	CALL	HL2DE         
1354: E700     2108E0     	LXI	H,INBUFF+2;now move the remainder of the input
1355: E703                UNKWN5:             
1356: E703     7E         	MOV	A,M	;line down to (0080h). Look for a non blank.
1357: E704     B7         	ORA	A	;or a null.  
1358: E705     CA11E7     	JZ	UNKWN6          
1359: E708     FE20       	CPI	BLANK          
1360: E70A     CA11E7     	JZ	UNKWN6          
1361: E70D     23         	INX	H              
1362: E70E     C303E7     	JMP	UNKWN5         
1363: E711                ;                   
1364: E711                ;   Do the line move now. It ends in a null byte.
1365: E711                ;                   
1366: E711                UNKWN6:             
1367: E711     0600       	MVI	B,0	;keep a character count.
1368: E713     118100     	LXI	D,Pg0Buffer+1;data gets put here.
1369: E716                UNKWN7:             
1370: E716     7E         	MOV	A,M	;move it now.
1371: E717     12         	STAX	D             
1372: E718     B7         	ORA	A              
1373: E719     CA22E7     	JZ	UNKWN8          
1374: E71C     04         	INR	B              
1375: E71D     23         	INX	H              
1376: E71E     13         	INX	D              
1377: E71F     C316E7     	JMP	UNKWN7         
1378: E722                UNKWN8:             
1379: E722     78         	MOV	A,B	;now store the character count.
1380: E723     328000     	STA	Pg0Buffer      
1381: E726     CD98E0     	CALL	CRLF	;clean up the screen.
1382: E729     CDD5E1     	CALL	STDDMA	;set standard transfer address.
1383: E72C     CD1AE1     	CALL	SETCDRV	;reset current drive.
1384: E72F     CD0001     	CALL	TBASE	;and execute the program.
1385: E732                ;                   
1386: E732                ;   Transiant programs return here (or reboot).
1387: E732                ;                   
1388: E732     317EE7     	LXI	SP,BATCH	;set stack first off.
1389: E735     CD29E1     	CALL	MOVECD	;move current drive into place (TDRIVE).
1390: E738     CDBDE0     	CALL	DSKSEL	;and reselect it.
1391: E73B     C358E3     	JMP	CMMND1	;back to comand mode.
1392: E73E                ;                   
1393: E73E                ;   Get here if some error occured.
1394: E73E                ;                   
1395: E73E                UNKWN9:             
1396: E73E     CD3CE4     	CALL	RESETDR	;inproper format.
1397: E741     C3F5E1     	JMP	SYNERR         
1398: E744                UNKWN0:             
1399: E744     014DE7     	LXI	B,BADLOAD;read error or won't fit.
1400: E747     CDA7E0     	CALL	PLINE         
1401: E74A     C359E7     	JMP	GETBACK        
1402: E74D                BADLOAD:            
1403: E74D     424144204C4F414400 	DB	'Bad load',0    
1404: E756                COMFILE:            
1405: E756     434F4D     	DB	'COM'	;command file extension.
1406: E759                ;                   
1407: E759                ;   Get here to return to command level. We will reset the
1408: E759                ; previous active drive and then either return to command
1409: E759                ; level directly or print error message and then return.
1410: E759                ;                   
1411: E759                GETBACK:            
1412: E759     CD3CE4     	CALL	RESETDR	;reset previous drive.
1413: E75C                GETBACK1:           
1414: E75C     CD4AE2     	CALL	CONVFST	;convert first name in (FCB).
1415: E75F     3AA1E7     	LDA	FCB+1	;if this was just a drive change request,
1416: E762     D620       	SUI	BLANK	;make sure it was valid.
1417: E764     21C3E7     	LXI	H,CHGDRV       
1418: E767     B6         	ORA	M              
1419: E768     C2F5E1     	JNZ	SYNERR         
1420: E76B     C358E3     	JMP	CMMND1	;ok, return to command level.
1421: E76E                ;                   
1422: E76E                ;   ccp stack area. 
1423: E76E                ;                   
1424: E76E     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1425: E77E                CCPStack	EQU	$	;end of ccp stack area.
1426: E77E                ;                   
1427: E77E                ;   Batch (or SUBMIT) processing information storage.
1428: E77E                ;                   
1429: E77E                BATCH:              
1430: E77E     00         	DB	0	;batch mode flag (0=not active).
1431: E77F                BATCHFCB:           
1432: E77F     002424242020202020535542000000000000000000000000000000000000000000 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1433: E7A0                ;                   
1434: E7A0                ;   File control block setup by the CCP.
1435: E7A0                ;                   
1436: E7A0                FCB:                
1437: E7A0     002020202020202020202020000000000020202020202020202020200000000000 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1438: E7C1                RTNCODE:            
1439: E7C1     00         	DB	0	;status returned from bdos call.
1440: E7C2                CDRIVE:             
1441: E7C2     00         	DB	0	;currently active drive.
1442: E7C3                CHGDRV:             
1443: E7C3     00         	DB	0	;change in drives flag (0=no change).
1444: E7C4                NBYTES:             
1445: E7C4     0000       	DW	0	;byte counter used by TYPE.
1446: E7C6                ;                   
1447: E7C6                ;   Room for expansion?
1448: E7C6                ;                   
1449: E7C6     00000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1450: E7D3                ;                   
1451: E7D3                ;   Note that the following six bytes must match those at
1452: E7D3                ; (PATTRN1) or cp/m will HALT. Why?
1453: E7D3                ;                   
1454: E7D3                ;PATTRN2:           
1455: E7D3                ;	DB	0,22,0,0,0,0;(* serial number bytes *).
1456: E7D3                ;                   
1457: E7D3                ;**************************************************************
1458: E7D3                ;*                  
1459: E7D3                ;*                    B D O S   E N T R Y
1460: E7D3                ;*                  
1461: E7D3                ;**************************************************************
1462: E7D3                ;                   
1463: E7D3                ;   Entry into bdos.
1464: E7D3                ;			Parameters: (DE) or (E) are the parameters passed. The
1465: E7D3                ;						(C) - function number
1466: E7D3                ;	The user's stack is saved (UserStack) 
1467: E7D3                ;	BDOS uses its own stack  (BDOSstack)
1468: E7D3                ;	The Function number is checked
1469: E7D3                ;	The corect routine is calcualted using the FunctionVector and (C)
1470: E7D3                ;                   
1471: E7D3                	ORG  0E806H					; forces - see start of bios fix later
1472: E806                BDOSEntry:          
1473: E806                ;	JMP	BDOSSetup     
1474: E806                ;BDOSSetup:         
1475: E806     EB         	XCHG						; Swap  (DE) and (HL). **23**
1476: E807     223CE8     	SHLD	ParamsDE			; Save (DE)
1477: E80A     EB         	XCHG						; Restore (DE) and (HL) to original values
1478: E80B     7B         	MOV		A,E	          
1479: E80C     323EE8     	STA		ParamE				; Save register (E) in particular.
1480: E80F     210000     	LXI		H,0           
1481: E812     223FE8     	SHLD	StatusBDOSReturn	;clear return status.
1482: E815     39         	DAD		SP            
1483: E816     2241E8     	SHLD	UserStack			; ave users stack pointer.
1484: E819     3173E8     	LXI		SP,BDOSstack		; nd set our own.
1485: E81C     AF         	XRA		A					; lear A for flags resets
1486: E81D     32E0F5     	STA		AutoSelectFlag		; lear auto select storage Flag
1487: E820     32DEF5     	STA		AutoSelectActive	; lear auto select Active Flag
1488: E823     2173E8     	LXI		H,BDOSExit			; et return address to BDOSExit routine
1489: E826     E5         	PUSH	H					; ut it on the stack
1490: E827     79         	MOV		A,C					; get function number and put into A.
1491: E828     FE29       	CPI		FunctionCount + 1	; valid function number?
1492: E82A     D0         	RNC							; Exit if not valid
1493: E82B     4B         	MOV		C,E					; keep single register function value in C.
1494: E82C     219AE8     	LXI		H,FunctionVector	; now look thru the function table.
1495: E82F     5F         	MOV		E,A           
1496: E830     1600       	MVI		D,0					;(DE)=function number.
1497: E832     19         	DAD		D             
1498: E833     19         	DAD		D					;(HL)=(start of table)+2*(function number).
1499: E834     5E         	MOV		E,M           
1500: E835     23         	INX		H             
1501: E836     56         	MOV		D,M					; now (DE)=address for this function.
1502: E837     2A3CE8     	LHLD	ParamsDE			; retrieve parameters.
1503: E83A     EB         	XCHG						;now (DE) has the original parameters.
1504: E83B     E9         	PCHL						;execute desired function.
1505: E83C                ;----------------------------------
1506: E83C     0000       ParamsDE:			DW	0	;(DE) parameters saved here on entry to BDOS.
1507: E83E     00         ParamE:				DB	0	;storage for register (E) on entry to bdos.
1508: E83F     0000       StatusBDOSReturn:	DW	0	;status returned from bdos function.
1509: E841     0000       UserStack:			DW	0	;save users stack pointer here.
1510: E843                ;                   
1511: E843                ;   Stack area for BDOS calls.
1512: E843                ;                   
1513: E843                					DS	030H        
1514: E873                BDOSstack	EQU	$	;end of stack area.
1515: E873                ;----------------------------------
1516: E873                BDOSExit:           
1517: E873     3ADEF5     	LDA	AutoSelectActive	;was auto select activated?
1518: E876     B7         	ORA	A              
1519: E877     CA90E8     	JZ	BDOSExit1       
1520: E87A     2A3CE8     	LHLD	ParamsDE	;yes, but was a change made?
1521: E87D     3600       	MVI	M,0	;(* reset first byte of fcb *)
1522: E87F     3AE0F5     	LDA	AutoSelectFlag 
1523: E882     B7         	ORA	A              
1524: E883     CA90E8     	JZ	BDOSExit1       
1525: E886     77         	MOV	M,A	;yes, reset first byte properly.
1526: E887     3ADFF5     	LDA	OLDDRV	;and get the old drive and select it.
1527: E88A     323EE8     	STA	ParamE         
1528: E88D     CD6AF4     	CALL	SETDSK        
1529: E890                BDOSExit1:          
1530: E890     2A41E8     	LHLD		UserStack			;Get  the users stack pointer.
1531: E893     F9         	SPHL		             
1532: E894     2A3FE8     	LHLD		StatusBDOSReturn	;get return status.
1533: E897     7D         	MOV	A,L							;force version 1.4 compatability.
1534: E898     44         	MOV	B,H            
1535: E899     C9         	RET			;and go back to user.
1536: E89A                                    
1537: E89A                	                   
1538: E89A                	                   
1539: E89A                ;                   
1540: E89A                ;   BDOS function jump table.
1541: E89A                ;                   
1542: E89A                ;NFUNCTS	EQU	41	;number of functions in followin table.
1543: E89A                ;                   
1544: E89A                FunctionVector:     
1545: E89A     03F6       	DW	WBOOT	;0		Overall system and BDOS reset
1546: E89C     23EB       	DW	GETCON	;1		Read a byte from the console keyboard
1547: E89E     EBE9       	DW	OUTCON	;2		Write a byte to the console screen
1548: E8A0     29EB       	DW	GETRDR	;3		Read a byte from the logical reader device
1549: E8A2     12F6       	DW	PUNCH	;4		Write a byte to the logical punch device
1550: E8A4     0FF6       	DW	LIST	;5		Write a byte to the logical list device
1551: E8A6     2FEB       	DW	DIRCIO	;6		Direct console I/O (no CCP-style editing)
1552: E8A8     48EB       	DW	GETIOB	;7		Read the current setting of the IOBYTE
1553: E8AA     4EEB       	DW	SETIOB	;8		Set a new value of the IOBYTE
1554: E8AC     53EB       	DW	PRTSTR	;9		Send a "$"-terminated string to the console
1555: E8AE     3CEA       	DW	RDBUFF	;10		Read a string from the console into a buffer
1556: E8B0     59EB       	DW	GETCSTS	;11		Check if a console key is waiting to be read
1557: E8B2     A3F4       	DW	GETVER	;12		Return the CP/M version number
1558: E8B4                	                   
1559: E8B4     A8F4       	DW	RSTDSK		;13		Reset disk system
1560: E8B6     6AF4       	DW	SETDSK		;14		Select specified logical disk drive
1561: E8B8     C1F4       	DW	OPENFIL		;15		Open specified file for reading/writing
1562: E8BA     CAF4       	DW	CLOSEFIL	;16		Close specified file after reading/writing
1563: E8BC     D0F4       	DW	GETFST		;17		Search file directory for first match with filename
1564: E8BE     EDF4       	DW	GETNXT		;18		Search file directory for next match with filename
1565: E8C0     FCF4       	DW	DELFILE		;19		Delete (erase) file
1566: E8C2     05F5       	DW	READSEQ		;20		Read the next "record" sequentially
1567: E8C4     0BF5       	DW	WRTSEQ		;21		Write the next "record" sequentially
1568: E8C6     11F5       	DW	FCREATE		;22		Create a new file with the specified name
1569: E8C8     1AF5       	DW	RENFILE		;23		Rename a file to a new name
1570: E8CA     23F5       	DW	GETLOG		;24		Indicate which logical disks are active
1571: E8CC     29F5       	DW	GETCRNT		;25		Return the current default disk drive number
1572: E8CE     2FF5       	DW	PUTDMA		;26		Set the DMA address (read/write address)
1573: E8D0     36F5       	DW	GETALOC		;27		Return the address of an allocation vector
1574: E8D2     3CED       	DW	WRTPRTD		;28		Return the address of an allocation vector
1575: E8D4     3CF5       	DW	GETROV		;29		Indicate which disks are currently Read-Only status
1576: E8D6     42F5       	DW	SETATTR		;30		Set specified file to System or Read-Only status
1577: E8D8     4BF5       	DW	GETPARM		;31		Return address of disk parameter block (DPB)
1578: E8DA     52F5       	DW	GETUSER		;32		Set/Get the current user number
1579: E8DC     66F5       	DW	RDRANDOM	;33		Set/Get the current user number
1580: E8DE     6CF5       	DW	WTRANDOM	;34		Write a "record" randomly
1581: E8E0     72F5       	DW	FILESIZE	;35		Return logical file size (even for random files)
1582: E8E2     C2F3       	DW	SETRAN		;36		Set record number for the next random read/write
1583: E8E4     78F5       	DW	LOGOFF		;37     
1584: E8E6     5FEB       	DW	Return			;38		Simple Return
1585: E8E8     5FEB       	DW	Return			;39		Simple Return
1586: E8EA     99F5       	DW	WTSPECL		;40		Write a "record" randomly with zero fill
1587: E8EC                	                   
1588: E8EC                FunctionCount	EQU	 ($ -FunctionVector)/2
1589: E8EC                                    
1590: E8EC                ;                   
1591: E8EC                ;   Bdos error table.
1592: E8EC                ;                   
1593: E8EC     F4E8       BADSCTR:	DW	ERROR1	;bad sector on read or write.
1594: E8EE     00E9       BADSLCT:	DW	ERROR2	;bad disk select.
1595: E8F0     06E9       RODISK:		DW	ERROR3	;disk is read only.
1596: E8F2     0CE9       ROFILE:		DW	ERROR4	;file is read only.
1597: E8F4                ;                   
1598: E8F4                ;                   
1599: E8F4                ;   Bdos error message section.
1600: E8F4                ;                   
1601: E8F4                ERROR1:             
1602: E8F4     2125E9     	LXI	H,BADSEC	;bad sector message.
1603: E8F7     CD40E9     	CALL	PRTERR	;print it and get a 1 char responce.
1604: E8FA     FE03       	CPI	CNTRLC	;re-boot request (control-c)?
1605: E8FC     CA0000     	JZ	0	;yes.         
1606: E8FF     C9         	RET		;no, return to retry i/o function.
1607: E900                ;                   
1608: E900                ERROR2:             
1609: E900     2130E9     	LXI	H,BADSEL	;bad drive selected.
1610: E903     C30FE9     	JMP	ERROR5         
1611: E906                ;                   
1612: E906                ERROR3:             
1613: E906     213CE9     	LXI	H,DISKRO	;disk is read only.
1614: E909     C30FE9     	JMP	ERROR5         
1615: E90C                ;                   
1616: E90C                ERROR4:             
1617: E90C     2137E9     	LXI	H,FILERO	;file is read only.
1618: E90F                ;                   
1619: E90F                ERROR5:             
1620: E90F     CD40E9     	CALL	PRTERR        
1621: E912     C30000     	JMP	0	;always reboot on these errors.
1622: E915                ;                   
1623: E915     42444F5320455252204F4E20 BDOSERR:	DB	'Bdos Err On '
1624: E921     203A2024   BDOSDRV:	DB	' : $'  
1625: E925     42414420534543544F5224 BADSEC:		DB	'Bad Sector$'
1626: E930     53454C45435424 BADSEL:		DB	'Select$'
1627: E937     46494C4520 FILERO:		DB	'File ' 
1628: E93C     522F4F24   DISKRO:		DB	'R/O$'  
1629: E940                ;                   
1630: E940                ;   Print bdos error message.
1631: E940                ;                   
1632: E940                PRTERR:             
1633: E940     E5         	PUSH	H	;save second message pointer.
1634: E941     CD24EA     	CALL	OUTCRLF	;send (cr)(lf).
1635: E944     3AABF5     	LDA	CurrentDrive	;get Current Drive drive.
1636: E947     C641       	ADI	041H	; 'A'	;make ascii.
1637: E949     3221E9     	STA	BDOSDRV	;and put in message.
1638: E94C     0115E9     	LXI	B,BDOSERR;and print it.
1639: E94F     CD2EEA     	CALL	PRTMESG       
1640: E952     C1         	POP	B	;print second message line now.
1641: E953     CD2EEA     	CALL	PRTMESG       
1642: E956                ;                   
1643: E956                ;   Get an input character. We will check our 1 character
1644: E956                ; buffer first. This may be set by the console status routine.
1645: E956                ;                   
1646: E956                GETCHAR:            
1647: E956     2169EB     	LXI	H,CHARBUF;check character buffer.
1648: E959     7E         	MOV	A,M	;anything present already?
1649: E95A     3600       	MVI	M,0	;...either case clear it.
1650: E95C     B7         	ORA	A              
1651: E95D     C0         	RNZ		;yes, use it. 
1652: E95E     C309F6     	JMP	CONIN	;nope, go get a character responce.
1653: E961                ;                   
1654: E961                ;   Input and echo a character.
1655: E961                ;                   
1656: E961                GETECHO:            
1657: E961     CD56E9     	CALL	GETCHAR	;input a character.
1658: E964     CD6FE9     	CALL	CHKCHAR	;carriage control?
1659: E967     D8         	RC		;no, a regular control char so don't echo.
1660: E968     F5         	PUSH	PSW	;ok, save character now.
1661: E969     4F         	MOV	C,A            
1662: E96A     CDEBE9     	CALL	OUTCON	;and echo it.
1663: E96D     F1         	POP	PSW	;get character and return.
1664: E96E     C9         	RET                
1665: E96F                ;                   
1666: E96F                ;   Check character in (A). Set the zero flag on a carriage
1667: E96F                ; control character and the carry flag on any other control
1668: E96F                ; character.        
1669: E96F                ;                   
1670: E96F                CHKCHAR:            
1671: E96F     FE0D       	CPI	CR	;check for carriage return, line feed, backspace,
1672: E971     C8         	RZ		;or a tab.     
1673: E972     FE0A       	CPI	LF             
1674: E974     C8         	RZ                 
1675: E975     FE09       	CPI	TAB            
1676: E977     C8         	RZ                 
1677: E978     FE08       	CPI	BS             
1678: E97A     C8         	RZ                 
1679: E97B     FE20       	CPI	BLANK	;other control char? Set carry flag.
1680: E97D     C9         	RET                
1681: E97E                ;                   
1682: E97E                ;   Check the console during output. Halt on a control-s, then
1683: E97E                ; reboot on a control-c. If anything else is ready, clear the
1684: E97E                ; zero flag and return (the calling routine may want to do
1685: E97E                ; something).       
1686: E97E                ;                   
1687: E97E                CKCONSOL:           
1688: E97E     3A69EB     	LDA	CHARBUF	;check buffer.
1689: E981     B7         	ORA	A	;if anything, just return without checking.
1690: E982     C2A0E9     	JNZ	CKCON2         
1691: E985     CD06F6     	CALL	CONST	;nothing in buffer. Check console.
1692: E988     E601       	ANI	01H	;look at bit 0.
1693: E98A     C8         	RZ		;return if nothing.
1694: E98B     CD09F6     	CALL	CONIN	;ok, get it.
1695: E98E     FE13       	CPI	CNTRLS	;if not control-s, return with zero cleared.
1696: E990     C29DE9     	JNZ	CKCON1         
1697: E993     CD09F6     	CALL	CONIN	;halt processing until another char
1698: E996     FE03       	CPI	CNTRLC	;is typed. Control-c?
1699: E998     CA0000     	JZ	0	;yes, reboot now.
1700: E99B     AF         	XRA	A	;no, just pretend nothing was ever ready.
1701: E99C     C9         	RET                
1702: E99D                CKCON1:             
1703: E99D     3269EB     	STA	CHARBUF	;save character in buffer for later processing.
1704: E9A0                CKCON2:             
1705: E9A0     3E01       	MVI	A,1	;set (A) to non zero to mean something is ready.
1706: E9A2     C9         	RET                
1707: E9A3                ;                   
1708: E9A3                ;   Output (C) to the screen. If the printer flip-flop flag
1709: E9A3                ; is set, we will send character to printer also. The console
1710: E9A3                ; will be checked in the process.
1711: E9A3                ;                   
1712: E9A3                OUTCHAR:            
1713: E9A3     3A65EB     	LDA	OUTFLAG	;check output flag.
1714: E9A6     B7         	ORA	A	;anything and we won't generate output.
1715: E9A7     C2BDE9     	JNZ	OUTCHR1        
1716: E9AA     C5         	PUSH	B             
1717: E9AB     CD7EE9     	CALL	CKCONSOL;check console (we don't care whats there).
1718: E9AE     C1         	POP	B              
1719: E9AF     C5         	PUSH	B             
1720: E9B0     CD0CF6     	CALL	CONOUT	;output (C) to the screen.
1721: E9B3     C1         	POP	B              
1722: E9B4     C5         	PUSH	B             
1723: E9B5     3A68EB     	LDA	PRTFLAG	;check printer flip-flop flag.
1724: E9B8     B7         	ORA	A              
1725: E9B9     C40FF6     	CNZ	LIST	;print it also if non-zero.
1726: E9BC     C1         	POP	B              
1727: E9BD                OUTCHR1:            
1728: E9BD     79         	MOV	A,C	;update cursors position.
1729: E9BE     2167EB     	LXI	H,CURPOS       
1730: E9C1     FE7F       	CPI	DEL	;rubouts don't do anything here.
1731: E9C3     C8         	RZ                 
1732: E9C4     34         	INR	M	;bump line pointer.
1733: E9C5     FE20       	CPI	BLANK	;and return if a normal character.
1734: E9C7     D0         	RNC                
1735: E9C8     35         	DCR	M	;restore and check for the start of the line.
1736: E9C9     7E         	MOV	A,M            
1737: E9CA     B7         	ORA	A              
1738: E9CB     C8         	RZ		;ingnore control characters at the start of the line.
1739: E9CC     79         	MOV	A,C            
1740: E9CD     FE08       	CPI	BS	;is it a backspace?
1741: E9CF     C2D4E9     	JNZ	OUTCHR2        
1742: E9D2     35         	DCR	M	;yes, backup pointer.
1743: E9D3     C9         	RET                
1744: E9D4                OUTCHR2:            
1745: E9D4     FE0A       	CPI	LF	;is it a line feed?
1746: E9D6     C0         	RNZ		;ignore anything else.
1747: E9D7     3600       	MVI	M,0	;reset pointer to start of line.
1748: E9D9     C9         	RET                
1749: E9DA                ;                   
1750: E9DA                ;   Output (A) to the screen. If it is a control character
1751: E9DA                ; (other than carriage control), use ^x format.
1752: E9DA                ;                   
1753: E9DA                SHOWIT:             
1754: E9DA     79         	MOV	A,C            
1755: E9DB     CD6FE9     	CALL	CHKCHAR	;check character.
1756: E9DE     D2EBE9     	JNC	OUTCON	;not a control, use normal output.
1757: E9E1     F5         	PUSH	PSW           
1758: E9E2     0E5E       	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1759: E9E4     CDA3E9     	CALL	OUTCHAR       
1760: E9E7     F1         	POP	PSW            
1761: E9E8     F640       	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1762: E9EA     4F         	MOV	C,A            
1763: E9EB                ;                   
1764: E9EB                ;   Function to output (C) to the console device and expand tabs
1765: E9EB                ; if necessary.     
1766: E9EB                ;                   
1767: E9EB                OUTCON:             
1768: E9EB     79         	MOV	A,C            
1769: E9EC     FE09       	CPI	TAB	;is it a tab?
1770: E9EE     C2A3E9     	JNZ	OUTCHAR	;use regular output.
1771: E9F1                OUTCON1:            
1772: E9F1     0E20       	MVI	C,BLANK	;yes it is, use spaces instead.
1773: E9F3     CDA3E9     	CALL	OUTCHAR       
1774: E9F6     3A67EB     	LDA	CURPOS	;go until the cursor is at a multiple of 8
1775: E9F9                                    
1776: E9F9     E607       	ANI	07H	;position. 
1777: E9FB     C2F1E9     	JNZ	OUTCON1        
1778: E9FE     C9         	RET                
1779: E9FF                ;                   
1780: E9FF                ;   Echo a backspace character. Erase the prevoius character
1781: E9FF                ; on the screen.    
1782: E9FF                ;                   
1783: E9FF                BACKUP:             
1784: E9FF     CD07EA     	CALL	BACKUP1	;backup the screen 1 place.
1785: EA02     0E20       	MVI	C,BLANK	;then blank that character.
1786: EA04     CD0CF6     	CALL	CONOUT        
1787: EA07                BACKUP1:            
1788: EA07     0E08       	MVI	C,BS	;then back space once more.
1789: EA09     C30CF6     	JMP	CONOUT         
1790: EA0C                ;                   
1791: EA0C                ;   Signal a deleted line. Print a '#' at the end and start
1792: EA0C                ; over.             
1793: EA0C                ;                   
1794: EA0C                NEWLINE:            
1795: EA0C     0E23       	MVI	C, POUNDSN		; '#'
1796: EA0E     CDA3E9     	CALL	OUTCHAR	;print this.
1797: EA11     CD24EA     	CALL	OUTCRLF	;start new line.
1798: EA14                NEWLN1:             
1799: EA14     3A67EB     	LDA	CURPOS	;move the cursor to the starting position.
1800: EA17     2166EB     	LXI	H,STARTING     
1801: EA1A     BE         	CMP	M              
1802: EA1B     D0         	RNC		;there yet?   
1803: EA1C     0E20       	MVI	C,BLANK        
1804: EA1E     CDA3E9     	CALL	OUTCHAR	;nope, keep going.
1805: EA21     C314EA     	JMP	NEWLN1         
1806: EA24                ;                   
1807: EA24                ;   Output a (cr) (lf) to the console device (screen).
1808: EA24                ;                   
1809: EA24                OUTCRLF:            
1810: EA24     0E0D       	MVI	C,CR           
1811: EA26     CDA3E9     	CALL	OUTCHAR       
1812: EA29     0E0A       	MVI	C,LF           
1813: EA2B     C3A3E9     	JMP	OUTCHAR        
1814: EA2E                ;                   
1815: EA2E                ;   Print message pointed to by (BC). It will end with a '$'.
1816: EA2E                ;                   
1817: EA2E                PRTMESG:            
1818: EA2E     0A         	LDAX	B	;check for terminating character.
1819: EA2F     FE24       	CPI	DOLLAR		; '$'  
1820: EA31     C8         	RZ                 
1821: EA32     03         	INX	B              
1822: EA33     C5         	PUSH	B	;otherwise, bump pointer and print it.
1823: EA34     4F         	MOV	C,A            
1824: EA35     CDEBE9     	CALL	OUTCON        
1825: EA38     C1         	POP	B              
1826: EA39     C32EEA     	JMP	PRTMESG        
1827: EA3C                ;                   
1828: EA3C                ;   Function to execute a buffered read.
1829: EA3C                ;                   
1830: EA3C                RDBUFF:             
1831: EA3C     3A67EB     	LDA	CURPOS	;use present location as starting one.
1832: EA3F     3266EB     	STA	STARTING       
1833: EA42     2A3CE8     	LHLD	ParamsDE	;get the maximum buffer space.
1834: EA45     4E         	MOV	C,M            
1835: EA46     23         	INX	H	;point to first available space.
1836: EA47     E5         	PUSH	H	;and save.  
1837: EA48     0600       	MVI	B,0	;keep a character count.
1838: EA4A                RDBUF1:             
1839: EA4A     C5         	PUSH	B             
1840: EA4B     E5         	PUSH	H             
1841: EA4C                RDBUF2:             
1842: EA4C     CD56E9     	CALL	GETCHAR	;get the next input character.
1843: EA4F     E67F       	ANI	7FH	;strip bit 7.
1844: EA51     E1         	POP	H	;reset registers.
1845: EA52     C1         	POP	B              
1846: EA53     FE0D       	CPI	CR	;en of the line?
1847: EA55     CA1CEB     	JZ	RDBUF17         
1848: EA58     FE0A       	CPI	LF             
1849: EA5A     CA1CEB     	JZ	RDBUF17         
1850: EA5D     FE08       	CPI	BS	;how about a backspace?
1851: EA5F     C271EA     	JNZ	RDBUF3         
1852: EA62     78         	MOV	A,B	;yes, but ignore at the beginning of the line.
1853: EA63     B7         	ORA	A              
1854: EA64     CA4AEA     	JZ	RDBUF1          
1855: EA67     05         	DCR	B	;ok, update counter.
1856: EA68     3A67EB     	LDA	CURPOS	;if we backspace to the start of the line,
1857: EA6B     3265EB     	STA	OUTFLAG	;treat as a cancel (control-x).
1858: EA6E     C3CBEA     	JMP	RDBUF10        
1859: EA71                RDBUF3:             
1860: EA71     FE7F       	CPI	DEL	;user typed a rubout?
1861: EA73     C281EA     	JNZ	RDBUF4         
1862: EA76     78         	MOV	A,B	;ignore at the start of the line.
1863: EA77     B7         	ORA	A              
1864: EA78     CA4AEA     	JZ	RDBUF1          
1865: EA7B     7E         	MOV	A,M	;ok, echo the prevoius character.
1866: EA7C     05         	DCR	B	;and reset pointers (counters).
1867: EA7D     2B         	DCX	H              
1868: EA7E     C304EB     	JMP	RDBUF15        
1869: EA81                RDBUF4:             
1870: EA81     FE05       	CPI	CNTRLE	;physical end of line?
1871: EA83     C292EA     	JNZ	RDBUF5         
1872: EA86     C5         	PUSH	B	;yes, do it.
1873: EA87     E5         	PUSH	H             
1874: EA88     CD24EA     	CALL	OUTCRLF       
1875: EA8B     AF         	XRA	A	;and update starting position.
1876: EA8C     3266EB     	STA	STARTING       
1877: EA8F     C34CEA     	JMP	RDBUF2         
1878: EA92                RDBUF5:             
1879: EA92     FE10       	CPI	CNTRLP	;control-p?
1880: EA94     C2A3EA     	JNZ	RDBUF6         
1881: EA97     E5         	PUSH	H	;yes, flip the print flag filp-flop byte.
1882: EA98     2168EB     	LXI	H,PRTFLAG      
1883: EA9B     3E01       	MVI	A,1	;PRTFLAG=1-PRTFLAG
1884: EA9D     96         	SUB	M              
1885: EA9E     77         	MOV	M,A            
1886: EA9F     E1         	POP	H              
1887: EAA0     C34AEA     	JMP	RDBUF1         
1888: EAA3                RDBUF6:             
1889: EAA3     FE18       	CPI	CNTRLX	;control-x (cancel)?
1890: EAA5     C2BAEA     	JNZ	RDBUF8         
1891: EAA8     E1         	POP	H              
1892: EAA9                RDBUF7:             
1893: EAA9     3A66EB     	LDA	STARTING;yes, backup the cursor to here.
1894: EAAC     2167EB     	LXI	H,CURPOS       
1895: EAAF     BE         	CMP	M              
1896: EAB0     D23CEA     	JNC	RDBUFF	;done yet?
1897: EAB3     35         	DCR	M	;no, decrement pointer and output back up one space.
1898: EAB4     CDFFE9     	CALL	BACKUP        
1899: EAB7     C3A9EA     	JMP	RDBUF7         
1900: EABA                RDBUF8:             
1901: EABA     FE15       	CPI	CNTRLU	;cntrol-u (cancel line)?
1902: EABC     C2C6EA     	JNZ	RDBUF9         
1903: EABF     CD0CEA     	CALL	NEWLINE	;start a new line.
1904: EAC2     E1         	POP	H              
1905: EAC3     C33CEA     	JMP	RDBUFF         
1906: EAC6                RDBUF9:             
1907: EAC6     FE12       	CPI	CNTRLR	;control-r?
1908: EAC8     C201EB     	JNZ	RDBUF14        
1909: EACB                RDBUF10:            
1910: EACB     C5         	PUSH	B	;yes, start a new line and retype the old one.
1911: EACC     CD0CEA     	CALL	NEWLINE       
1912: EACF     C1         	POP	B              
1913: EAD0     E1         	POP	H              
1914: EAD1     E5         	PUSH	H             
1915: EAD2     C5         	PUSH	B             
1916: EAD3                RDBUF11:            
1917: EAD3     78         	MOV	A,B	;done whole line yet?
1918: EAD4     B7         	ORA	A              
1919: EAD5     CAE5EA     	JZ	RDBUF12         
1920: EAD8     23         	INX	H	;nope, get next character.
1921: EAD9     4E         	MOV	C,M            
1922: EADA     05         	DCR	B	;count it.   
1923: EADB     C5         	PUSH	B             
1924: EADC     E5         	PUSH	H             
1925: EADD     CDDAE9     	CALL	SHOWIT	;and display it.
1926: EAE0     E1         	POP	H              
1927: EAE1     C1         	POP	B              
1928: EAE2     C3D3EA     	JMP	RDBUF11        
1929: EAE5                RDBUF12:            
1930: EAE5     E5         	PUSH	H	;done with line. If we were displaying
1931: EAE6     3A65EB     	LDA	OUTFLAG	;then update cursor position.
1932: EAE9     B7         	ORA	A              
1933: EAEA     CA4CEA     	JZ	RDBUF2          
1934: EAED     2167EB     	LXI	H,CURPOS;because this line is shorter, we must
1935: EAF0     96         	SUB	M	;back up the cursor (not the screen however)
1936: EAF1     3265EB     	STA	OUTFLAG	;some number of positions.
1937: EAF4                RDBUF13:            
1938: EAF4     CDFFE9     	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1939: EAF7     2165EB     	LXI	H,OUTFLAG;zero, the screen will not be changed.
1940: EAFA     35         	DCR	M              
1941: EAFB     C2F4EA     	JNZ	RDBUF13        
1942: EAFE     C34CEA     	JMP	RDBUF2	;now just get the next character.
1943: EB01                ;                   
1944: EB01                ;   Just a normal character, put this in our buffer and echo.
1945: EB01                ;                   
1946: EB01                RDBUF14:            
1947: EB01     23         	INX	H              
1948: EB02     77         	MOV	M,A	;store character.
1949: EB03     04         	INR	B	;and count it.
1950: EB04                RDBUF15:            
1951: EB04     C5         	PUSH	B             
1952: EB05     E5         	PUSH	H             
1953: EB06     4F         	MOV	C,A	;echo it now.
1954: EB07     CDDAE9     	CALL	SHOWIT        
1955: EB0A     E1         	POP	H              
1956: EB0B     C1         	POP	B              
1957: EB0C     7E         	MOV	A,M	;was it an abort request?
1958: EB0D     FE03       	CPI	CNTRLC	;control-c abort?
1959: EB0F     78         	MOV	A,B            
1960: EB10     C218EB     	JNZ	RDBUF16        
1961: EB13     FE01       	CPI	1	;only if at start of line.
1962: EB15     CA0000     	JZ	0               
1963: EB18                RDBUF16:            
1964: EB18     B9         	CMP	C	;nope, have we filled the buffer?
1965: EB19     DA4AEA     	JC	RDBUF1          
1966: EB1C                RDBUF17:            
1967: EB1C     E1         	POP	H	;yes end the line and return.
1968: EB1D     70         	MOV	M,B            
1969: EB1E     0E0D       	MVI	C,CR           
1970: EB20     C3A3E9     	JMP	OUTCHAR	;output (cr) and return.
1971: EB23                ;                   
1972: EB23                ;   Function to get a character from the console device.
1973: EB23                ;                   
1974: EB23                GETCON:             
1975: EB23     CD61E9     	CALL	GETECHO	;get and echo.
1976: EB26     C35CEB     	JMP	SETSTAT	;save status and return.
1977: EB29                ;                   
1978: EB29                ;   Function to get a character from the tape reader device.
1979: EB29                ;                   
1980: EB29                GETRDR:             
1981: EB29     CD15F6     	CALL	READER	;get a character from reader, set status and return.
1982: EB2C     C35CEB     	JMP	SETSTAT        
1983: EB2F                ;                   
1984: EB2F                ;  Function to perform direct console i/o. If (C) contains (FF)
1985: EB2F                ; then this is an input request. If (C) contains (FE) then
1986: EB2F                ; this is a status request. Otherwise we are to output (C).
1987: EB2F                ;                   
1988: EB2F                DIRCIO:             
1989: EB2F     79         	MOV	A,C	;test for (FF).
1990: EB30     3C         	INR	A              
1991: EB31     CA3BEB     	JZ	DIRC1           
1992: EB34     3C         	INR	A	;test for (FE).
1993: EB35     CA06F6     	JZ	CONST           
1994: EB38     C30CF6     	JMP	CONOUT	;just output (C).
1995: EB3B                DIRC1:              
1996: EB3B     CD06F6     	CALL	CONST	;this is an input request.
1997: EB3E     B7         	ORA	A              
1998: EB3F     CA90E8     	JZ	BDOSExit1	;not ready? Just return (directly).
1999: EB42     CD09F6     	CALL	CONIN	;yes, get character.
2000: EB45     C35CEB     	JMP	SETSTAT	;set status and return.
2001: EB48                ;                   
2002: EB48                ;   Function to return the i/o byte.
2003: EB48                ;                   
2004: EB48                GETIOB:             
2005: EB48     3A0300     	LDA	IOBYTE         
2006: EB4B     C35CEB     	JMP	SETSTAT        
2007: EB4E                ;                   
2008: EB4E                ;   Function to set the i/o byte.
2009: EB4E                ;                   
2010: EB4E                SETIOB:             
2011: EB4E     210300     	LXI	H,IOBYTE       
2012: EB51     71         	MOV	M,C            
2013: EB52     C9         	RET                
2014: EB53                ;                   
2015: EB53                ;   Function to print the character string pointed to by (DE)
2016: EB53                ; on the console device. The string ends with a '$'.
2017: EB53                ;                   
2018: EB53                PRTSTR:             
2019: EB53     EB         	XCHG               
2020: EB54     4D         	MOV	C,L            
2021: EB55     44         	MOV	B,H	;now (BC) points to it.
2022: EB56     C32EEA     	JMP	PRTMESG        
2023: EB59                ;                   
2024: EB59                ;   Function to interigate the console device.
2025: EB59                ;                   
2026: EB59                GETCSTS:            
2027: EB59     CD7EE9     	CALL	CKCONSOL      
2028: EB5C                ;                   
2029: EB5C                ;   Get here to set the status and return to the cleanup
2030: EB5C                ; section. Then back to the user.
2031: EB5C                ;                   
2032: EB5C                SETSTAT:            
2033: EB5C     323FE8     	STA	StatusBDOSReturn
2034: EB5F                Return:             
2035: EB5F     C9         	RET                
2036: EB60                ;                   
2037: EB60                ;   Set the status to 1 (read or write error code).
2038: EB60                ;                   
2039: EB60                IOERR1:             
2040: EB60     3E01       	MVI	A,1            
2041: EB62     C35CEB     	JMP	SETSTAT        
2042: EB65                ;                   
2043: EB65     00         OUTFLAG:	DB	0	;output flag (non zero means no output).
2044: EB66     02         STARTING:	DB	2	;starting position for cursor.
2045: EB67     00         CURPOS:		DB	0	;cursor position (0=start of line).
2046: EB68     00         PRTFLAG:	DB	0	;printer flag (control-p toggle). List if non zero.
2047: EB69     00         CHARBUF:	DB	0	;single input character buffer.
2048: EB6A                ;                   
2049: EB6A                ;   Stack area for BDOS calls.
2050: EB6A                ;                   
2051: EB6A                                    
2052: EB6A                ;                   
2053: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2054: EB6A                ;	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
2055: EB6A                ;BDOSstack	EQU	$	;end of stack area.
2056: EB6A                ;                   
2057: EB6A                ;                   
2058: EB6A                ;   Select error occured, jump to error routine.
2059: EB6A                ;                   
2060: EB6A                SLCTERR:            
2061: EB6A     21EEE8     	LXI	H,BADSLCT      
2062: EB6D                ;                   
2063: EB6D                ;   Jump to (HL) indirectly.
2064: EB6D                ;                   
2065: EB6D                JUMPHL:             
2066: EB6D     5E         	MOV	E,M            
2067: EB6E     23         	INX	H              
2068: EB6F     56         	MOV	D,M	;now (DE) contain the desired address.
2069: EB70     EB         	XCHG               
2070: EB71     E9         	PCHL               
2071: EB72                ;                   
2072: EB72                ;   Block move. (DE) to (HL), (C) bytes total.
2073: EB72                ;                   
2074: EB72                DE2HL:              
2075: EB72     0C         	INR	C	;is count down to zero?
2076: EB73                DE2HL1:             
2077: EB73     0D         	DCR	C              
2078: EB74     C8         	RZ		;yes, we are done.
2079: EB75     1A         	LDAX	D	;no, move one more byte.
2080: EB76     77         	MOV	M,A            
2081: EB77     13         	INX	D              
2082: EB78     23         	INX	H              
2083: EB79     C373EB     	JMP	DE2HL1	;and repeat.
2084: EB7C                ;                   
2085: EB7C                ;   Select the desired drive.
2086: EB7C                ;                   
2087: EB7C                SelectDisk:         
2088: EB7C     3AABF5     	LDA		CurrentDrive		; get active disk.
2089: EB7F     4F         	MOV		C,A					; set up for Bios call, put disk in (C)
2090: EB80     CD1BF6     	CALL	SELDSK				; BIOS CALL )select it.
2091: EB83     7C         	MOV		A,H					; HL = 0000 if invalid
2092: EB84     B5         	ORA		L					; otherwise it points to the correct Disk Parameter Block
2093: EB85     C8         	RZ							; so, return if HL = 0000
2094: EB86                ;                   
2095: EB86                ;   Here, the BIOS returned the address of the parameter block
2096: EB86                ; in (HL). We will extract the necessary pointers and save them.
2097: EB86                ;                   
2098: EB86     5E         	MOV		E,M					; first word of DPB points to the drive's skew table
2099: EB87     23         	INX		H             
2100: EB88     56         	MOV		D,M						; Get it and put it into (DE)
2101: EB89     23         	INX		H					        
2102: EB8A     22B4F5     	SHLD	FilePosInDir		;save pointers to scratch areas.
2103: EB8D     23         	INX		H             
2104: EB8E     23         	INX		H             
2105: EB8F     22B6F5     	SHLD	LastTrackNumber		;ditto.
2106: EB92     23         	INX		H             
2107: EB93     23         	INX		H             
2108: EB94     22B8F5     	SHLD	LastSectorNumber	;ditto.
2109: EB97     23         	INX		H             
2110: EB98     23         	INX		H             
2111: EB99     EB         	XCHG						; been holding the translation table address in DE, now in HL
2112: EB9A                								; Moved Directory buffer pointer into DE (from HL
2113: EB9A     22D1F5     	SHLD	XLATE				     
2114: EB9D     21BAF5     	LXI		H,DIRBUF			; get address of the directory buffer vector
2115: EBA0     0E08       	MVI		C,8					;they consist of the directory buffer
2116: EBA2     CD72EB     	CALL	DE2HL				;pointer, parameter block pointer,
2117: EBA5     2ABCF5     	LHLD	DISKPB	;check and allocation vectors. (* DISK PARAMTER BLOCK POINTER)
2118: EBA8     EB         	XCHG					; put into DE
2119: EBA9     21C2F5     	LXI	H,SECTORS	;get Sectors per Block
2120: EBAC     0E0F       	MVI	C,15	;it is 15 bytes long. 
2121: EBAE     CD72EB     	CALL	DE2HL	;( move disk parameter block from BIOS to BDOS for current disk)
2122: EBB1     2AC7F5     	LHLD	DSKSIZE	;check disk size.
2123: EBB4     7C         	MOV	A,H	;more than 256 blocks on this?
2124: EBB5     21DDF5     	LXI	H,BIGDISK		;(should be called SmallDisk [ if BIGDISK =0 then > 256 block long])
2125: EBB8     36FF       	MVI	M,0FFH	;set to samll.
2126: EBBA     B7         	ORA	A              
2127: EBBB     CAC0EB     	JZ	SelectDisk1     
2128: EBBE     3600       	MVI	M,0	;wrong, set to large.
2129: EBC0                SelectDisk1:        
2130: EBC0     3EFF       	MVI	A,0FFH	;clear the zero flag.
2131: EBC2     B7         	ORA	A              
2132: EBC3     C9         	RET                
2133: EBC4                ;                   
2134: EBC4                ;   Routine to home the disk track head and clear pointers.
2135: EBC4                ;                   
2136: EBC4                HOMEDRV:            
2137: EBC4     CD18F6     	CALL	HOME	;home the head.
2138: EBC7     AF         	XRA	A              
2139: EBC8     2AB6F5     	LHLD	LastTrackNumber;set our track pointer also.
2140: EBCB     77         	MOV	M,A            
2141: EBCC     23         	INX	H              
2142: EBCD     77         	MOV	M,A            
2143: EBCE     2AB8F5     	LHLD	LastSectorNumber;and our sector pointer.
2144: EBD1     77         	MOV	M,A            
2145: EBD2     23         	INX	H              
2146: EBD3     77         	MOV	M,A            
2147: EBD4     C9         	RET                
2148: EBD5                ;                   
2149: EBD5                ;   Do the actual disk read and check the error return status.
2150: EBD5                ;                   
2151: EBD5                DOREAD:             
2152: EBD5     CD27F6     	CALL	READ          
2153: EBD8     C3DEEB     	JMP	IORET          
2154: EBDB                ;                   
2155: EBDB                ;   Do the actual disk write and handle any bios error.
2156: EBDB                ;                   
2157: EBDB                DOWRITE:            
2158: EBDB     CD2AF6     	CALL	WRITE         
2159: EBDE                IORET:              
2160: EBDE     B7         	ORA	A              
2161: EBDF     C8         	RZ		;return unless an error occured.
2162: EBE0     21ECE8     	LXI	H,BADSCTR;bad read/write on this sector.
2163: EBE3     C36DEB     	JMP	JUMPHL         
2164: EBE6                ;                   
2165: EBE6                ;   Routine to select the track and sector that the desired
2166: EBE6                ; block number falls in.
2167: EBE6                ;                   
2168: EBE6                TRKSEC:             
2169: EBE6     2AEAF5     	LHLD	FILEPOS			; get position of last accessed file
2170: EBE9     0E02       	MVI		C,2				; in directory and compute sector #.
2171: EBEB     CD0DED     	CALL	SHIFTR			; sector #=file-position/4.
2172: EBEE     22E5F5     	SHLD	BLKNMBR			; save this as the block number of interest.
2173: EBF1     22ECF5     	SHLD	CKSUMTBL		; what's it doing here too?
2174: EBF4                ;                   
2175: EBF4                ;   if the sector number has already been set (BLKNMBR), enter
2176: EBF4                ; at this point.    
2177: EBF4                ;                   
2178: EBF4                TRKSEC1:            
2179: EBF4                		;move Desired sector number into (BC).
2180: EBF4     21E5F5     	LXI		H,BLKNMBR     
2181: EBF7     4E         	MOV		C,M				       
2182: EBF8     23         	INX		H             
2183: EBF9     46         	MOV		B,M           
2184: EBFA                		;move Last sector number into (DE).
2185: EBFA     2AB8F5     	LHLD	LastSectorNumber
2186: EBFD     5E         	MOV		E,M	          
2187: EBFE     23         	INX		H             
2188: EBFF     56         	MOV		D,M           
2189: EC00                		;move current track number into (HL).
2190: EC00     2AB6F5     	LHLD	LastTrackNumber
2191: EC03     7E         	MOV		A,M           
2192: EC04     23         	INX		H             
2193: EC05     66         	MOV		H,M           
2194: EC06     6F         	MOV		L,A           
2195: EC07                	                   
2196: EC07                TRKSEC2:            
2197: EC07     79         	MOV		A,C			;is desired sector before current one?
2198: EC08     93         	SUB		E             
2199: EC09     78         	MOV		A,B           
2200: EC0A     9A         	SBB		D             
2201: EC0B     D21DEC     	JNC		TRKSEC3       
2202: EC0E     E5         	PUSH	H			;yes, decrement sectors by one track.
2203: EC0F     2AC2F5     	LHLD	SECTORS		;get sectors per track.
2204: EC12     7B         	MOV		A,E           
2205: EC13     95         	SUB		L             
2206: EC14     5F         	MOV		E,A           
2207: EC15     7A         	MOV		A,D           
2208: EC16     9C         	SBB		H             
2209: EC17     57         	MOV		D,A			;now we have backed up one full track.
2210: EC18     E1         	POP		H             
2211: EC19     2B         	DCX		H			;adjust track counter.
2212: EC1A     C307EC     	JMP		TRKSEC2       
2213: EC1D                TRKSEC3:            
2214: EC1D     E5         	PUSH	H			;desired sector is after current one.
2215: EC1E     2AC2F5     	LHLD	SECTORS		;get sectors per track.
2216: EC21     19         	DAD	D				;bump sector pointer to next track.
2217: EC22     DA32EC     	JC		TRKSEC4        
2218: EC25     79         	MOV		A,C			;is desired sector now before current one?
2219: EC26     95         	SUB		L             
2220: EC27     78         	MOV		A,B           
2221: EC28     9C         	SBB		H             
2222: EC29     DA32EC     	JC		TRKSEC4        
2223: EC2C     EB         	XCHG				;not yes, increment track counter
2224: EC2D     E1         	POP		H			;and continue until it is.
2225: EC2E     23         	INX		H             
2226: EC2F     C31DEC     	JMP		TRKSEC3       
2227: EC32                ;                   
2228: EC32                ;   here we have determined the track number that contains the
2229: EC32                ; desired sector.   
2230: EC32                ;                   
2231: EC32                TRKSEC4:            
2232: EC32     E1         	POP		H			;get track number (HL).
2233: EC33     C5         	PUSH	B             
2234: EC34     D5         	PUSH	D             
2235: EC35     E5         	PUSH	H             
2236: EC36     EB         	XCHG               
2237: EC37     2ACFF5     	LHLD	OFFSET		;adjust for first track offset.
2238: EC3A     19         	DAD		D             
2239: EC3B     44         	MOV		B,H           
2240: EC3C     4D         	MOV		C,L           
2241: EC3D     CD1EF6     	CALL	SETTRK		;select this track.
2242: EC40     D1         	POP		D			;reset current track pointer.
2243: EC41     2AB6F5     	LHLD	LastTrackNumber
2244: EC44     73         	MOV		M,E           
2245: EC45     23         	INX		H             
2246: EC46     72         	MOV		M,D           
2247: EC47     D1         	POP		D             
2248: EC48     2AB8F5     	LHLD	LastSectorNumber	;reset the first sector on this track.
2249: EC4B     73         	MOV		M,E           
2250: EC4C     23         	INX		H             
2251: EC4D     72         	MOV		M,D           
2252: EC4E     C1         	POP		B             
2253: EC4F     79         	MOV		A,C			;now subtract the desired one.
2254: EC50     93         	SUB		E			;to make it relative (1-# sectors/track).
2255: EC51     4F         	MOV		C,A           
2256: EC52     78         	MOV		A,B           
2257: EC53     9A         	SBB		D             
2258: EC54     47         	MOV		B,A           
2259: EC55     2AD1F5     	LHLD	XLATE		;translate this sector according to this table.
2260: EC58     EB         	XCHG               
2261: EC59     CD30F6     	CALL	SECTRN		;let the bios translate it.
2262: EC5C     4D         	MOV		C,L           
2263: EC5D     44         	MOV		B,H           
2264: EC5E     C321F6     	JMP		SETSEC		;and select it.
2265: EC61                ;                   
2266: EC61                ;   Compute block number from record number (SAVNREC) and
2267: EC61                ; extent number (SAVEXT).
2268: EC61                ;                   
2269: EC61                GETBLOCK:           
2270: EC61     21C4F5     	LXI	H,BLKSHFT;get logical to physical conversion.
2271: EC64     4E         	MOV	C,M	;note that this is base 2 log of ratio.
2272: EC65     3AE3F5     	LDA	SAVNREC	;get record number.
2273: EC68                GETBLK1:            
2274: EC68     B7         	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2275: EC69     1F         	RAR                
2276: EC6A     0D         	DCR	C              
2277: EC6B     C268EC     	JNZ	GETBLK1        
2278: EC6E     47         	MOV	B,A	;save result in (B).
2279: EC6F     3E08       	MVI	A,8            
2280: EC71     96         	SUB	M              
2281: EC72     4F         	MOV	C,A	;compute (C)=8-BLKSHFT.
2282: EC73     3AE2F5     	LDA	SAVEXT         
2283: EC76                GETBLK2:            
2284: EC76     0D         	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2285: EC77     CA7FEC     	JZ	GETBLK3         
2286: EC7A     B7         	ORA	A              
2287: EC7B     17         	RAL                
2288: EC7C     C376EC     	JMP	GETBLK2        
2289: EC7F                GETBLK3:            
2290: EC7F     80         	ADD	B              
2291: EC80     C9         	RET                
2292: EC81                ;                   
2293: EC81                ;   Routine to extract the (BC) block byte from the fcb pointed
2294: EC81                ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2295: EC81                ; block numbers, else they are 8 bit numbers.
2296: EC81                ; Number is returned in (HL).
2297: EC81                ;                   
2298: EC81                EXTBLK:             
2299: EC81     2A3CE8     	LHLD	ParamsDE	;get fcb address.
2300: EC84     111000     	LXI	D,16	;block numbers start 16 bytes into fcb.
2301: EC87     19         	DAD	D              
2302: EC88     09         	DAD	B              
2303: EC89     3ADDF5     	LDA	BIGDISK	;are we using a big-disk?
2304: EC8C     B7         	ORA	A              
2305: EC8D     CA94EC     	JZ	EXTBLK1         
2306: EC90     6E         	MOV	L,M	;no, extract an 8 bit number from the fcb.
2307: EC91     2600       	MVI	H,0            
2308: EC93     C9         	RET                
2309: EC94                EXTBLK1:            
2310: EC94     09         	DAD	B	;yes, extract a 16 bit number.
2311: EC95     5E         	MOV	E,M            
2312: EC96     23         	INX	H              
2313: EC97     56         	MOV	D,M            
2314: EC98     EB         	XCHG		;return in (HL).
2315: EC99     C9         	RET                
2316: EC9A                ;                   
2317: EC9A                ;   Compute block number.
2318: EC9A                ;                   
2319: EC9A                COMBLK:             
2320: EC9A     CD61EC     	CALL	GETBLOCK      
2321: EC9D     4F         	MOV	C,A            
2322: EC9E     0600       	MVI	B,0            
2323: ECA0     CD81EC     	CALL	EXTBLK        
2324: ECA3     22E5F5     	SHLD	BLKNMBR       
2325: ECA6     C9         	RET                
2326: ECA7                ;                   
2327: ECA7                ;   Check for a zero block number (unused).
2328: ECA7                ;                   
2329: ECA7                CHKBLK:             
2330: ECA7     2AE5F5     	LHLD	BLKNMBR       
2331: ECAA     7D         	MOV	A,L	;is it zero?
2332: ECAB     B4         	ORA	H              
2333: ECAC     C9         	RET                
2334: ECAD                ;                   
2335: ECAD                ;   Adjust physical block (BLKNMBR) and convert to logical
2336: ECAD                ; sector (LOGSECT). This is the starting sector of this block.
2337: ECAD                ; The actual sector of interest is then added to this and the
2338: ECAD                ; resulting sector number is stored back in (BLKNMBR). This
2339: ECAD                ; will still have to be adjusted for the track number.
2340: ECAD                ;                   
2341: ECAD                LOGICAL:            
2342: ECAD     3AC4F5     	LDA	BLKSHFT	;get log2(physical/logical sectors).
2343: ECB0     2AE5F5     	LHLD	BLKNMBR	;get physical sector desired.
2344: ECB3                LOGICL1:            
2345: ECB3     29         	DAD	H	;compute logical sector number.
2346: ECB4     3D         	DCR	A	;note logical sectors are 128 bytes long.
2347: ECB5     C2B3EC     	JNZ	LOGICL1        
2348: ECB8     22E7F5     	SHLD	LOGSECT	;save logical sector.
2349: ECBB     3AC5F5     	LDA	BLKMASK	;get block mask.
2350: ECBE     4F         	MOV	C,A            
2351: ECBF     3AE3F5     	LDA	SAVNREC	;get next sector to access.
2352: ECC2     A1         	ANA	C	;extract the relative position within physical block.
2353: ECC3     B5         	ORA	L	;and add it too logical sector.
2354: ECC4     6F         	MOV	L,A            
2355: ECC5     22E5F5     	SHLD	BLKNMBR	;and store.
2356: ECC8     C9         	RET                
2357: ECC9                ;                   
2358: ECC9                ;   Set (HL) to point to extent byte in fcb.
2359: ECC9                ;                   
2360: ECC9                SETEXT:             
2361: ECC9     2A3CE8     	LHLD	ParamsDE      
2362: ECCC     110C00     	LXI	D,12	;it is the twelth byte.
2363: ECCF     19         	DAD	D              
2364: ECD0     C9         	RET                
2365: ECD1                ;                   
2366: ECD1                ;   Set (HL) to point to record count byte in fcb and (DE) to
2367: ECD1                ; next record number byte.
2368: ECD1                ;                   
2369: ECD1                SETHLDE:            
2370: ECD1     2A3CE8     	LHLD	ParamsDE      
2371: ECD4     110F00     	LXI	D,15	;record count byte (#15).
2372: ECD7     19         	DAD	D              
2373: ECD8     EB         	XCHG               
2374: ECD9     211100     	LXI	H,17	;next record number (#32).
2375: ECDC     19         	DAD	D              
2376: ECDD     C9         	RET                
2377: ECDE                ;                   
2378: ECDE                ;   Save current file data from fcb.
2379: ECDE                ;                   
2380: ECDE                STRDATA:            
2381: ECDE     CDD1EC     	CALL	SETHLDE       
2382: ECE1     7E         	MOV	A,M	;get and store record count byte.
2383: ECE2     32E3F5     	STA	SAVNREC        
2384: ECE5     EB         	XCHG               
2385: ECE6     7E         	MOV	A,M	;get and store next record number byte.
2386: ECE7     32E1F5     	STA	SAVNXT         
2387: ECEA     CDC9EC     	CALL	SETEXT	;point to extent byte.
2388: ECED     3AC6F5     	LDA	EXTMASK	;get extent mask.
2389: ECF0     A6         	ANA	M              
2390: ECF1     32E2F5     	STA	SAVEXT	;and save extent here.
2391: ECF4     C9         	RET                
2392: ECF5                ;                   
2393: ECF5                ;   Set the next record to access. If (MODE) is set to 2, then
2394: ECF5                ; the last record byte (SAVNREC) has the correct number to access.
2395: ECF5                ; For sequential access, (MODE) will be equal to 1.
2396: ECF5                ;                   
2397: ECF5                SETNREC:            
2398: ECF5     CDD1EC     	CALL	SETHLDE       
2399: ECF8     3AD6F5     	LDA	MODE	;get sequential flag (=1).
2400: ECFB     FE02       	CPI	2	;a 2 indicates that no adder is needed.
2401: ECFD     C201ED     	JNZ	STNREC1        
2402: ED00     AF         	XRA	A	;clear adder (random access?).
2403: ED01                STNREC1:            
2404: ED01     4F         	MOV	C,A            
2405: ED02     3AE3F5     	LDA	SAVNREC	;get last record number.
2406: ED05     81         	ADD	C	;increment record count.
2407: ED06     77         	MOV	M,A	;and set fcb's next record byte.
2408: ED07     EB         	XCHG               
2409: ED08     3AE1F5     	LDA	SAVNXT	;get next record byte from storage.
2410: ED0B     77         	MOV	M,A	;and put this into fcb as number of records used.
2411: ED0C     C9         	RET                
2412: ED0D                ;                   
2413: ED0D                ;   Shift HL right (C) bits.
2414: ED0D                ;                   
2415: ED0D                SHIFTR:             
2416: ED0D     0C         	INR		C			; minor adjustment
2417: ED0E                SHIFTR1:            
2418: ED0E     0D         	DCR		C			; count down
2419: ED0F     C8         	RZ					; exit if done
2420: ED10     7C         	MOV		A,H			; get the hi byte
2421: ED11     B7         	ORA		A			; reset carry bit
2422: ED12     1F         	RAR					; rotate right thru carry
2423: ED13     67         	MOV		H,A			; return new hi byte
2424: ED14     7D         	MOV		A,L			; get lo byte
2425: ED15     1F         	RAR					; rotate right thru carry
2426: ED16     6F         	MOV		L,A			; return new lo byte
2427: ED17     C30EED     	JMP		SHIFTR1		; keep doing it
2428: ED1A                ;                   
2429: ED1A                ;   Compute the check-sum for the directory buffer. Return
2430: ED1A                ; integer sum in (A).
2431: ED1A                ;                   
2432: ED1A                CHECKSUM:           
2433: ED1A     0E80       	MVI	C,128	;length of buffer.
2434: ED1C     2ABAF5     	LHLD	DIRBUF	;get its location.
2435: ED1F     AF         	XRA	A	;clear summation byte.
2436: ED20                CHKSUM1:            
2437: ED20     86         	ADD	M	;and compute sum ignoring carries.
2438: ED21     23         	INX	H              
2439: ED22     0D         	DCR	C              
2440: ED23     C220ED     	JNZ	CHKSUM1        
2441: ED26     C9         	RET                
2442: ED27                ;                   
2443: ED27                ;   Shift (HL) left (C) bits.
2444: ED27                ;                   
2445: ED27                SHIFTL:             
2446: ED27     0C         	INR	C              
2447: ED28                SHIFTL1:            
2448: ED28     0D         	DCR	C              
2449: ED29     C8         	RZ                 
2450: ED2A     29         	DAD	H	;shift left 1 bit.
2451: ED2B     C328ED     	JMP	SHIFTL1        
2452: ED2E                                    
2453: ED2E                ;                   
2454: ED2E                ;   Extract the write protect status bit for the current drive.
2455: ED2E                ; The result is returned in (A), bit 0.
2456: ED2E                ;                   
2457: ED2E                GETWPRT:            
2458: ED2E     2AAEF5     	LHLD	ROBitMap		;get Read Only Bit Map
2459: ED31     3AABF5     	LDA		CurrentDrive	;which drive is current?
2460: ED34     4F         	MOV		C,A           
2461: ED35     CD0DED     	CALL	SHIFTR			;shift status such that bit 0 is the
2462: ED38     7D         	MOV		A,L				;one of interest for this drive.
2463: ED39     E601       	ANI		01H				;and isolate it.
2464: ED3B     C9         	RET						; Zero if not write protected
2465: ED3C                ;                   
2466: ED3C                ;   Function to write protect the current disk.
2467: ED3C                ;                   
2468: ED3C                WRTPRTD:            
2469: ED3C     21AEF5     	LXI	H,ROBitMap	;point to Read Only Bit Map
2470: ED3F     4E         	MOV	C,M	;set (BC) equal to the status.
2471: ED40     23         	INX	H              
2472: ED41     46         	MOV	B,M            
2473: ED42     CD57F4     	CALL	SETBIT	;and set this bit according to current drive.
2474: ED45     22AEF5     	SHLD	ROBitMap	;then save.
2475: ED48     2AC9F5     	LHLD	DIRSIZE	;now save directory size limit.
2476: ED4B     23         	INX	H	;remember the last one.
2477: ED4C     EB         	XCHG               
2478: ED4D     2AB4F5     	LHLD	FilePosInDir;and store it here.
2479: ED50     73         	MOV	M,E	;put low byte.
2480: ED51     23         	INX	H              
2481: ED52     72         	MOV	M,D	;then high byte.
2482: ED53     C9         	RET                
2483: ED54                ;                   
2484: ED54                ;   Check for a read only file.
2485: ED54                ;                   
2486: ED54                CHKROFL:            
2487: ED54     CD6EED     	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2488: ED57                CKROF1:             
2489: ED57     110900     	LXI	D,9	;look at bit 7 of the ninth byte.
2490: ED5A     19         	DAD	D              
2491: ED5B     7E         	MOV	A,M            
2492: ED5C     17         	RAL                
2493: ED5D     D0         	RNC		;return if ok.
2494: ED5E     21F2E8     	LXI	H,ROFILE;else, print error message and terminate.
2495: ED61     C36DEB     	JMP	JUMPHL         
2496: ED64                ;                   
2497: ED64                ;   Check the write protect status of the active disk.
2498: ED64                ;                   
2499: ED64                CHKWPRT:            
2500: ED64     CD2EED     	CALL	GETWPRT			; is it write protected ?
2501: ED67     C8         	RZ						; NO, return.
2502: ED68     21F0E8     	LXI		H,RODISK      
2503: ED6B     C36DEB     	JMP	JUMPHL		; else print message and terminate.
2504: ED6E                ;                   
2505: ED6E                ;   Routine to set (HL) pointing to the proper entry in the
2506: ED6E                ; directory buffer. 
2507: ED6E                ;                   
2508: ED6E                FCB2HL:             
2509: ED6E     2ABAF5     	LHLD	DIRBUF		;get address of buffer.
2510: ED71     3AE9F5     	LDA		FCBPOS		;relative position of file.
2511: ED74                ;                   
2512: ED74                ;   Routine to add (A) to (HL).
2513: ED74                ;                   
2514: ED74                ADDA2HL:            
2515: ED74     85         	ADD		L             
2516: ED75     6F         	MOV		L,A           
2517: ED76     D0         	RNC	               
2518: ED77     24         	INR		H			;take care of any carry.
2519: ED78     C9         	RET                
2520: ED79                ;                   
2521: ED79                ;   Routine to get the 's2' byte(Extent Count) from the fcb supplied in
2522: ED79                ; the initial parameter specification.
2523: ED79                ;                   
2524: ED79                GETS2:              
2525: ED79     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
2526: ED7C     110E00     	LXI		D,14		;relative position of 's2'.
2527: ED7F     19         	DAD		D             
2528: ED80     7E         	MOV		A,M			;extract this byte.
2529: ED81     C9         	RET                
2530: ED82                ;                   
2531: ED82                ;   Clear the 's2' byte in the fcb.
2532: ED82                ;                   
2533: ED82                CLEARS2:            
2534: ED82     CD79ED     	CALL	GETS2		;this sets (HL) pointing to it.
2535: ED85     3600       	MVI		M,0			;now clear it.
2536: ED87     C9         	RET                
2537: ED88                ;                   
2538: ED88                ;   Set bit 7 in the 's2' byte of the fcb.
2539: ED88                ;                   
2540: ED88                SETS2B7:            
2541: ED88     CD79ED     	CALL	GETS2		;get the byte.
2542: ED8B     F680       	ORI		80H			;and set bit 7.
2543: ED8D     77         	MOV		M,A			;then store.
2544: ED8E     C9         	RET                
2545: ED8F                ;                   
2546: ED8F                ;   Compare (FILEPOS) with (FilePosInDir) and set flags based on
2547: ED8F                ; the difference. This checks to see if there are more file
2548: ED8F                ; names in the directory. We are at (FILEPOS) and there are
2549: ED8F                ; (FilePosInDir) of them to check.
2550: ED8F                ;                   
2551: ED8F                MOREFLS:            
2552: ED8F     2AEAF5     	LHLD	FILEPOS			;we are here.
2553: ED92     EB         	XCHG               
2554: ED93     2AB4F5     	LHLD	FilePosInDir	;and don't go past here.
2555: ED96     7B         	MOV		A,E				;compute difference but don't keep.
2556: ED97     96         	SUB		M             
2557: ED98     23         	INX		H             
2558: ED99     7A         	MOV		A,D           
2559: ED9A     9E         	SBB		M				;set carry if no more names.
2560: ED9B     C9         	RET                
2561: ED9C                ;                   
2562: ED9C                ;   Call this routine to prevent (FilePosInDir) from being greater
2563: ED9C                ; than (FILEPOS).   
2564: ED9C                ;                   
2565: ED9C                CHKNMBR:            
2566: ED9C     CD8FED     	CALL	MOREFLS		;FilePosInDir too big?
2567: ED9F     D8         	RC                 
2568: EDA0     13         	INX		D		;yes, reset it to (FILEPOS).
2569: EDA1     72         	MOV		M,D           
2570: EDA2     2B         	DCX		H             
2571: EDA3     73         	MOV		M,E           
2572: EDA4     C9         	RET                
2573: EDA5                ;                   
2574: EDA5                ;   Compute (HL)=(DE)-(HL)
2575: EDA5                ;                   
2576: EDA5                SUBHL:              
2577: EDA5     7B         	MOV		A,E		;compute difference.
2578: EDA6     95         	SUB		L             
2579: EDA7     6F         	MOV		L,A		;store low byte.
2580: EDA8     7A         	MOV		A,D           
2581: EDA9     9C         	SBB		H             
2582: EDAA     67         	MOV		H,A		;and then high byte.
2583: EDAB     C9         	RET                
2584: EDAC                ;                   
2585: EDAC                ;   Set the directory checksum byte.
2586: EDAC                ;                   
2587: EDAC                SETDIR:             
2588: EDAC     0EFF       	MVI	C,0FFH         
2589: EDAE                ;                   
2590: EDAE                ;   Routine to set or compare the directory checksum byte. If
2591: EDAE                ; (C)=0ffh, then this will set the checksum byte. Else the byte
2592: EDAE                ; will be checked. If the check fails (the disk has been changed),
2593: EDAE                ; then this disk will be write protected.
2594: EDAE                ;                   
2595: EDAE                CHECKDIR:           
2596: EDAE     2AECF5     	LHLD	CKSUMTBL      
2597: EDB1     EB         	XCHG               
2598: EDB2     2ACDF5     	LHLD	ALLOC1        
2599: EDB5     CDA5ED     	CALL	SUBHL         
2600: EDB8     D0         	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2601: EDB9     C5         	PUSH	B             
2602: EDBA     CD1AED     	CALL	CHECKSUM;else compute checksum.
2603: EDBD     2ABEF5     	LHLD	CHKVECT	;get address of checksum table.
2604: EDC0     EB         	XCHG               
2605: EDC1     2AECF5     	LHLD	CKSUMTBL      
2606: EDC4     19         	DAD	D	;set (HL) to point to byte for this drive.
2607: EDC5     C1         	POP	B              
2608: EDC6     0C         	INR	C	;set or check ?
2609: EDC7     CAD4ED     	JZ	CHKDIR1         
2610: EDCA     BE         	CMP	M	;check them. 
2611: EDCB     C8         	RZ		;return if they are the same.
2612: EDCC     CD8FED     	CALL	MOREFLS	;not the same, do we care?
2613: EDCF     D0         	RNC                
2614: EDD0     CD3CED     	CALL	WRTPRTD	;yes, mark this as write protected.
2615: EDD3     C9         	RET                
2616: EDD4                CHKDIR1:            
2617: EDD4     77         	MOV	M,A	;just set the byte.
2618: EDD5     C9         	RET                
2619: EDD6                ;                   
2620: EDD6                ;   Do a write to the directory of the current disk.
2621: EDD6                ;                   
2622: EDD6                DIRWRITE:           
2623: EDD6     CDACED     	CALL	SETDIR			;set checksum byte.
2624: EDD9     CDF0ED     	CALL	SetDirDMA		;set directory dma address.
2625: EDDC     0E01       	MVI		C,1				;tell the bios to actually write.
2626: EDDE     CDDBEB     	CALL	DOWRITE			;then do the write.
2627: EDE1     C3EAED     	JMP		Set2UsersDMA  
2628: EDE4                ;                   
2629: EDE4                ;   Read from the directory.
2630: EDE4                ;                   
2631: EDE4                DIRREAD:            
2632: EDE4     CDF0ED     	CALL	SetDirDMA	;set the directory dma address.
2633: EDE7     CDD5EB     	CALL	DOREAD	;and read it.
2634: EDEA                ;                   
2635: EDEA                ;   Routine to set the dma address to the users choice.
2636: EDEA                ;                   
2637: EDEA                Set2UsersDMA:       
2638: EDEA     21B2F5     	LXI		H,UsersDMA		;reset the default dma address and return.
2639: EDED     C3F3ED     	JMP		SetDMA0       
2640: EDF0                ;                   
2641: EDF0                ;   Routine to set the dma address for directory work.
2642: EDF0                ;                   
2643: EDF0                SetDirDMA:          
2644: EDF0     21BAF5     	LXI		H,DIRBUF      
2645: EDF3                ;                   
2646: EDF3                ;   Set the dma address. On entry, (HL) points to
2647: EDF3                ; word containing the desired dma address.
2648: EDF3                ;                   
2649: EDF3                SetDMA0:            
2650: EDF3     4E         	MOV		C,M           
2651: EDF4     23         	INX		H             
2652: EDF5     46         	MOV		B,M			;setup (BC) and go to the bios to set it.
2653: EDF6     C324F6     	JMP		SETDMA        
2654: EDF9                ;                   
2655: EDF9                ;   Move the directory buffer into user's dma space.
2656: EDF9                ;                   
2657: EDF9                MOVEDIR:            
2658: EDF9     2ABAF5     	LHLD	DIRBUF	;buffer is located here, and
2659: EDFC     EB         	XCHG               
2660: EDFD     2AB2F5     	LHLD	UsersDMA; put it here.
2661: EE00     0E80       	MVI	C,128	;this is its length.
2662: EE02     C372EB     	JMP	DE2HL	;move it now and return.
2663: EE05                ;                   
2664: EE05                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2665: EE05                ;                   
2666: EE05                CKFILPOS:           
2667: EE05     21EAF5     	LXI	H,FILEPOS      
2668: EE08     7E         	MOV	A,M            
2669: EE09     23         	INX	H              
2670: EE0A     BE         	CMP	M	;are both bytes the same?
2671: EE0B     C0         	RNZ                
2672: EE0C     3C         	INR	A	;yes, but are they each 0ffh?
2673: EE0D     C9         	RET                
2674: EE0E                ;                   
2675: EE0E                ;   Set location (FILEPOS) to 0ffffh.
2676: EE0E                ;                   
2677: EE0E                STFILPOS:           
2678: EE0E     21FFFF     	LXI	H,-1           
2679: EE11     22EAF5     	SHLD	FILEPOS       
2680: EE14     C9         	RET                
2681: EE15                ;                   
2682: EE15                ;   Move on to the next file position within the current
2683: EE15                ; directory buffer. If no more exist, set pointer to 0ffffh
2684: EE15                ; and the calling routine will check for this. Enter with (C)
2685: EE15                ; equal to 0ffh to cause the checksum byte to be set, else we
2686: EE15                ; will check this disk and set write protect if checksums are
2687: EE15                ; not the same (applies only if another directory sector must
2688: EE15                ; be read).         
2689: EE15                ;                   
2690: EE15                NXENTRY:            
2691: EE15     2AC9F5     	LHLD	DIRSIZE		; Get directory entry size limit.
2692: EE18     EB         	XCHG               
2693: EE19     2AEAF5     	LHLD	FILEPOS		; Get index into directory.
2694: EE1C     23         	INX		H			; Point at the next one
2695: EE1D     22EAF5     	SHLD	FILEPOS		; Save it
2696: EE20     CDA5ED     	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
2697: EE23     D229EE     	JNC		NXENTRY1	; Are there any more entries?
2698: EE26     C30EEE     	JMP		STFILPOS	; No. - Set this flag and return.
2699: EE29                	                   
2700: EE29                NXENTRY1:           
2701: EE29     3AEAF5     	LDA		FILEPOS		; Get current index for dirctory directory.
2702: EE2C     E603       	ANI		03H			;only look within this sector (only 4 entries fit).
2703: EE2E     0605       	MVI		B,5			;convert to relative position (32 bytes each).
2704: EE30                NXENTRY2:           
2705: EE30     87         	ADD		A			;note that this is not efficient code.
2706: EE31     05         	DCR		B			;5 'ADD A's would be better.
2707: EE32     C230EE     	JNZ		NXENTRY2      
2708: EE35                	                   
2709: EE35     32E9F5     	STA		FCBPOS		;save it as position of fcb.
2710: EE38     B7         	ORA		A             
2711: EE39     C0         	RNZ					;return if we are within buffer.
2712: EE3A     C5         	PUSH	B             
2713: EE3B     CDE6EB     	CALL	TRKSEC		;we need the next directory sector.
2714: EE3E     CDE4ED     	CALL	DIRREAD       
2715: EE41     C1         	POP		B             
2716: EE42     C3AEED     	JMP		CHECKDIR      
2717: EE45                ;                   
2718: EE45                ;   Routine to to get a bit from the disk space allocation
2719: EE45                ; map. It is returned in (A), bit position 0. On entry to here,
2720: EE45                ; set (BC) to the block number on the disk to check.
2721: EE45                ; On return, (D) will contain the original bit position for
2722: EE45                ; this block number and (HL) will point to the address for it.
2723: EE45                ;                   
2724: EE45                CKBITMAP:           
2725: EE45     79         	MOV		A,C			; Determine block number of interest.
2726: EE46     E607       	ANI		07H			; Y = X and 7.
2727: EE48     3C         	INR		A			; Z = y + 1.
2728: EE49     5F         	MOV		E,A			; Save particular bit number.
2729: EE4A     57         	MOV		D,A			; save it again
2730: EE4B                ;                   
2731: EE4B                ;   compute (BC)=(BC)/8.
2732: EE4B                ;   to determin in which Allocation block the number resides
2733: EE4B                ;                   
2734: EE4B     79         	MOV		A,C			; get the block
2735: EE4C     0F         	RRC					;now shift right 3 bits.
2736: EE4D     0F         	RRC                
2737: EE4E     0F         	RRC                
2738: EE4F     E61F       	ANI		1FH			;and clear bits 7,6,5.
2739: EE51     4F         	MOV		C,A           
2740: EE52     78         	MOV		A,B           
2741: EE53     87         	ADD		A			;now shift (B) into bits 7,6,5.
2742: EE54     87         	ADD		A             
2743: EE55     87         	ADD		A             
2744: EE56     87         	ADD		A             
2745: EE57     87         	ADD		A             
2746: EE58     B1         	ORA		C			;and add in (C).
2747: EE59     4F         	MOV		C,A			;ok, (C) has been completed.
2748: EE5A     78         	MOV		A,B			;is there a better way of doing this?
2749: EE5B     0F         	RRC                
2750: EE5C     0F         	RRC                
2751: EE5D     0F         	RRC                
2752: EE5E     E61F       	ANI		1FH           
2753: EE60     47         	MOV		B,A			;and now (B) is completed.
2754: EE61                ;                   
2755: EE61                ;   use this as an offset into the disk space allocation
2756: EE61                ; table.            
2757: EE61                ;                   
2758: EE61     2AC0F5     	LHLD	ALOCVECT      
2759: EE64     09         	DAD	B              
2760: EE65     7E         	MOV	A,M	;now get correct byte.
2761: EE66                CKBMAP1:            
2762: EE66     07         	RLC		;get correct bit into position 0.
2763: EE67     1D         	DCR	E              
2764: EE68     C266EE     	JNZ	CKBMAP1        
2765: EE6B     C9         	RET                
2766: EE6C                ;                   
2767: EE6C                ;   Set or clear the bit map such that block number (BC) will be marked
2768: EE6C                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2769: EE6C                ; 1 then it will be set (don't use anyother values).
2770: EE6C                ;                   
2771: EE6C                STBITMAP:           
2772: EE6C                ;	PUSH	D				; Save Set/Clear indicator
2773: EE6C     CD45EE     	CALL	CKBITMAP		; Get the byte of interest.
2774: EE6F     E6FE       	ANI		0FEH			; clear the affected bit.
2775: EE71     4F         	MOV		C,A				; Save it in C
2776: EE72     3AACF5     	LDA		BitSetFlag		; get the flag
2777: EE75     B1         	ORA		C				; and now set(01)/reset(01) acording to flag
2778: EE76                ;	POP	B             
2779: EE76                ;	ORA	C	;and now set it acording to (C).
2780: EE76                ;                   
2781: EE76                ;  entry to restore the original bit position and then store
2782: EE76                ; in table. (A) contains the value, (D) contains the bit
2783: EE76                ; position (1-8), and (HL) points to the address within the
2784: EE76                ; space allocation table for this byte.
2785: EE76                ;                   
2786: EE76                STBMAP1:            
2787: EE76     0F         	RRC		;restore original bit position.
2788: EE77     15         	DCR	D              
2789: EE78     C276EE     	JNZ	STBMAP1        
2790: EE7B     77         	MOV	M,A	;and stor byte in table.
2791: EE7C     C9         	RET                
2792: EE7D                ;                   
2793: EE7D                ;   Set/clear space used bits in allocation map for this file.
2794: EE7D                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2795: EE7D                ;                   
2796: EE7D                SETFILE:            
2797: EE7D     CD6EED     	CALL	FCB2HL			; Get address of fcb
2798: EE80     111000     	LXI		D,16			; Offset to Block Pointers in Directory entry
2799: EE83     19         	DAD		D				; Compute start to block number bytes. (A1..A10)
2800: EE84                ;	PUSH	B				; Save Set/Clear indicator 
2801: EE84     0E11       	MVI		C,17			; Check all 16 bytes (max) of table.
2802: EE86                SETFL1:             
2803: EE86                ;	POP		D				; Retreive Set/Clear indicator
2804: EE86     0D         	DCR		C				; Counter
2805: EE87     C8         	RZ						; Done?, then return
2806: EE88                	                   
2807: EE88                ;	PUSH	D				; Save Set/Clear indicator
2808: EE88     3ADDF5     	LDA		BIGDISK			; check disk size .
2809: EE8B     B7         	ORA		A             
2810: EE8C     CA97EE     	JZ		SETFL2			; If it is a big disk, use 16 bits
2811: EE8F                	                   
2812: EE8F     C5         	PUSH	B				; Only 8 bit numbers. Save counter.
2813: EE90     E5         	PUSH	H				; Save pointer to current Allocation byte
2814: EE91     4E         	MOV		C,M				; Get low byte from table, always
2815: EE92     0600       	MVI		B,0				; Set high byte to zero.
2816: EE94     C39DEE     	JMP		SETFL3			; skip 16 bit number processing
2817: EE97                	                   
2818: EE97                SETFL2:             
2819: EE97     0D         	DCR		C				; Adjust counter for 16 bit block numbers,.
2820: EE98     C5         	PUSH	B				; Save Counter
2821: EE99     4E         	MOV		C,M				; Now get both the low and high bytes.
2822: EE9A     23         	INX		H             
2823: EE9B     46         	MOV		B,M           
2824: EE9C     E5         	PUSH	H				; Save pointer to current Allocation byte
2825: EE9D                SETFL3:             
2826: EE9D     79         	MOV		A,C				; Block used? if both (b) and (c) are 00
2827: EE9E     B0         	ORA		B				; the block is NOT used
2828: EE9F     CAACEE     	JZ		SETFL4			; NOT used move on			
2829: EEA2     2AC7F5     	LHLD	DSKSIZE			; Is this block number within the
2830: EEA5     7D         	MOV		A,L	          
2831: EEA6     91         	SUB		C             
2832: EEA7     7C         	MOV		A,H           
2833: EEA8     98         	SBB		B             
2834: EEA9     D46CEE     	CNC		STBITMAP		; Yes, set the proper bit.
2835: EEAC                SETFL4:             
2836: EEAC     E1         	POP	H					; Point to next block number in fcb.
2837: EEAD     23         	INX	H              
2838: EEAE     C1         	POP	B					; Retreive the counter
2839: EEAF     C386EE     	JMP	SETFL1         
2840: EEB2                                    
2841: EEB2                ;                   
2842: EEB2                ;   Set the status (StatusBDOSReturn) and return.
2843: EEB2                ;                   
2844: EEB2                STSTATUS:           
2845: EEB2     3AD5F5     	LDA	FNDSTAT        
2846: EEB5     C35CEB     	JMP	SETSTAT        
2847: EEB8                ;                   
2848: EEB8                ;   Check extents in (A) and (C). Set the zero flag if they
2849: EEB8                ; are the same. The number of 16k chunks of disk space that
2850: EEB8                ; the directory extent covers is expressad is (EXTMASK+1).
2851: EEB8                ; No registers are modified.
2852: EEB8                ;                   
2853: EEB8                SAMEXT:             
2854: EEB8     C5         	PUSH	B             
2855: EEB9     F5         	PUSH	PSW           
2856: EEBA     3AC6F5     	LDA	EXTMASK	;get extent mask and use it to
2857: EEBD     2F         	CMA		;to compare both extent numbers.
2858: EEBE     47         	MOV	B,A	;save resulting mask here.
2859: EEBF     79         	MOV	A,C	;mask first extent and save in (C).
2860: EEC0     A0         	ANA	B              
2861: EEC1     4F         	MOV	C,A            
2862: EEC2     F1         	POP	PSW	;now mask second extent and compare
2863: EEC3     A0         	ANA	B	;with the first one.
2864: EEC4     91         	SUB	C              
2865: EEC5     E61F       	ANI	1FH	;(* only check buts 0-4 *)
2866: EEC7     C1         	POP	B	;the zero flag is set if they are the same.
2867: EEC8     C9         	RET		;restore (BC) and return.
2868: EEC9                ;                   
2869: EEC9                ;   Search for the first occurence of a file name. On entry,
2870: EEC9                ; register (C) should contain the number of bytes of the fcb
2871: EEC9                ; that must match.  
2872: EEC9                ;                   
2873: EEC9                FINDFST:            
2874: EEC9     3EFF       	MVI		A,0FFH        
2875: EECB     32D5F5     	STA		FNDSTAT			; set flag to not match found
2876: EECE     21D8F5     	LXI		H,COUNTER		; point at character counter.
2877: EED1     71         	MOV		M,C				; put in number of bytes to match
2878: EED2     2A3CE8     	LHLD	ParamsDE		; get filename to match.
2879: EED5     22D9F5     	SHLD	SAVEFCB			; and save.
2880: EED8     CD0EEE     	CALL	STFILPOS		; clear initial file position (set to 0ffffh).
2881: EEDB     CDC4EB     	CALL	HOMEDRV			;home the drive.
2882: EEDE                ;                   
2883: EEDE                ;   Entry to locate the next occurence of a filename within the
2884: EEDE                ; directory. The disk is not expected to have been changed. If
2885: EEDE                ; it was, then it will be write protected.
2886: EEDE                ;                   
2887: EEDE                FINDNXT:            
2888: EEDE     0E00       	MVI		C,0			;write protect the disk if changed.
2889: EEE0     CD15EE     	CALL	NXENTRY		;get next filename entry in directory.
2890: EEE3     CD05EE     	CALL	CKFILPOS;is file position = 0ffffh?
2891: EEE6     CA45EF     	JZ	FNDNXT6	;yes, exit now then.
2892: EEE9     2AD9F5     	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2893: EEEC     EB         	XCHG               
2894: EEED     1A         	LDAX	D             
2895: EEEE     FEE5       	CPI	0E5H	;empty directory entry?
2896: EEF0     CAFBEE     	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2897: EEF3     D5         	PUSH	D             
2898: EEF4     CD8FED     	CALL	MOREFLS	;more files in directory?
2899: EEF7     D1         	POP	D              
2900: EEF8     D245EF     	JNC	FNDNXT6	;no more. Exit now.
2901: EEFB                FNDNXT1:            
2902: EEFB     CD6EED     	CALL	FCB2HL	;get address of this fcb in directory.
2903: EEFE     3AD8F5     	LDA	COUNTER	;get number of bytes (characters) to check.
2904: EF01     4F         	MOV	C,A            
2905: EF02     0600       	MVI	B,0	;initialize byte position counter.
2906: EF04                FNDNXT2:            
2907: EF04     79         	MOV	A,C	;are we done with the compare?
2908: EF05     B7         	ORA	A              
2909: EF06     CA34EF     	JZ	FNDNXT5         
2910: EF09     1A         	LDAX	D	;no, check next byte.
2911: EF0A     FE3F       	CPI	QMARK		; '?'	;don't care about this character?
2912: EF0C     CA2DEF     	JZ	FNDNXT4         
2913: EF0F     78         	MOV	A,B	;get bytes position in fcb.
2914: EF10     FE0D       	CPI	13	;don't care about the thirteenth byte either.
2915: EF12     CA2DEF     	JZ	FNDNXT4         
2916: EF15     FE0C       	CPI	12	;extent byte?
2917: EF17     1A         	LDAX	D             
2918: EF18     CA24EF     	JZ	FNDNXT3         
2919: EF1B     96         	SUB	M	;otherwise compare characters.
2920: EF1C     E67F       	ANI	7FH            
2921: EF1E     C2DEEE     	JNZ	FINDNXT	;not the same, check next entry.
2922: EF21     C32DEF     	JMP	FNDNXT4	;so far so good, keep checking.
2923: EF24                FNDNXT3:            
2924: EF24     C5         	PUSH	B	;check the extent byte here.
2925: EF25     4E         	MOV	C,M            
2926: EF26     CDB8EE     	CALL	SAMEXT        
2927: EF29     C1         	POP	B              
2928: EF2A     C2DEEE     	JNZ	FINDNXT	;not the same, look some more.
2929: EF2D                ;                   
2930: EF2D                ;   So far the names compare. Bump pointers to the next byte
2931: EF2D                ; and continue until all (C) characters have been checked.
2932: EF2D                ;                   
2933: EF2D                FNDNXT4:            
2934: EF2D     13         	INX	D	;bump pointers.
2935: EF2E     23         	INX	H              
2936: EF2F     04         	INR	B              
2937: EF30     0D         	DCR	C	;adjust character counter.
2938: EF31     C304EF     	JMP	FNDNXT2        
2939: EF34                FNDNXT5:            
2940: EF34     3AEAF5     	LDA	FILEPOS	;return the position of this entry.
2941: EF37     E603       	ANI	03H            
2942: EF39     323FE8     	STA	StatusBDOSReturn
2943: EF3C     21D5F5     	LXI	H,FNDSTAT      
2944: EF3F     7E         	MOV	A,M            
2945: EF40     17         	RAL                
2946: EF41     D0         	RNC                
2947: EF42     AF         	XRA	A              
2948: EF43     77         	MOV	M,A            
2949: EF44     C9         	RET                
2950: EF45                ;                   
2951: EF45                ;   Filename was not found. Set appropriate status.
2952: EF45                ;                   
2953: EF45                FNDNXT6:            
2954: EF45     CD0EEE     	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2955: EF48     3EFF       	MVI	A,0FFH	;say not located.
2956: EF4A     C35CEB     	JMP	SETSTAT        
2957: EF4D                ;                   
2958: EF4D                ;   Erase files from the directory. Only the first byte of the
2959: EF4D                ; fcb will be affected. It is set to (E5).
2960: EF4D                ;                   
2961: EF4D                ERAFILE:            
2962: EF4D     CD64ED     	CALL	CHKWPRT		;is disk write protected?
2963: EF50     0E0C       	MVI		C,12		;only compare file names.
2964: EF52     CDC9EE     	CALL	FINDFST		;get first file name.
2965: EF55                ERAFIL1:            
2966: EF55     CD05EE     	CALL	CKFILPOS	;any found?
2967: EF58     C8         	RZ					;nope, we must be done.
2968: EF59     CD54ED     	CALL	CHKROFL	;is file read only?
2969: EF5C     CD6EED     	CALL	FCB2HL	;nope, get address of fcb and
2970: EF5F     36E5       	MVI	M,0E5H	;set first byte to 'empty'.
2971: EF61                ;	MVI	C,0	;clear the space from the bit map.
2972: EF61     3E00       	MVI		A,00H		; want to clear the bit
2973: EF63     32ACF5     	STA		BitSetFlag	; Flag = 00, clear bit
2974: EF66     CD7DEE     	CALL	SETFILE       
2975: EF69     CDD6ED     	CALL	DIRWRITE;now write the directory sector back out.
2976: EF6C     CDDEEE     	CALL	FINDNXT	;find the next file name.
2977: EF6F     C355EF     	JMP	ERAFIL1	;and repeat process.
2978: EF72                ;                   
2979: EF72                ;   Look through the space allocation map (bit map) for the
2980: EF72                ; next available block. Start searching at block number (BC-1).
2981: EF72                ; The search procedure is to look for an empty block that is
2982: EF72                ; before the starting block. If not empty, look at a later
2983: EF72                ; block number. In this way, we return the closest empty block
2984: EF72                ; on either side of the 'target' block number. This will speed
2985: EF72                ; access on random devices. For serial devices, this should be
2986: EF72                ; changed to look in the forward direction first and then start
2987: EF72                ; at the front and search some more.
2988: EF72                ;                   
2989: EF72                ;   On return, (DE)= block number that is empty and (HL) =0
2990: EF72                ; if no empry block was found.
2991: EF72                ;                   
2992: EF72                FNDSPACE:           
2993: EF72     50         	MOV	D,B	;set (DE) as the block that is checked.
2994: EF73     59         	MOV	E,C            
2995: EF74                ;                   
2996: EF74                ;   Look before target block. Registers (BC) are used as the lower
2997: EF74                ; pointer and (DE) as the upper pointer.
2998: EF74                ;                   
2999: EF74                FNDSPA1:            
3000: EF74     79         	MOV	A,C	;is block 0 specified?
3001: EF75     B0         	ORA	B              
3002: EF76     CA85EF     	JZ	FNDSPA2         
3003: EF79     0B         	DCX	B	;nope, check previous block.
3004: EF7A     D5         	PUSH	D             
3005: EF7B     C5         	PUSH	B             
3006: EF7C     CD45EE     	CALL	CKBITMAP      
3007: EF7F     1F         	RAR		;is this block empty?
3008: EF80     D2A0EF     	JNC	FNDSPA3	;yes. use this.
3009: EF83                ;                   
3010: EF83                ;   Note that the above logic gets the first block that it finds
3011: EF83                ; that is empty. Thus a file could be written 'backward' making
3012: EF83                ; it very slow to access. This could be changed to look for the
3013: EF83                ; first empty block and then continue until the start of this
3014: EF83                ; empty space is located and then used that starting block.
3015: EF83                ; This should help speed up access to some files especially on
3016: EF83                ; a well used disk with lots of fairly small 'holes'.
3017: EF83                ;                   
3018: EF83     C1         	POP	B	;nope, check some more.
3019: EF84     D1         	POP	D              
3020: EF85                ;                   
3021: EF85                ;   Now look after target block.
3022: EF85                ;                   
3023: EF85                FNDSPA2:            
3024: EF85     2AC7F5     	LHLD	DSKSIZE	;is block (DE) within disk limits?
3025: EF88     7B         	MOV	A,E            
3026: EF89     95         	SUB	L              
3027: EF8A     7A         	MOV	A,D            
3028: EF8B     9C         	SBB	H              
3029: EF8C     D2A8EF     	JNC	FNDSPA4        
3030: EF8F     13         	INX	D	;yes, move on to next one.
3031: EF90     C5         	PUSH	B             
3032: EF91     D5         	PUSH	D             
3033: EF92     42         	MOV	B,D            
3034: EF93     4B         	MOV	C,E            
3035: EF94     CD45EE     	CALL	CKBITMAP;check it.
3036: EF97     1F         	RAR		;empty?       
3037: EF98     D2A0EF     	JNC	FNDSPA3        
3038: EF9B     D1         	POP	D	;nope, continue searching.
3039: EF9C     C1         	POP	B              
3040: EF9D     C374EF     	JMP	FNDSPA1        
3041: EFA0                ;                   
3042: EFA0                ;   Empty block found. Set it as used and return with (HL)
3043: EFA0                ; pointing to it (true?).
3044: EFA0                ;                   
3045: EFA0                FNDSPA3:            
3046: EFA0     17         	RAL		;reset byte.  
3047: EFA1     3C         	INR	A	;and set bit 0.
3048: EFA2     CD76EE     	CALL	STBMAP1	;update bit map.
3049: EFA5     E1         	POP	H	;set return registers.
3050: EFA6     D1         	POP	D              
3051: EFA7     C9         	RET                
3052: EFA8                ;                   
3053: EFA8                ;   Free block was not found. If (BC) is not zero, then we have
3054: EFA8                ; not checked all of the disk space.
3055: EFA8                ;                   
3056: EFA8                FNDSPA4:            
3057: EFA8     79         	MOV	A,C            
3058: EFA9     B0         	ORA	B              
3059: EFAA     C274EF     	JNZ	FNDSPA1        
3060: EFAD     210000     	LXI	H,0	;set 'not found' status.
3061: EFB0     C9         	RET                
3062: EFB1                ;                   
3063: EFB1                ;   Move a complete fcb entry into the directory and write it.
3064: EFB1                ;                   
3065: EFB1                FCBSET:             
3066: EFB1     0E00       	MVI	C,0            
3067: EFB3     1E20       	MVI	E,32	;length of each entry.
3068: EFB5                ;                   
3069: EFB5                ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3070: EFB5                ; fcb in directory starting at relative byte (C). This updated
3071: EFB5                ; directory buffer is then written to the disk.
3072: EFB5                ;                   
3073: EFB5                UPDATE:             
3074: EFB5     D5         	PUSH	D             
3075: EFB6     0600       	MVI	B,0	;set (BC) to relative byte position.
3076: EFB8     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3077: EFBB     09         	DAD	B	;compute starting byte.
3078: EFBC     EB         	XCHG               
3079: EFBD     CD6EED     	CALL	FCB2HL	;get address of fcb to update in directory.
3080: EFC0     C1         	POP	B	;set (C) to number of bytes to change.
3081: EFC1     CD72EB     	CALL	DE2HL         
3082: EFC4                UPDATE1:            
3083: EFC4     CDE6EB     	CALL	TRKSEC	;determine the track and sector affected.
3084: EFC7     C3D6ED     	JMP	DIRWRITE	;then write this sector out.
3085: EFCA                ;                   
3086: EFCA                ;   Routine to change the name of all files on the disk with a
3087: EFCA                ; specified name. The fcb contains the current name as the
3088: EFCA                ; first 12 characters and the new name 16 bytes into the fcb.
3089: EFCA                ;                   
3090: EFCA                CHGNAMES:           
3091: EFCA     CD64ED     	CALL	CHKWPRT	;check for a write protected disk.
3092: EFCD     0E0C       	MVI	C,12	;match first 12 bytes of fcb only.
3093: EFCF     CDC9EE     	CALL	FINDFST	;get first name.
3094: EFD2     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3095: EFD5     7E         	MOV	A,M	;get user number.
3096: EFD6     111000     	LXI	D,16	;move over to desired name.
3097: EFD9     19         	DAD	D              
3098: EFDA     77         	MOV	M,A	;keep same user number.
3099: EFDB                CHGNAM1:            
3100: EFDB     CD05EE     	CALL	CKFILPOS;any matching file found?
3101: EFDE     C8         	RZ		;no, we must be done.
3102: EFDF     CD54ED     	CALL	CHKROFL	;check for read only file.
3103: EFE2     0E10       	MVI	C,16	;start 16 bytes into fcb.
3104: EFE4     1E0C       	MVI	E,12	;and update the first 12 bytes of directory.
3105: EFE6     CDB5EF     	CALL	UPDATE        
3106: EFE9     CDDEEE     	CALL	FINDNXT	;get te next file name.
3107: EFEC     C3DBEF     	JMP	CHGNAM1	;and continue.
3108: EFEF                ;                   
3109: EFEF                ;   Update a files attributes. The procedure is to search for
3110: EFEF                ; every file with the same name as shown in fcb (ignoring bit 7)
3111: EFEF                ; and then to update it (which includes bit 7). No other changes
3112: EFEF                ; are made.         
3113: EFEF                ;                   
3114: EFEF                SAVEATTR:           
3115: EFEF     0E0C       	MVI	C,12	;match first 12 bytes.
3116: EFF1     CDC9EE     	CALL	FINDFST	;look for first filename.
3117: EFF4                SAVATR1:            
3118: EFF4     CD05EE     	CALL	CKFILPOS;was one found?
3119: EFF7     C8         	RZ		;nope, we must be done.
3120: EFF8     0E00       	MVI	C,0	;yes, update the first 12 bytes now.
3121: EFFA     1E0C       	MVI	E,12           
3122: EFFC     CDB5EF     	CALL	UPDATE	;update filename and write directory.
3123: EFFF     CDDEEE     	CALL	FINDNXT	;and get the next file.
3124: F002     C3F4EF     	JMP	SAVATR1	;then continue until done.
3125: F005                ;                   
3126: F005                ;  Open a file (name specified in fcb).
3127: F005                ;                   
3128: F005                OPENIT:             
3129: F005     0E0F       	MVI	C,15	;compare the first 15 bytes.
3130: F007     CDC9EE     	CALL	FINDFST	;get the first one in directory.
3131: F00A     CD05EE     	CALL	CKFILPOS;any at all?
3132: F00D     C8         	RZ                 
3133: F00E                OPENIT1:            
3134: F00E     CDC9EC     	CALL	SETEXT	;point to extent byte within users fcb.
3135: F011     7E         	MOV	A,M	;and get it.
3136: F012     F5         	PUSH	PSW	;save it and address.
3137: F013     E5         	PUSH	H             
3138: F014     CD6EED     	CALL	FCB2HL	;point to fcb in directory.
3139: F017     EB         	XCHG               
3140: F018     2A3CE8     	LHLD	ParamsDE	;this is the users copy.
3141: F01B     0E20       	MVI	C,32	;move it into users space.
3142: F01D     D5         	PUSH	D             
3143: F01E     CD72EB     	CALL	DE2HL         
3144: F021     CD88ED     	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
3145: F024     D1         	POP	D	;now get the extent byte from this fcb.
3146: F025     210C00     	LXI	H,12           
3147: F028     19         	DAD	D              
3148: F029     4E         	MOV	C,M	;into (C). 
3149: F02A     210F00     	LXI	H,15	;now get the record count byte into (B).
3150: F02D     19         	DAD	D              
3151: F02E     46         	MOV	B,M            
3152: F02F     E1         	POP	H	;keep the same extent as the user had originally.
3153: F030     F1         	POP	PSW            
3154: F031     77         	MOV	M,A            
3155: F032     79         	MOV	A,C	;is it the same as in the directory fcb?
3156: F033     BE         	CMP	M              
3157: F034     78         	MOV	A,B	;if yes, then use the same record count.
3158: F035     CA3FF0     	JZ	OPENIT2         
3159: F038     3E00       	MVI	A,0	;if the user specified an extent greater than
3160: F03A     DA3FF0     	JC	OPENIT2	;the one in the directory, then set record count to 0.
3161: F03D     3E80       	MVI	A,128	;otherwise set to maximum.
3162: F03F                OPENIT2:            
3163: F03F     2A3CE8     	LHLD	ParamsDE	;set record count in users fcb to (A).
3164: F042     110F00     	LXI	D,15           
3165: F045     19         	DAD	D	;compute relative position.
3166: F046     77         	MOV	M,A	;and set the record count.
3167: F047     C9         	RET                
3168: F048                ;                   
3169: F048                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3170: F048                ; point to a zero value (16 bit).
3171: F048                ;   Return with zero flag set it (DE) was moved. Registers (DE)
3172: F048                ; and (HL) are not changed. However (A) is.
3173: F048                ;                   
3174: F048                MOVEWORD:           
3175: F048     7E         	MOV	A,M	;check for a zero word.
3176: F049     23         	INX	H              
3177: F04A     B6         	ORA	M	;both bytes zero?
3178: F04B     2B         	DCX	H              
3179: F04C     C0         	RNZ		;nope, just return.
3180: F04D     1A         	LDAX	D	;yes, move two bytes from (DE) into
3181: F04E     77         	MOV	M,A	;this zero space.
3182: F04F     13         	INX	D              
3183: F050     23         	INX	H              
3184: F051     1A         	LDAX	D             
3185: F052     77         	MOV	M,A            
3186: F053     1B         	DCX	D	;don't disturb these registers.
3187: F054     2B         	DCX	H              
3188: F055     C9         	RET                
3189: F056                ;                   
3190: F056                ;   Get here to close a file specified by (fcb).
3191: F056                ;                   
3192: F056                CLOSEIT:            
3193: F056     AF         	XRA	A	;clear status and file position bytes.
3194: F057     323FE8     	STA	StatusBDOSReturn
3195: F05A     32EAF5     	STA	FILEPOS        
3196: F05D     32EBF5     	STA	FILEPOS+1      
3197: F060     CD2EED     	CALL	GETWPRT	;get write protect bit for this drive.
3198: F063     C0         	RNZ		;just return if it is set.
3199: F064     CD79ED     	CALL	GETS2	;else get the 's2' byte.
3200: F067     E680       	ANI	80H	;and look at bit 7 (file unmodified?).
3201: F069     C0         	RNZ		;just return if set.
3202: F06A     0E0F       	MVI	C,15	;else look up this file in directory.
3203: F06C     CDC9EE     	CALL	FINDFST       
3204: F06F     CD05EE     	CALL	CKFILPOS;was it found?
3205: F072     C8         	RZ		;just return if not.
3206: F073     011000     	LXI	B,16	;set (HL) pointing to records used section.
3207: F076     CD6EED     	CALL	FCB2HL        
3208: F079     09         	DAD	B              
3209: F07A     EB         	XCHG               
3210: F07B     2A3CE8     	LHLD	ParamsDE	;do the same for users specified fcb.
3211: F07E     09         	DAD	B              
3212: F07F     0E10       	MVI	C,16	;this many bytes are present in this extent.
3213: F081                CLOSEIT1:           
3214: F081     3ADDF5     	LDA	BIGDISK	;8 or 16 bit record numbers?
3215: F084     B7         	ORA	A              
3216: F085     CA9CF0     	JZ	CLOSEIT4        
3217: F088     7E         	MOV	A,M	;just 8 bit. Get one from users fcb.
3218: F089     B7         	ORA	A              
3219: F08A     1A         	LDAX	D	;now get one from directory fcb.
3220: F08B     C28FF0     	JNZ	CLOSEIT2       
3221: F08E     77         	MOV	M,A	;users byte was zero. Update from directory.
3222: F08F                CLOSEIT2:           
3223: F08F     B7         	ORA	A              
3224: F090     C295F0     	JNZ	CLOSEIT3       
3225: F093     7E         	MOV	A,M	;directories byte was zero, update from users fcb.
3226: F094     12         	STAX	D             
3227: F095                CLOSEIT3:           
3228: F095     BE         	CMP	M	;if neither one of these bytes were zero,
3229: F096     C2D3F0     	JNZ	CLOSEIT7	;then close error if they are not the same.
3230: F099     C3B1F0     	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3231: F09C                CLOSEIT4:           
3232: F09C     CD48F0     	CALL	MOVEWORD;update users fcb if it is zero.
3233: F09F     EB         	XCHG               
3234: F0A0     CD48F0     	CALL	MOVEWORD;update directories fcb if it is zero.
3235: F0A3     EB         	XCHG               
3236: F0A4     1A         	LDAX	D	;if these two values are no different,
3237: F0A5     BE         	CMP	M	;then a close error occured.
3238: F0A6     C2D3F0     	JNZ	CLOSEIT7       
3239: F0A9     13         	INX	D	;check second byte.
3240: F0AA     23         	INX	H              
3241: F0AB     1A         	LDAX	D             
3242: F0AC     BE         	CMP	M              
3243: F0AD     C2D3F0     	JNZ	CLOSEIT7       
3244: F0B0     0D         	DCR	C	;remember 16 bit values.
3245: F0B1                CLOSEIT5:           
3246: F0B1     13         	INX	D	;bump to next item in table.
3247: F0B2     23         	INX	H              
3248: F0B3     0D         	DCR	C	;there are 16 entries only.
3249: F0B4     C281F0     	JNZ	CLOSEIT1;continue if more to do.
3250: F0B7     01ECFF     	LXI	B,0FFECH;backup 20 places (extent byte).
3251: F0BA     09         	DAD	B              
3252: F0BB     EB         	XCHG               
3253: F0BC     09         	DAD	B              
3254: F0BD     1A         	LDAX	D             
3255: F0BE     BE         	CMP	M	;directory's extent already greater than the
3256: F0BF     DACBF0     	JC	CLOSEIT6	;users extent?
3257: F0C2     77         	MOV	M,A	;no, update directory extent.
3258: F0C3     010300     	LXI	B,3	;and update the record count byte in
3259: F0C6     09         	DAD	B	;directories fcb.
3260: F0C7     EB         	XCHG               
3261: F0C8     09         	DAD	B              
3262: F0C9     7E         	MOV	A,M	;get from user.
3263: F0CA     12         	STAX	D	;and put in directory.
3264: F0CB                CLOSEIT6:           
3265: F0CB     3EFF       	MVI	A,0FFH	;set 'was open and is now closed' byte.
3266: F0CD     32D3F5     	STA	CLOSEFLG       
3267: F0D0     C3C4EF     	JMP	UPDATE1	;update the directory now.
3268: F0D3                CLOSEIT7:           
3269: F0D3     213FE8     	LXI	H,StatusBDOSReturn;set return status and then return.
3270: F0D6     35         	DCR	M              
3271: F0D7     C9         	RET                
3272: F0D8                ;                   
3273: F0D8                ;   Routine to get the next empty space in the directory. It
3274: F0D8                ; will then be cleared for use.
3275: F0D8                ;                   
3276: F0D8                GETEMPTY:           
3277: F0D8     CD64ED     	CALL	CHKWPRT		;make sure disk is not write protected.
3278: F0DB     2A3CE8     	LHLD	ParamsDE	;save current parameters (fcb).
3279: F0DE     E5         	PUSH	H             
3280: F0DF     21ADF5     	LXI		H,EMPTYFCB	;use special one for empty space.
3281: F0E2     223CE8     	SHLD	ParamsDE      
3282: F0E5     0E01       	MVI	C,1	;search for first empty spot in directory.
3283: F0E7     CDC9EE     	CALL	FINDFST	;(* only check first byte *)
3284: F0EA     CD05EE     	CALL	CKFILPOS;none?
3285: F0ED     E1         	POP	H              
3286: F0EE     223CE8     	SHLD	ParamsDE	;restore original fcb address.
3287: F0F1     C8         	RZ		;return if no more space.
3288: F0F2     EB         	XCHG               
3289: F0F3     210F00     	LXI	H,15	;point to number of records for this file.
3290: F0F6     19         	DAD	D              
3291: F0F7     0E11       	MVI	C,17	;and clear all of this space.
3292: F0F9     AF         	XRA	A              
3293: F0FA                GETMT1:             
3294: F0FA     77         	MOV	M,A            
3295: F0FB     23         	INX	H              
3296: F0FC     0D         	DCR	C              
3297: F0FD     C2FAF0     	JNZ	GETMT1         
3298: F100     210D00     	LXI	H,13	;clear the 's1' byte also.
3299: F103     19         	DAD	D              
3300: F104     77         	MOV	M,A            
3301: F105     CD9CED     	CALL	CHKNMBR	;keep (FilePosInDir) within bounds.
3302: F108     CDB1EF     	CALL	FCBSET	;write out this fcb entry to directory.
3303: F10B     C388ED     	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
3304: F10E                ;                   
3305: F10E                ;   Routine to close the current extent and open the next one
3306: F10E                ; for reading.      
3307: F10E                ;                   
3308: F10E                GETNEXT:            
3309: F10E     AF         	XRA	A              
3310: F10F     32D3F5     	STA	CLOSEFLG;clear close flag.
3311: F112     CD56F0     	CALL	CLOSEIT	;close this extent.
3312: F115     CD05EE     	CALL	CKFILPOS      
3313: F118     C8         	RZ		;not there???  
3314: F119     2A3CE8     	LHLD	ParamsDE	;get extent byte.
3315: F11C     010C00     	LXI	B,12           
3316: F11F     09         	DAD	B              
3317: F120     7E         	MOV	A,M	;and increment it.
3318: F121     3C         	INR	A              
3319: F122     E61F       	ANI	1FH	;keep within range 0-31.
3320: F124     77         	MOV	M,A            
3321: F125     CA37F1     	JZ	GTNEXT1	;overflow?
3322: F128     47         	MOV	B,A	;mask extent byte.
3323: F129     3AC6F5     	LDA	EXTMASK        
3324: F12C     A0         	ANA	B              
3325: F12D     21D3F5     	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3326: F130     A6         	ANA	M              
3327: F131     CA42F1     	JZ	GTNEXT2	;if zero, we must read in next extent.
3328: F134     C360F1     	JMP	GTNEXT3	;else, it is already in memory.
3329: F137                GTNEXT1:            
3330: F137     010200     	LXI	B,2	;Point to the 's2' byte.
3331: F13A     09         	DAD	B              
3332: F13B     34         	INR	M	;and bump it.
3333: F13C     7E         	MOV	A,M	;too many extents?
3334: F13D     E60F       	ANI	0FH            
3335: F13F     CA6AF1     	JZ	GTNEXT5	;yes, set error code.
3336: F142                ;                   
3337: F142                ;   Get here to open the next extent.
3338: F142                ;                   
3339: F142                GTNEXT2:            
3340: F142     0E0F       	MVI	C,15	;set to check first 15 bytes of fcb.
3341: F144     CDC9EE     	CALL	FINDFST	;find the first one.
3342: F147     CD05EE     	CALL	CKFILPOS;none available?
3343: F14A     C260F1     	JNZ	GTNEXT3        
3344: F14D     3AD4F5     	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3345: F150     3C         	INR	A	;0ffh means reading (so not possible).
3346: F151     CA6AF1     	JZ	GTNEXT5	;or an error.
3347: F154     CDD8F0     	CALL	GETEMPTY;we are writing, get an empty entry.
3348: F157     CD05EE     	CALL	CKFILPOS;none?
3349: F15A     CA6AF1     	JZ	GTNEXT5	;error if true.
3350: F15D     C363F1     	JMP	GTNEXT4	;else we are almost done.
3351: F160                GTNEXT3:            
3352: F160     CD0EF0     	CALL	OPENIT1	;open this extent.
3353: F163                GTNEXT4:            
3354: F163     CDDEEC     	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3355: F166     AF         	XRA	A	;clear status and return.
3356: F167     C35CEB     	JMP	SETSTAT        
3357: F16A                ;                   
3358: F16A                ;   Error in extending the file. Too many extents were needed
3359: F16A                ; or not enough space on the disk.
3360: F16A                ;                   
3361: F16A                GTNEXT5:            
3362: F16A     CD60EB     	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3363: F16D     C388ED     	JMP	SETS2B7	;so this is not written on a close.
3364: F170                ;                   
3365: F170                ;   Read a sequential file.
3366: F170                ;                   
3367: F170                RDSEQ:              
3368: F170     3E01       	MVI	A,1	;set sequential access mode.
3369: F172     32D6F5     	STA	MODE           
3370: F175                RDSEQ1:             
3371: F175     3EFF       	MVI	A,0FFH	;don't allow reading unwritten space.
3372: F177     32D4F5     	STA	RDWRTFLG       
3373: F17A     CDDEEC     	CALL	STRDATA	;put rec# and ext# into fcb.
3374: F17D     3AE3F5     	LDA	SAVNREC	;get next record to read.
3375: F180     21E1F5     	LXI	H,SAVNXT;get number of records in extent.
3376: F183     BE         	CMP	M	;within this extent?
3377: F184     DA9AF1     	JC	RDSEQ2          
3378: F187     FE80       	CPI	128	;no. Is this extent fully used?
3379: F189     C2AFF1     	JNZ	RDSEQ3	;no. End-of-file.
3380: F18C     CD0EF1     	CALL	GETNEXT	;yes, open the next one.
3381: F18F     AF         	XRA	A	;reset next record to read.
3382: F190     32E3F5     	STA	SAVNREC        
3383: F193     3A3FE8     	LDA	StatusBDOSReturn	;check on open, successful?
3384: F196     B7         	ORA	A              
3385: F197     C2AFF1     	JNZ	RDSEQ3	;no, error.
3386: F19A                RDSEQ2:             
3387: F19A     CD9AEC     	CALL	COMBLK	;ok. compute block number to read.
3388: F19D     CDA7EC     	CALL	CHKBLK	;check it. Within bounds?
3389: F1A0     CAAFF1     	JZ	RDSEQ3	;no, error.
3390: F1A3     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
3391: F1A6     CDF4EB     	CALL	TRKSEC1	;set the track and sector for this block #.
3392: F1A9     CDD5EB     	CALL	DOREAD	;and read it.
3393: F1AC     C3F5EC     	JMP	SETNREC	;and set the next record to be accessed.
3394: F1AF                ;                   
3395: F1AF                ;   Read error occured. Set status and return.
3396: F1AF                ;                   
3397: F1AF                RDSEQ3:             
3398: F1AF     C360EB     	JMP	IOERR1         
3399: F1B2                ;                   
3400: F1B2                ;   Write the next sequential record.
3401: F1B2                ;                   
3402: F1B2                WTSEQ:              
3403: F1B2     3E01       	MVI	A,1	;set sequential access mode.
3404: F1B4     32D6F5     	STA	MODE           
3405: F1B7                WTSEQ1:             
3406: F1B7     3E00       	MVI	A,0	;allow an addition empty extent to be opened.
3407: F1B9     32D4F5     	STA	RDWRTFLG       
3408: F1BC     CD64ED     	CALL	CHKWPRT	;check write protect status.
3409: F1BF     2A3CE8     	LHLD	ParamsDE      
3410: F1C2     CD57ED     	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3411: F1C5     CDDEEC     	CALL	STRDATA	;put updated data into fcb.
3412: F1C8     3AE3F5     	LDA	SAVNREC	;get record number to write.
3413: F1CB     FE80       	CPI	128	;within range?
3414: F1CD     D260EB     	JNC	IOERR1	;no, error(?).
3415: F1D0     CD9AEC     	CALL	COMBLK	;compute block number.
3416: F1D3     CDA7EC     	CALL	CHKBLK	;check number.
3417: F1D6     0E00       	MVI	C,0	;is there one to write to?
3418: F1D8     C222F2     	JNZ	WTSEQ6	;yes, go do it.
3419: F1DB     CD61EC     	CALL	GETBLOCK;get next block number within fcb to use.
3420: F1DE     32D7F5     	STA	RELBLOCK;and save.
3421: F1E1     010000     	LXI	B,0	;start looking for space from the start
3422: F1E4     B7         	ORA	A	;if none allocated as yet.
3423: F1E5     CAEFF1     	JZ	WTSEQ2          
3424: F1E8     4F         	MOV	C,A	;extract previous block number from fcb
3425: F1E9     0B         	DCX	B	;so we can be closest to it.
3426: F1EA     CD81EC     	CALL	EXTBLK        
3427: F1ED     44         	MOV	B,H            
3428: F1EE     4D         	MOV	C,L            
3429: F1EF                WTSEQ2:             
3430: F1EF     CD72EF     	CALL	FNDSPACE;find the next empty block nearest number (BC).
3431: F1F2     7D         	MOV	A,L	;check for a zero number.
3432: F1F3     B4         	ORA	H              
3433: F1F4     C2FCF1     	JNZ	WTSEQ3         
3434: F1F7     3E02       	MVI	A,2	;no more space?
3435: F1F9     C35CEB     	JMP	SETSTAT        
3436: F1FC                WTSEQ3:             
3437: F1FC     22E5F5     	SHLD	BLKNMBR	;save block number to access.
3438: F1FF     EB         	XCHG		;put block number into (DE).
3439: F200     2A3CE8     	LHLD	ParamsDE	;now we must update the fcb for this
3440: F203     011000     	LXI	B,16	;newly allocated block.
3441: F206     09         	DAD	B              
3442: F207     3ADDF5     	LDA	BIGDISK	;8 or 16 bit block numbers?
3443: F20A     B7         	ORA	A              
3444: F20B     3AD7F5     	LDA	RELBLOCK	;(* update this entry *)
3445: F20E     CA18F2     	JZ	WTSEQ4	;zero means 16 bit ones.
3446: F211     CD74ED     	CALL	ADDA2HL	;(HL)=(HL)+(A)
3447: F214     73         	MOV	M,E	;store new block number.
3448: F215     C320F2     	JMP	WTSEQ5         
3449: F218                WTSEQ4:             
3450: F218     4F         	MOV	C,A	;compute spot in this 16 bit table.
3451: F219     0600       	MVI	B,0            
3452: F21B     09         	DAD	B              
3453: F21C     09         	DAD	B              
3454: F21D     73         	MOV	M,E	;stuff block number (DE) there.
3455: F21E     23         	INX	H              
3456: F21F     72         	MOV	M,D            
3457: F220                WTSEQ5:             
3458: F220     0E02       	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3459: F222                WTSEQ6:             
3460: F222     3A3FE8     	LDA	StatusBDOSReturn	;are we ok so far?
3461: F225     B7         	ORA	A              
3462: F226     C0         	RNZ                
3463: F227     C5         	PUSH	B	;yes, save write flag for bios (register C).
3464: F228     CDADEC     	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3465: F22B     3AD6F5     	LDA	MODE	;get access mode flag (1=sequential,
3466: F22E     3D         	DCR	A	;0=random, 2=special?).
3467: F22F     3D         	DCR	A              
3468: F230     C26FF2     	JNZ	WTSEQ9         
3469: F233                ;                   
3470: F233                ;   Special random i/o from function #40. Maybe for M/PM, but the
3471: F233                ; current block, if it has not been written to, will be zeroed
3472: F233                ; out and then written (reason?).
3473: F233                ;                   
3474: F233     C1         	POP	B              
3475: F234     C5         	PUSH	B             
3476: F235     79         	MOV	A,C	;get write status flag (2=writing unused space).
3477: F236     3D         	DCR	A              
3478: F237     3D         	DCR	A              
3479: F238     C26FF2     	JNZ	WTSEQ9         
3480: F23B     E5         	PUSH	H             
3481: F23C     2ABAF5     	LHLD	DIRBUF	;zero out the directory buffer.
3482: F23F     57         	MOV	D,A	;note that (A) is zero here.
3483: F240                WTSEQ7:             
3484: F240     77         	MOV	M,A            
3485: F241     23         	INX	H              
3486: F242     14         	INR	D	;do 128 bytes.
3487: F243     F240F2     	JP	WTSEQ7          
3488: F246     CDF0ED     	CALL	SetDirDMA	;tell the bios the dma address for directory access.
3489: F249     2AE7F5     	LHLD	LOGSECT	;get sector that starts current block.
3490: F24C     0E02       	MVI	C,2	;set 'writing to unused space' flag.
3491: F24E                WTSEQ8:             
3492: F24E     22E5F5     	SHLD	BLKNMBR	;save sector to write.
3493: F251     C5         	PUSH	B             
3494: F252     CDF4EB     	CALL	TRKSEC1	;determine its track and sector numbers.
3495: F255     C1         	POP	B              
3496: F256     CDDBEB     	CALL	DOWRITE	;now write out 128 bytes of zeros.
3497: F259     2AE5F5     	LHLD	BLKNMBR	;get sector number.
3498: F25C     0E00       	MVI	C,0	;set normal write flag.
3499: F25E     3AC5F5     	LDA	BLKMASK	;determine if we have written the entire
3500: F261     47         	MOV	B,A	;physical block.
3501: F262     A5         	ANA	L              
3502: F263     B8         	CMP	B              
3503: F264     23         	INX	H	;prepare for the next one.
3504: F265     C24EF2     	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3505: F268     E1         	POP	H	;reset next sector number.
3506: F269     22E5F5     	SHLD	BLKNMBR       
3507: F26C     CDEAED     	CALL	Set2UsersDMA	;and reset dma address.
3508: F26F                ;                   
3509: F26F                ;   Normal disk write. Set the desired track and sector then
3510: F26F                ; do the actual write.
3511: F26F                ;                   
3512: F26F                WTSEQ9:             
3513: F26F     CDF4EB     	CALL	TRKSEC1	;determine track and sector for this write.
3514: F272     C1         	POP	B	;get write status flag.
3515: F273     C5         	PUSH	B             
3516: F274     CDDBEB     	CALL	DOWRITE	;and write this out.
3517: F277     C1         	POP	B              
3518: F278     3AE3F5     	LDA	SAVNREC	;get number of records in file.
3519: F27B     21E1F5     	LXI	H,SAVNXT;get last record written.
3520: F27E     BE         	CMP	M              
3521: F27F     DA86F2     	JC	WTSEQ10         
3522: F282     77         	MOV	M,A	;we have to update record count.
3523: F283     34         	INR	M              
3524: F284     0E02       	MVI	C,2            
3525: F286                ;                   
3526: F286                ;*   This area has been patched to correct disk update problem
3527: F286                ;* when using blocking and de-blocking in the BIOS.
3528: F286                ;                   
3529: F286                WTSEQ10:            
3530: F286     00         	NOP		;was 'dcr c'  
3531: F287     00         	NOP		;was 'dcr c'  
3532: F288     210000     	LXI	H,0	;was 'jnz wtseq99'
3533: F28B                ;                   
3534: F28B                ; *   End of patch. 
3535: F28B                ;                   
3536: F28B     F5         	PUSH	PSW           
3537: F28C     CD79ED     	CALL	GETS2	;set 'extent written to' flag.
3538: F28F     E67F       	ANI	7FH	;(* clear bit 7 *)
3539: F291     77         	MOV	M,A            
3540: F292     F1         	POP	PSW	;get record count for this extent.
3541: F293                WTSEQ99:            
3542: F293     FE7F       	CPI	127	;is it full?
3543: F295     C2B4F2     	JNZ	WTSEQ12        
3544: F298     3AD6F5     	LDA	MODE	;yes, are we in sequential mode?
3545: F29B     FE01       	CPI	1              
3546: F29D     C2B4F2     	JNZ	WTSEQ12        
3547: F2A0     CDF5EC     	CALL	SETNREC	;yes, set next record number.
3548: F2A3     CD0EF1     	CALL	GETNEXT	;and get next empty space in directory.
3549: F2A6     213FE8     	LXI	H,StatusBDOSReturn;ok?
3550: F2A9     7E         	MOV	A,M            
3551: F2AA     B7         	ORA	A              
3552: F2AB     C2B2F2     	JNZ	WTSEQ11        
3553: F2AE     3D         	DCR	A	;yes, set record count to -1.
3554: F2AF     32E3F5     	STA	SAVNREC        
3555: F2B2                WTSEQ11:            
3556: F2B2     3600       	MVI	M,0	;clear status.
3557: F2B4                WTSEQ12:            
3558: F2B4     C3F5EC     	JMP	SETNREC	;set next record to access.
3559: F2B7                ;                   
3560: F2B7                ;   For random i/o, set the fcb for the desired record number
3561: F2B7                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3562: F2B7                ; used as follows:  
3563: F2B7                ;                   
3564: F2B7                ;       fcb+35            fcb+34            fcb+33
3565: F2B7                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3566: F2B7                ;  |7             0 | 7             0 | 7             0|
3567: F2B7                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3568: F2B7                ;  |    overflow   | | extra |  extent   |   record #  |
3569: F2B7                ;  | ______________| |_extent|__number___|_____________|
3570: F2B7                ;                     also 's2'
3571: F2B7                ;                   
3572: F2B7                ;   On entry, register (C) contains 0ffh if this is a read
3573: F2B7                ; and thus we can not access unwritten disk space. Otherwise,
3574: F2B7                ; another extent will be opened (for writing) if required.
3575: F2B7                ;                   
3576: F2B7                POSITION:           
3577: F2B7     AF         	XRA	A	;set random i/o flag.
3578: F2B8     32D6F5     	STA	MODE           
3579: F2BB                ;                   
3580: F2BB                ;   Special entry (function #40). M/PM ?
3581: F2BB                ;                   
3582: F2BB                POSITN1:            
3583: F2BB     C5         	PUSH	B	;save read/write flag.
3584: F2BC     2A3CE8     	LHLD	ParamsDE	;get address of fcb.
3585: F2BF     EB         	XCHG               
3586: F2C0     212100     	LXI	H,33	;now get byte 'r0'.
3587: F2C3     19         	DAD	D              
3588: F2C4     7E         	MOV	A,M            
3589: F2C5     E67F       	ANI	7FH	;keep bits 0-6 for the record number to access.
3590: F2C7     F5         	PUSH	PSW           
3591: F2C8     7E         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3592: F2C9     17         	RAL                
3593: F2CA     23         	INX	H              
3594: F2CB     7E         	MOV	A,M            
3595: F2CC     17         	RAL                
3596: F2CD     E61F       	ANI	1FH	;and save this in bits 0-4 of (C).
3597: F2CF     4F         	MOV	C,A	;this is the extent byte.
3598: F2D0     7E         	MOV	A,M	;now get the extra extent byte.
3599: F2D1     1F         	RAR                
3600: F2D2     1F         	RAR                
3601: F2D3     1F         	RAR                
3602: F2D4     1F         	RAR                
3603: F2D5     E60F       	ANI	0FH            
3604: F2D7     47         	MOV	B,A	;and save it in (B).
3605: F2D8     F1         	POP	PSW	;get record number back to (A).
3606: F2D9     23         	INX	H	;check overflow byte 'r2'.
3607: F2DA     6E         	MOV	L,M            
3608: F2DB     2C         	INR	L              
3609: F2DC     2D         	DCR	L              
3610: F2DD     2E06       	MVI	L,6	;prepare for error.
3611: F2DF     C23FF3     	JNZ	POSITN5	;out of disk space error.
3612: F2E2     212000     	LXI	H,32	;store record number into fcb.
3613: F2E5     19         	DAD	D              
3614: F2E6     77         	MOV	M,A            
3615: F2E7     210C00     	LXI	H,12	;and now check the extent byte.
3616: F2EA     19         	DAD	D              
3617: F2EB     79         	MOV	A,C            
3618: F2EC     96         	SUB	M	;same extent as before?
3619: F2ED     C2FBF2     	JNZ	POSITN2        
3620: F2F0     210E00     	LXI	H,14	;yes, check extra extent byte 's2' also.
3621: F2F3     19         	DAD	D              
3622: F2F4     78         	MOV	A,B            
3623: F2F5     96         	SUB	M              
3624: F2F6     E67F       	ANI	7FH            
3625: F2F8     CA33F3     	JZ	POSITN3;same, we are almost done then.
3626: F2FB                ;                   
3627: F2FB                ;  Get here when another extent is required.
3628: F2FB                ;                   
3629: F2FB                POSITN2:            
3630: F2FB     C5         	PUSH	B             
3631: F2FC     D5         	PUSH	D             
3632: F2FD     CD56F0     	CALL	CLOSEIT	;close current extent.
3633: F300     D1         	POP	D              
3634: F301     C1         	POP	B              
3635: F302     2E03       	MVI	L,3	;prepare for error.
3636: F304     3A3FE8     	LDA	StatusBDOSReturn
3637: F307     3C         	INR	A              
3638: F308     CA38F3     	JZ	POSITN4	;close error.
3639: F30B     210C00     	LXI	H,12	;put desired extent into fcb now.
3640: F30E     19         	DAD	D              
3641: F30F     71         	MOV	M,C            
3642: F310     210E00     	LXI	H,14	;and store extra extent byte 's2'.
3643: F313     19         	DAD	D              
3644: F314     70         	MOV	M,B            
3645: F315     CD05F0     	CALL	OPENIT	;try and get this extent.
3646: F318     3A3FE8     	LDA	StatusBDOSReturn	;was it there?
3647: F31B     3C         	INR	A              
3648: F31C     C233F3     	JNZ	POSITN3        
3649: F31F     C1         	POP	B	;no. can we create a new one (writing?).
3650: F320     C5         	PUSH	B             
3651: F321     2E04       	MVI	L,4	;prepare for error.
3652: F323     0C         	INR	C              
3653: F324     CA38F3     	JZ	POSITN4	;nope, reading unwritten space error.
3654: F327     CDD8F0     	CALL	GETEMPTY;yes we can, try to find space.
3655: F32A     2E05       	MVI	L,5	;prepare for error.
3656: F32C     3A3FE8     	LDA	StatusBDOSReturn
3657: F32F     3C         	INR	A              
3658: F330     CA38F3     	JZ	POSITN4	;out of space?
3659: F333                ;                   
3660: F333                ;   Normal return location. Clear error code and return.
3661: F333                ;                   
3662: F333                POSITN3:            
3663: F333     C1         	POP	B	;restore stack.
3664: F334     AF         	XRA	A	;and clear error code byte.
3665: F335     C35CEB     	JMP	SETSTAT        
3666: F338                ;                   
3667: F338                ;   Error. Set the 's2' byte to indicate this (why?).
3668: F338                ;                   
3669: F338                POSITN4:            
3670: F338     E5         	PUSH	H             
3671: F339     CD79ED     	CALL	GETS2         
3672: F33C     36C0       	MVI	M,0C0H         
3673: F33E     E1         	POP	H              
3674: F33F                ;                   
3675: F33F                ;   Return with error code (presently in L).
3676: F33F                ;                   
3677: F33F                POSITN5:            
3678: F33F     C1         	POP	B              
3679: F340     7D         	MOV	A,L	;get error code.
3680: F341     323FE8     	STA	StatusBDOSReturn
3681: F344     C388ED     	JMP	SETS2B7        
3682: F347                ;                   
3683: F347                ;   Read a random record.
3684: F347                ;                   
3685: F347                READRAN:            
3686: F347     0EFF       	MVI	C,0FFH	;set 'read' status.
3687: F349     CDB7F2     	CALL	POSITION;position the file to proper record.
3688: F34C     CC75F1     	CZ	RDSEQ1	;and read it as usual (if no errors).
3689: F34F     C9         	RET                
3690: F350                ;                   
3691: F350                ;   Write to a random record.
3692: F350                ;                   
3693: F350                WRITERAN:           
3694: F350     0E00       	MVI	C,0	;set 'writing' flag.
3695: F352     CDB7F2     	CALL	POSITION;position the file to proper record.
3696: F355     CCB7F1     	CZ	WTSEQ1	;and write as usual (if no errors).
3697: F358     C9         	RET                
3698: F359                ;                   
3699: F359                ;   Compute the random record number. Enter with (HL) pointing
3700: F359                ; to a fcb an (DE) contains a relative location of a record
3701: F359                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3702: F359                ; byte, and (A) the 'r2' byte.
3703: F359                ;                   
3704: F359                ;   On return, the zero flag is set if the record is within
3705: F359                ; bounds. Otherwise, an overflow occured.
3706: F359                ;                   
3707: F359                COMPRAND:           
3708: F359     EB         	XCHG		;save fcb pointer in (DE).
3709: F35A     19         	DAD	D	;compute relative position of record #.
3710: F35B     4E         	MOV	C,M	;get record number into (BC).
3711: F35C     0600       	MVI	B,0            
3712: F35E     210C00     	LXI	H,12	;now get extent.
3713: F361     19         	DAD	D              
3714: F362     7E         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3715: F363     0F         	RRC		;move lower bit into bit 7.
3716: F364     E680       	ANI	80H	;and ignore all other bits.
3717: F366     81         	ADD	C	;add to our record number.
3718: F367     4F         	MOV	C,A            
3719: F368     3E00       	MVI	A,0	;take care of any carry.
3720: F36A     88         	ADC	B              
3721: F36B     47         	MOV	B,A            
3722: F36C     7E         	MOV	A,M	;now get the upper bits of extent into
3723: F36D     0F         	RRC		;bit positions 0-3.
3724: F36E     E60F       	ANI	0FH	;and ignore all others.
3725: F370     80         	ADD	B	;add this in to 'r1' byte.
3726: F371     47         	MOV	B,A            
3727: F372     210E00     	LXI	H,14	;get the 's2' byte (extra extent).
3728: F375     19         	DAD	D              
3729: F376     7E         	MOV	A,M            
3730: F377     87         	ADD	A	;and shift it left 4 bits (bits 4-7).
3731: F378     87         	ADD	A              
3732: F379     87         	ADD	A              
3733: F37A     87         	ADD	A              
3734: F37B     F5         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3735: F37C     80         	ADD	B	;now add extra extent into 'r1'.
3736: F37D     47         	MOV	B,A            
3737: F37E     F5         	PUSH	PSW	;and save carry (overflow byte 'r2').
3738: F37F     E1         	POP	H	;bit 0 of (L) is the overflow indicator.
3739: F380     7D         	MOV	A,L            
3740: F381     E1         	POP	H	;and same for first carry flag.
3741: F382     B5         	ORA	L	;either one of these set?
3742: F383     E601       	ANI	01H	;only check the carry flags.
3743: F385     C9         	RET                
3744: F386                ;                   
3745: F386                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3746: F386                ; reflect the last record used for a random (or other) file.
3747: F386                ; This reads the directory and looks at all extents computing
3748: F386                ; the largerst record number for each and keeping the maximum
3749: F386                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3750: F386                ; maximum record number. This is used to compute the space used
3751: F386                ; by a random file. 
3752: F386                ;                   
3753: F386                RANSIZE:            
3754: F386     0E0C       	MVI	C,12	;look thru directory for first entry with
3755: F388     CDC9EE     	CALL	FINDFST	;this name.
3756: F38B     2A3CE8     	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3757: F38E     112100     	LXI	D,33           
3758: F391     19         	DAD	D              
3759: F392     E5         	PUSH	H             
3760: F393     72         	MOV	M,D	;note that (D)=0.
3761: F394     23         	INX	H              
3762: F395     72         	MOV	M,D            
3763: F396     23         	INX	H              
3764: F397     72         	MOV	M,D            
3765: F398                RANSIZ1:            
3766: F398     CD05EE     	CALL	CKFILPOS;is there an extent to process?
3767: F39B     CAC0F3     	JZ	RANSIZ3	;no, we are done.
3768: F39E     CD6EED     	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3769: F3A1     110F00     	LXI	D,15	;point to last record in extent.
3770: F3A4     CD59F3     	CALL	COMPRAND;and compute random parameters.
3771: F3A7     E1         	POP	H              
3772: F3A8     E5         	PUSH	H	;now check these values against those
3773: F3A9     5F         	MOV	E,A	;already in fcb.
3774: F3AA     79         	MOV	A,C	;the carry flag will be set if those
3775: F3AB     96         	SUB	M	;in the fcb represent a larger size than
3776: F3AC     23         	INX	H	;this extent does.
3777: F3AD     78         	MOV	A,B            
3778: F3AE     9E         	SBB	M              
3779: F3AF     23         	INX	H              
3780: F3B0     7B         	MOV	A,E            
3781: F3B1     9E         	SBB	M              
3782: F3B2     DABAF3     	JC	RANSIZ2         
3783: F3B5     73         	MOV	M,E	;we found a larger (in size) extent.
3784: F3B6     2B         	DCX	H	;stuff these values into fcb.
3785: F3B7     70         	MOV	M,B            
3786: F3B8     2B         	DCX	H              
3787: F3B9     71         	MOV	M,C            
3788: F3BA                RANSIZ2:            
3789: F3BA     CDDEEE     	CALL	FINDNXT	;now get the next extent.
3790: F3BD     C398F3     	JMP	RANSIZ1	;continue til all done.
3791: F3C0                RANSIZ3:            
3792: F3C0     E1         	POP	H	;we are done, restore the stack and
3793: F3C1     C9         	RET		;return.      
3794: F3C2                ;                   
3795: F3C2                ;   Function to return the random record position of a given
3796: F3C2                ; file which has been read in sequential mode up to now.
3797: F3C2                ;                   
3798: F3C2                SETRAN:             
3799: F3C2     2A3CE8     	LHLD	ParamsDE	;point to fcb.
3800: F3C5     112000     	LXI	D,32	;and to last used record.
3801: F3C8     CD59F3     	CALL	COMPRAND;compute random position.
3802: F3CB     212100     	LXI	H,33	;now stuff these values into fcb.
3803: F3CE     19         	DAD	D              
3804: F3CF     71         	MOV	M,C	;move 'r0'.
3805: F3D0     23         	INX	H              
3806: F3D1     70         	MOV	M,B	;and 'r1'. 
3807: F3D2     23         	INX	H              
3808: F3D3     77         	MOV	M,A	;and lastly 'r2'.
3809: F3D4     C9         	RET                
3810: F3D5                ;                   
3811: F3D5                ; This routine selects the drive specified in (CurrentDrive) and
3812: F3D5                ; updates the login vector and bitmap table if this drive was
3813: F3D5                ; not already active.
3814: F3D5                ;                   
3815: F3D5                LoginDrive:         
3816: F3D5     2AB0F5     	LHLD	LoggedBitMap		; point at the "logged In" Bitmap.
3817: F3D8     3AABF5     	LDA		CurrentDrive		; get the Subject Drive.
3818: F3DB     4F         	MOV		C,A					; Save current drive
3819: F3DC     CD0DED     	CALL	SHIFTR				; Return with CurrentDrive's bit in L's lsb (byte 0)
3820: F3DF     E5         	PUSH	H					; Save it, so we will know if it is already active
3821: F3E0     EB         	XCHG               
3822: F3E1     CD7CEB     	CALL	SelectDisk			; select this drive (in BIOS).
3823: F3E4     CA6AEB     	JZ		SLCTERR				; If not valid then error exit outta here
3824: F3E7     E1         	POP	H						; retreive original state of the drive
3825: F3E8     7D         	MOV	A,L						; and put it into (A) 
3826: F3E9     1F         	RAR							; move the lsb (bit 0) into the carry flag		
3827: F3EA     D8         	RC							; if its set then this drive has already been activated
3828: F3EB                							;No, then update the logged Bitmap to reflect this drive.
3829: F3EB     2AB0F5     	LHLD	LoggedBitMap		
3830: F3EE     4D         	MOV		C,L           
3831: F3EF     44         	MOV		B,H					; put the map into (BC)
3832: F3F0     CD57F4     	CALL	SETBIT				; Set it in the LoggedBitMap
3833: F3F3     22B0F5     	SHLD	LoggedBitMap		; and save the Bit map.
3834: F3F6                ;	JMP	BITMAP	;now update the bitmap.
3835: F3F6                ;-----------------------------------------------------------
3836: F3F6                ;                   
3837: F3F6                ;   Construct the space used allocation bit map for the active
3838: F3F6                ; drive. If a file name starts with '$' and it is under the
3839: F3F6                ; current user number, then (StatusBDOSReturn) is set to minus 1. Otherwise
3840: F3F6                ; it is not set at all.
3841: F3F6                ;                   
3842: F3F6                BITMAP:             
3843: F3F6                								;compute size of allocation table.
3844: F3F6     2AC7F5     	LHLD		DSKSIZE		; get maximum  Allocation Block number
3845: F3F9     0E03       	MVI			C,3			; 2 raised to 3rd power = 8
3846: F3FB     CD0DED     	CALL		SHIFTR		;(HL)=(HL)/8.
3847: F3FE     23         	INX			H			;at lease 1 byte.
3848: F3FF     44         	MOV			B,H          
3849: F400     4D         	MOV			C,L			;set (BC) to the allocation table length.
3850: F401                ;                   
3851: F401                ;   Initialize the bitmap for this drive. Right now, the first
3852: F401                ; two bytes are specified by the disk parameter block. However
3853: F401                ; a patch could be entered here if it were necessary to setup
3854: F401                ; this table in a special mannor. For example, the bios could
3855: F401                ; determine locations of 'bad blocks' and set them as already
3856: F401                ; 'used' in the map.
3857: F401                ;                   
3858: F401     2AC0F5     	LHLD		ALOCVECT	;now zero out the table now.
3859: F404                BITMAP1:            
3860: F404     3600       	MVI			M,0			; put zero in vector
3861: F406     23         	INX			H			; point at next locatio
3862: F407     0B         	DCX			B			; count down
3863: F408     78         	MOV			A,B          
3864: F409     B1         	ORA			C			; equals zero if both (B) and (B) are Zero
3865: F40A     C204F4     	JNZ			BITMAP1		; loop for more
3866: F40D                	; allocation vector is cleared
3867: F40D     2ACBF5     	LHLD		ALLOC0		;get initial space used by directory.
3868: F410     EB         	XCHG               
3869: F411     2AC0F5     	LHLD	ALOCVECT;and put this into map.
3870: F414     73         	MOV	M,E            
3871: F415     23         	INX	H              
3872: F416     72         	MOV	M,D            
3873: F417                ;                   
3874: F417                ;   End of initialization portion.
3875: F417                ;                   
3876: F417     CDC4EB     	CALL	HOMEDRV	;now home the drive.
3877: F41A     2AB4F5     	LHLD	FilePosInDir  
3878: F41D     3603       	MVI	M,3	;force next directory request to read
3879: F41F     23         	INX	H	;in a sector.
3880: F420     3600       	MVI	M,0            
3881: F422     CD0EEE     	CALL	STFILPOS;clear initial file position also.
3882: F425                BITMAP2:            
3883: F425     0EFF       	MVI		C,0FFH			; Read next file name in directory
3884: F427     CD15EE     	CALL	NXENTRY			; And set checksum byte.
3885: F42A     CD05EE     	CALL	CKFILPOS		; Is there another file?
3886: F42D     C8         	RZ						; NO - return
3887: F42E                	                   
3888: F42E     CD6EED     	CALL	FCB2HL			; YES, get its address.
3889: F431     3EE5       	MVI		A,0E5H        
3890: F433     BE         	CMP		M				; Is it an empty file entry?
3891: F434     CA25F4     	JZ		BITMAP2			; YES - Go back for next entry
3892: F437                	                   
3893: F437     3AAAF5     	LDA		CurrentUser		; NO, Do we have the correct user number?
3894: F43A     BE         	CMP		M             
3895: F43B     C249F4     	JNZ		BITMAP3			; NO -			
3896: F43E     23         	INX		H				; YES -skip to first character in file name
3897: F43F     7E         	MOV		A,M				; Does name start with a '$'?
3898: F440     D624       	SUI		DOLLAR			; Clear acc(if =) and test for equality at the same time
3899: F442     C249F4     	JNZ		BITMAP3       
3900: F445     3D         	DCR		A				; Yes, set atatus to minus one.
3901: F446     323FE8     	STA		StatusBDOSReturn	; set return status
3902: F449                BITMAP3:            
3903: F449                ;	MVI		C,1				;now set this file's space as used in bit map.
3904: F449     3E01       	MVI		A,01H		; want to set the bit
3905: F44B     32ACF5     	STA		BitSetFlag	; Flag = 01, set the bit
3906: F44E     CD7DEE     	CALL	SETFILE       
3907: F451     CD9CED     	CALL	CHKNMBR	;keep (FilePosInDir) in bounds.
3908: F454     C325F4     	JMP	BITMAP2        
3909: F457                ;-----------------------------------------------------------
3910: F457                ;                   
3911: F457                ;  Routine to set a bit in a 16 bit value contained in (BC).
3912: F457                ; The bit set depends on the current drive selection.
3913: F457                ;                   
3914: F457                SETBIT:             
3915: F457     C5         	PUSH	B					;save original bit (BC)
3916: F458     3AABF5     	LDA		CurrentDrive		;get active drive.
3917: F45B     4F         	MOV		C,A           
3918: F45C     210100     	LXI		H,1           
3919: F45F     CD27ED     	CALL	SHIFTL				;shift bit into place for Drive bit .
3920: F462     C1         	POP		B					;now 'or' this with the original word.
3921: F463     79         	MOV		A,C           
3922: F464     B5         	ORA		L             
3923: F465     6F         	MOV		L,A					;low byte done, do high byte.
3924: F466     78         	MOV		A,B           
3925: F467     B4         	ORA		H             
3926: F468     67         	MOV		H,A           
3927: F469     C9         	RET							; HL has the result
3928: F46A                ;                   
3929: F46A                ;   Function to set the active disk number.
3930: F46A                ;                   
3931: F46A                SETDSK:             
3932: F46A     3A3EE8     	LDA	ParamE	;get parameter passed and see if this
3933: F46D     21ABF5     	LXI	H,CurrentDrive;represents a change in drives.
3934: F470     BE         	CMP	M              
3935: F471     C8         	RZ                 
3936: F472     77         	MOV	M,A	;yes it does, log it in.
3937: F473     C3D5F3     	JMP	LoginDrive     
3938: F476                ;                   
3939: F476                ;   This is the 'auto disk select' routine. The firsst byte
3940: F476                ; of the fcb is examined for a drive specification. If non
3941: F476                ; zero then the drive will be selected and loged in.
3942: F476                ;                   
3943: F476                AUTOSEL:            
3944: F476     3EFF       	MVI		A,0FFH			;say 'auto-select activated'.
3945: F478     32DEF5     	STA		AutoSelectActive
3946: F47B     2A3CE8     	LHLD	ParamsDE		;get drive specified.
3947: F47E     7E         	MOV		A,M           
3948: F47F     E61F       	ANI		1FH				;look at lower 5 bits.
3949: F481     3D         	DCR		A				;adjust for (1=A, 2=B) etc.
3950: F482     323EE8     	STA		ParamE			;and save for the select routine.
3951: F485     FE1E       	CPI		1EH				;check for 'no change' condition.
3952: F487     D29AF4     	JNC		AUTOSL1			;yes, don't change.
3953: F48A     3AABF5     	LDA		CurrentDrive	;we must change, save currently active
3954: F48D     32DFF5     	STA		OLDDRV			;drive.
3955: F490     7E         	MOV		A,M				;and save first byte of fcb also.
3956: F491     32E0F5     	STA		AutoSelectFlag	;this must be non-zero.
3957: F494     E6E0       	ANI		0E0H			;whats this for (bits 6,7 are used for
3958: F496     77         	MOV		M,A				;something)?
3959: F497     CD6AF4     	CALL	SETDSK			;select and log in this drive.
3960: F49A                AUTOSL1:            
3961: F49A     3AAAF5     	LDA		CurrentUser		;move user number into fcb.
3962: F49D     2A3CE8     	LHLD	ParamsDE		;(* upper half of first byte *)
3963: F4A0     B6         	ORA		M             
3964: F4A1     77         	MOV		M,A           
3965: F4A2     C9         	RET		;and return (all done).
3966: F4A3                ;                   
3967: F4A3                ;   Function to return the current cp/m version number.
3968: F4A3                ;                   
3969: F4A3                GETVER:             
3970: F4A3     3E22       	MVI	A,022h	;version 2.2
3971: F4A5     C35CEB     	JMP	SETSTAT        
3972: F4A8                ;                   
3973: F4A8                ;   Function (0D) to reset the disk system.
3974: F4A8                ;                   
3975: F4A8                RSTDSK:             
3976: F4A8     210000     	LXI		H,0				; clear write protect status and log
3977: F4AB     22AEF5     	SHLD	ROBitMap		; clear All Read Only Bits
3978: F4AE     22B0F5     	SHLD	LoggedBitMap	; clear all logged in drives
3979: F4B1     AF         	XRA		A             
3980: F4B2     32ABF5     	STA		CurrentDrive	;select drive 'A'.
3981: F4B5     218000     	LXI		H,Pg0Buffer		;setup default dma address.
3982: F4B8     22B2F5     	SHLD	UsersDMA      
3983: F4BB     CDEAED     	CALL	Set2UsersDMA	; Call BIOS to set DMAA 
3984: F4BE     C3D5F3     	JMP		LoginDrive		;now log in drive 'A'.
3985: F4C1                ;                   
3986: F4C1                ;   Function to open a specified file.
3987: F4C1                ;                   
3988: F4C1                OPENFIL:            
3989: F4C1     CD82ED     	CALL	CLEARS2	;clear 's2' byte.
3990: F4C4     CD76F4     	CALL	AUTOSEL	;select proper disk.
3991: F4C7     C305F0     	JMP	OPENIT	;and open the file.
3992: F4CA                ;                   
3993: F4CA                ;   Function to close a specified file.
3994: F4CA                ;                   
3995: F4CA                CLOSEFIL:           
3996: F4CA     CD76F4     	CALL	AUTOSEL	;select proper disk.
3997: F4CD     C356F0     	JMP	CLOSEIT	;and close the file.
3998: F4D0                ;                   
3999: F4D0                ;   Function to return the first occurence of a specified file
4000: F4D0                ; name. If the first byte of the fcb is '?' then the name will
4001: F4D0                ; not be checked (get the first entry no matter what).
4002: F4D0                ;                   
4003: F4D0                GETFST:             
4004: F4D0     0E00       	MVI	C,0	;prepare for special search.
4005: F4D2     EB         	XCHG               
4006: F4D3     7E         	MOV	A,M	;is first byte a '?'?
4007: F4D4     FE3F       	CPI	QMARK		;'?'    
4008: F4D6     CAE7F4     	JZ	GETFST1	;yes, just get very first entry (zero length match).
4009: F4D9     CDC9EC     	CALL	SETEXT	;get the extension byte from fcb.
4010: F4DC     7E         	MOV	A,M	;is it '?'? if yes, then we want
4011: F4DD     FE3F       	CPI	QMARK		; '?'	;an entry with a specific 's2' byte.
4012: F4DF     C482ED     	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
4013: F4E2     CD76F4     	CALL	AUTOSEL	;select proper drive.
4014: F4E5     0E0F       	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
4015: F4E7                GETFST1:            
4016: F4E7     CDC9EE     	CALL	FINDFST	;find an entry and then move it into
4017: F4EA     C3F9ED     	JMP	MOVEDIR	;the users dma space.
4018: F4ED                ;                   
4019: F4ED                ;   Function to return the next occurence of a file name.
4020: F4ED                ;                   
4021: F4ED                GETNXT:             
4022: F4ED     2AD9F5     	LHLD	SAVEFCB	;restore pointers. note that no
4023: F4F0     223CE8     	SHLD	ParamsDE	;other dbos calls are allowed.
4024: F4F3     CD76F4     	CALL	AUTOSEL	;no error will be returned, but the
4025: F4F6     CDDEEE     	CALL	FINDNXT	;results will be wrong.
4026: F4F9     C3F9ED     	JMP	MOVEDIR        
4027: F4FC                ;                   
4028: F4FC                ;   Function to delete a file by name.
4029: F4FC                ;                   
4030: F4FC                DELFILE:            
4031: F4FC     CD76F4     	CALL	AUTOSEL		;select proper drive.
4032: F4FF     CD4DEF     	CALL	ERAFILE		;erase the file.
4033: F502     C3B2EE     	JMP		STSTATUS	;set status and return.
4034: F505                ;                   
4035: F505                ;   Function to execute a sequential read of the specified
4036: F505                ; record number.    
4037: F505                ;                   
4038: F505                READSEQ:            
4039: F505     CD76F4     	CALL	AUTOSEL	;select proper drive then read.
4040: F508     C370F1     	JMP	RDSEQ          
4041: F50B                ;                   
4042: F50B                ;   Function to write the net sequential record.
4043: F50B                ;                   
4044: F50B                WRTSEQ:             
4045: F50B     CD76F4     	CALL	AUTOSEL	;select proper drive then write.
4046: F50E     C3B2F1     	JMP	WTSEQ          
4047: F511                ;                   
4048: F511                ;   Create a file function.
4049: F511                ;                   
4050: F511                FCREATE:            
4051: F511     CD82ED     	CALL	CLEARS2	;clear the 's2' byte ( extents counter hi byte).
4052: F514     CD76F4     	CALL	AUTOSEL	;select proper drive and get the next
4053: F517     C3D8F0     	JMP		GETEMPTY;empty directory space.
4054: F51A                ;                   
4055: F51A                ;   Function to rename a file.
4056: F51A                ;                   
4057: F51A                RENFILE:            
4058: F51A     CD76F4     	CALL	AUTOSEL	;select proper drive and then switch
4059: F51D     CDCAEF     	CALL	CHGNAMES;file names.
4060: F520     C3B2EE     	JMP	STSTATUS       
4061: F523                ;                   
4062: F523                ;   Function to return the logged in Bit map.
4063: F523                ;                   
4064: F523                GETLOG:             
4065: F523     2AB0F5     	LHLD	LoggedBitMap  
4066: F526     C34EF5     	JMP	GETPRM1        
4067: F529                ;                   
4068: F529                ;   Function to return the current disk assignment.
4069: F529                ;                   
4070: F529                GETCRNT:            
4071: F529     3AABF5     	LDA	CurrentDrive   
4072: F52C     C35CEB     	JMP	SETSTAT        
4073: F52F                ;                   
4074: F52F                ;   Function to set the dma address.
4075: F52F                ;                   
4076: F52F                PUTDMA:             
4077: F52F     EB         	XCHG               
4078: F530     22B2F5     	SHLD	UsersDMA	;save in our space and then get to
4079: F533     C3EAED     	JMP	Set2UsersDMA	;the bios with this also.
4080: F536                ;                   
4081: F536                ;   Function to return the allocation vector.
4082: F536                ;                   
4083: F536                GETALOC:            
4084: F536     2AC0F5     	LHLD	ALOCVECT      
4085: F539     C34EF5     	JMP	GETPRM1        
4086: F53C                ;                   
4087: F53C                ;   Function to return the read-only status vector.
4088: F53C                ;                   
4089: F53C                GETROV:             
4090: F53C     2AAEF5     	LHLD	ROBitMap      
4091: F53F     C34EF5     	JMP	GETPRM1        
4092: F542                ;                   
4093: F542                ;   Function to set the file attributes (read-only, system).
4094: F542                ;                   
4095: F542                SETATTR:            
4096: F542     CD76F4     	CALL	AUTOSEL	;select proper drive then save attributes.
4097: F545     CDEFEF     	CALL	SAVEATTR      
4098: F548     C3B2EE     	JMP	STSTATUS       
4099: F54B                ;                   
4100: F54B                ;   Function to return the address of the disk parameter block
4101: F54B                ; for the current drive.
4102: F54B                ;                   
4103: F54B                GETPARM:            
4104: F54B     2ABCF5     	LHLD	DISKPB        
4105: F54E                GETPRM1:            
4106: F54E     223FE8     	SHLD	StatusBDOSReturn
4107: F551     C9         	RET                
4108: F552                ;                   
4109: F552                ;   Function to get or set the user number. If (E) was (FF)
4110: F552                ; then this is a request to return the current user number.
4111: F552                ; Else set the user number from (E).
4112: F552                ;                   
4113: F552                GETUSER:            
4114: F552     3A3EE8     	LDA			ParamE			; get parameter.
4115: F555     FEFF       	CPI			0FFH			; want to get user number?
4116: F557     C260F5     	JNZ			SETUSER			; No, then set it
4117: F55A     3AAAF5     	LDA			CurrentUser		;yes, just return it in A
4118: F55D     C35CEB     	JMP			SETSTAT			; exit while setting return status
4119: F560                	                   
4120: F560                SETUSER:            
4121: F560     E61F       	ANI			1FH				;no,just keep the low bits (000X XXXX)
4122: F562     32AAF5     	STA			CurrentUser		;and save in Current user
4123: F565     C9         	RET                
4124: F566                ;                   
4125: F566                ;   Function to read a random record from a file.
4126: F566                ;                   
4127: F566                RDRANDOM:           
4128: F566     CD76F4     	CALL	AUTOSEL	;select proper drive and read.
4129: F569     C347F3     	JMP	READRAN        
4130: F56C                ;                   
4131: F56C                ;   Function to compute the file size for random files.
4132: F56C                ;                   
4133: F56C                WTRANDOM:           
4134: F56C     CD76F4     	CALL	AUTOSEL	;select proper drive and write.
4135: F56F     C350F3     	JMP	WRITERAN       
4136: F572                ;                   
4137: F572                ;   Function to compute the size of a random file.
4138: F572                ;                   
4139: F572                FILESIZE:           
4140: F572     CD76F4     	CALL	AUTOSEL	;select proper drive and check file length
4141: F575     C386F3     	JMP	RANSIZE        
4142: F578                ;                   
4143: F578                ;   Function #37. This allows a program to log off any drives.
4144: F578                ; On entry, set (DE) to contain a word with bits set for those
4145: F578                ; drives that are to be logged off. The log-in vector and the
4146: F578                ; write protect vector will be updated. This must be a M/PM
4147: F578                ; special function. 
4148: F578                ;                   
4149: F578                LOGOFF:             
4150: F578     2A3CE8     	LHLD	ParamsDE	;get drives to log off.
4151: F57B     7D         	MOV	A,L	;for each bit that is set, we want
4152: F57C     2F         	CMA		;to clear that bit in (LoggedBitMap)
4153: F57D     5F         	MOV	E,A	;and (ROBitMap).
4154: F57E     7C         	MOV	A,H            
4155: F57F     2F         	CMA                
4156: F580     2AB0F5     	LHLD	LoggedBitMap	;reset the login Bit map.
4157: F583     A4         	ANA	H              
4158: F584     57         	MOV	D,A            
4159: F585     7D         	MOV	A,L            
4160: F586     A3         	ANA	E              
4161: F587     5F         	MOV	E,A            
4162: F588     2AAEF5     	LHLD	ROBitMap      
4163: F58B     EB         	XCHG               
4164: F58C     22B0F5     	SHLD	LoggedBitMap	;and save.
4165: F58F     7D         	MOV	A,L	;now do the write protect vector.
4166: F590     A3         	ANA	E              
4167: F591     6F         	MOV	L,A            
4168: F592     7C         	MOV	A,H            
4169: F593     A2         	ANA	D              
4170: F594     67         	MOV	H,A            
4171: F595     22AEF5     	SHLD	ROBitMap	;and save. all done.
4172: F598     C9         	RET                
4173: F599                ;                   
4174: F599                ;   Get here to return to the user.
4175: F599                ;                   
4176: F599                                    
4177: F599                ;                   
4178: F599                ;   Function #40. This is a special entry to do random i/o.
4179: F599                ; For the case where we are writing to unused disk space, this
4180: F599                ; space will be zeroed out first. This must be a M/PM special
4181: F599                ; purpose function, because why would any normal program even
4182: F599                ; care about the previous contents of a sector about to be
4183: F599                ; written over.     
4184: F599                ;                   
4185: F599                WTSPECL:            
4186: F599     CD76F4     	CALL	AUTOSEL	;select proper drive.
4187: F59C     3E02       	MVI	A,2	;use special write mode.
4188: F59E     32D6F5     	STA	MODE           
4189: F5A1     0E00       	MVI	C,0	;set write indicator.
4190: F5A3     CDBBF2     	CALL	POSITN1	;position the file.
4191: F5A6     CCB7F1     	CZ	WTSEQ1	;and write (if no errors).
4192: F5A9     C9         	RET                
4193: F5AA                                    
4194: F5AA                ;**************************************************************
4195: F5AA                ;*                  
4196: F5AA                ;*     BDOS data storage pool.
4197: F5AA                ;*                  
4198: F5AA                ;**************************************************************
4199: F5AA                                    
4200: F5AA     00         CurrentUser:			DB	0	;current user number.
4201: F5AB     00         CurrentDrive:			DB	0	;currently active drive.
4202: F5AC     00         BitSetFlag:				DB	0	; Flag to set(01) or reset(00) bit in disk allocation table
4203: F5AD                                    
4204: F5AD                ;                   
4205: F5AD     E5         EMPTYFCB:				DB	0E5H	;empty directory segment indicator.
4206: F5AE     0000       ROBitMap:				DW	0	;write protect status for all 16 drives.
4207: F5B0     0000       LoggedBitMap:			DW	0	;drive active word (1 bit per drive).
4208: F5B2     8000       UsersDMA:				DW	080H	;user's dma address (defaults to 80h).
4209: F5B4                ;                   
4210: F5B4                ;   Scratch areas from parameter block.
4211: F5B4                ;                   
4212: F5B4     0000       FilePosInDir:			DW	0	;relative position within dir segment for file (0-3).
4213: F5B6     0000       LastTrackNumber:		DW	0	;last selected track number.
4214: F5B8     0000       LastSectorNumber:		DW	0	;last selected sector number.
4215: F5BA                ;                   
4216: F5BA                ;   Disk storage areas from parameter block.
4217: F5BA                ;                   
4218: F5BA     0000       DIRBUF:					DW	0	;address of directory buffer to use.
4219: F5BC     0000       DISKPB:					DW	0	;contains address of disk parameter block.
4220: F5BE     0000       CHKVECT:				DW	0	;address of check vector.
4221: F5C0     0000       ALOCVECT:				DW	0	;address of allocation vector (bit map).
4222: F5C2                ;                   
4223: F5C2                ;   Parameter block returned from the bios.
4224: F5C2                ;                   
4225: F5C2     0000       SECTORS:				DW	0	;sectors per track from bios.
4226: F5C4     00         BLKSHFT:				DB	0	;block shift.
4227: F5C5     00         BLKMASK:				DB	0	;block mask.
4228: F5C6     00         EXTMASK:				DB	0	;extent mask.
4229: F5C7     0000       DSKSIZE:				DW	0	;disk size from bios (number of blocks-1).
4230: F5C9     0000       DIRSIZE:				DW	0	;directory size.
4231: F5CB     0000       ALLOC0:					DW	0	;storage for first bytes of bit map (dir space used).
4232: F5CD     0000       ALLOC1:					DW	0    
4233: F5CF     0000       OFFSET:					DW	0	;first usable track number.
4234: F5D1     0000       XLATE:					DW	0	;sector translation table address.
4235: F5D3                ;                   
4236: F5D3                ;                   
4237: F5D3     00         CLOSEFLG:				DB	0	;close flag (=0ffh is extent written ok).
4238: F5D4     00         RDWRTFLG:				DB	0	;read/write flag (0ffh=read, 0=write).
4239: F5D5     00         FNDSTAT:				DB	0	;filename found status (0=found first entry).
4240: F5D6     00         MODE:					DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4241: F5D7     00         RELBLOCK:				DB	0	;relative position within fcb of block number written.
4242: F5D8     00         COUNTER:				DB	0	;byte counter for directory name searches.
4243: F5D9     00000000   SAVEFCB:				DW	0,0	;save space for address of fcb (for directory searches).
4244: F5DD     00         BIGDISK:				DB	0	;if =0 then disk is > 256 blocks long.
4245: F5DE     00         AutoSelectActive:		DB	0	;if non-zero, then auto select activated.
4246: F5DF     00         OLDDRV:					DB	0	;on auto select, storage for previous drive.
4247: F5E0     00         AutoSelectFlag:			DB	0	;if non-zero, then auto select changed drives.
4248: F5E1     00         SAVNXT:					DB	0	;storage for next record number to access.
4249: F5E2     00         SAVEXT:					DB	0	;storage for extent number of file.
4250: F5E3     0000       SAVNREC:				DW	0	;storage for number of records in file.
4251: F5E5     0000       BLKNMBR:				DW	0	;block number (physical sector) used within a file or logical sector.
4252: F5E7     0000       LOGSECT:				DW	0	;starting logical (128 byte) sector of block (physical sector).
4253: F5E9     00         FCBPOS:					DB	0	;relative position within buffer for fcb of file of interest.
4254: F5EA     0000       FILEPOS:				DW	0	;files position within directory (0 to max entries -1).
4255: F5EC                ;                   
4256: F5EC                ;   Disk directory buffer checksum bytes. One for each of the
4257: F5EC                ; 16 possible drives.
4258: F5EC                ;                   
4259: F5EC                CKSUMTBL:           
4260: F5EC     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4261: F5FC                ;                   
4262: F5FC                ;   Extra space ?   
4263: F5FC                ;                   
4264: F5FC     00000000   	DB	0,0,0,0         
4265: F600                ;                   
4266: F600                ;**************************************************************
4267: F600                ;*                  
4268: F600                ;*        B I O S   J U M P   T A B L E
4269: F600                ;*                  
4270: F600                ;**************************************************************
4271: F600                ;                   
4272: F600                BIOSEntry	Equ	0F600H		; start of bios
4273: F600                                    
4274: F600                BOOT	EQU		BIOSEntry + 000H	
4275: F600                WBOOT	EQU		BIOSEntry + 003H
4276: F600                CONST	EQU		BIOSEntry + 006H
4277: F600                CONIN	EQU		BIOSEntry + 009H
4278: F600                CONOUT	EQU		BIOSEntry + 00CH
4279: F600                LIST	EQU		BIOSEntry + 00FH
4280: F600                PUNCH	EQU		BIOSEntry + 012H
4281: F600                READER	EQU		BIOSEntry + 015H
4282: F600                HOME	EQU		BIOSEntry + 018H
4283: F600                SELDSK	EQU		BIOSEntry + 01BH
4284: F600                SETTRK	EQU		BIOSEntry + 01EH
4285: F600                SETSEC	EQU		BIOSEntry + 021H
4286: F600                SETDMA	EQU		BIOSEntry + 024H
4287: F600                READ	EQU		BIOSEntry + 027H
4288: F600                WRITE	EQU		BIOSEntry + 02AH
4289: F600                PRSTAT	EQU		BIOSEntry + 02DH
4290: F600                SECTRN	EQU		BIOSEntry + 030H
4291: F600                                    
4292: F600                ;*                  
4293: F600                ;******************   E N D   O F   C P / M   *****************
4294: F600                ;*                  
4295: F600                CodeEnd:            
4296: F600                		END               




                                    Xref


0000	0000	$                             		  1588,

2514	ED74	ADDA2HL                       		  3446,
0500	E245	ADDHL                         		  0518,  0918,  1111,
0637	E2BD	AFN                           		  0645,
0643	E2C5	AFN1                          		  0641,
4231	F5CB	ALLOC0                        		  3867,
4232	F5CD	ALLOC1                        		  2598,
4221	F5C0	ALOCVECT                      		  2758,  3858,  3869,  4084,
0050	002A	ASTRK                         		  0658,
0052	0040	ATSIGN                        		  1761,
3943	F476	AUTOSEL                       		  3990,  3996,  4013,  4024,  4031,  4039,  4045,  4052,  4058,  4096,  4128,  4134,  4140,  4186,
4245	F5DE	AUTOSELECTACTIVE              		  1487,  1517,  3945,
4247	F5E0	AUTOSELECTFLAG                		  1486,  1522,  3956,
3960	F49A	AUTOSL1                       		  3952,

1783	E9FF	BACKUP                        		  1898,  1938,
1787	EA07	BACKUP1                       		  1784,
1402	E74D	BADLOAD                       		  1399,
1593	E8EC	BADSCTR                       		  2162,
1625	E925	BADSEC                        		  1602,
1626	E930	BADSEL                        		  1609,
1594	E8EE	BADSLCT                       		  2061,
1429	E77E	BATCH                         		  0288,  0406,  0760,  1388,
1431	E77F	BATCHFCB                      		  0300,  0303,  0305,  0306,  0316,  0320,  0413,
1624	E921	BDOSDRV                       		  1637,
1472	E806	BDOSENTRY                     		
1623	E915	BDOSERR                       		  1638,
1516	E873	BDOSEXIT                      		  1488,
1529	E890	BDOSEXIT1                     		  1519,  1524,  1998,
1514	E873	BDOSSTACK                     		  1484,
4244	F5DD	BIGDISK                       		  2124,  2303,  2808,  3214,  3442,
4272	F600	BIOSENTRY                     		  4274,  4275,  4276,  4277,  4278,  4279,  4280,  4281,  4282,  4283,  4284,  4285,  4286,  4287,  4288,  4289,  4290,
3842	F3F6	BITMAP                        		
3859	F404	BITMAP1                       		  3865,
3882	F425	BITMAP2                       		  3891,  3908,
3902	F449	BITMAP3                       		  3895,  3899,
4202	F5AC	BITSETFLAG                    		  2776,  2973,  3905,
0039	0020	BLANK                         		  0112,  0442,  0466,  0492,  0672,  0720,  0861,  0888,  0963,  1015,  1024,  1027,  1269,  1283,  1299,  1359,  1416,  1679,  1733,  1772,  1785,  1803,
4227	F5C5	BLKMASK                       		  2349,  3499,
4251	F5E5	BLKNMBR                       		  2172,  2180,  2324,  2330,  2343,  2355,  3437,  3492,  3497,  3506,
4226	F5C4	BLKSHFT                       		  2270,  2342,
4274	F600	BOOT                          		
0040	007B	BRACKETLEFT                   		  0278,
0041	007D	BRACKETRIGHT                  		
0026	0008	BS                            		  1677,  1740,  1788,  1850,

0051	005E	CARET                         		  1758,
0062	E000	CBASE                         		  0826,  0827,  1323,
1425	E77E	CCPSTACK                      		  0749,  0773,
1440	E7C2	CDRIVE                        		  0260,  0268,  0296,  0323,  0415,  0542,  0764,  0788,  0933,  0946,  0949,  1289,
2047	EB69	CHARBUF                       		  1647,  1688,  1703,
0461	E21C	CHECK                         		  0572,  0610,  0655,
2595	EDAE	CHECKDIR                      		  2716,
2432	ED1A	CHECKSUM                      		  2602,
1442	E7C3	CHGDRV                        		  0522,  0547,  0791,  0854,  0929,  0942,  1200,  1224,  1285,  1339,  1417,
3099	EFDB	CHGNAM1                       		  3107,
3090	EFCA	CHGNAMES                      		  4059,
2329	ECA7	CHKBLK                        		  3388,  3416,
1670	E96F	CHKCHAR                       		  1658,  1755,
0376	E1C2	CHKCON                        		  0331,  1041,  1116,
2616	EDD4	CHKDIR1                       		  2609,
2565	ED9C	CHKNMBR                       		  3301,  3907,
2486	ED54	CHKROFL                       		  2968,  3102,
2436	ED20	CHKSUM1                       		  2440,
4220	F5BE	CHKVECT                       		  2603,
2499	ED64	CHKWPRT                       		  2962,  3091,  3277,  3408,
2724	EE45	CKBITMAP                      		  2773,  3006,  3035,
2761	EE66	CKBMAP1                       		  2764,
1702	E99D	CKCON1                        		  1696,
1704	E9A0	CKCON2                        		  1690,
1687	E97E	CKCONSOL                      		  1717,  2027,
2666	EE05	CKFILPOS                      		  2890,  2966,  3100,  3118,  3131,  3204,  3284,  3312,  3342,  3348,  3766,  3885,
2488	ED57	CKROF1                        		  3410,
4259	F5EC	CKSUMTBL                      		  2173,  2596,  2605,
0735	E32E	CLEARBUF                      		  0064,
0621	E2AC	CLEAREXTENT                   		  0590,  0611,
0623	E2AE	CLEAREXTENT1                  		  0627,
2533	ED82	CLEARS2                       		  3989,  4012,  4051,
0170	E0DA	CLOSE                         		  0321,  1176,
3995	F4CA	CLOSEFIL                      		  1562,
4237	F5D3	CLOSEFLG                      		  3266,  3310,  3325,
3192	F056	CLOSEIT                       		  3311,  3632,  3997,
3213	F081	CLOSEIT1                      		  3249,
3222	F08F	CLOSEIT2                      		  3220,
3227	F095	CLOSEIT3                      		  3224,
3231	F09C	CLOSEIT4                      		  3216,
3245	F0B1	CLOSEIT5                      		  3230,
3264	F0CB	CLOSEIT6                      		  3256,
3268	F0D3	CLOSEIT7                      		  3229,  3238,  3243,
0813	E397	CMDADR                        		  0800,
0681	E2EC	CMDTBL                        		  0703,
0772	E358	CMMND1                        		  0339,  0456,  1064,  1068,  1391,  1420,
0784	E36E	CMMND2                        		  0768,
0024	0003	CNTRLC                        		  1604,  1698,  1958,
0025	0005	CNTRLE                        		  1870,
0031	0010	CNTRLP                        		  1879,
0032	0012	CNTRLR                        		  1907,
0033	0013	CNTRLS                        		  1695,
0034	0015	CNTRLU                        		  1901,
0035	0018	CNTRLX                        		  1889,
0036	001A	CNTRLZ                        		  1113,
4295	F600	CODEEND                       		
0060	E000	CODESTART                     		
0046	003A	COLON                         		  0476,  0538,  1001,  1006,
2319	EC9A	COMBLK                        		  3387,  3415,
1404	E756	COMFILE                       		  1305,
0748	E332	COMMAND                       		  0063,
3707	F359	COMPRAND                      		  3770,  3801,
4277	F609	CONIN                         		  1652,  1694,  1697,  1999,
4278	F60C	CONOUT                        		  1720,  1786,  1789,  1994,
4276	F606	CONST                         		  1691,  1993,  1996,
0516	E24C	CONVERT                       		  1344,
0509	E24A	CONVFST                       		  0789,  0853,  0959,  1056,  1088,  1139,  1198,  1220,  1338,  1414,
0541	E275	CONVRT1                       		  0532,
0545	E27C	CONVRT2                       		  0539,
0553	E282	CONVRT3                       		  0544,
0555	E284	CONVRT4                       		
0571	E287	CONVRT7                       		  0575,
4242	F5D8	COUNTER                       		  2876,  2903,
0030	000D	CR                            		  0104,  1671,  1810,  1846,  1969,
0229	E109	CREATE                        		  1146,
0103	E098	CRLF                          		  0120,  0438,  0454,  0774,  0995,  1093,  1381,
2045	EB67	CURPOS                        		  1729,  1774,  1799,  1831,  1856,  1894,  1934,
4201	F5AB	CURRENTDRIVE                  		  1635,  2088,  2459,  3817,  3916,  3933,  3953,  3980,  4071,
4200	F5AA	CURRENTUSER                   		  3893,  3961,  4117,  4122,

2074	EB72	DE2HL                         		  2116,  2121,  2662,  3081,  3143,
2076	EB73	DE2HL1                        		  2083,
0852	E3CE	DECODE                        		  1137,  1264,
0859	E3DE	DECODE1                       		  0884,
0654	E2CC	DECODENAME                    		  0556,  0594,  0667,
0662	E2DD	DECODENAME1                   		  0659,
0665	E2DF	DECODENAME2                   		  0661,
0037	007F	DEL                           		  1730,  1860,
0405	E1DD	DELBATCH                      		  0338,  0345,  0455,
0195	E0EF	DELETE                        		  0414,  1074,  1144,
4030	F4FC	DELFILE                       		  1565,
4218	F5BA	DIRBUF                        		  2114,  2434,  2509,  2644,  2658,  3481,
1995	EB3B	DIRC1                         		  1991,
1988	EB2F	DIRCIO                        		  1551,
0958	E44D	DIRECT                        		  0814,
0966	E45E	DIRECT1                       		  0970,
0971	E465	DIRECT2                       		  0964,
0976	E46E	DIRECT3                       		  1044,
1004	E4A2	DIRECT4                       		  0994,
1008	E4AA	DIRECT5                       		  1003,
1011	E4AF	DIRECT6                       		  1035,  1037,
1038	E4E4	DIRECT7                       		  1025,  1033,
1040	E4E5	DIRECT8                       		  0987,
1045	E4F1	DIRECT9                       		  0977,  1042,
2631	EDE4	DIRREAD                       		  2714,
4230	F5C9	DIRSIZE                       		  2475,  2691,
2622	EDD6	DIRWRITE                      		  2975,  3084,
4219	F5BC	DISKPB                        		  2117,  4104,
1628	E93C	DISKRO                        		  1613,
0399	E1D8	DMASET                        		  0786,  1164,  1316,
0054	0024	DOLLAR                        		  1819,  3898,
2151	EBD5	DOREAD                        		  2633,  3392,
2157	EBDB	DOWRITE                       		  2626,  3496,  3516,
1026	E4CD	DRECT63                       		  1020,
1028	E4CF	DRECT65                       		  1016,
0926	E42A	DSELECT                       		  0960,  1072,  1090,  1141,  1202,  1303,
0140	E0BD	DSKSEL                        		  0299,  0325,  0412,  0416,  0765,  0936,  0950,  1291,  1390,
4229	F5C7	DSKSIZE                       		  2122,  2829,  3024,  3844,

4205	F5AD	EMPTYFCB                      		  3280,
0017	0005	ENTRY                         		  0090,  0136,  0143,  0149,  0197,  0203,  0238,  0250,  0349,  0378,  0382,  0390,  0401,
0148	E0C3	ENTRY1                        		  0158,  0172,  0179,  0185,  0231,
0202	E0F4	ENTRY2                        		  0212,  0225,
0043	003D	EQUALS                        		  0470,  1212,
2965	EF55	ERAFIL1                       		  2977,
2961	EF4D	ERAFILE                       		  4032,
1055	E4F5	ERASE                         		  0815,
1071	E518	ERASE1                        		  1058,
1601	E8F4	ERROR1                        		  1593,
1608	E900	ERROR2                        		  1594,
1612	E906	ERROR3                        		  1595,
1616	E90C	ERROR4                        		  1596,
1619	E90F	ERROR5                        		  1610,  1614,
1254	E658	EXISTS                        		  1251,
2298	EC81	EXTBLK                        		  2323,  3426,
2309	EC94	EXTBLK1                       		  2305,
4228	F5C6	EXTMASK                       		  2388,  2856,  3323,
0915	E421	EXTRACT                       		  0985,  1013,  1022,

1436	E7A0	FCB                           		  0164,  0165,  0190,  0217,  0517,  0709,  0857,  0928,  0961,  1073,  1142,  1149,  1165,  1175,  1205,  1206,  1234,  1238,  1268,  1282,  1297,  1317,  1342,  1347,  1349,  1351,  1415,
2508	ED6E	FCB2HL                        		  2487,  2797,  2902,  2969,  3079,  3138,  3207,  3768,  3888,
4253	F5E9	FCBPOS                        		  2510,  2709,
3065	EFB1	FCBSET                        		  3302,
4050	F511	FCREATE                       		  1568,
0029	000C	FF                            		
4254	F5EA	FILEPOS                       		  2169,  2552,  2667,  2679,  2693,  2695,  2701,  2940,  3195,  3196,
4212	F5B4	FILEPOSINDIR                  		  2102,  2478,  2554,  3877,
1627	E937	FILERO                        		  1617,
4139	F572	FILESIZE                      		  1581,
2873	EEC9	FINDFST                       		  2964,  3093,  3116,  3130,  3203,  3283,  3341,  3755,  4016,
2887	EEDE	FINDNXT                       		  2921,  2928,  2976,  3106,  3123,  3789,  4025,
2901	EEFB	FNDNXT1                       		  2896,
2906	EF04	FNDNXT2                       		  2938,
2923	EF24	FNDNXT3                       		  2918,
2933	EF2D	FNDNXT4                       		  2912,  2915,  2922,
2939	EF34	FNDNXT5                       		  2909,
2953	EF45	FNDNXT6                       		  2891,  2900,
2999	EF74	FNDSPA1                       		  3040,  3059,
3023	EF85	FNDSPA2                       		  3002,
3045	EFA0	FNDSPA3                       		  3008,  3037,
3056	EFA8	FNDSPA4                       		  3029,
2992	EF72	FNDSPACE                      		  3430,
4239	F5D5	FNDSTAT                       		  2845,  2875,  2943,
1588	0028	FUNCTIONCOUNT                 		  1491,
1544	E89A	FUNCTIONVECTOR                		  1588,  1494,

4083	F536	GETALOC                       		  1573,
1411	E759	GETBACK                       		  1047,  1077,  1114,  1117,  1124,  1187,  1240,  1246,  1253,  1401,
1413	E75C	GETBACK1                      		  1272,  1287,  1292,
2273	EC68	GETBLK1                       		  2277,
2283	EC76	GETBLK2                       		  2288,
2289	EC7F	GETBLK3                       		  2285,
2269	EC61	GETBLOCK                      		  2320,  3419,
1646	E956	GETCHAR                       		  1657,  1842,
1974	EB23	GETCON                        		  1546,
4070	F529	GETCRNT                       		  1571,
2026	EB59	GETCSTS                       		  1556,
0388	E1D0	GETDSK                        		  0775,  0787,  0997,
1656	E961	GETECHO                       		  1975,
3276	F0D8	GETEMPTY                      		  3347,  3654,  4053,
0584	E291	GETEXT                        		  0573,
0591	E29E	GETEXT1                       		  0588,
0609	E2A2	GETEXT4                       		  0613,
4003	F4D0	GETFST                        		  1563,
4015	F4E7	GETFST1                       		  4008,
0287	E139	GETINP                        		  0780,  1061,
0344	E196	GETINP1                       		  0290,  0302,  0308,  0322,
0354	E1A7	GETINP2                       		  0332,
0357	E1AB	GETINP3                       		  0366,
0367	E1BA	GETINP4                       		  0361,
2004	EB48	GETIOB                        		  1552,
4064	F523	GETLOG                        		  1570,
3293	F0FA	GETMT1                        		  3297,
3308	F10E	GETNEXT                       		  3380,  3548,
4021	F4ED	GETNXT                        		  1564,
4103	F54B	GETPARM                       		  1577,
4105	F54E	GETPRM1                       		  4066,  4085,  4091,
1980	EB29	GETRDR                        		  1548,
4089	F53C	GETROV                        		  1575,
2524	ED79	GETS2                         		  2534,  2541,  3199,  3537,  3671,
0248	E115	GETSETUC                      		  0758,  1271,
4113	F552	GETUSER                       		  1578,
0242	E113	GETUSR                        		  0255,
3969	F4A3	GETVER                        		  1557,
2457	ED2E	GETWPRT                       		  2500,  3197,
0049	003E	GRTTHAN                       		  0482,  0778,
3329	F137	GTNEXT1                       		  3321,
3339	F142	GTNEXT2                       		  3327,
3351	F160	GTNEXT3                       		  3328,  3343,
3353	F163	GTNEXT4                       		  3350,
3361	F16A	GTNEXT5                       		  3335,  3346,  3349,

0824	E3A5	HALT                          		
0904	E418	HL2DE                         		  0315,  0910,  1208,  1353,
4282	F618	HOME                          		  2137,
2136	EBC4	HOMEDRV                       		  2881,  3876,

0070	E006	INBUFF                        		  0080,  0312,  0329,  0348,  0355,  0369,  0737,  0766,  1062,  1354,
0079	E088	INPOINT                       		  0370,  0523,  0629,  1070,  1209,  1219,
0015	0003	IOBYTE                        		  2005,  2011,
2039	EB60	IOERR1                        		  3362,  3398,  3414,
2159	EBDE	IORET                         		  2153,

2065	EB6D	JUMPHL                        		  2163,  2495,  2503,

4214	F5B8	LASTSECTORNUMBER              		  2108,  2143,  2185,  2248,
4213	F5B6	LASTTRACKNUMBER               		  2105,  2139,  2190,  2243,
0048	003C	LESSTH                        		  0480,
0028	000A	LF                            		  0106,  1673,  1745,  1812,  1848,
4279	F60F	LIST                          		  1550,  1725,
4207	F5B0	LOGGEDBITMAP                  		  3816,  3829,  3833,  3978,  4065,  4156,  4164,
2341	ECAD	LOGICAL                       		  3390,  3464,
2344	ECB3	LOGICL1                       		  2347,
3815	F3D5	LOGINDRIVE                    		  3937,  3984,
4149	F578	LOGOFF                        		  1583,
4252	F5E7	LOGSECT                       		  2348,  3489,

0013	0040	MEM                           		  0059,
4240	F5D6	MODE                          		  2399,  3369,  3404,  3465,  3544,  3578,  4188,
2551	ED8F	MOREFLS                       		  2566,  2612,  2898,
0899	E416	MOVE3                         		  1306,
0267	E129	MOVECD                        		  0350,  1290,  1389,
2657	EDF9	MOVEDIR                       		  4017,  4026,
3174	F048	MOVEWORD                      		  3232,  3234,

0081	E08A	NAMEPNT                       		  0439,  0527,
1444	E7C4	NBYTES                        		  1094,  1097,
1794	EA0C	NEWLINE                       		  1903,  1911,
1798	EA14	NEWLN1                        		  1805,
0844	E3C6	NOFILE                        		  0842,
0488	E23B	NONBLANK                      		  0496,  0525,  1211,
0841	E3C0	NONE                          		  0975,  1076,  1245,
1188	E5DD	NOSPACE                       		  1183,
0680	0006	NUMCMDS                       		  0707,
2690	EE15	NXENTRY                       		  2889,  3884,
2700	EE29	NXENTRY1                      		  2697,
2704	EE30	NXENTRY2                      		  2707,

4233	F5CF	OFFSET                        		  2237,
4246	F5DF	OLDDRV                        		  1526,  3954,
0156	E0CB	OPEN                          		  0166,  0301,
0162	E0D0	OPENFCB                       		  1091,  1307,
3988	F4C1	OPENFIL                       		  1561,
3128	F005	OPENIT                        		  3645,  3991,
3133	F00E	OPENIT1                       		  3352,
3162	F03F	OPENIT2                       		  3158,  3160,
1712	E9A3	OUTCHAR                       		  1759,  1770,  1773,  1796,  1804,  1811,  1813,  1970,
1727	E9BD	OUTCHR1                       		  1715,
1744	E9D4	OUTCHR2                       		  1741,
1767	E9EB	OUTCON                        		  1547,  1662,  1756,  1824,
1771	E9F1	OUTCON1                       		  1777,
1809	EA24	OUTCRLF                       		  1634,  1797,  1874,
2043	EB65	OUTFLAG                       		  1713,  1857,  1931,  1936,  1939,

0670	E2E4	PADFIELD                      		  0589,  0656,  0674,
0886	E409	PADNUMBER                     		  0862,  0892,
1507	E83E	PARAME                        		  1479,  1527,  3932,  3950,  4114,
1506	E83C	PARAMSDE                      		  1476,  1502,  1520,  1833,  2299,  2361,  2370,  2525,  2878,  3076,  3094,  3140,  3163,  3210,  3278,  3281,  3286,  3314,  3409,  3439,  3584,  3756,  3799,  3946,  3962,  4023,  4150,
0045	002E	PERIOD                        		  0474,  0586,
0019	0080	PG0BUFFER                     		  0313,  0395,  0785,  0916,  1110,  1368,  1380,  3981,
0118	E0A7	PLINE                         		  0834,  0843,  1060,  1184,  1252,  1400,
0122	E0AC	PLINE2                        		  0130,  0330,
3576	F2B7	POSITION                      		  3687,  3695,
3582	F2BB	POSITN1                       		  4190,
3629	F2FB	POSITN2                       		  3619,
3662	F333	POSITN3                       		  3625,  3648,
3669	F338	POSITN4                       		  3638,  3653,  3658,
3677	F33F	POSITN5                       		  3611,
0053	0023	POUNDSN                       		  1795,
0087	E08C	PRINT                         		  0096,  0128,  0447,  0453,  0777,  0779,  1115,
0094	E092	PRINTB                        		  0105,  0107,  0113,  1000,  1002,  1007,  1029,
4289	F62D	PRSTAT                        		
1632	E940	PRTERR                        		  1603,  1620,
2046	EB68	PRTFLAG                       		  1723,  1882,
1817	EA2E	PRTMESG                       		  1639,  1641,  1826,  2022,
2018	EB53	PRTSTR                        		  1554,
4280	F612	PUNCH                         		  1549,
4076	F52F	PUTDMA                        		  1572,

0042	003F	QMARK                         		  0452,  0640,  0660,  0967,  2911,  4007,  4011,

3765	F398	RANSIZ1                       		  3790,
3788	F3BA	RANSIZ2                       		  3782,
3791	F3C0	RANSIZ3                       		  3767,
3753	F386	RANSIZE                       		  4141,
1838	EA4A	RDBUF1                        		  1854,  1864,  1887,  1965,
1909	EACB	RDBUF10                       		  1858,
1916	EAD3	RDBUF11                       		  1928,
1929	EAE5	RDBUF12                       		  1919,
1937	EAF4	RDBUF13                       		  1941,
1946	EB01	RDBUF14                       		  1908,
1950	EB04	RDBUF15                       		  1868,
1963	EB18	RDBUF16                       		  1960,
1966	EB1C	RDBUF17                       		  1847,  1849,
1841	EA4C	RDBUF2                        		  1877,  1933,  1942,
1859	EA71	RDBUF3                        		  1851,
1869	EA81	RDBUF4                        		  1861,
1878	EA92	RDBUF5                        		  1871,
1888	EAA3	RDBUF6                        		  1880,
1892	EAA9	RDBUF7                        		  1899,
1900	EABA	RDBUF8                        		  1890,
1906	EAC6	RDBUF9                        		  1902,
1830	EA3C	RDBUFF                        		  1555,  1896,  1905,
0835	E3B5	RDERR                         		  0833,
0832	E3AF	RDERROR                       		  1125,
4127	F566	RDRANDOM                      		  1579,
0210	E0F9	RDREC                         		  0218,  0307,  1318,
3367	F170	RDSEQ                         		  4040,
3370	F175	RDSEQ1                        		  3688,
3386	F19A	RDSEQ2                        		  3377,
3397	F1AF	RDSEQ3                        		  3379,  3385,  3389,
4238	F5D4	RDWRTFLG                      		  3344,  3372,  3407,
4287	F627	READ                          		  2152,
4281	F615	READER                        		  1981,
0216	E0FE	READFCB                       		  1103,
3685	F347	READRAN                       		  4129,
4038	F505	READSEQ                       		  1566,
4241	F5D7	RELBLOCK                      		  3420,  3444,
0236	E10E	RENAM                         		  1239,
1197	E5E6	RENAME                        		  0818,
1216	E615	RENAME1                       		  1213,
1231	E62F	RENAME2                       		  1227,
1235	E634	RENAME3                       		
1244	E643	RENAME4                       		  1237,
1247	E649	RENAME5                       		  1215,  1221,  1230,
1250	E64F	RENAME6                       		  1204,
4057	F51A	RENFILE                       		  1569,
0134	E0B8	RESDSK                        		  0759,
0941	E43C	RESETDR                       		  1127,  1248,  1337,  1396,  1412,
2034	EB5F	RETURN                        		  1584,  1585,
4206	F5AE	ROBITMAP                      		  2458,  2469,  2474,  3977,  4090,  4162,  4171,
1595	E8F0	RODISK                        		  2502,
1596	E8F2	ROFILE                        		  2494,
3975	F4A8	RSTDSK                        		  1559,
1438	E7C1	RTNCODE                       		  0150,  0978,

2853	EEB8	SAMEXT                        		  2926,
3117	EFF4	SAVATR1                       		  3124,
1136	E583	SAVE                          		  0817,
1155	E5AA	SAVE1                         		  1170,
1174	E5C7	SAVE2                         		  1158,
1182	E5D1	SAVE3                         		  1147,  1169,
1185	E5D7	SAVE4                         		  1178,
3114	EFEF	SAVEATTR                      		  4097,
4243	F5D9	SAVEFCB                       		  2879,  2892,  4022,
4249	F5E2	SAVEXT                        		  2282,  2390,
4250	F5E3	SAVNREC                       		  2272,  2351,  2383,  2405,  3374,  3382,  3412,  3518,  3554,
4248	F5E1	SAVNXT                        		  2386,  2409,  3375,  3519,
0702	E304	SEARCH                        		  0794,
0705	E309	SEARCH1                       		  0730,
0711	E312	SEARCH2                       		  0718,
0724	E325	SEARCH3                       		  0714,  0727,
0728	E32A	SEARCH4                       		  0721,
4225	F5C2	SECTORS                       		  2119,  2203,  2215,
4290	F630	SECTRN                        		  2261,
4283	F61B	SELDSK                        		  2090,
2087	EB7C	SELECTDISK                    		  3822,
2129	EBC0	SELECTDISK1                   		  2127,
0047	003B	SEMIC                         		  0478,
2637	EDEA	SET2USERSDMA                  		  2627,  3507,  3983,  4079,
4095	F542	SETATTR                       		  1576,
3914	F457	SETBIT                        		  2473,  3832,
0254	E11A	SETCDRV                       		  0346,  1383,
2587	EDAC	SETDIR                        		  2623,
2643	EDF0	SETDIRDMA                     		  2624,  2632,  3488,
4286	F624	SETDMA                        		  2653,
2649	EDF3	SETDMA0                       		  2639,
3931	F46A	SETDSK                        		  1528,  1560,  3959,
2360	ECC9	SETEXT                        		  2387,  3134,  4009,
2796	EE7D	SETFILE                       		  2974,  3906,
2802	EE86	SETFL1                        		  2839,
2818	EE97	SETFL2                        		  2810,
2825	EE9D	SETFL3                        		  2816,
2835	EEAC	SETFL4                        		  2828,
2369	ECD1	SETHLDE                       		  2381,  2398,
2010	EB4E	SETIOB                        		  1553,
2397	ECF5	SETNREC                       		  3393,  3547,  3558,
3798	F3C2	SETRAN                        		  1582,
2540	ED88	SETS2B7                       		  3144,  3303,  3363,  3681,
4285	F621	SETSEC                        		  2264,
2032	EB5C	SETSTAT                       		  1976,  1982,  2000,  2006,  2041,  2846,  2956,  3356,  3435,  3665,  3971,  4072,  4118,
4284	F61E	SETTRK                        		  2241,
4120	F560	SETUSER                       		  4116,
2445	ED27	SHIFTL                        		  3919,
2447	ED28	SHIFTL1                       		  2451,
2415	ED0D	SHIFTR                        		  2171,  2461,  3819,  3846,
2417	ED0E	SHIFTR1                       		  2427,
1753	E9DA	SHOWIT                        		  1925,  1954,
2060	EB6A	SLCTERR                       		  3823,
0111	E0A2	SPACE                         		  1005,  1009,  1036,
0189	E0E9	SRCHFCB                       		  0974,  1203,  1236,
0177	E0DF	SRCHFST                       		  0191,
0183	E0E4	SRCHNXT                       		  1043,
2044	EB66	STARTING                      		  1800,  1832,  1876,  1893,
1508	E83F	STATUSBDOSRETURN              		  1481,  1532,  2033,  2942,  3194,  3269,  3383,  3460,  3549,  3636,  3646,  3656,  3680,  3901,  4106,
2771	EE6C	STBITMAP                      		  2834,
2786	EE76	STBMAP1                       		  2789,  3048,
0394	E1D5	STDDMA                        		  1186,  1382,
2677	EE0E	STFILPOS                      		  2698,  2880,  2954,  3881,
2403	ED01	STNREC1                       		  2401,
2380	ECDE	STRDATA                       		  3354,  3373,  3411,
2844	EEB2	STSTATUS                      		  4033,  4060,  4098,
2576	EDA5	SUBHL                         		  2599,  2696,
0437	E1F5	SYNERR                        		  0467,  0790,  0856,  0866,  0871,  0877,  0879,  0881,  0889,  1089,  1128,  1140,  1199,  1249,  1266,  1270,  1300,  1397,  1419,
0440	E1FB	SYNERR1                       		  0450,
0451	E20E	SYNERR2                       		  0443,  0445,

0027	0009	TAB                           		  1675,  1769,
0020	0100	TBASE                         		  1154,  1312,  1384,
0016	0004	TDRIVE                        		  0262,  0269,
0018	005C	TFCB                          		  1350,
2168	EBE6	TRKSEC                        		  2713,  3083,
2178	EBF4	TRKSEC1                       		  3391,  3494,  3513,
2196	EC07	TRKSEC2                       		  2212,
2213	EC1D	TRKSEC3                       		  2201,  2226,
2231	EC32	TRKSEC4                       		  2217,  2222,
1087	E533	TYPE                          		  0816,
1096	E54A	TYPE1                         		  1118,
1098	E54D	TYPE2                         		
1108	E55D	TYPE3                         		  1101,
1122	E576	TYPE4                         		  1105,
1126	E57D	TYPE5                         		  1092,

1280	E67B	UNKNOWN                       		  0793,  0820,
1398	E744	UNKWN0                        		  1328,  1336,
1296	E697	UNKWN1                        		  1284,
1301	E6A0	UNKWN2                        		
1313	E6B4	UNKWN3                        		  1329,
1333	E6D4	UNKWN4                        		  1319,
1355	E703	UNKWN5                        		  1362,
1366	E711	UNKWN6                        		  1358,  1360,
1369	E716	UNKWN7                        		  1377,
1378	E722	UNKWN8                        		  1373,
1395	E73E	UNKWN9                        		  1308,
3073	EFB5	UPDATE                        		  3105,  3122,
3082	EFC4	UPDATE1                       		  3267,
0275	E130	UPPER                         		  0363,
0044	005F	USCORE                        		  0472,  1214,
1263	E664	USER                          		  0819,
4208	F5B2	USERSDMA                      		  2638,  2660,  3982,  4078,
1509	E841	USERSTACK                     		  1483,  1530,

4275	F603	WBOOT                         		  1545,
4288	F62A	WRITE                         		  2158,
3693	F350	WRITERAN                      		  4135,
2468	ED3C	WRTPRTD                       		  1574,  2614,
0223	E104	WRTREC                        		  1166,
4044	F50B	WRTSEQ                        		  1567,
4133	F56C	WTRANDOM                      		  1580,
3402	F1B2	WTSEQ                         		  4046,
3405	F1B7	WTSEQ1                        		  3696,  4191,
3529	F286	WTSEQ10                       		  3521,
3555	F2B2	WTSEQ11                       		  3552,
3557	F2B4	WTSEQ12                       		  3543,  3546,
3429	F1EF	WTSEQ2                        		  3423,
3436	F1FC	WTSEQ3                        		  3433,
3449	F218	WTSEQ4                        		  3445,
3457	F220	WTSEQ5                        		  3448,
3459	F222	WTSEQ6                        		  3418,
3483	F240	WTSEQ7                        		  3487,
3491	F24E	WTSEQ8                        		  3504,
3512	F26F	WTSEQ9                        		  3468,  3479,
3541	F293	WTSEQ99                       		
4185	F599	WTSPECL                       		  1586,

4234	F5D1	XLATE                         		  2113,  2259,

1078	E528	YESNO                         		  1059,
