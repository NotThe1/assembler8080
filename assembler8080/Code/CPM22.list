0001: 0000 		 
0002: 0000 		 ;**************************************************************
0003: 0000 		 ;*
0004: 0000 		 ;*             C P / M   version   2 . 2
0005: 0000 		 ;*
0006: 0000 		 ;*   Reconstructed from memory image on February 27, 1981
0007: 0000 		 ;*
0008: 0000 		 ;*                by Clark A. Calkins
0009: 0000 		 ;*
0010: 0000 		 ;**************************************************************
0011: 0000 		 ;
0012: 0000 		 ;   Set memory limit here. This is the amount of contiguous
0013: 0000 		 ; ram starting from 0000. CP/M will reside at the end of this space.
0014: 0000 		 ;
0015: 0000 		 MEM	EQU	64	;for a 64k system 
0016: 0000 		 ;
0017: 0000 		 IOBYTE	EQU	3	;i/o definition byte.
0018: 0000 		 TDRIVE	EQU	4	;current drive name and user number.
0019: 0000 		 ENTRY	EQU	5	;entry point for the cp/m bdos.
0020: 0000 		 TFCB	EQU	5CH	;default file control block.
0021: 0000 		 TBUFF	EQU	80H	;i/o buffer and command line storage.
0022: 0000 		 TBASE	EQU	100H	;transiant program storage area.
0023: 0000 		 ;
0024: 0000 		 ;   Set control character equates.
0025: 0000 		 ;
0026: 0000 		 CNTRLC	EQU	3	;control-c
0027: 0000 		 CNTRLE	EQU	05H	;control-e
0028: 0000 		 BS	EQU	08H	;backspace
0029: 0000 		 TAB	EQU	09H	;tab
0030: 0000 		 LF	EQU	0AH	;line feed
0031: 0000 		 FF	EQU	0CH	;form feed
0032: 0000 		 CR	EQU	0DH	;carriage return
0033: 0000 		 CNTRLP	EQU	10H	;control-p
0034: 0000 		 CNTRLR	EQU	12H	;control-r
0035: 0000 		 CNTRLS	EQU	13H	;control-s
0036: 0000 		 CNTRLU	EQU	15H	;control-u
0037: 0000 		 CNTRLX	EQU	18H	;control-x
0038: 0000 		 CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
0039: 0000 		 DEL	EQU	7FH	;rubout
0040: 0000 		 ;
0041: 0000 		 BLANK	EQU	020H	; Space/Blank
0042: 0000 		 BRACKETLEFT		EQU	07BH	; {
0043: 0000 		 BRACKETRIGHT	EQU	07DH	; }
0044: 0000 		 QMARK	EQU		03FH		; ?
0045: 0000 		 EQUALS	EQU		03DH		; =
0046: 0000 		 USCORE	EQU		05FH		; _
0047: 0000 		 PERIOD	EQU		02EH		; .
0048: 0000 		 COLON	EQU		03AH		; :
0049: 0000 		 SEMIC	EQU		03BH		; ;
0050: 0000 		 LESSTH	EQU		03CH		; <
0051: 0000 		 GRTTHAN	EQU		03EH		; >
0052: 0000 		 ASTRK	EQU		02AH		; *
0053: 0000 		 CARET	EQU		05EH		; ^
0054: 0000 		 ATSIGN	EQU		040H		; @
0055: 0000 		 POUNDSN	EQU		023H		; #
0056: 0000 		 DOLLAR	EQU		024H		; $
0057: 0000 		 
0058: 0000 		 ;
0059: 0000 		 ;   Set origin for CP/M
0060: 0000 		 ;
0061: 0000 		 	ORG	(MEM-8)*1024
0062: E000 		 ;
0063: E000 		 CBASE:
0064: E000 	C35CE3	 	JMP	COMMAND	;execute command processor (ccp).
0065: E003 	C358E3	 	JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
0066: E006 		 
0067: E006 		 ;
0068: E006 		 ;   Standard cp/m ccp input buffer. Format is (max length),
0069: E006 		 ; (actual length), (char #1), (char #2), (char #3), etc.
0070: E006 		 ;
0071: E006 		 INBUFF:
0072: E006 	7F	 	DB	127	;length of input buffer.
0073: E007 	00	 	DB	0	;current length of contents.
0074: E008 	434F50595249474854	 	DB	'Copyright'
0075: E011 	203139373920284329204259204449474954414C205245534541524348202020202020	 	DB	' 1979 (c) by Digital Research      '
0076: E034 	0000000000000000000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0077: E04B 	0000000000000000000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0078: E062 	0000000000000000000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0079: E079 	000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0080: E088 		 INPOINT:
0081: E088 	08E0	 	DW	INBUFF+2;input line pointer
0082: E08A 		 NAMEPNT:
0083: E08A 	0000	 	DW	0	;input line pointer used for error message. Points to
0084: E08C 		 ;			;start of name in error.
0085: E08C 		 ;
0086: E08C 		 ;   Routine to print (A) on the console. All registers used.
0087: E08C 		 ;
0088: E08C 		 PRINT:
0089: E08C 	5F	 	MOV	E,A	;setup bdos call.
0090: E08D 	0E02	 	MVI	C,2
0091: E08F 	C30500	 	JMP	ENTRY
0092: E092 		 ;
0093: E092 		 ;   Routine to print (A) on the console and to save (BC).
0094: E092 		 ;
0095: E092 		 PRINTB:
0096: E092 	C5	 	PUSH	B
0097: E093 	CD8CE0	 	CALL	PRINT
0098: E096 	C1	 	POP	B
0099: E097 	C9	 	RET
0100: E098 		 ;
0101: E098 		 ;   Routine to send a carriage return, line feed combination
0102: E098 		 ; to the console.
0103: E098 		 ;
0104: E098 		 CRLF:
0105: E098 	3E0D	 	MVI	A,CR
0106: E09A 	CD92E0	 	CALL	PRINTB
0107: E09D 	3E0A	 	MVI	A,LF
0108: E09F 	C392E0	 	JMP	PRINTB
0109: E0A2 		 ;
0110: E0A2 		 ;   Routine to send one space to the console and save (BC).
0111: E0A2 		 ;
0112: E0A2 		 SPACE:
0113: E0A2 	3E20	 	MVI	A,BLANK		; blank/Space
0114: E0A4 	C392E0	 	JMP	PRINTB
0115: E0A7 		 ;
0116: E0A7 		 ;   Routine to print character string pointed to be (BC) on the
0117: E0A7 		 ; console. It must terminate with a null byte.
0118: E0A7 		 ;
0119: E0A7 		 PLINE:
0120: E0A7 	C5	 	PUSH	B
0121: E0A8 	CD98E0	 	CALL	CRLF
0122: E0AB 	E1	 	POP	H
0123: E0AC 		 PLINE2:
0124: E0AC 	7E	 	MOV	A,M
0125: E0AD 	B7	 	ORA	A
0126: E0AE 	C8	 	RZ
0127: E0AF 	23	 	INX	H
0128: E0B0 	E5	 	PUSH	H
0129: E0B1 	CD8CE0	 	CALL	PRINT
0130: E0B4 	E1	 	POP	H
0131: E0B5 	C3ACE0	 	JMP	PLINE2
0132: E0B8 		 ;
0133: E0B8 		 ;   Routine to reset the disk system.
0134: E0B8 		 ;
0135: E0B8 		 RESDSK:
0136: E0B8 	0E0D	 	MVI	C,13
0137: E0BA 	C30500	 	JMP	ENTRY
0138: E0BD 		 ;
0139: E0BD 		 ;   Routine to select disk (A).
0140: E0BD 		 ;
0141: E0BD 		 DSKSEL:
0142: E0BD 	5F	 	MOV	E,A
0143: E0BE 	0E0E	 	MVI	C,14
0144: E0C0 	C30500	 	JMP	ENTRY
0145: E0C3 		 ;
0146: E0C3 		 ;   Routine to call bdos and save the return code. The zero
0147: E0C3 		 ; flag is set on a return of 0ffh.
0148: E0C3 		 ;
0149: E0C3 		 ENTRY1:
0150: E0C3 	CD0500	 	CALL	ENTRY
0151: E0C6 	32EEE7	 	STA	RTNCODE	;save return code.
0152: E0C9 	3C	 	INR	A	;set zero if 0ffh returned.
0153: E0CA 	C9	 	RET
0154: E0CB 		 ;
0155: E0CB 		 ;   Routine to open a file. (DE) must point to the FCB.
0156: E0CB 		 ;
0157: E0CB 		 OPEN:
0158: E0CB 	0E0F	 	MVI	C,15
0159: E0CD 	C3C3E0	 	JMP	ENTRY1
0160: E0D0 		 ;
0161: E0D0 		 ;   Routine to open file at (FCB).
0162: E0D0 		 ;
0163: E0D0 		 OPENFCB:
0164: E0D0 	AF	 	XRA	A	;clear the record number byte at fcb+32
0165: E0D1 	32EDE7	 	STA	FCB+32
0166: E0D4 	11CDE7	 	LXI	D,FCB
0167: E0D7 	C3CBE0	 	JMP	OPEN
0168: E0DA 		 ;
0169: E0DA 		 ;   Routine to close a file. (DE) points to FCB.
0170: E0DA 		 ;
0171: E0DA 		 CLOSE:
0172: E0DA 	0E10	 	MVI	C,16
0173: E0DC 	C3C3E0	 	JMP	ENTRY1
0174: E0DF 		 ;
0175: E0DF 		 ;   Routine to search for the first file with ambigueous name
0176: E0DF 		 ; (DE).
0177: E0DF 		 ;
0178: E0DF 		 SRCHFST:
0179: E0DF 	0E11	 	MVI	C,17
0180: E0E1 	C3C3E0	 	JMP	ENTRY1
0181: E0E4 		 ;
0182: E0E4 		 ;   Search for the next ambigeous file name.
0183: E0E4 		 ;
0184: E0E4 		 SRCHNXT:
0185: E0E4 	0E12	 	MVI	C,18
0186: E0E6 	C3C3E0	 	JMP	ENTRY1
0187: E0E9 		 ;
0188: E0E9 		 ;   Search for file at (FCB).
0189: E0E9 		 ;
0190: E0E9 		 SRCHFCB:
0191: E0E9 	11CDE7	 	LXI	D,FCB
0192: E0EC 	C3DFE0	 	JMP	SRCHFST
0193: E0EF 		 ;
0194: E0EF 		 ;   Routine to delete a file pointed to by (DE).
0195: E0EF 		 ;
0196: E0EF 		 DELETE:
0197: E0EF 	0E13	 	MVI	C,19
0198: E0F1 	C30500	 	JMP	ENTRY
0199: E0F4 		 ;
0200: E0F4 		 ;   Routine to call the bdos and set the zero flag if a zero
0201: E0F4 		 ; status is returned.
0202: E0F4 		 ;
0203: E0F4 		 ENTRY2:
0204: E0F4 	CD0500	 	CALL	ENTRY
0205: E0F7 	B7	 	ORA	A	;set zero flag if appropriate.
0206: E0F8 	C9	 	RET
0207: E0F9 		 ;
0208: E0F9 		 ;   Routine to read the next record from a sequential file.
0209: E0F9 		 ; (DE) points to the FCB.
0210: E0F9 		 ;
0211: E0F9 		 RDREC:
0212: E0F9 	0E14	 	MVI	C,20
0213: E0FB 	C3F4E0	 	JMP	ENTRY2
0214: E0FE 		 ;
0215: E0FE 		 ;   Routine to read file at (FCB).
0216: E0FE 		 ;
0217: E0FE 		 READFCB:
0218: E0FE 	11CDE7	 	LXI	D,FCB
0219: E101 	C3F9E0	 	JMP	RDREC
0220: E104 		 ;
0221: E104 		 ;   Routine to write the next record of a sequential file.
0222: E104 		 ; (DE) points to the FCB.
0223: E104 		 ;
0224: E104 		 WRTREC:
0225: E104 	0E15	 	MVI	C,21
0226: E106 	C3F4E0	 	JMP	ENTRY2
0227: E109 		 ;
0228: E109 		 ;   Routine to create the file pointed to by (DE).
0229: E109 		 ;
0230: E109 		 CREATE:
0231: E109 	0E16	 	MVI	C,22
0232: E10B 	C3C3E0	 	JMP	ENTRY1
0233: E10E 		 ;
0234: E10E 		 ;   Routine to rename the file pointed to by (DE). Note that
0235: E10E 		 ; the new name starts at (DE+16).
0236: E10E 		 ;
0237: E10E 		 RENAM:
0238: E10E 	0E17	 	MVI	C,23
0239: E110 	C30500	 	JMP	ENTRY
0240: E113 		 ;
0241: E113 		 ;   Get the current user code.
0242: E113 		 ;
0243: E113 		 GETUSR:
0244: E113 	1EFF	 	MVI	E,0FFH
0245: E115 		 ;
0246: E115 		 ;   Routine to get or set the current user code.
0247: E115 		 ; If (E) is FF then this is a GET, else it is a SET.
0248: E115 		 ;
0249: E115 		 GETSETUC:
0250: E115 	0E20	 MVI	C,32
0251: E117 	C30500	 	JMP	ENTRY
0252: E11A 		 ;
0253: E11A 		 ;   Routine to set the current drive byte at (TDRIVE).
0254: E11A 		 ;
0255: E11A 		 SETCDRV:
0256: E11A 	CD13E1	 	CALL	GETUSR	;get user number
0257: E11D 	87	 	ADD	A	;and shift into the upper 4 bits.
0258: E11E 	87	 	ADD	A
0259: E11F 	87	 	ADD	A
0260: E120 	87	 	ADD	A
0261: E121 	21EFE7	 	LXI	H,CDRIVE;now add in the current drive number.
0262: E124 	B6	 	ORA	M
0263: E125 	320400	 	STA	TDRIVE	;and save.
0264: E128 	C9	 	RET
0265: E129 		 ;
0266: E129 		 ;   Move currently active drive down to (TDRIVE).
0267: E129 		 ;
0268: E129 		 MOVECD:
0269: E129 	3AEFE7	 	LDA	CDRIVE
0270: E12C 	320400	 	STA	TDRIVE
0271: E12F 	C9	 	RET
0272: E130 		 ;
0273: E130 		 ;   Routine to convert (A) into upper case ascii. Only letters
0274: E130 		 ; are affected.
0275: E130 		 ;
0276: E130 		 UPPER:
0277: E130 	FE61	 	CPI	061H	; 'a'	;check for letters in the range of 'a' to 'z'.
0278: E132 	D8	 	RC
0279: E133 	FE7B	 	CPI	BRACKETLEFT		;'{'
0280: E135 	D0	 	RNC
0281: E136 	E65F	 	ANI	5FH	;convert it if found.
0282: E138 	C9	 	RET
0283: E139 		 ;
0284: E139 		 ;   Routine to get a line of input. We must check to see if the
0285: E139 		 ; user is in (BATCH) mode. If so, then read the input from file
0286: E139 		 ; ($$$.SUB). At the end, reset to console input.
0287: E139 		 ;
0288: E139 		 GETINP:
0289: E139 	3AABE7	 	LDA	BATCH	;if =0, then use console input.
0290: E13C 	B7	 	ORA	A
0291: E13D 	CA96E1	 	JZ	GETINP1
0292: E140 		 ;
0293: E140 		 ;   Use the submit file ($$$.sub) which is prepared by a
0294: E140 		 ; SUBMIT run. It must be on drive (A) and it will be deleted
0295: E140 		 ; if and error occures (like eof).
0296: E140 		 ;
0297: E140 	3AEFE7	 	LDA	CDRIVE	;select drive 0 if need be.
0298: E143 	B7	 	ORA	A
0299: E144 	3E00	 	MVI	A,0	;always use drive A for submit.
0300: E146 	C4BDE0	 	CNZ	DSKSEL	;select it if required.
0301: E149 	11ACE7	 	LXI	D,BATCHFCB
0302: E14C 	CDCBE0	 	CALL	OPEN	;look for it.
0303: E14F 	CA96E1	 	JZ	GETINP1	;if not there, use normal input.
0304: E152 	3ABBE7	 	LDA	BATCHFCB+15;get last record number+1.
0305: E155 	3D	 	DCR	A
0306: E156 	32CCE7	 	STA	BATCHFCB+32
0307: E159 	11ACE7	 	LXI	D,BATCHFCB
0308: E15C 	CDF9E0	 	CALL	RDREC	;read last record.
0309: E15F 	C296E1	 	JNZ	GETINP1	;quit on end of file.
0310: E162 		 ;
0311: E162 		 ;   Move this record into input buffer.
0312: E162 		 ;
0313: E162 	1107E0	 	LXI	D,INBUFF+1
0314: E165 	218000	 	LXI	H,TBUFF	;data was read into buffer here.
0315: E168 	0680	 	MVI	B,128	;all 128 characters may be used.
0316: E16A 	CD42E4	 	CALL	HL2DE	;(HL) to (DE), (B) bytes.
0317: E16D 	21BAE7	 	LXI	H,BATCHFCB+14
0318: E170 	3600	 	MVI	M,0	;zero out the 's2' byte.
0319: E172 	23	 	INX	H	;and decrement the record count.
0320: E173 	35	 	DCR	M
0321: E174 	11ACE7	 	LXI	D,BATCHFCB;close the batch file now.
0322: E177 	CDDAE0	 	CALL	CLOSE
0323: E17A 	CA96E1	 	JZ	GETINP1	;quit on an error.
0324: E17D 	3AEFE7	 	LDA	CDRIVE	;re-select previous drive if need be.
0325: E180 	B7	 	ORA	A
0326: E181 	C4BDE0	 	CNZ	DSKSEL	;don't do needless selects.
0327: E184 		 ;
0328: E184 		 ;   Print line just read on console.
0329: E184 		 ;
0330: E184 	2108E0	 	LXI	H,INBUFF+2
0331: E187 	CDACE0	 	CALL	PLINE2
0332: E18A 	CDC2E1	 	CALL	CHKCON	;check console, quit on a key.
0333: E18D 	CAA7E1	 	JZ	GETINP2	;jump if no key is pressed.
0334: E190 		 ;
0335: E190 		 ;   Terminate the submit job on any keyboard input. Delete this
0336: E190 		 ; file such that it is not re-started and jump to normal keyboard
0337: E190 		 ; input section.
0338: E190 		 ;
0339: E190 	CDDDE1	 	CALL	DELBATCH;delete the batch file.
0340: E193 	C382E3	 	JMP	CMMND1	;and restart command input.
0341: E196 		 ;
0342: E196 		 ;   Get here for normal keyboard input. Delete the submit file
0343: E196 		 ; incase there was one.
0344: E196 		 ;
0345: E196 		 GETINP1:
0346: E196 	CDDDE1	 	CALL	DELBATCH;delete file ($$$.sub).
0347: E199 	CD1AE1	 	CALL	SETCDRV	;reset active disk.
0348: E19C 	0E0A	 	MVI	C,10	;get line from console device.
0349: E19E 	1106E0	 	LXI	D,INBUFF
0350: E1A1 	CD0500	 	CALL	ENTRY
0351: E1A4 	CD29E1	 	CALL	MOVECD	;reset current drive (again).
0352: E1A7 		 ;
0353: E1A7 		 ;   Convert input line to upper case.
0354: E1A7 		 ;
0355: E1A7 		 GETINP2:
0356: E1A7 	2107E0	 	LXI	H,INBUFF+1
0357: E1AA 	46	 	MOV	B,M	;(B)=character counter.
0358: E1AB 		 GETINP3:
0359: E1AB 	23	 	INX	H
0360: E1AC 	78	 	MOV	A,B	;end of the line?
0361: E1AD 	B7	 	ORA	A
0362: E1AE 	CABAE1	 	JZ	GETINP4
0363: E1B1 	7E	 	MOV	A,M	;convert to upper case.
0364: E1B2 	CD30E1	 	CALL	UPPER
0365: E1B5 	77	 	MOV	M,A
0366: E1B6 	05	 	DCR	B	;adjust character count.
0367: E1B7 	C3ABE1	 	JMP	GETINP3
0368: E1BA 		 GETINP4:
0369: E1BA 	77	 	MOV	M,A	;add trailing null.
0370: E1BB 	2108E0	 	LXI	H,INBUFF+2
0371: E1BE 	2288E0	 	SHLD	INPOINT	;reset input line pointer.
0372: E1C1 	C9	 	RET
0373: E1C2 		 ;
0374: E1C2 		 ;   Routine to check the console for a key pressed. The zero
0375: E1C2 		 ; flag is set is none, else the character is returned in (A).
0376: E1C2 		 ;
0377: E1C2 		 CHKCON:
0378: E1C2 	0E0B	 	MVI	C,11	;check console.
0379: E1C4 	CD0500	 	CALL	ENTRY
0380: E1C7 	B7	 	ORA	A
0381: E1C8 	C8	 	RZ		;return if nothing.
0382: E1C9 	0E01	 	MVI	C,1	;else get character.
0383: E1CB 	CD0500	 	CALL	ENTRY
0384: E1CE 	B7	 	ORA	A	;clear zero flag and return.
0385: E1CF 	C9	 	RET
0386: E1D0 		 ;
0387: E1D0 		 ;   Routine to get the currently active drive number.
0388: E1D0 		 ;
0389: E1D0 		 GETDSK:
0390: E1D0 	0E19	 	MVI	C,25
0391: E1D2 	C30500	 	JMP	ENTRY
0392: E1D5 		 ;
0393: E1D5 		 ;   Set the stabdard dma address.
0394: E1D5 		 ;
0395: E1D5 		 STDDMA:
0396: E1D5 	118000	 	LXI	D,TBUFF
0397: E1D8 		 ;
0398: E1D8 		 ;   Routine to set the dma address to (DE).
0399: E1D8 		 ;
0400: E1D8 		 DMASET:
0401: E1D8 	0E1A	 	MVI	C,26
0402: E1DA 	C30500	 	JMP	ENTRY
0403: E1DD 		 ;
0404: E1DD 		 ;  Delete the batch file created by SUBMIT.
0405: E1DD 		 ;
0406: E1DD 		 DELBATCH:
0407: E1DD 	21ABE7	 LXI	H,BATCH	;is batch active?
0408: E1E0 	7E	 	MOV	A,M
0409: E1E1 	B7	 	ORA	A
0410: E1E2 	C8	 	RZ
0411: E1E3 	3600	 	MVI	M,0	;yes, de-activate it.
0412: E1E5 	AF	 	XRA	A
0413: E1E6 	CDBDE0	 	CALL	DSKSEL	;select drive 0 for sure.
0414: E1E9 	11ACE7	 	LXI	D,BATCHFCB;and delete this file.
0415: E1EC 	CDEFE0	 	CALL	DELETE
0416: E1EF 	3AEFE7	 	LDA	CDRIVE	;reset current drive.
0417: E1F2 	C3BDE0	 	JMP	DSKSEL
0418: E1F5 		 ;
0419: E1F5 		 ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0420: E1F5 		 ; the same or we halt....
0421: E1F5 		 ;
0422: E1F5 		 VERIFY:
0423: E1F5 	1128E3	 	LXI	D,PATTRN1;these are the serial number bytes.
0424: E1F8 	2100E8	 	LXI	H,PATTRN2;ditto, but how could they be different?
0425: E1FB 	0606	 	MVI	B,6	;6 bytes each.
0426: E1FD 		 VERIFY1:
0427: E1FD 	1A	 	LDAX	D
0428: E1FE 	BE	 	CMP	M
0429: E1FF 	C2CFE3	 	JNZ	HALT	;jump to halt routine.
0430: E202 	13	 	INX	D
0431: E203 	23	 	INX	H
0432: E204 	05	 	DCR	B
0433: E205 	C2FDE1	 	JNZ	VERIFY1
0434: E208 	C9	 	RET
0435: E209 		 ;
0436: E209 		 ;   Print back file name with a '?' to indicate a syntax error.
0437: E209 		 ;
0438: E209 		 SYNERR:
0439: E209 	CD98E0	 	CALL	CRLF	;end current line.
0440: E20C 	2A8AE0	 	LHLD	NAMEPNT	;this points to name in error.
0441: E20F 		 SYNERR1:
0442: E20F 	7E	 	MOV	A,M	;print it until a space or null is found.
0443: E210 	FE20	 	CPI	BLANK		; Space
0444: E212 	CA22E2	 	JZ	SYNERR2
0445: E215 	B7	 	ORA	A
0446: E216 	CA22E2	 	JZ	SYNERR2
0447: E219 	E5	 	PUSH	H
0448: E21A 	CD8CE0	 	CALL	PRINT
0449: E21D 	E1	 	POP	H
0450: E21E 	23	 	INX	H
0451: E21F 	C30FE2	 	JMP	SYNERR1
0452: E222 		 SYNERR2:
0453: E222 	3E3F	 	MVI	A,QMARK		;add trailing '?'.
0454: E224 	CD8CE0	 	CALL	PRINT
0455: E227 	CD98E0	 	CALL	CRLF
0456: E22A 	CDDDE1	 	CALL	DELBATCH;delete any batch file.
0457: E22D 	C382E3	 	JMP	CMMND1	;and restart from console input.
0458: E230 		 ;
0459: E230 		 ;   Check character at (DE) for legal command input. Note that the
0460: E230 		 ; zero flag is set if the character is a delimiter.
0461: E230 		 ;
0462: E230 		 CHECK:
0463: E230 	1A	 	LDAX	D
0464: E231 	B7	 	ORA	A
0465: E232 	C8	 	RZ
0466: E233 	FE20	 	CPI	BLANK	;control characters are not legal here.
0467: E235 	DA09E2	 	JC	SYNERR
0468: E238 	C8	 	RZ		;check for valid delimiter.
0469: E239 	FE3D	 	CPI	EQUALS		; '='
0470: E23B 	C8	 	RZ
0471: E23C 	FE5F	 	CPI	USCORE		; '_'
0472: E23E 	C8	 	RZ
0473: E23F 	FE2E	 	CPI	PERIOD		; '.'
0474: E241 	C8	 	RZ
0475: E242 	FE3A	 	CPI	COLON		; ':'
0476: E244 	C8	 	RZ
0477: E245 	FE3B	 	CPI	SEMIC		; ';'
0478: E247 	C8	 	RZ
0479: E248 	FE3C	 	CPI	LESSTH		; '<'
0480: E24A 	C8	 	RZ
0481: E24B 	FE3E	 	CPI	GRTTHAN		; '>'
0482: E24D 	C8	 	RZ
0483: E24E 	C9	 	RET
0484: E24F 		 ;
0485: E24F 		 ;   Get the next non-blank character from (DE).
0486: E24F 		 ;
0487: E24F 		 NONBLANK:
0488: E24F 	1A	 LDAX	D
0489: E250 	B7	 	ORA	A	;string ends with a null.
0490: E251 	C8	 	RZ
0491: E252 	FE20	 	CPI	BLANK
0492: E254 	C0	 	RNZ
0493: E255 	13	 	INX	D
0494: E256 	C34FE2	 	JMP	NONBLANK
0495: E259 		 ;
0496: E259 		 ;   Add (HL)=(HL)+(A)
0497: E259 		 ;
0498: E259 		 ADDHL:
0499: E259 	85	 	ADD	L
0500: E25A 	6F	 	MOV	L,A
0501: E25B 	D0	 	RNC	;take care of any carry.
0502: E25C 	24	 	INR	H
0503: E25D 	C9	 	RET
0504: E25E 		 ;
0505: E25E 		 ;   Convert the first name in (FCB).
0506: E25E 		 ;
0507: E25E 		 CONVFST:
0508: E25E 	3E00	 	MVI	A,0
0509: E260 		 ;
0510: E260 		 ;   Format a file name (convert * to '?', etc.). On return,
0511: E260 		 ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0512: E260 		 ; the position within the fcb for the name (either 0 or 16).
0513: E260 		 ;
0514: E260 		 CONVERT:
0515: E260 	21CDE7	 	LXI	H,FCB
0516: E263 	CD59E2	 	CALL	ADDHL
0517: E266 	E5	 	PUSH	H
0518: E267 	E5	 	PUSH	H
0519: E268 	AF	 	XRA	A
0520: E269 	32F0E7	 	STA	CHGDRV	;initialize drive change flag.
0521: E26C 	2A88E0	 	LHLD	INPOINT	;set (HL) as pointer into input line.
0522: E26F 	EB	 	XCHG
0523: E270 	CD4FE2	 	CALL	NONBLANK;get next non-blank character.
0524: E273 	EB	 	XCHG
0525: E274 	228AE0	 	SHLD	NAMEPNT	;save pointer here for any error message.
0526: E277 	EB	 	XCHG
0527: E278 	E1	 	POP	H
0528: E279 	1A	 	LDAX	D	;get first character.
0529: E27A 	B7	 	ORA	A
0530: E27B 	CA89E2	 	JZ	CONVRT1
0531: E27E 	DE40	 	SBI	040H		;'A'-1	;might be a drive name, convert to binary.
0532: E280 	47	 	MOV	B,A	;and save.
0533: E281 	13	 	INX	D	;check next character for a ':'.
0534: E282 	1A	 	LDAX	D
0535: E283 	FE3A	 	CPI	COLON		;':'
0536: E285 	CA90E2	 	JZ	CONVRT2
0537: E288 	1B	 	DCX	D	;nope, move pointer back to the start of the line.
0538: E289 		 CONVRT1:
0539: E289 	3AEFE7	 	LDA	CDRIVE
0540: E28C 	77	 	MOV	M,A
0541: E28D 	C396E2	 	JMP	CONVRT3
0542: E290 		 CONVRT2:
0543: E290 	78	 	MOV	A,B
0544: E291 	32F0E7	 	STA	CHGDRV	;set change in drives flag.
0545: E294 	70	 	MOV	M,B
0546: E295 	13	 	INX	D
0547: E296 		 ;
0548: E296 		 ;   Convert the basic file name.
0549: E296 		 ;
0550: E296 		 CONVRT3:
0551: E296 	0608	 	MVI	B,08H
0552: E298 		 CONVRT4:
0553: E298 	CD30E2	 	CALL	CHECK
0554: E29B 	CAB9E2	 	JZ	CONVRT8
0555: E29E 	23	 	INX	H
0556: E29F 	FE2A	 	CPI	ASTRK		; '*'	;note that an '*' will fill the remaining
0557: E2A1 	C2A9E2	 	JNZ	CONVRT5	;field with '?'.
0558: E2A4 	363F	 	MVI	M,QMARK		; '?'
0559: E2A6 	C3ABE2	 	JMP	CONVRT6
0560: E2A9 		 CONVRT5:
0561: E2A9 	77	 	MOV	M,A
0562: E2AA 	13	 	INX	D
0563: E2AB 		 CONVRT6:
0564: E2AB 	05	 	DCR	B
0565: E2AC 	C298E2	 	JNZ	CONVRT4
0566: E2AF 		 CONVRT7:
0567: E2AF 	CD30E2	 	CALL	CHECK	;get next delimiter.
0568: E2B2 	CAC0E2	 	JZ	GETEXT
0569: E2B5 	13	 	INX	D
0570: E2B6 	C3AFE2	 	JMP	CONVRT7
0571: E2B9 		 CONVRT8:
0572: E2B9 	23	 	INX	H	;blank fill the file name.
0573: E2BA 	3620	 	MVI	M,BLANK
0574: E2BC 	05	 	DCR	B
0575: E2BD 	C2B9E2	 	JNZ	CONVRT8
0576: E2C0 		 ;
0577: E2C0 		 ;   Get the extension and convert it.
0578: E2C0 		 ;
0579: E2C0 		 GETEXT:
0580: E2C0 	0603	 	MVI	B,03H
0581: E2C2 	FE2E	 	CPI	PERIOD		; '.'
0582: E2C4 	C2E9E2	 	JNZ	GETEXT5
0583: E2C7 	13	 	INX	D
0584: E2C8 		 GETEXT1:
0585: E2C8 	CD30E2	 	CALL	CHECK
0586: E2CB 	CAE9E2	 	JZ	GETEXT5
0587: E2CE 	23	 	INX	H
0588: E2CF 	FE2A	 	CPI	ASTRK		; '*'
0589: E2D1 	C2D9E2	 	JNZ	GETEXT2
0590: E2D4 	363F	 	MVI	M,QMARK		;'?'
0591: E2D6 	C3DBE2	 	JMP	GETEXT3
0592: E2D9 		 GETEXT2:
0593: E2D9 	77	 	MOV	M,A
0594: E2DA 	13	 	INX	D
0595: E2DB 		 GETEXT3:
0596: E2DB 	05	 	DCR	B
0597: E2DC 	C2C8E2	 	JNZ	GETEXT1
0598: E2DF 		 GETEXT4:
0599: E2DF 	CD30E2	 	CALL	CHECK
0600: E2E2 	CAF0E2	 	JZ	GETEXT6
0601: E2E5 	13	 	INX	D
0602: E2E6 	C3DFE2	 	JMP	GETEXT4
0603: E2E9 		 GETEXT5:
0604: E2E9 	23	 	INX	H
0605: E2EA 	3620	 	MVI	M,BLANK
0606: E2EC 	05	 	DCR	B
0607: E2ED 	C2E9E2	 	JNZ	GETEXT5
0608: E2F0 		 GETEXT6:
0609: E2F0 	0603	 	MVI	B,3
0610: E2F2 		 GETEXT7:
0611: E2F2 	23	 	INX	H
0612: E2F3 	3600	 	MVI	M,0
0613: E2F5 	05	 	DCR	B
0614: E2F6 	C2F2E2	 	JNZ	GETEXT7
0615: E2F9 	EB	 	XCHG
0616: E2FA 	2288E0	 	SHLD	INPOINT	;save input line pointer.
0617: E2FD 	E1	 	POP	H
0618: E2FE 		 ;
0619: E2FE 		 ;   Check to see if this is an ambigeous file name specification.
0620: E2FE 		 ; Set the (A) register to non zero if it is.
0621: E2FE 		 ;
0622: E2FE 	010B00	 	LXI	B,11	;set name length.
0623: E301 		 GETEXT8:
0624: E301 	23	 	INX	H
0625: E302 	7E	 	MOV	A,M
0626: E303 	FE3F	 	CPI	QMARK		; '?'	;any question marks?
0627: E305 	C209E3	 	JNZ	GETEXT9
0628: E308 	04	 	INR	B	;count them.
0629: E309 		 GETEXT9:
0630: E309 	0D	 	DCR	C
0631: E30A 	C201E3	 	JNZ	GETEXT8
0632: E30D 	78	 	MOV	A,B
0633: E30E 	B7	 	ORA	A
0634: E30F 	C9	 	RET
0635: E310 		 ;
0636: E310 		 ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0637: E310 		 ;
0638: E310 		 NUMCMDS	EQU	6	;number of commands
0639: E310 		 CMDTBL:
0640: E310 	44495220	 	DB	'DIR '
0641: E314 	45524120	 	DB	'ERA '
0642: E318 	54595045	 	DB	'TYPE'
0643: E31C 	53415645	 	DB	'SAVE'
0644: E320 	52454E20	 	DB	'REN '
0645: E324 	55534552	 	DB	'USER'
0646: E328 		 ;
0647: E328 		 ;   The following six bytes must agree with those at (PATTRN2)
0648: E328 		 ; or cp/m will HALT. Why?
0649: E328 		 ;
0650: E328 		 PATTRN1:
0651: E328 	001600000000	 	DB	0,22,0,0,0,0;(* serial number bytes *).
0652: E32E 		 ;
0653: E32E 		 ;   Search the command table for a match with what has just
0654: E32E 		 ; been entered. If a match is found, then we jump to the
0655: E32E 		 ; proper section. Else jump to (UNKNOWN).
0656: E32E 		 ; On return, the (C) register is set to the command number
0657: E32E 		 ; that matched (or NUMCMDS+1 if no match).
0658: E32E 		 ;
0659: E32E 		 SEARCH:
0660: E32E 	2110E3	 	LXI	H,CMDTBL
0661: E331 	0E00	 	MVI	C,0
0662: E333 		 SEARCH1:
0663: E333 	79	 	MOV	A,C
0664: E334 	FE06	 	CPI	NUMCMDS	;this commands exists.
0665: E336 	D0	 	RNC
0666: E337 	11CEE7	 	LXI	D,FCB+1	;check this one.
0667: E33A 	0604	 	MVI	B,4	;max command length.
0668: E33C 		 SEARCH2:
0669: E33C 	1A	 	LDAX	D
0670: E33D 	BE	 	CMP	M
0671: E33E 	C24FE3	 	JNZ	SEARCH3	;not a match.
0672: E341 	13	 	INX	D
0673: E342 	23	 	INX	H
0674: E343 	05	 	DCR	B
0675: E344 	C23CE3	 	JNZ	SEARCH2
0676: E347 	1A	 	LDAX	D	;allow a 3 character command to match.
0677: E348 	FE20	 	CPI	BLANK
0678: E34A 	C254E3	 	JNZ	SEARCH4
0679: E34D 	79	 	MOV	A,C	;set return register for this command.
0680: E34E 	C9	 	RET
0681: E34F 		 SEARCH3:
0682: E34F 	23	 	INX	H
0683: E350 	05	 	DCR	B
0684: E351 	C24FE3	 	JNZ	SEARCH3
0685: E354 		 SEARCH4:
0686: E354 	0C	 	INR	C
0687: E355 	C333E3	 	JMP	SEARCH1
0688: E358 		 ;
0689: E358 		 ;   Set the input buffer to empty and then start the command
0690: E358 		 ; processor (ccp).
0691: E358 		 ;
0692: E358 		 CLEARBUF:
0693: E358 	AF	 XRA	A
0694: E359 	3207E0	 	STA	INBUFF+1;second byte is actual length.
0695: E35C 		 ;
0696: E35C 		 ;**************************************************************
0697: E35C 		 ;*
0698: E35C 		 ;*
0699: E35C 		 ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0700: E35C 		 ;*
0701: E35C 		 ;**************************************************************
0702: E35C 		 ;*
0703: E35C 		 COMMAND:
0704: E35C 	31ABE7	 	LXI	SP,CCPSTACK;setup stack area.
0705: E35F 	C5	 	PUSH	B	;note that (C) should be equal to:
0706: E360 	79	 	MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
0707: E361 	1F	 	RAR		;and 'dddd' is the drive number.
0708: E362 	1F	 	RAR
0709: E363 	1F	 	RAR
0710: E364 	1F	 	RAR
0711: E365 	E60F	 	ANI	0FH	;isolate the user number.
0712: E367 	5F	 	MOV	E,A
0713: E368 	CD15E1	 	CALL	GETSETUC;and set it.
0714: E36B 	CDB8E0	 	CALL	RESDSK	;reset the disk system.
0715: E36E 	32ABE7	 	STA	BATCH	;clear batch mode flag.
0716: E371 	C1	 	POP	B
0717: E372 	79	 	MOV	A,C
0718: E373 	E60F	 	ANI	0FH	;isolate the drive number.
0719: E375 	32EFE7	 	STA	CDRIVE	;and save.
0720: E378 	CDBDE0	 	CALL	DSKSEL	;...and select.
0721: E37B 	3A07E0	 	LDA	INBUFF+1
0722: E37E 	B7	 	ORA	A	;anything in input buffer already?
0723: E37F 	C298E3	 	JNZ	CMMND2	;yes, we just process it.
0724: E382 		 ;
0725: E382 		 ;   Entry point to get a command line from the console.
0726: E382 		 ;
0727: E382 		 CMMND1:
0728: E382 	31ABE7	 	LXI	SP,CCPSTACK;set stack straight.
0729: E385 	CD98E0	 	CALL	CRLF	;start a new line on the screen.
0730: E388 	CDD0E1	 	CALL	GETDSK	;get current drive.
0731: E38B 	C661	 	ADI	061H		; 'a'
0732: E38D 	CD8CE0	 	CALL	PRINT	;print current drive.
0733: E390 	3E3E	 	MVI	A,GRTTHAN	; '>'
0734: E392 	CD8CE0	 	CALL	PRINT	;and add prompt.
0735: E395 	CD39E1	 	CALL	GETINP	;get line from user.
0736: E398 		 ;
0737: E398 		 ;   Process command line here.
0738: E398 		 ;
0739: E398 		 CMMND2:
0740: E398 	118000	 	LXI	D,TBUFF
0741: E39B 	CDD8E1	 	CALL	DMASET	;set standard dma address.
0742: E39E 	CDD0E1	 	CALL	GETDSK
0743: E3A1 	32EFE7	 	STA	CDRIVE	;set current drive.
0744: E3A4 	CD5EE2	 	CALL	CONVFST	;convert name typed in.
0745: E3A7 	C409E2	 	CNZ	SYNERR	;wild cards are not allowed.
0746: E3AA 	3AF0E7	 	LDA	CHGDRV	;if a change in drives was indicated,
0747: E3AD 	B7	 	ORA	A	;then treat this as an unknown command
0748: E3AE 	C2A5E6	 	JNZ	UNKNOWN	;which gets executed.
0749: E3B1 	CD2EE3	 	CALL	SEARCH	;else search command table for a match.
0750: E3B4 		 ;
0751: E3B4 		 ;   Note that an unknown command returns
0752: E3B4 		 ; with (A) pointing to the last address
0753: E3B4 		 ; in our table which is (UNKNOWN).
0754: E3B4 		 ;
0755: E3B4 	21C1E3	 	LXI	H,CMDADR;now, look thru our address table for command (A).
0756: E3B7 	5F	 	MOV	E,A	;set (DE) to command number.
0757: E3B8 	1600	 	MVI	D,0
0758: E3BA 	19	 	DAD	D
0759: E3BB 	19	 	DAD	D	;(HL)=(CMDADR)+2*(command number).
0760: E3BC 	7E	 	MOV	A,M	;now pick out this address.
0761: E3BD 	23	 	INX	H
0762: E3BE 	66	 	MOV	H,M
0763: E3BF 	6F	 	MOV	L,A
0764: E3C0 	E9	 	PCHL		;now execute it.
0765: E3C1 		 ;
0766: E3C1 		 ;   CP/M command address table.
0767: E3C1 		 ;
0768: E3C1 		 CMDADR:
0769: E3C1 	77E41FE55DE5ADE5	 	DW	DIRECT,ERASE,TYPE,SAVE
0770: E3C9 	10E68EE6A5E6	 	DW	RENAME,USER,UNKNOWN
0771: E3CF 		 ;
0772: E3CF 		 ;   Halt the system. Reason for this is unknown at present.
0773: E3CF 		 ;
0774: E3CF 		 HALT:
0775: E3CF 	21F376	 	LXI	H,76F3H	;'DI HLT' instructions.
0776: E3D2 	2200E0	 	SHLD	CBASE
0777: E3D5 	2100E0	 	LXI	H,CBASE
0778: E3D8 	E9	 	PCHL
0779: E3D9 		 ;
0780: E3D9 		 ;   Read error while TYPEing a file.
0781: E3D9 		 ;
0782: E3D9 		 RDERROR:
0783: E3D9 	01DFE3	 	LXI	B,RDERR
0784: E3DC 	C3A7E0	 	JMP	PLINE
0785: E3DF 		 RDERR:
0786: E3DF 	52454144204552524F5200	 	DB	'Read error',0
0787: E3EA 		 ;
0788: E3EA 		 ;   Required file was not located.
0789: E3EA 		 ;
0790: E3EA 		 
0791: E3EA 		 NONE:
0792: E3EA 	01F0E3	 	LXI	B,NOFILE
0793: E3ED 	C3A7E0	 	JMP	PLINE
0794: E3F0 		 NOFILE:
0795: E3F0 	4E4F2046494C4500	 	DB	'No file',0
0796: E3F8 		 ;
0797: E3F8 		 ;   Decode a command of the form 'A>filename number{ filename}.
0798: E3F8 		 ; Note that a drive specifier is not allowed on the first file
0799: E3F8 		 ; name. On return, the number is in register (A). Any error
0800: E3F8 		 ; causes 'filename?' to be printed and the command is aborted.
0801: E3F8 		 ;
0802: E3F8 		 DECODE:
0803: E3F8 	CD5EE2	 	CALL	CONVFST	;convert filename.
0804: E3FB 	3AF0E7	 	LDA	CHGDRV	;do not allow a drive to be specified.
0805: E3FE 	B7	 	ORA	A
0806: E3FF 	C209E2	 	JNZ	SYNERR
0807: E402 	21CEE7	 	LXI	H,FCB+1	;convert number now.
0808: E405 	010B00	 	LXI	B,11	;(B)=sum register, (C)=max digit count.
0809: E408 		 DECODE1:
0810: E408 	7E	 	MOV	A,M
0811: E409 	FE20	 	CPI	BLANK	;a space terminates the numeral.
0812: E40B 	CA33E4	 	JZ	DECODE3
0813: E40E 	23	 	INX	H
0814: E40F 	D630	 	SUI	030H		 ;'0'	make binary from ascii. ZERO ????
0815: E411 	FE0A	 	CPI	10	;legal digit?
0816: E413 	D209E2	 	JNC	SYNERR
0817: E416 	57	 	MOV	D,A	;yes, save it in (D).
0818: E417 	78	 	MOV	A,B	;compute (B)=(B)*10 and check for overflow.
0819: E418 	E6E0	 	ANI	0E0H
0820: E41A 	C209E2	 	JNZ	SYNERR
0821: E41D 	78	 	MOV	A,B
0822: E41E 	07	 	RLC
0823: E41F 	07	 	RLC
0824: E420 	07	 	RLC	;(A)=(B)*8
0825: E421 	80	 	ADD	B	;.......*9
0826: E422 	DA09E2	 	JC	SYNERR
0827: E425 	80	 	ADD	B	;.......*10
0828: E426 	DA09E2	 	JC	SYNERR
0829: E429 	82	 	ADD	D	;add in new digit now.
0830: E42A 		 DECODE2:
0831: E42A 	DA09E2	 	JC	SYNERR
0832: E42D 	47	 	MOV	B,A	;and save result.
0833: E42E 	0D	 	DCR	C	;only look at 11 digits.
0834: E42F 	C208E4	 	JNZ	DECODE1
0835: E432 	C9	 	RET
0836: E433 		 DECODE3:
0837: E433 	7E	 	MOV	A,M	;spaces must follow (why?).
0838: E434 	FE20	 	CPI	BLANK
0839: E436 	C209E2	 	JNZ	SYNERR
0840: E439 	23	 	INX	H
0841: E43A 		 DECODE4:
0842: E43A 	0D	 	DCR	C
0843: E43B 	C233E4	 	JNZ	DECODE3
0844: E43E 	78	 	MOV	A,B	;set (A)=the numeric value entered.
0845: E43F 	C9	 	RET
0846: E440 		 ;
0847: E440 		 ;   Move 3 bytes from (HL) to (DE). Note that there is only
0848: E440 		 ; one reference to this at (A2D5h).
0849: E440 		 ;
0850: E440 		 MOVE3:
0851: E440 	0603	 	MVI	B,3
0852: E442 		 ;
0853: E442 		 ;   Move (B) bytes from (HL) to (DE).
0854: E442 		 ;
0855: E442 		 HL2DE:
0856: E442 	7E	 	MOV	A,M
0857: E443 	12	 	STAX	D
0858: E444 	23	 	INX	H
0859: E445 	13	 	INX	D
0860: E446 	05	 	DCR	B
0861: E447 	C242E4	 	JNZ	HL2DE
0862: E44A 	C9	 	RET
0863: E44B 		 ;
0864: E44B 		 ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
0865: E44B 		 ;
0866: E44B 		 EXTRACT:
0867: E44B 	218000	 	LXI	H,TBUFF
0868: E44E 	81	 	ADD	C
0869: E44F 	CD59E2	 	CALL	ADDHL
0870: E452 	7E	 	MOV	A,M
0871: E453 	C9	 	RET
0872: E454 		 ;
0873: E454 		 ;  Check drive specified. If it means a change, then the new
0874: E454 		 ; drive will be selected. In any case, the drive byte of the
0875: E454 		 ; fcb will be set to null (means use current drive).
0876: E454 		 ;
0877: E454 		 DSELECT:
0878: E454 	AF	 	XRA	A	;null out first byte of fcb.
0879: E455 	32CDE7	 	STA	FCB
0880: E458 	3AF0E7	 	LDA	CHGDRV	;a drive change indicated?
0881: E45B 	B7	 	ORA	A
0882: E45C 	C8	 	RZ
0883: E45D 	3D	 	DCR	A	;yes, is it the same as the current drive?
0884: E45E 	21EFE7	 	LXI	H,CDRIVE
0885: E461 	BE	 	CMP	M
0886: E462 	C8	 	RZ
0887: E463 	C3BDE0	 	JMP	DSKSEL	;no. Select it then.
0888: E466 		 ;
0889: E466 		 ;   Check the drive selection and reset it to the previous
0890: E466 		 ; drive if it was changed for the preceeding command.
0891: E466 		 ;
0892: E466 		 RESETDR:
0893: E466 	3AF0E7	 	LDA	CHGDRV	;drive change indicated?
0894: E469 	B7	 	ORA	A
0895: E46A 	C8	 	RZ
0896: E46B 	3D	 	DCR	A	;yes, was it a different drive?
0897: E46C 	21EFE7	 	LXI	H,CDRIVE
0898: E46F 	BE	 	CMP	M
0899: E470 	C8	 	RZ
0900: E471 	3AEFE7	 	LDA	CDRIVE	;yes, re-select our old drive.
0901: E474 	C3BDE0	 	JMP	DSKSEL
0902: E477 		 ;
0903: E477 		 ;**************************************************************
0904: E477 		 ;*
0905: E477 		 ;*           D I R E C T O R Y   C O M M A N D
0906: E477 		 ;*
0907: E477 		 ;**************************************************************
0908: E477 		 ;
0909: E477 		 DIRECT:
0910: E477 	CD5EE2	 	CALL	CONVFST	;convert file name.
0911: E47A 	CD54E4	 	CALL	DSELECT	;select indicated drive.
0912: E47D 	21CEE7	 	LXI	H,FCB+1	;was any file indicated?
0913: E480 	7E	 	MOV	A,M
0914: E481 	FE20	 	CPI	BLANK
0915: E483 	C28FE4	 	JNZ	DIRECT2
0916: E486 	060B	 	MVI	B,11	;no. Fill field with '?' - same as *.*.
0917: E488 		 DIRECT1:
0918: E488 	363F	 	MVI	M,QMARK		; '?'
0919: E48A 	23	 	INX	H
0920: E48B 	05	 	DCR	B
0921: E48C 	C288E4	 	JNZ	DIRECT1
0922: E48F 		 DIRECT2:
0923: E48F 	1E00	 	MVI	E,0	;set initial cursor position.
0924: E491 	D5	 	PUSH	D
0925: E492 	CDE9E0	 	CALL	SRCHFCB	;get first file name.
0926: E495 	CCEAE3	 	CZ	NONE	;none found at all?
0927: E498 		 DIRECT3:
0928: E498 	CA1BE5	 	JZ	DIRECT9	;terminate if no more names.
0929: E49B 	3AEEE7	 	LDA	RTNCODE	;get file's position in segment (0-3).
0930: E49E 	0F	 	RRC
0931: E49F 	0F	 	RRC
0932: E4A0 	0F	 	RRC
0933: E4A1 	E660	 	ANI	60H	;(A)=position*32
0934: E4A3 	4F	 	MOV	C,A
0935: E4A4 	3E0A	 	MVI	A,10
0936: E4A6 	CD4BE4	 	CALL	EXTRACT	;extract the tenth entry in fcb.
0937: E4A9 	17	 	RAL		;check system file status bit.
0938: E4AA 	DA0FE5	 	JC	DIRECT8	;we don't list them.
0939: E4AD 	D1	 	POP	D
0940: E4AE 	7B	 	MOV	A,E	;bump name count.
0941: E4AF 	1C	 	INR	E
0942: E4B0 	D5	 	PUSH	D
0943: E4B1 	E603	 	ANI	03H	;at end of line?
0944: E4B3 	F5	 	PUSH	PSW
0945: E4B4 	C2CCE4	 	JNZ	DIRECT4
0946: E4B7 	CD98E0	 	CALL	CRLF	;yes, end this line and start another.
0947: E4BA 	C5	 	PUSH	B
0948: E4BB 	CDD0E1	 	CALL	GETDSK	;start line with ('A:').
0949: E4BE 	C1	 	POP	B
0950: E4BF 	C641	 	ADI	041H	; 'A'
0951: E4C1 	CD92E0	 	CALL	PRINTB
0952: E4C4 	3E3A	 	MVI	A, COLON		; ':'
0953: E4C6 	CD92E0	 	CALL	PRINTB
0954: E4C9 	C3D4E4	 	JMP	DIRECT5
0955: E4CC 		 DIRECT4:
0956: E4CC 	CDA2E0	 	CALL	SPACE	;add seperator between file names.
0957: E4CF 	3E3A	 	MVI	A, COLON	;':'
0958: E4D1 	CD92E0	 	CALL	PRINTB
0959: E4D4 		 DIRECT5:
0960: E4D4 	CDA2E0	 	CALL	SPACE
0961: E4D7 	0601	 	MVI	B,1	;'extract' each file name character at a time.
0962: E4D9 		 DIRECT6:
0963: E4D9 	78	 	MOV	A,B
0964: E4DA 	CD4BE4	 	CALL	EXTRACT
0965: E4DD 	E67F	 	ANI	7FH	;strip bit 7 (status bit).
0966: E4DF 	FE20	 	CPI	BLANK	;are we at the end of the name?
0967: E4E1 	C2F9E4	 	JNZ	DRECT65
0968: E4E4 	F1	 	POP	PSW	;yes, don't print spaces at the end of a line.
0969: E4E5 	F5	 	PUSH	PSW
0970: E4E6 	FE03	 	CPI	3
0971: E4E8 	C2F7E4	 	JNZ	DRECT63
0972: E4EB 	3E09	 	MVI	A,9	;first check for no extension.
0973: E4ED 	CD4BE4	 	CALL	EXTRACT
0974: E4F0 	E67F	 	ANI	7FH
0975: E4F2 	FE20	 	CPI	BLANK
0976: E4F4 	CA0EE5	 	JZ	DIRECT7	;don't print spaces.
0977: E4F7 		 DRECT63:
0978: E4F7 	3E20	 	MVI	A,BLANK	;else print them.
0979: E4F9 		 DRECT65:
0980: E4F9 	CD92E0	 	CALL	PRINTB
0981: E4FC 	04	 	INR	B	;bump to next character psoition.
0982: E4FD 	78	 	MOV	A,B
0983: E4FE 	FE0C	 	CPI	12	;end of the name?
0984: E500 	D20EE5	 	JNC	DIRECT7
0985: E503 	FE09	 	CPI	9	;nope, starting extension?
0986: E505 	C2D9E4	 	JNZ	DIRECT6
0987: E508 	CDA2E0	 	CALL	SPACE	;yes, add seperating space.
0988: E50B 	C3D9E4	 	JMP	DIRECT6
0989: E50E 		 DIRECT7:
0990: E50E 	F1	 	POP	PSW	;get the next file name.
0991: E50F 		 DIRECT8:
0992: E50F 	CDC2E1	 	CALL	CHKCON	;first check console, quit on anything.
0993: E512 	C21BE5	 	JNZ	DIRECT9
0994: E515 	CDE4E0	 	CALL	SRCHNXT	;get next name.
0995: E518 	C398E4	 	JMP	DIRECT3	;and continue with our list.
0996: E51B 		 DIRECT9:
0997: E51B 	D1	 	POP	D	;restore the stack and return to command level.
0998: E51C 	C386E7	 	JMP	GETBACK
0999: E51F 		 ;
1000: E51F 		 ;**************************************************************
1001: E51F 		 ;*
1002: E51F 		 ;*                E R A S E   C O M M A N D
1003: E51F 		 ;*
1004: E51F 		 ;**************************************************************
1005: E51F 		 ;
1006: E51F 		 ERASE:
1007: E51F 	CD5EE2	 	CALL	CONVFST	;convert file name.
1008: E522 	FE0B	 	CPI	11	;was '*.*' entered?
1009: E524 	C242E5	 	JNZ	ERASE1
1010: E527 	0152E5	 	LXI	B,YESNO	;yes, ask for confirmation.
1011: E52A 	CDA7E0	 	CALL	PLINE
1012: E52D 	CD39E1	 	CALL	GETINP
1013: E530 	2107E0	 	LXI	H,INBUFF+1
1014: E533 	35	 	DCR	M	;must be exactly 'y'.
1015: E534 	C282E3	 	JNZ	CMMND1
1016: E537 	23	 	INX	H
1017: E538 	7E	 	MOV	A,M
1018: E539 	FE59	 	CPI	059H	; 'Y'
1019: E53B 	C282E3	 	JNZ	CMMND1
1020: E53E 	23	 	INX	H
1021: E53F 	2288E0	 	SHLD	INPOINT	;save input line pointer.
1022: E542 		 ERASE1:
1023: E542 	CD54E4	 	CALL	DSELECT	;select desired disk.
1024: E545 	11CDE7	 	LXI	D,FCB
1025: E548 	CDEFE0	 	CALL	DELETE	;delete the file.
1026: E54B 	3C	 	INR	A
1027: E54C 	CCEAE3	 	CZ	NONE	;not there?
1028: E54F 	C386E7	 	JMP	GETBACK	;return to command level now.
1029: E552 		 YESNO:
1030: E552 	414C4C2028592F4E293F00	 	DB	'All (y/n)?',0
1031: E55D 		 ;
1032: E55D 		 ;**************************************************************
1033: E55D 		 ;*
1034: E55D 		 ;*            T Y P E   C O M M A N D
1035: E55D 		 ;*
1036: E55D 		 ;**************************************************************
1037: E55D 		 ;
1038: E55D 		 TYPE:
1039: E55D 	CD5EE2	 	CALL	CONVFST	;convert file name.
1040: E560 	C209E2	 	JNZ	SYNERR	;wild cards not allowed.
1041: E563 	CD54E4	 	CALL	DSELECT	;select indicated drive.
1042: E566 	CDD0E0	 	CALL	OPENFCB	;open the file.
1043: E569 	CAA7E5	 	JZ	TYPE5	;not there?
1044: E56C 	CD98E0	 	CALL	CRLF	;ok, start a new line on the screen.
1045: E56F 	21F1E7	 	LXI	H,NBYTES;initialize byte counter.
1046: E572 	36FF	 	MVI	M,0FFH	;set to read first sector.
1047: E574 		 TYPE1:
1048: E574 	21F1E7	 	LXI	H,NBYTES
1049: E577 		 TYPE2:
1050: E577 	7E	 	MOV	A,M	;have we written the entire sector?
1051: E578 	FE80	 	CPI	128
1052: E57A 	DA87E5	 	JC	TYPE3
1053: E57D 	E5	 	PUSH	H	;yes, read in the next one.
1054: E57E 	CDFEE0	 	CALL	READFCB
1055: E581 	E1	 	POP	H
1056: E582 	C2A0E5	 	JNZ	TYPE4	;end or error?
1057: E585 	AF	 	XRA	A	;ok, clear byte counter.
1058: E586 	77	 	MOV	M,A
1059: E587 		 TYPE3:
1060: E587 	34	 	INR	M	;count this byte.
1061: E588 	218000	 	LXI	H,TBUFF	;and get the (A)th one from the buffer (TBUFF).
1062: E58B 	CD59E2	 	CALL	ADDHL
1063: E58E 	7E	 	MOV	A,M
1064: E58F 	FE1A	 	CPI	CNTRLZ	;end of file mark?
1065: E591 	CA86E7	 	JZ	GETBACK
1066: E594 	CD8CE0	 	CALL	PRINT	;no, print it.
1067: E597 	CDC2E1	 	CALL	CHKCON	;check console, quit if anything ready.
1068: E59A 	C286E7	 	JNZ	GETBACK
1069: E59D 	C374E5	 	JMP	TYPE1
1070: E5A0 		 ;
1071: E5A0 		 ;   Get here on an end of file or read error.
1072: E5A0 		 ;
1073: E5A0 		 TYPE4:
1074: E5A0 	3D	 	DCR	A	;read error?
1075: E5A1 	CA86E7	 	JZ	GETBACK
1076: E5A4 	CDD9E3	 	CALL	RDERROR	;yes, print message.
1077: E5A7 		 TYPE5:
1078: E5A7 	CD66E4	 	CALL	RESETDR	;and reset proper drive
1079: E5AA 	C309E2	 	JMP	SYNERR	;now print file name with problem.
1080: E5AD 		 ;
1081: E5AD 		 ;**************************************************************
1082: E5AD 		 ;*
1083: E5AD 		 ;*            S A V E   C O M M A N D
1084: E5AD 		 ;*
1085: E5AD 		 ;**************************************************************
1086: E5AD 		 ;
1087: E5AD 		 SAVE:
1088: E5AD 	CDF8E3	 	CALL	DECODE	;get numeric number that follows SAVE.
1089: E5B0 	F5	 	PUSH	PSW	;save number of pages to write.
1090: E5B1 	CD5EE2	 	CALL	CONVFST	;convert file name.
1091: E5B4 	C209E2	 	JNZ	SYNERR	;wild cards not allowed.
1092: E5B7 	CD54E4	 	CALL	DSELECT	;select specified drive.
1093: E5BA 	11CDE7	 	LXI	D,FCB	;now delete this file.
1094: E5BD 	D5	 	PUSH	D
1095: E5BE 	CDEFE0	 	CALL	DELETE
1096: E5C1 	D1	 	POP	D
1097: E5C2 	CD09E1	 	CALL	CREATE	;and create it again.
1098: E5C5 	CAFBE5	 	JZ	SAVE3	;can't create?
1099: E5C8 	AF	 	XRA	A	;clear record number byte.
1100: E5C9 	32EDE7	 	STA	FCB+32
1101: E5CC 	F1	 	POP	PSW	;convert pages to sectors.
1102: E5CD 	6F	 	MOV	L,A
1103: E5CE 	2600	 	MVI	H,0
1104: E5D0 	29	 	DAD	H	;(HL)=number of sectors to write.
1105: E5D1 	110001	 	LXI	D,TBASE	;and we start from here.
1106: E5D4 		 SAVE1:
1107: E5D4 	7C	 	MOV	A,H	;done yet?
1108: E5D5 	B5	 	ORA	L
1109: E5D6 	CAF1E5	 	JZ	SAVE2
1110: E5D9 	2B	 	DCX	H	;nope, count this and compute the start
1111: E5DA 	E5	 	PUSH	H	;of the next 128 byte sector.
1112: E5DB 	218000	 	LXI	H,128
1113: E5DE 	19	 	DAD	D
1114: E5DF 	E5	 	PUSH	H	;save it and set the transfer address.
1115: E5E0 	CDD8E1	 	CALL	DMASET
1116: E5E3 	11CDE7	 	LXI	D,FCB	;write out this sector now.
1117: E5E6 	CD04E1	 	CALL	WRTREC
1118: E5E9 	D1	 	POP	D	;reset (DE) to the start of the last sector.
1119: E5EA 	E1	 	POP	H	;restore sector count.
1120: E5EB 	C2FBE5	 	JNZ	SAVE3	;write error?
1121: E5EE 	C3D4E5	 	JMP	SAVE1
1122: E5F1 		 ;
1123: E5F1 		 ;   Get here after writing all of the file.
1124: E5F1 		 ;
1125: E5F1 		 SAVE2:
1126: E5F1 	11CDE7	 	LXI	D,FCB	;now close the file.
1127: E5F4 	CDDAE0	 	CALL	CLOSE
1128: E5F7 	3C	 	INR	A	;did it close ok?
1129: E5F8 	C201E6	 	JNZ	SAVE4
1130: E5FB 		 ;
1131: E5FB 		 ;   Print out error message (no space).
1132: E5FB 		 ;
1133: E5FB 		 SAVE3:
1134: E5FB 	0107E6	 	LXI	B,NOSPACE
1135: E5FE 	CDA7E0	 	CALL	PLINE
1136: E601 		 SAVE4:
1137: E601 	CDD5E1	 	CALL	STDDMA	;reset the standard dma address.
1138: E604 	C386E7	 	JMP	GETBACK
1139: E607 		 NOSPACE:
1140: E607 	4E4F20535041434500	 	DB	'No space',0
1141: E610 		 ;
1142: E610 		 ;**************************************************************
1143: E610 		 ;*
1144: E610 		 ;*           R E N A M E   C O M M A N D
1145: E610 		 ;*
1146: E610 		 ;**************************************************************
1147: E610 		 ;
1148: E610 		 RENAME:
1149: E610 	CD5EE2	 	CALL	CONVFST	;convert first file name.
1150: E613 	C209E2	 	JNZ	SYNERR	;wild cards not allowed.
1151: E616 	3AF0E7	 	LDA	CHGDRV	;remember any change in drives specified.
1152: E619 	F5	 	PUSH	PSW
1153: E61A 	CD54E4	 	CALL	DSELECT	;and select this drive.
1154: E61D 	CDE9E0	 	CALL	SRCHFCB	;is this file present?
1155: E620 	C279E6	 	JNZ	RENAME6	;yes, print error message.
1156: E623 	21CDE7	 	LXI	H,FCB	;yes, move this name into second slot.
1157: E626 	11DDE7	 	LXI	D,FCB+16
1158: E629 	0610	 	MVI	B,16
1159: E62B 	CD42E4	 	CALL	HL2DE
1160: E62E 	2A88E0	 	LHLD	INPOINT	;get input pointer.
1161: E631 	EB	 	XCHG
1162: E632 	CD4FE2	 	CALL	NONBLANK;get next non blank character.
1163: E635 	FE3D	 	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1164: E637 	CA3FE6	 	JZ	RENAME1
1165: E63A 	FE5F	 	CPI	USCORE		; '_'
1166: E63C 	C273E6	 	JNZ	RENAME5
1167: E63F 		 RENAME1:
1168: E63F 	EB	 	XCHG
1169: E640 	23	 	INX	H	;ok, skip seperator.
1170: E641 	2288E0	 	SHLD	INPOINT	;save input line pointer.
1171: E644 	CD5EE2	 	CALL	CONVFST	;convert this second file name now.
1172: E647 	C273E6	 	JNZ	RENAME5	;again, no wild cards.
1173: E64A 	F1	 	POP	PSW	;if a drive was specified, then it
1174: E64B 	47	 	MOV	B,A	;must be the same as before.
1175: E64C 	21F0E7	 	LXI	H,CHGDRV
1176: E64F 	7E	 	MOV	A,M
1177: E650 	B7	 	ORA	A
1178: E651 	CA59E6	 	JZ	RENAME2
1179: E654 	B8	 	CMP	B
1180: E655 	70	 	MOV	M,B
1181: E656 	C273E6	 	JNZ	RENAME5	;they were different, error.
1182: E659 		 RENAME2:
1183: E659 	70	 	MOV	M,B;	reset as per the first file specification.
1184: E65A 	AF	 	XRA	A
1185: E65B 	32CDE7	 	STA	FCB	;clear the drive byte of the fcb.
1186: E65E 		 RENAME3:
1187: E65E 	CDE9E0	 	CALL	SRCHFCB	;and go look for second file.
1188: E661 	CA6DE6	 	JZ	RENAME4	;doesn't exist?
1189: E664 	11CDE7	 	LXI	D,FCB
1190: E667 	CD0EE1	 	CALL	RENAM	;ok, rename the file.
1191: E66A 	C386E7	 	JMP	GETBACK
1192: E66D 		 ;
1193: E66D 		 ;   Process rename errors here.
1194: E66D 		 ;
1195: E66D 		 RENAME4:
1196: E66D 	CDEAE3	 	CALL	NONE	;file not there.
1197: E670 	C386E7	 	JMP	GETBACK
1198: E673 		 RENAME5:
1199: E673 	CD66E4	 	CALL	RESETDR	;bad command format.
1200: E676 	C309E2	 	JMP	SYNERR
1201: E679 		 RENAME6:
1202: E679 	0182E6	 	LXI	B,EXISTS;destination file already exists.
1203: E67C 	CDA7E0	 	CALL	PLINE
1204: E67F 	C386E7	 	JMP	GETBACK
1205: E682 		 EXISTS:
1206: E682 	46494C452045584953545300	 	DB	'File exists',0
1207: E68E 		 ;
1208: E68E 		 ;**************************************************************
1209: E68E 		 ;*
1210: E68E 		 ;*             U S E R   C O M M A N D
1211: E68E 		 ;*
1212: E68E 		 ;**************************************************************
1213: E68E 		 ;
1214: E68E 		 USER:
1215: E68E 	CDF8E3	 	CALL	DECODE	;get numeric value following command.
1216: E691 	FE10	 	CPI	16	;legal user number?
1217: E693 	D209E2	 	JNC	SYNERR
1218: E696 	5F	 	MOV	E,A	;yes but is there anything else?
1219: E697 	3ACEE7	 	LDA	FCB+1
1220: E69A 	FE20	 	CPI	BLANK
1221: E69C 	CA09E2	 	JZ	SYNERR	;yes, that is not allowed.
1222: E69F 	CD15E1	 	CALL	GETSETUC;ok, set user code.
1223: E6A2 	C389E7	 	JMP	GETBACK1
1224: E6A5 		 ;
1225: E6A5 		 ;**************************************************************
1226: E6A5 		 ;*
1227: E6A5 		 ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1228: E6A5 		 ;*
1229: E6A5 		 ;**************************************************************
1230: E6A5 		 ;
1231: E6A5 		 UNKNOWN:
1232: E6A5 	CDF5E1	 	CALL	VERIFY	;check for valid system (why?).
1233: E6A8 	3ACEE7	 	LDA	FCB+1	;anything to execute?
1234: E6AB 	FE20	 	CPI	BLANK
1235: E6AD 	C2C4E6	 	JNZ	UNKWN1
1236: E6B0 	3AF0E7	 	LDA	CHGDRV	;nope, only a drive change?
1237: E6B3 	B7	 	ORA	A
1238: E6B4 	CA89E7	 	JZ	GETBACK1;neither???
1239: E6B7 	3D	 	DCR	A
1240: E6B8 	32EFE7	 	STA	CDRIVE	;ok, store new drive.
1241: E6BB 	CD29E1	 	CALL	MOVECD	;set (TDRIVE) also.
1242: E6BE 	CDBDE0	 	CALL	DSKSEL	;and select this drive.
1243: E6C1 	C389E7	 	JMP	GETBACK1;then return.
1244: E6C4 		 ;
1245: E6C4 		 ;   Here a file name was typed. Prepare to execute it.
1246: E6C4 		 ;
1247: E6C4 		 UNKWN1:
1248: E6C4 	11D6E7	 	LXI	D,FCB+9	;an extension specified?
1249: E6C7 	1A	 	LDAX	D
1250: E6C8 	FE20	 	CPI	BLANK
1251: E6CA 	C209E2	 	JNZ	SYNERR	;yes, not allowed.
1252: E6CD 		 UNKWN2:
1253: E6CD 	D5	 	PUSH	D
1254: E6CE 	CD54E4	 	CALL	DSELECT	;select specified drive.
1255: E6D1 	D1	 	POP	D
1256: E6D2 	2183E7	 	LXI	H,COMFILE	;set the extension to 'COM'.
1257: E6D5 	CD40E4	 	CALL	MOVE3
1258: E6D8 	CDD0E0	 	CALL	OPENFCB	;and open this file.
1259: E6DB 	CA6BE7	 	JZ	UNKWN9	;not present?
1260: E6DE 		 ;
1261: E6DE 		 ;   Load in the program.
1262: E6DE 		 ;
1263: E6DE 	210001	 	LXI	H,TBASE	;store the program starting here.
1264: E6E1 		 UNKWN3:
1265: E6E1 	E5	 	PUSH	H
1266: E6E2 	EB	 	XCHG
1267: E6E3 	CDD8E1	 	CALL	DMASET	;set transfer address.
1268: E6E6 	11CDE7	 	LXI	D,FCB	;and read the next record.
1269: E6E9 	CDF9E0	 	CALL	RDREC
1270: E6EC 	C201E7	 	JNZ	UNKWN4	;end of file or read error?
1271: E6EF 	E1	 	POP	H	;nope, bump pointer for next sector.
1272: E6F0 	118000	 	LXI	D,128
1273: E6F3 	19	 	DAD	D
1274: E6F4 	1100E0	 	LXI	D,CBASE	;enough room for the whole file?
1275: E6F7 	7D	 	MOV	A,L
1276: E6F8 	93	 	SUB	E
1277: E6F9 	7C	 	MOV	A,H
1278: E6FA 	9A	 	SBB	D
1279: E6FB 	D271E7	 	JNC	UNKWN0	;no, it can't fit.
1280: E6FE 	C3E1E6	 	JMP	UNKWN3
1281: E701 		 ;
1282: E701 		 ;   Get here after finished reading.
1283: E701 		 ;
1284: E701 		 UNKWN4:
1285: E701 	E1	 	POP	H
1286: E702 	3D	 	DCR	A	;normal end of file?
1287: E703 	C271E7	 	JNZ	UNKWN0
1288: E706 	CD66E4	 	CALL	RESETDR	;yes, reset previous drive.
1289: E709 	CD5EE2	 	CALL	CONVFST	;convert the first file name that follows
1290: E70C 	21F0E7	 	LXI	H,CHGDRV;command name.
1291: E70F 	E5	 	PUSH	H
1292: E710 	7E	 	MOV	A,M	;set drive code in default fcb.
1293: E711 	32CDE7	 	STA	FCB
1294: E714 	3E10	 	MVI	A,16	;put second name 16 bytes later.
1295: E716 	CD60E2	 	CALL	CONVERT	;convert second file name.
1296: E719 	E1	 	POP	H
1297: E71A 	7E	 	MOV	A,M	;and set the drive for this second file.
1298: E71B 	32DDE7	 	STA	FCB+16
1299: E71E 	AF	 	XRA	A	;clear record byte in fcb.
1300: E71F 	32EDE7	 	STA	FCB+32
1301: E722 	115C00	 	LXI	D,TFCB	;move it into place at(005Ch).
1302: E725 	21CDE7	 	LXI	H,FCB
1303: E728 	0621	 	MVI	B,33
1304: E72A 	CD42E4	 	CALL	HL2DE
1305: E72D 	2108E0	 	LXI	H,INBUFF+2;now move the remainder of the input
1306: E730 		 UNKWN5:
1307: E730 	7E	 	MOV	A,M	;line down to (0080h). Look for a non blank.
1308: E731 	B7	 	ORA	A	;or a null.
1309: E732 	CA3EE7	 	JZ	UNKWN6
1310: E735 	FE20	 	CPI	BLANK
1311: E737 	CA3EE7	 	JZ	UNKWN6
1312: E73A 	23	 	INX	H
1313: E73B 	C330E7	 	JMP	UNKWN5
1314: E73E 		 ;
1315: E73E 		 ;   Do the line move now. It ends in a null byte.
1316: E73E 		 ;
1317: E73E 		 UNKWN6:
1318: E73E 	0600	 	MVI	B,0	;keep a character count.
1319: E740 	118100	 	LXI	D,TBUFF+1;data gets put here.
1320: E743 		 UNKWN7:
1321: E743 	7E	 	MOV	A,M	;move it now.
1322: E744 	12	 	STAX	D
1323: E745 	B7	 	ORA	A
1324: E746 	CA4FE7	 	JZ	UNKWN8
1325: E749 	04	 	INR	B
1326: E74A 	23	 	INX	H
1327: E74B 	13	 	INX	D
1328: E74C 	C343E7	 	JMP	UNKWN7
1329: E74F 		 UNKWN8:
1330: E74F 	78	 	MOV	A,B	;now store the character count.
1331: E750 	328000	 	STA	TBUFF
1332: E753 	CD98E0	 	CALL	CRLF	;clean up the screen.
1333: E756 	CDD5E1	 	CALL	STDDMA	;set standard transfer address.
1334: E759 	CD1AE1	 	CALL	SETCDRV	;reset current drive.
1335: E75C 	CD0001	 	CALL	TBASE	;and execute the program.
1336: E75F 		 ;
1337: E75F 		 ;   Transiant programs return here (or reboot).
1338: E75F 		 ;
1339: E75F 	31ABE7	 	LXI	SP,BATCH	;set stack first off.
1340: E762 	CD29E1	 	CALL	MOVECD	;move current drive into place (TDRIVE).
1341: E765 	CDBDE0	 	CALL	DSKSEL	;and reselect it.
1342: E768 	C382E3	 	JMP	CMMND1	;back to comand mode.
1343: E76B 		 ;
1344: E76B 		 ;   Get here if some error occured.
1345: E76B 		 ;
1346: E76B 		 UNKWN9:
1347: E76B 	CD66E4	 	CALL	RESETDR	;inproper format.
1348: E76E 	C309E2	 	JMP	SYNERR
1349: E771 		 UNKWN0:
1350: E771 	017AE7	 	LXI	B,BADLOAD;read error or won't fit.
1351: E774 	CDA7E0	 	CALL	PLINE
1352: E777 	C386E7	 	JMP	GETBACK
1353: E77A 		 BADLOAD:
1354: E77A 	424144204C4F414400	 	DB	'Bad load',0
1355: E783 		 COMFILE:
1356: E783 	434F4D	 	DB	'COM'	;command file extension.
1357: E786 		 ;
1358: E786 		 ;   Get here to return to command level. We will reset the
1359: E786 		 ; previous active drive and then either return to command
1360: E786 		 ; level directly or print error message and then return.
1361: E786 		 ;
1362: E786 		 GETBACK:
1363: E786 	CD66E4	 	CALL	RESETDR	;reset previous drive.
1364: E789 		 GETBACK1:
1365: E789 	CD5EE2	 	CALL	CONVFST	;convert first name in (FCB).
1366: E78C 	3ACEE7	 	LDA	FCB+1	;if this was just a drive change request,
1367: E78F 	D620	 	SUI	BLANK	;make sure it was valid.
1368: E791 	21F0E7	 	LXI	H,CHGDRV
1369: E794 	B6	 	ORA	M
1370: E795 	C209E2	 	JNZ	SYNERR
1371: E798 	C382E3	 	JMP	CMMND1	;ok, return to command level.
1372: E79B 		 ;
1373: E79B 		 ;   ccp stack area.
1374: E79B 		 ;
1375: E79B 	00000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1376: E7AB 		 CCPSTACK	EQU	$	;end of ccp stack area.
1377: E7AB 		 ;
1378: E7AB 		 ;   Batch (or SUBMIT) processing information storage.
1379: E7AB 		 ;
1380: E7AB 		 BATCH:
1381: E7AB 	00	 	DB	0	;batch mode flag (0=not active).
1382: E7AC 		 BATCHFCB:
1383: E7AC 	002424242020202020535542000000000000000000000000000000000000000000	 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1384: E7CD 		 ;
1385: E7CD 		 ;   File control block setup by the CCP.
1386: E7CD 		 ;
1387: E7CD 		 FCB:
1388: E7CD 	002020202020202020202020000000000020202020202020202020200000000000	 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1389: E7EE 		 RTNCODE:
1390: E7EE 	00	 	DB	0	;status returned from bdos call.
1391: E7EF 		 CDRIVE:
1392: E7EF 	00	 	DB	0	;currently active drive.
1393: E7F0 		 CHGDRV:
1394: E7F0 	00	 	DB	0	;change in drives flag (0=no change).
1395: E7F1 		 NBYTES:
1396: E7F1 	0000	 	DW	0	;byte counter used by TYPE.
1397: E7F3 		 ;
1398: E7F3 		 ;   Room for expansion?
1399: E7F3 		 ;
1400: E7F3 	00000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1401: E800 		 ;
1402: E800 		 ;   Note that the following six bytes must match those at
1403: E800 		 ; (PATTRN1) or cp/m will HALT. Why?
1404: E800 		 ;
1405: E800 		 PATTRN2:
1406: E800 	001600000000	 	DB	0,22,0,0,0,0;(* serial number bytes *).
1407: E806 		 ;
1408: E806 		 ;**************************************************************
1409: E806 		 ;*
1410: E806 		 ;*                    B D O S   E N T R Y
1411: E806 		 ;*
1412: E806 		 ;**************************************************************
1413: E806 		 ;
1414: E806 		 BDOSEntry:
1415: E806 	C311E8	 	JMP	BDOSSetup
1416: E809 		 ;
1417: E809 		 ;   Bdos error table.
1418: E809 		 ;
1419: E809 	99E8	 BADSCTR:	DW	ERROR1	;bad sector on read or write.
1420: E80B 	A5E8	 BADSLCT:	DW	ERROR2	;bad disk select.
1421: E80D 	ABE8	 RODISK:		DW	ERROR3	;disk is read only.
1422: E80F 	B1E8	 ROFILE:		DW	ERROR4	;file is read only.
1423: E811 		 ;
1424: E811 		 ;   Entry into bdos.
1425: E811 		 ;			Parameters: (DE) or (E) are the parameters passed. The
1426: E811 		 ;						(C) - function number
1427: E811 		 ;	The user's stack is saved (UserStack) 
1428: E811 		 ;	BDOS uses its own stack  (BDOSstack)
1429: E811 		 ;	The Function number is checked
1430: E811 		 ;	The corect routine is calcualted using the FunctionVector and (C)
1431: E811 		 ;
1432: E811 		 BDOSSetup:
1433: E811 	EB	 	XCHG						;save the (DE) parameters.
1434: E812 	2243EB	 	SHLD	ParamsDE
1435: E815 	EB	 	XCHG
1436: E816 	7B	 	MOV		A,E					;and save register (E) in particular.
1437: E817 	32D6F5	 	STA		ParamE
1438: E81A 	210000	 	LXI		H,0
1439: E81D 	2245EB	 	SHLD	STATUS				;clear return status.
1440: E820 	39	 	DAD		SP
1441: E821 	220FEB	 	SHLD	UserStack			;save users stack pointer.
1442: E824 	3141EB	 	LXI		SP,BDOSstack		;and set our own.
1443: E827 	AF	 	XRA		A					;clear auto select storage space.
1444: E828 	32E0F5	 	STA		AUTOFLAG
1445: E82B 	32DEF5	 	STA		AUTO
1446: E82E 	2174F5	 	LXI		H,BDOSExit			;set return address.
1447: E831 	E5	 	PUSH	H
1448: E832 	79	 	MOV		A,C					;get function number.
1449: E833 	FE29	 	CPI		FunctionCount + 1	;valid function number?
1450: E835 	D0	 	RNC
1451: E836 	4B	 	MOV		C,E					;keep single register function here.
1452: E837 	2147E8	 	LXI		H,FunctionVector	;now look thru the function table.
1453: E83A 	5F	 	MOV		E,A
1454: E83B 	1600	 	MVI		D,0					;(DE)=function number.
1455: E83D 	19	 	DAD		D
1456: E83E 	19	 	DAD		D					;(HL)=(start of table)+2*(function number).
1457: E83F 	5E	 	MOV		E,M
1458: E840 	23	 	INX		H
1459: E841 	56	 	MOV		D,M					;now (DE)=address for this function.
1460: E842 	2A43EB	 	LHLD	ParamsDE			;retrieve parameters.
1461: E845 	EB	 	XCHG						;now (DE) has the original parameters.
1462: E846 	E9	 	PCHL			;execute desired function.
1463: E847 		 ;
1464: E847 		 ;   BDOS function jump table.
1465: E847 		 ;
1466: E847 		 ;NFUNCTS	EQU	41	;number of functions in followin table.
1467: E847 		 ;
1468: E847 		 FunctionVector:
1469: E847 	03F6	 	DW	WBOOT	;0		Overall system and BDOS reset
1470: E849 	C8EA	 	DW	GETCON	;1		Read a byte from the console keyboard
1471: E84B 	90E9	 	DW	OUTCON	;2		Write a byte to the console screen
1472: E84D 	CEEA	 	DW	GETRDR	;3		Read a byte from the logical reader device
1473: E84F 	12F6	 	DW	PUNCH	;4		Write a byte to the logical punch device
1474: E851 	0FF6	 	DW	LIST	;5		Write a byte to the logical list device
1475: E853 	D4EA	 	DW	DIRCIO	;6		Direct console I/O (no CCP-style editing)
1476: E855 	EDEA	 	DW	GETIOB	;7		Read the current setting of the IOBYTE
1477: E857 	F3EA	 	DW	SETIOB	;8		Set a new value of the IOBYTE
1478: E859 	F8EA	 	DW	PRTSTR	;9		Send a "$"-terminated string to the console
1479: E85B 	E1E9	 	DW	RDBUFF	;10		Read a string from the console into a buffer
1480: E85D 	FEEA	 	DW	GETCSTS	;11		Check if a console key is waiting to be read
1481: E85F 	7EF4	 	DW	GETVER	;12		Return the CP/M version number
1482: E861 		 	
1483: E861 	83F4	 	DW	RSTDSK		;13		Reset disk system
1484: E863 	45F4	 	DW	SETDSK		;14		Select specified logical disk drive
1485: E865 	9CF4	 	DW	OPENFIL		;15		Open specified file for reading/writing
1486: E867 	A5F4	 	DW	CLOSEFIL	;16		Close specified file after reading/writing
1487: E869 	ABF4	 	DW	GETFST		;17		Search file directory for first match with filename
1488: E86B 	C8F4	 	DW	GETNXT		;18		Search file directory for next match with filename
1489: E86D 	D7F4	 	DW	DELFILE		;19		Delete (erase) file
1490: E86F 	E0F4	 	DW	READSEQ		;20		Read the next "record" sequentially
1491: E871 	E6F4	 	DW	WRTSEQ		;21		Write the next "record" sequentially
1492: E873 	ECF4	 	DW	FCREATE		;22		Create a new file with the specified name
1493: E875 	F5F4	 	DW	RENFILE		;23		Rename a file to a new name
1494: E877 	FEF4	 	DW	GETLOG		;24		Indicate which logical disks are active
1495: E879 	04F5	 	DW	GETCRNT		;25		Return the current default disk drive number
1496: E87B 	0AF5	 	DW	PUTDMA		;26		Set the DMA address (read/write address)
1497: E87D 	11F5	 	DW	GETALOC		;27		Return the address of an allocation vector
1498: E87F 	2CED	 	DW	WRTPRTD		;28		Return the address of an allocation vector
1499: E881 	17F5	 	DW	GETROV		;29		Indicate which disks are currently Read-Only status
1500: E883 	1DF5	 	DW	SETATTR		;30		Set specified file to System or Read-Only status
1501: E885 	26F5	 	DW	GETPARM		;31		Return address of disk parameter block (DPB)
1502: E887 	2DF5	 	DW	GETUSER		;32		Set/Get the current user number
1503: E889 	41F5	 	DW	RDRANDOM	;33		Set/Get the current user number
1504: E88B 	47F5	 	DW	WTRANDOM	;34		Write a "record" randomly
1505: E88D 	4DF5	 	DW	FILESIZE	;35		Return logical file size (even for random files)
1506: E88F 	0EF4	 	DW	SETRAN		;36		Set record number for the next random read/write
1507: E891 	53F5	 	DW	LOGOFF		;37
1508: E893 	04EB	 	DW	Return			;38		Simple Return
1509: E895 	04EB	 	DW	Return			;39		Simple Return
1510: E897 	9BF5	 	DW	WTSPECL		;40		Write a "record" randomly with zero fill
1511: E899 		 	
1512: E899 		 FunctionCount	EQU	 ($ -FunctionVector)/2
1513: E899 		 ;
1514: E899 		 ;   Bdos error message section.
1515: E899 		 ;
1516: E899 		 ERROR1:
1517: E899 	21CAE8	 	LXI	H,BADSEC	;bad sector message.
1518: E89C 	CDE5E8	 	CALL	PRTERR	;print it and get a 1 char responce.
1519: E89F 	FE03	 	CPI	CNTRLC	;re-boot request (control-c)?
1520: E8A1 	CA0000	 	JZ	0	;yes.
1521: E8A4 	C9	 	RET		;no, return to retry i/o function.
1522: E8A5 		 ;
1523: E8A5 		 ERROR2:
1524: E8A5 	21D5E8	 	LXI	H,BADSEL	;bad drive selected.
1525: E8A8 	C3B4E8	 	JMP	ERROR5
1526: E8AB 		 ;
1527: E8AB 		 ERROR3:
1528: E8AB 	21E1E8	 	LXI	H,DISKRO	;disk is read only.
1529: E8AE 	C3B4E8	 	JMP	ERROR5
1530: E8B1 		 ;
1531: E8B1 		 ERROR4:
1532: E8B1 	21DCE8	 	LXI	H,FILERO	;file is read only.
1533: E8B4 		 ;
1534: E8B4 		 ERROR5:
1535: E8B4 	CDE5E8	 	CALL	PRTERR
1536: E8B7 	C30000	 	JMP	0	;always reboot on these errors.
1537: E8BA 		 ;
1538: E8BA 	42444F5320455252204F4E20	 BDOSERR:	DB	'Bdos Err On '
1539: E8C6 	203A2024	 BDOSDRV:	DB	' : $'
1540: E8CA 	42414420534543544F5224	 BADSEC:		DB	'Bad Sector$'
1541: E8D5 	53454C45435424	 BADSEL:		DB	'Select$'
1542: E8DC 	46494C4520	 FILERO:		DB	'File '
1543: E8E1 	522F4F24	 DISKRO:		DB	'R/O$'
1544: E8E5 		 ;
1545: E8E5 		 ;   Print bdos error message.
1546: E8E5 		 ;
1547: E8E5 		 PRTERR:
1548: E8E5 	E5	 	PUSH	H	;save second message pointer.
1549: E8E6 	CDC9E9	 	CALL	OUTCRLF	;send (cr)(lf).
1550: E8E9 	3A42EB	 	LDA	ACTIVE	;get active drive.
1551: E8EC 	C641	 	ADI	041H	; 'A'	;make ascii.
1552: E8EE 	32C6E8	 	STA	BDOSDRV	;and put in message.
1553: E8F1 	01BAE8	 	LXI	B,BDOSERR;and print it.
1554: E8F4 	CDD3E9	 	CALL	PRTMESG
1555: E8F7 	C1	 	POP	B	;print second message line now.
1556: E8F8 	CDD3E9	 	CALL	PRTMESG
1557: E8FB 		 ;
1558: E8FB 		 ;   Get an input character. We will check our 1 character
1559: E8FB 		 ; buffer first. This may be set by the console status routine.
1560: E8FB 		 ;
1561: E8FB 		 GETCHAR:
1562: E8FB 	210EEB	 	LXI	H,CHARBUF;check character buffer.
1563: E8FE 	7E	 	MOV	A,M	;anything present already?
1564: E8FF 	3600	 	MVI	M,0	;...either case clear it.
1565: E901 	B7	 	ORA	A
1566: E902 	C0	 	RNZ		;yes, use it.
1567: E903 	C309F6	 	JMP	CONIN	;nope, go get a character responce.
1568: E906 		 ;
1569: E906 		 ;   Input and echo a character.
1570: E906 		 ;
1571: E906 		 GETECHO:
1572: E906 	CDFBE8	 	CALL	GETCHAR	;input a character.
1573: E909 	CD14E9	 	CALL	CHKCHAR	;carriage control?
1574: E90C 	D8	 	RC		;no, a regular control char so don't echo.
1575: E90D 	F5	 	PUSH	PSW	;ok, save character now.
1576: E90E 	4F	 	MOV	C,A
1577: E90F 	CD90E9	 	CALL	OUTCON	;and echo it.
1578: E912 	F1	 	POP	PSW	;get character and return.
1579: E913 	C9	 	RET
1580: E914 		 ;
1581: E914 		 ;   Check character in (A). Set the zero flag on a carriage
1582: E914 		 ; control character and the carry flag on any other control
1583: E914 		 ; character.
1584: E914 		 ;
1585: E914 		 CHKCHAR:
1586: E914 	FE0D	 	CPI	CR	;check for carriage return, line feed, backspace,
1587: E916 	C8	 	RZ		;or a tab.
1588: E917 	FE0A	 	CPI	LF
1589: E919 	C8	 	RZ
1590: E91A 	FE09	 	CPI	TAB
1591: E91C 	C8	 	RZ
1592: E91D 	FE08	 	CPI	BS
1593: E91F 	C8	 	RZ
1594: E920 	FE20	 	CPI	BLANK	;other control char? Set carry flag.
1595: E922 	C9	 	RET
1596: E923 		 ;
1597: E923 		 ;   Check the console during output. Halt on a control-s, then
1598: E923 		 ; reboot on a control-c. If anything else is ready, clear the
1599: E923 		 ; zero flag and return (the calling routine may want to do
1600: E923 		 ; something).
1601: E923 		 ;
1602: E923 		 CKCONSOL:
1603: E923 	3A0EEB	 	LDA	CHARBUF	;check buffer.
1604: E926 	B7	 	ORA	A	;if anything, just return without checking.
1605: E927 	C245E9	 	JNZ	CKCON2
1606: E92A 	CD06F6	 	CALL	CONST	;nothing in buffer. Check console.
1607: E92D 	E601	 	ANI	01H	;look at bit 0.
1608: E92F 	C8	 	RZ		;return if nothing.
1609: E930 	CD09F6	 	CALL	CONIN	;ok, get it.
1610: E933 	FE13	 	CPI	CNTRLS	;if not control-s, return with zero cleared.
1611: E935 	C242E9	 	JNZ	CKCON1
1612: E938 	CD09F6	 	CALL	CONIN	;halt processing until another char
1613: E93B 	FE03	 	CPI	CNTRLC	;is typed. Control-c?
1614: E93D 	CA0000	 	JZ	0	;yes, reboot now.
1615: E940 	AF	 	XRA	A	;no, just pretend nothing was ever ready.
1616: E941 	C9	 	RET
1617: E942 		 CKCON1:
1618: E942 	320EEB	 	STA	CHARBUF	;save character in buffer for later processing.
1619: E945 		 CKCON2:
1620: E945 	3E01	 	MVI	A,1	;set (A) to non zero to mean something is ready.
1621: E947 	C9	 	RET
1622: E948 		 ;
1623: E948 		 ;   Output (C) to the screen. If the printer flip-flop flag
1624: E948 		 ; is set, we will send character to printer also. The console
1625: E948 		 ; will be checked in the process.
1626: E948 		 ;
1627: E948 		 OUTCHAR:
1628: E948 	3A0AEB	 	LDA	OUTFLAG	;check output flag.
1629: E94B 	B7	 	ORA	A	;anything and we won't generate output.
1630: E94C 	C262E9	 	JNZ	OUTCHR1
1631: E94F 	C5	 	PUSH	B
1632: E950 	CD23E9	 	CALL	CKCONSOL;check console (we don't care whats there).
1633: E953 	C1	 	POP	B
1634: E954 	C5	 	PUSH	B
1635: E955 	CD0CF6	 	CALL	CONOUT	;output (C) to the screen.
1636: E958 	C1	 	POP	B
1637: E959 	C5	 	PUSH	B
1638: E95A 	3A0DEB	 	LDA	PRTFLAG	;check printer flip-flop flag.
1639: E95D 	B7	 	ORA	A
1640: E95E 	C40FF6	 	CNZ	LIST	;print it also if non-zero.
1641: E961 	C1	 	POP	B
1642: E962 		 OUTCHR1:
1643: E962 	79	 	MOV	A,C	;update cursors position.
1644: E963 	210CEB	 	LXI	H,CURPOS
1645: E966 	FE7F	 	CPI	DEL	;rubouts don't do anything here.
1646: E968 	C8	 	RZ
1647: E969 	34	 	INR	M	;bump line pointer.
1648: E96A 	FE20	 	CPI	BLANK	;and return if a normal character.
1649: E96C 	D0	 	RNC
1650: E96D 	35	 	DCR	M	;restore and check for the start of the line.
1651: E96E 	7E	 	MOV	A,M
1652: E96F 	B7	 	ORA	A
1653: E970 	C8	 	RZ		;ingnore control characters at the start of the line.
1654: E971 	79	 	MOV	A,C
1655: E972 	FE08	 	CPI	BS	;is it a backspace?
1656: E974 	C279E9	 	JNZ	OUTCHR2
1657: E977 	35	 	DCR	M	;yes, backup pointer.
1658: E978 	C9	 	RET
1659: E979 		 OUTCHR2:
1660: E979 	FE0A	 	CPI	LF	;is it a line feed?
1661: E97B 	C0	 	RNZ		;ignore anything else.
1662: E97C 	3600	 	MVI	M,0	;reset pointer to start of line.
1663: E97E 	C9	 	RET
1664: E97F 		 ;
1665: E97F 		 ;   Output (A) to the screen. If it is a control character
1666: E97F 		 ; (other than carriage control), use ^x format.
1667: E97F 		 ;
1668: E97F 		 SHOWIT:
1669: E97F 	79	 	MOV	A,C
1670: E980 	CD14E9	 	CALL	CHKCHAR	;check character.
1671: E983 	D290E9	 	JNC	OUTCON	;not a control, use normal output.
1672: E986 	F5	 	PUSH	PSW
1673: E987 	0E5E	 	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1674: E989 	CD48E9	 	CALL	OUTCHAR
1675: E98C 	F1	 	POP	PSW
1676: E98D 	F640	 	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1677: E98F 	4F	 	MOV	C,A
1678: E990 		 ;
1679: E990 		 ;   Function to output (C) to the console device and expand tabs
1680: E990 		 ; if necessary.
1681: E990 		 ;
1682: E990 		 OUTCON:
1683: E990 	79	 	MOV	A,C
1684: E991 	FE09	 	CPI	TAB	;is it a tab?
1685: E993 	C248E9	 	JNZ	OUTCHAR	;use regular output.
1686: E996 		 OUTCON1:
1687: E996 	0E20	 	MVI	C,BLANK	;yes it is, use spaces instead.
1688: E998 	CD48E9	 	CALL	OUTCHAR
1689: E99B 	3A0CEB	 	LDA	CURPOS	;go until the cursor is at a multiple of 8
1690: E99E 		 
1691: E99E 	E607	 	ANI	07H	;position.
1692: E9A0 	C296E9	 	JNZ	OUTCON1
1693: E9A3 	C9	 	RET
1694: E9A4 		 ;
1695: E9A4 		 ;   Echo a backspace character. Erase the prevoius character
1696: E9A4 		 ; on the screen.
1697: E9A4 		 ;
1698: E9A4 		 BACKUP:
1699: E9A4 	CDACE9	 	CALL	BACKUP1	;backup the screen 1 place.
1700: E9A7 	0E20	 	MVI	C,BLANK	;then blank that character.
1701: E9A9 	CD0CF6	 	CALL	CONOUT
1702: E9AC 		 BACKUP1:
1703: E9AC 	0E08	 	MVI	C,BS	;then back space once more.
1704: E9AE 	C30CF6	 	JMP	CONOUT
1705: E9B1 		 ;
1706: E9B1 		 ;   Signal a deleted line. Print a '#' at the end and start
1707: E9B1 		 ; over.
1708: E9B1 		 ;
1709: E9B1 		 NEWLINE:
1710: E9B1 	0E23	 	MVI	C, POUNDSN		; '#'
1711: E9B3 	CD48E9	 	CALL	OUTCHAR	;print this.
1712: E9B6 	CDC9E9	 	CALL	OUTCRLF	;start new line.
1713: E9B9 		 NEWLN1:
1714: E9B9 	3A0CEB	 	LDA	CURPOS	;move the cursor to the starting position.
1715: E9BC 	210BEB	 	LXI	H,STARTING
1716: E9BF 	BE	 	CMP	M
1717: E9C0 	D0	 	RNC		;there yet?
1718: E9C1 	0E20	 	MVI	C,BLANK
1719: E9C3 	CD48E9	 	CALL	OUTCHAR	;nope, keep going.
1720: E9C6 	C3B9E9	 	JMP	NEWLN1
1721: E9C9 		 ;
1722: E9C9 		 ;   Output a (cr) (lf) to the console device (screen).
1723: E9C9 		 ;
1724: E9C9 		 OUTCRLF:
1725: E9C9 	0E0D	 	MVI	C,CR
1726: E9CB 	CD48E9	 	CALL	OUTCHAR
1727: E9CE 	0E0A	 	MVI	C,LF
1728: E9D0 	C348E9	 	JMP	OUTCHAR
1729: E9D3 		 ;
1730: E9D3 		 ;   Print message pointed to by (BC). It will end with a '$'.
1731: E9D3 		 ;
1732: E9D3 		 PRTMESG:
1733: E9D3 	0A	 	LDAX	B	;check for terminating character.
1734: E9D4 	FE24	 	CPI	DOLLAR		; '$'
1735: E9D6 	C8	 	RZ
1736: E9D7 	03	 	INX	B
1737: E9D8 	C5	 	PUSH	B	;otherwise, bump pointer and print it.
1738: E9D9 	4F	 	MOV	C,A
1739: E9DA 	CD90E9	 	CALL	OUTCON
1740: E9DD 	C1	 	POP	B
1741: E9DE 	C3D3E9	 	JMP	PRTMESG
1742: E9E1 		 ;
1743: E9E1 		 ;   Function to execute a buffered read.
1744: E9E1 		 ;
1745: E9E1 		 RDBUFF:
1746: E9E1 	3A0CEB	 	LDA	CURPOS	;use present location as starting one.
1747: E9E4 	320BEB	 	STA	STARTING
1748: E9E7 	2A43EB	 	LHLD	ParamsDE	;get the maximum buffer space.
1749: E9EA 	4E	 	MOV	C,M
1750: E9EB 	23	 	INX	H	;point to first available space.
1751: E9EC 	E5	 	PUSH	H	;and save.
1752: E9ED 	0600	 	MVI	B,0	;keep a character count.
1753: E9EF 		 RDBUF1:
1754: E9EF 	C5	 	PUSH	B
1755: E9F0 	E5	 	PUSH	H
1756: E9F1 		 RDBUF2:
1757: E9F1 	CDFBE8	 	CALL	GETCHAR	;get the next input character.
1758: E9F4 	E67F	 	ANI	7FH	;strip bit 7.
1759: E9F6 	E1	 	POP	H	;reset registers.
1760: E9F7 	C1	 	POP	B
1761: E9F8 	FE0D	 	CPI	CR	;en of the line?
1762: E9FA 	CAC1EA	 	JZ	RDBUF17
1763: E9FD 	FE0A	 	CPI	LF
1764: E9FF 	CAC1EA	 	JZ	RDBUF17
1765: EA02 	FE08	 	CPI	BS	;how about a backspace?
1766: EA04 	C216EA	 	JNZ	RDBUF3
1767: EA07 	78	 	MOV	A,B	;yes, but ignore at the beginning of the line.
1768: EA08 	B7	 	ORA	A
1769: EA09 	CAEFE9	 	JZ	RDBUF1
1770: EA0C 	05	 	DCR	B	;ok, update counter.
1771: EA0D 	3A0CEB	 	LDA	CURPOS	;if we backspace to the start of the line,
1772: EA10 	320AEB	 	STA	OUTFLAG	;treat as a cancel (control-x).
1773: EA13 	C370EA	 	JMP	RDBUF10
1774: EA16 		 RDBUF3:
1775: EA16 	FE7F	 	CPI	DEL	;user typed a rubout?
1776: EA18 	C226EA	 	JNZ	RDBUF4
1777: EA1B 	78	 	MOV	A,B	;ignore at the start of the line.
1778: EA1C 	B7	 	ORA	A
1779: EA1D 	CAEFE9	 	JZ	RDBUF1
1780: EA20 	7E	 	MOV	A,M	;ok, echo the prevoius character.
1781: EA21 	05	 	DCR	B	;and reset pointers (counters).
1782: EA22 	2B	 	DCX	H
1783: EA23 	C3A9EA	 	JMP	RDBUF15
1784: EA26 		 RDBUF4:
1785: EA26 	FE05	 	CPI	CNTRLE	;physical end of line?
1786: EA28 	C237EA	 	JNZ	RDBUF5
1787: EA2B 	C5	 	PUSH	B	;yes, do it.
1788: EA2C 	E5	 	PUSH	H
1789: EA2D 	CDC9E9	 	CALL	OUTCRLF
1790: EA30 	AF	 	XRA	A	;and update starting position.
1791: EA31 	320BEB	 	STA	STARTING
1792: EA34 	C3F1E9	 	JMP	RDBUF2
1793: EA37 		 RDBUF5:
1794: EA37 	FE10	 	CPI	CNTRLP	;control-p?
1795: EA39 	C248EA	 	JNZ	RDBUF6
1796: EA3C 	E5	 	PUSH	H	;yes, flip the print flag filp-flop byte.
1797: EA3D 	210DEB	 	LXI	H,PRTFLAG
1798: EA40 	3E01	 	MVI	A,1	;PRTFLAG=1-PRTFLAG
1799: EA42 	96	 	SUB	M
1800: EA43 	77	 	MOV	M,A
1801: EA44 	E1	 	POP	H
1802: EA45 	C3EFE9	 	JMP	RDBUF1
1803: EA48 		 RDBUF6:
1804: EA48 	FE18	 	CPI	CNTRLX	;control-x (cancel)?
1805: EA4A 	C25FEA	 	JNZ	RDBUF8
1806: EA4D 	E1	 	POP	H
1807: EA4E 		 RDBUF7:
1808: EA4E 	3A0BEB	 	LDA	STARTING;yes, backup the cursor to here.
1809: EA51 	210CEB	 	LXI	H,CURPOS
1810: EA54 	BE	 	CMP	M
1811: EA55 	D2E1E9	 	JNC	RDBUFF	;done yet?
1812: EA58 	35	 	DCR	M	;no, decrement pointer and output back up one space.
1813: EA59 	CDA4E9	 	CALL	BACKUP
1814: EA5C 	C34EEA	 	JMP	RDBUF7
1815: EA5F 		 RDBUF8:
1816: EA5F 	FE15	 	CPI	CNTRLU	;cntrol-u (cancel line)?
1817: EA61 	C26BEA	 	JNZ	RDBUF9
1818: EA64 	CDB1E9	 	CALL	NEWLINE	;start a new line.
1819: EA67 	E1	 	POP	H
1820: EA68 	C3E1E9	 	JMP	RDBUFF
1821: EA6B 		 RDBUF9:
1822: EA6B 	FE12	 	CPI	CNTRLR	;control-r?
1823: EA6D 	C2A6EA	 	JNZ	RDBUF14
1824: EA70 		 RDBUF10:
1825: EA70 	C5	 	PUSH	B	;yes, start a new line and retype the old one.
1826: EA71 	CDB1E9	 	CALL	NEWLINE
1827: EA74 	C1	 	POP	B
1828: EA75 	E1	 	POP	H
1829: EA76 	E5	 	PUSH	H
1830: EA77 	C5	 	PUSH	B
1831: EA78 		 RDBUF11:
1832: EA78 	78	 	MOV	A,B	;done whole line yet?
1833: EA79 	B7	 	ORA	A
1834: EA7A 	CA8AEA	 	JZ	RDBUF12
1835: EA7D 	23	 	INX	H	;nope, get next character.
1836: EA7E 	4E	 	MOV	C,M
1837: EA7F 	05	 	DCR	B	;count it.
1838: EA80 	C5	 	PUSH	B
1839: EA81 	E5	 	PUSH	H
1840: EA82 	CD7FE9	 	CALL	SHOWIT	;and display it.
1841: EA85 	E1	 	POP	H
1842: EA86 	C1	 	POP	B
1843: EA87 	C378EA	 	JMP	RDBUF11
1844: EA8A 		 RDBUF12:
1845: EA8A 	E5	 	PUSH	H	;done with line. If we were displaying
1846: EA8B 	3A0AEB	 	LDA	OUTFLAG	;then update cursor position.
1847: EA8E 	B7	 	ORA	A
1848: EA8F 	CAF1E9	 	JZ	RDBUF2
1849: EA92 	210CEB	 	LXI	H,CURPOS;because this line is shorter, we must
1850: EA95 	96	 	SUB	M	;back up the cursor (not the screen however)
1851: EA96 	320AEB	 	STA	OUTFLAG	;some number of positions.
1852: EA99 		 RDBUF13:
1853: EA99 	CDA4E9	 	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1854: EA9C 	210AEB	 	LXI	H,OUTFLAG;zero, the screen will not be changed.
1855: EA9F 	35	 	DCR	M
1856: EAA0 	C299EA	 	JNZ	RDBUF13
1857: EAA3 	C3F1E9	 	JMP	RDBUF2	;now just get the next character.
1858: EAA6 		 ;
1859: EAA6 		 ;   Just a normal character, put this in our buffer and echo.
1860: EAA6 		 ;
1861: EAA6 		 RDBUF14:
1862: EAA6 	23	 	INX	H
1863: EAA7 	77	 	MOV	M,A	;store character.
1864: EAA8 	04	 	INR	B	;and count it.
1865: EAA9 		 RDBUF15:
1866: EAA9 	C5	 	PUSH	B
1867: EAAA 	E5	 	PUSH	H
1868: EAAB 	4F	 	MOV	C,A	;echo it now.
1869: EAAC 	CD7FE9	 	CALL	SHOWIT
1870: EAAF 	E1	 	POP	H
1871: EAB0 	C1	 	POP	B
1872: EAB1 	7E	 	MOV	A,M	;was it an abort request?
1873: EAB2 	FE03	 	CPI	CNTRLC	;control-c abort?
1874: EAB4 	78	 	MOV	A,B
1875: EAB5 	C2BDEA	 	JNZ	RDBUF16
1876: EAB8 	FE01	 	CPI	1	;only if at start of line.
1877: EABA 	CA0000	 	JZ	0
1878: EABD 		 RDBUF16:
1879: EABD 	B9	 	CMP	C	;nope, have we filled the buffer?
1880: EABE 	DAEFE9	 	JC	RDBUF1
1881: EAC1 		 RDBUF17:
1882: EAC1 	E1	 	POP	H	;yes end the line and return.
1883: EAC2 	70	 	MOV	M,B
1884: EAC3 	0E0D	 	MVI	C,CR
1885: EAC5 	C348E9	 	JMP	OUTCHAR	;output (cr) and return.
1886: EAC8 		 ;
1887: EAC8 		 ;   Function to get a character from the console device.
1888: EAC8 		 ;
1889: EAC8 		 GETCON:
1890: EAC8 	CD06E9	 	CALL	GETECHO	;get and echo.
1891: EACB 	C301EB	 	JMP	SETSTAT	;save status and return.
1892: EACE 		 ;
1893: EACE 		 ;   Function to get a character from the tape reader device.
1894: EACE 		 ;
1895: EACE 		 GETRDR:
1896: EACE 	CD15F6	 	CALL	READER	;get a character from reader, set status and return.
1897: EAD1 	C301EB	 	JMP	SETSTAT
1898: EAD4 		 ;
1899: EAD4 		 ;  Function to perform direct console i/o. If (C) contains (FF)
1900: EAD4 		 ; then this is an input request. If (C) contains (FE) then
1901: EAD4 		 ; this is a status request. Otherwise we are to output (C).
1902: EAD4 		 ;
1903: EAD4 		 DIRCIO:
1904: EAD4 	79	 	MOV	A,C	;test for (FF).
1905: EAD5 	3C	 	INR	A
1906: EAD6 	CAE0EA	 	JZ	DIRC1
1907: EAD9 	3C	 	INR	A	;test for (FE).
1908: EADA 	CA06F6	 	JZ	CONST
1909: EADD 	C30CF6	 	JMP	CONOUT	;just output (C).
1910: EAE0 		 DIRC1:
1911: EAE0 	CD06F6	 	CALL	CONST	;this is an input request.
1912: EAE3 	B7	 	ORA	A
1913: EAE4 	CA91F5	 	JZ	BDOSExit1	;not ready? Just return (directly).
1914: EAE7 	CD09F6	 	CALL	CONIN	;yes, get character.
1915: EAEA 	C301EB	 	JMP	SETSTAT	;set status and return.
1916: EAED 		 ;
1917: EAED 		 ;   Function to return the i/o byte.
1918: EAED 		 ;
1919: EAED 		 GETIOB:
1920: EAED 	3A0300	 	LDA	IOBYTE
1921: EAF0 	C301EB	 	JMP	SETSTAT
1922: EAF3 		 ;
1923: EAF3 		 ;   Function to set the i/o byte.
1924: EAF3 		 ;
1925: EAF3 		 SETIOB:
1926: EAF3 	210300	 	LXI	H,IOBYTE
1927: EAF6 	71	 	MOV	M,C
1928: EAF7 	C9	 	RET
1929: EAF8 		 ;
1930: EAF8 		 ;   Function to print the character string pointed to by (DE)
1931: EAF8 		 ; on the console device. The string ends with a '$'.
1932: EAF8 		 ;
1933: EAF8 		 PRTSTR:
1934: EAF8 	EB	 	XCHG
1935: EAF9 	4D	 	MOV	C,L
1936: EAFA 	44	 	MOV	B,H	;now (BC) points to it.
1937: EAFB 	C3D3E9	 	JMP	PRTMESG
1938: EAFE 		 ;
1939: EAFE 		 ;   Function to interigate the console device.
1940: EAFE 		 ;
1941: EAFE 		 GETCSTS:
1942: EAFE 	CD23E9	 	CALL	CKCONSOL
1943: EB01 		 ;
1944: EB01 		 ;   Get here to set the status and return to the cleanup
1945: EB01 		 ; section. Then back to the user.
1946: EB01 		 ;
1947: EB01 		 SETSTAT:
1948: EB01 	3245EB	 	STA	STATUS
1949: EB04 		 Return:
1950: EB04 	C9	 	RET
1951: EB05 		 ;
1952: EB05 		 ;   Set the status to 1 (read or write error code).
1953: EB05 		 ;
1954: EB05 		 IOERR1:
1955: EB05 	3E01	 	MVI	A,1
1956: EB07 	C301EB	 	JMP	SETSTAT
1957: EB0A 		 ;
1958: EB0A 	00	 OUTFLAG:	DB	0	;output flag (non zero means no output).
1959: EB0B 	02	 STARTING:	DB	2	;starting position for cursor.
1960: EB0C 	00	 CURPOS:		DB	0	;cursor position (0=start of line).
1961: EB0D 	00	 PRTFLAG:	DB	0	;printer flag (control-p toggle). List if non zero.
1962: EB0E 	00	 CHARBUF:	DB	0	;single input character buffer.
1963: EB0F 		 ;
1964: EB0F 		 ;   Stack area for BDOS calls.
1965: EB0F 		 ;
1966: EB0F 		 UserStack:
1967: EB0F 	0000	 	DW	0	;save users stack pointer here.
1968: EB11 		 ;
1969: EB11 	000000000000000000000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1970: EB29 	000000000000000000000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1971: EB41 		 BDOSstack	EQU	$	;end of stack area.
1972: EB41 		 ;
1973: EB41 	00	 USERNO:	DB	0	;current user number.
1974: EB42 	00	 ACTIVE:	DB	0	;currently active drive.
1975: EB43 	0000	 ParamsDE:	DW	0	;save (DE) parameters here on entry.
1976: EB45 	0000	 STATUS:	DW	0	;status returned from bdos function.
1977: EB47 		 ;
1978: EB47 		 ;   Select error occured, jump to error routine.
1979: EB47 		 ;
1980: EB47 		 SLCTERR:
1981: EB47 	210BE8	 	LXI	H,BADSLCT
1982: EB4A 		 ;
1983: EB4A 		 ;   Jump to (HL) indirectly.
1984: EB4A 		 ;
1985: EB4A 		 JUMPHL:
1986: EB4A 	5E	 	MOV	E,M
1987: EB4B 	23	 	INX	H
1988: EB4C 	56	 	MOV	D,M	;now (DE) contain the desired address.
1989: EB4D 	EB	 	XCHG
1990: EB4E 	E9	 	PCHL
1991: EB4F 		 ;
1992: EB4F 		 ;   Block move. (DE) to (HL), (C) bytes total.
1993: EB4F 		 ;
1994: EB4F 		 DE2HL:
1995: EB4F 	0C	 	INR	C	;is count down to zero?
1996: EB50 		 DE2HL1:
1997: EB50 	0D	 	DCR	C
1998: EB51 	C8	 	RZ		;yes, we are done.
1999: EB52 	1A	 	LDAX	D	;no, move one more byte.
2000: EB53 	77	 	MOV	M,A
2001: EB54 	13	 	INX	D
2002: EB55 	23	 	INX	H
2003: EB56 	C350EB	 	JMP	DE2HL1	;and repeat.
2004: EB59 		 ;
2005: EB59 		 ;   Select the desired drive.
2006: EB59 		 ;
2007: EB59 		 SELECT:
2008: EB59 	3A42EB	 	LDA	ACTIVE	;get active disk.
2009: EB5C 	4F	 	MOV	C,A
2010: EB5D 	CD1BF6	 	CALL	SELDSK	;select it.
2011: EB60 	7C	 	MOV	A,H	;valid drive?
2012: EB61 	B5	 	ORA	L	;valid drive?
2013: EB62 	C8	 	RZ		;return if not.
2014: EB63 		 ;
2015: EB63 		 ;   Here, the BIOS returned the address of the parameter block
2016: EB63 		 ; in (HL). We will extract the necessary pointers and save them.
2017: EB63 		 ;
2018: EB63 	5E	 	MOV	E,M	;yes, get address of translation table into (DE).
2019: EB64 	23	 	INX	H
2020: EB65 	56	 	MOV	D,M
2021: EB66 	23	 	INX	H
2022: EB67 	22B3F5	 	SHLD	SCRATCH1	;save pointers to scratch areas.
2023: EB6A 	23	 	INX	H
2024: EB6B 	23	 	INX	H
2025: EB6C 	22B5F5	 	SHLD	SCRATCH2	;ditto.
2026: EB6F 	23	 	INX	H
2027: EB70 	23	 	INX	H
2028: EB71 	22B7F5	 	SHLD	SCRATCH3	;ditto.
2029: EB74 	23	 	INX	H
2030: EB75 	23	 	INX	H
2031: EB76 	EB	 	XCHG		;now save the translation table address.
2032: EB77 	22D0F5	 	SHLD	XLATE
2033: EB7A 	21B9F5	 	LXI	H,DIRBUF	;put the next 8 bytes here.
2034: EB7D 	0E08	 	MVI	C,8	;they consist of the directory buffer
2035: EB7F 	CD4FEB	 	CALL	DE2HL	;pointer, parameter block pointer,
2036: EB82 	2ABBF5	 	LHLD	DISKPB	;check and allocation vectors.
2037: EB85 	EB	 	XCHG
2038: EB86 	21C1F5	 	LXI	H,SECTORS	;move parameter block into our ram.
2039: EB89 	0E0F	 	MVI	C,15	;it is 15 bytes long.
2040: EB8B 	CD4FEB	 	CALL	DE2HL
2041: EB8E 	2AC6F5	 	LHLD	DSKSIZE	;check disk size.
2042: EB91 	7C	 	MOV	A,H	;more than 256 blocks on this?
2043: EB92 	21DDF5	 	LXI	H,BIGDISK
2044: EB95 	36FF	 	MVI	M,0FFH	;set to samll.
2045: EB97 	B7	 	ORA	A
2046: EB98 	CA9DEB	 	JZ	SELECT1
2047: EB9B 	3600	 	MVI	M,0	;wrong, set to large.
2048: EB9D 		 SELECT1:
2049: EB9D 	3EFF	 	MVI	A,0FFH	;clear the zero flag.
2050: EB9F 	B7	 	ORA	A
2051: EBA0 	C9	 	RET
2052: EBA1 		 ;
2053: EBA1 		 ;   Routine to home the disk track head and clear pointers.
2054: EBA1 		 ;
2055: EBA1 		 HOMEDRV:
2056: EBA1 	CD18F6	 	CALL	HOME	;home the head.
2057: EBA4 	AF	 	XRA	A
2058: EBA5 	2AB5F5	 	LHLD	SCRATCH2;set our track pointer also.
2059: EBA8 	77	 	MOV	M,A
2060: EBA9 	23	 	INX	H
2061: EBAA 	77	 	MOV	M,A
2062: EBAB 	2AB7F5	 	LHLD	SCRATCH3;and our sector pointer.
2063: EBAE 	77	 	MOV	M,A
2064: EBAF 	23	 	INX	H
2065: EBB0 	77	 	MOV	M,A
2066: EBB1 	C9	 	RET
2067: EBB2 		 ;
2068: EBB2 		 ;   Do the actual disk read and check the error return status.
2069: EBB2 		 ;
2070: EBB2 		 DOREAD:
2071: EBB2 	CD27F6	 	CALL	READ
2072: EBB5 	C3BBEB	 	JMP	IORET
2073: EBB8 		 ;
2074: EBB8 		 ;   Do the actual disk write and handle any bios error.
2075: EBB8 		 ;
2076: EBB8 		 DOWRITE:
2077: EBB8 	CD2AF6	 	CALL	WRITE
2078: EBBB 		 IORET:
2079: EBBB 	B7	 	ORA	A
2080: EBBC 	C8	 	RZ		;return unless an error occured.
2081: EBBD 	2109E8	 	LXI	H,BADSCTR;bad read/write on this sector.
2082: EBC0 	C34AEB	 	JMP	JUMPHL
2083: EBC3 		 ;
2084: EBC3 		 ;   Routine to select the track and sector that the desired
2085: EBC3 		 ; block number falls in.
2086: EBC3 		 ;
2087: EBC3 		 TRKSEC:
2088: EBC3 	2AEAF5	 	LHLD	FILEPOS	;get position of last accessed file
2089: EBC6 	0E02	 	MVI	C,2	;in directory and compute sector #.
2090: EBC8 	CDEAEC	 	CALL	SHIFTR	;sector #=file-position/4.
2091: EBCB 	22E5F5	 	SHLD	BLKNMBR	;save this as the block number of interest.
2092: EBCE 	22ECF5	 	SHLD	CKSUMTBL;what's it doing here too?
2093: EBD1 		 ;
2094: EBD1 		 ;   if the sector number has already been set (BLKNMBR), enter
2095: EBD1 		 ; at this point.
2096: EBD1 		 ;
2097: EBD1 		 TRKSEC1:
2098: EBD1 	21E5F5	 	LXI	H,BLKNMBR
2099: EBD4 	4E	 	MOV	C,M	;move sector number into (BC).
2100: EBD5 	23	 	INX	H
2101: EBD6 	46	 	MOV	B,M
2102: EBD7 	2AB7F5	 	LHLD	SCRATCH3;get current sector number and
2103: EBDA 	5E	 	MOV	E,M	;move this into (DE).
2104: EBDB 	23	 	INX	H
2105: EBDC 	56	 	MOV	D,M
2106: EBDD 	2AB5F5	 	LHLD	SCRATCH2;get current track number.
2107: EBE0 	7E	 	MOV	A,M	;and this into (HL).
2108: EBE1 	23	 	INX	H
2109: EBE2 	66	 	MOV	H,M
2110: EBE3 	6F	 	MOV	L,A
2111: EBE4 		 TRKSEC2:
2112: EBE4 	79	 	MOV	A,C	;is desired sector before current one?
2113: EBE5 	93	 	SUB	E
2114: EBE6 	78	 	MOV	A,B
2115: EBE7 	9A	 	SBB	D
2116: EBE8 	D2FAEB	 	JNC	TRKSEC3
2117: EBEB 	E5	 	PUSH	H	;yes, decrement sectors by one track.
2118: EBEC 	2AC1F5	 	LHLD	SECTORS	;get sectors per track.
2119: EBEF 	7B	 	MOV	A,E
2120: EBF0 	95	 	SUB	L
2121: EBF1 	5F	 	MOV	E,A
2122: EBF2 	7A	 	MOV	A,D
2123: EBF3 	9C	 	SBB	H
2124: EBF4 	57	 	MOV	D,A	;now we have backed up one full track.
2125: EBF5 	E1	 	POP	H
2126: EBF6 	2B	 	DCX	H	;adjust track counter.
2127: EBF7 	C3E4EB	 	JMP	TRKSEC2
2128: EBFA 		 TRKSEC3:
2129: EBFA 	E5	 	PUSH	H	;desired sector is after current one.
2130: EBFB 	2AC1F5	 	LHLD	SECTORS	;get sectors per track.
2131: EBFE 	19	 	DAD	D	;bump sector pointer to next track.
2132: EBFF 	DA0FEC	 	JC	TRKSEC4
2133: EC02 	79	 	MOV	A,C	;is desired sector now before current one?
2134: EC03 	95	 	SUB	L
2135: EC04 	78	 	MOV	A,B
2136: EC05 	9C	 	SBB	H
2137: EC06 	DA0FEC	 	JC	TRKSEC4
2138: EC09 	EB	 	XCHG		;not yes, increment track counter
2139: EC0A 	E1	 	POP	H	;and continue until it is.
2140: EC0B 	23	 	INX	H
2141: EC0C 	C3FAEB	 	JMP	TRKSEC3
2142: EC0F 		 ;
2143: EC0F 		 ;   here we have determined the track number that contains the
2144: EC0F 		 ; desired sector.
2145: EC0F 		 ;
2146: EC0F 		 TRKSEC4:
2147: EC0F 	E1	 	POP	H	;get track number (HL).
2148: EC10 	C5	 	PUSH	B
2149: EC11 	D5	 	PUSH	D
2150: EC12 	E5	 	PUSH	H
2151: EC13 	EB	 	XCHG
2152: EC14 	2ACEF5	 	LHLD	OFFSET	;adjust for first track offset.
2153: EC17 	19	 	DAD	D
2154: EC18 	44	 	MOV	B,H
2155: EC19 	4D	 	MOV	C,L
2156: EC1A 	CD1EF6	 	CALL	SETTRK	;select this track.
2157: EC1D 	D1	 	POP	D	;reset current track pointer.
2158: EC1E 	2AB5F5	 	LHLD	SCRATCH2
2159: EC21 	73	 	MOV	M,E
2160: EC22 	23	 	INX	H
2161: EC23 	72	 	MOV	M,D
2162: EC24 	D1	 	POP	D
2163: EC25 	2AB7F5	 	LHLD	SCRATCH3;reset the first sector on this track.
2164: EC28 	73	 	MOV	M,E
2165: EC29 	23	 	INX	H
2166: EC2A 	72	 	MOV	M,D
2167: EC2B 	C1	 	POP	B
2168: EC2C 	79	 	MOV	A,C	;now subtract the desired one.
2169: EC2D 	93	 	SUB	E	;to make it relative (1-# sectors/track).
2170: EC2E 	4F	 	MOV	C,A
2171: EC2F 	78	 	MOV	A,B
2172: EC30 	9A	 	SBB	D
2173: EC31 	47	 	MOV	B,A
2174: EC32 	2AD0F5	 	LHLD	XLATE	;translate this sector according to this table.
2175: EC35 	EB	 	XCHG
2176: EC36 	CD30F6	 	CALL	SECTRN	;let the bios translate it.
2177: EC39 	4D	 	MOV	C,L
2178: EC3A 	44	 	MOV	B,H
2179: EC3B 	C321F6	 	JMP	SETSEC	;and select it.
2180: EC3E 		 ;
2181: EC3E 		 ;   Compute block number from record number (SAVNREC) and
2182: EC3E 		 ; extent number (SAVEXT).
2183: EC3E 		 ;
2184: EC3E 		 GETBLOCK:
2185: EC3E 	21C3F5	 	LXI	H,BLKSHFT;get logical to physical conversion.
2186: EC41 	4E	 	MOV	C,M	;note that this is base 2 log of ratio.
2187: EC42 	3AE3F5	 	LDA	SAVNREC	;get record number.
2188: EC45 		 GETBLK1:
2189: EC45 	B7	 	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2190: EC46 	1F	 	RAR
2191: EC47 	0D	 	DCR	C
2192: EC48 	C245EC	 	JNZ	GETBLK1
2193: EC4B 	47	 	MOV	B,A	;save result in (B).
2194: EC4C 	3E08	 	MVI	A,8
2195: EC4E 	96	 	SUB	M
2196: EC4F 	4F	 	MOV	C,A	;compute (C)=8-BLKSHFT.
2197: EC50 	3AE2F5	 	LDA	SAVEXT
2198: EC53 		 GETBLK2:
2199: EC53 	0D	 	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2200: EC54 	CA5CEC	 	JZ	GETBLK3
2201: EC57 	B7	 	ORA	A
2202: EC58 	17	 	RAL
2203: EC59 	C353EC	 	JMP	GETBLK2
2204: EC5C 		 GETBLK3:
2205: EC5C 	80	 	ADD	B
2206: EC5D 	C9	 	RET
2207: EC5E 		 ;
2208: EC5E 		 ;   Routine to extract the (BC) block byte from the fcb pointed
2209: EC5E 		 ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2210: EC5E 		 ; block numbers, else they are 8 bit numbers.
2211: EC5E 		 ; Number is returned in (HL).
2212: EC5E 		 ;
2213: EC5E 		 EXTBLK:
2214: EC5E 	2A43EB	 	LHLD	ParamsDE	;get fcb address.
2215: EC61 	111000	 	LXI	D,16	;block numbers start 16 bytes into fcb.
2216: EC64 	19	 	DAD	D
2217: EC65 	09	 	DAD	B
2218: EC66 	3ADDF5	 	LDA	BIGDISK	;are we using a big-disk?
2219: EC69 	B7	 	ORA	A
2220: EC6A 	CA71EC	 	JZ	EXTBLK1
2221: EC6D 	6E	 	MOV	L,M	;no, extract an 8 bit number from the fcb.
2222: EC6E 	2600	 	MVI	H,0
2223: EC70 	C9	 	RET
2224: EC71 		 EXTBLK1:
2225: EC71 	09	 	DAD	B	;yes, extract a 16 bit number.
2226: EC72 	5E	 	MOV	E,M
2227: EC73 	23	 	INX	H
2228: EC74 	56	 	MOV	D,M
2229: EC75 	EB	 	XCHG		;return in (HL).
2230: EC76 	C9	 	RET
2231: EC77 		 ;
2232: EC77 		 ;   Compute block number.
2233: EC77 		 ;
2234: EC77 		 COMBLK:
2235: EC77 	CD3EEC	 	CALL	GETBLOCK
2236: EC7A 	4F	 	MOV	C,A
2237: EC7B 	0600	 	MVI	B,0
2238: EC7D 	CD5EEC	 	CALL	EXTBLK
2239: EC80 	22E5F5	 	SHLD	BLKNMBR
2240: EC83 	C9	 	RET
2241: EC84 		 ;
2242: EC84 		 ;   Check for a zero block number (unused).
2243: EC84 		 ;
2244: EC84 		 CHKBLK:
2245: EC84 	2AE5F5	 	LHLD	BLKNMBR
2246: EC87 	7D	 	MOV	A,L	;is it zero?
2247: EC88 	B4	 	ORA	H
2248: EC89 	C9	 	RET
2249: EC8A 		 ;
2250: EC8A 		 ;   Adjust physical block (BLKNMBR) and convert to logical
2251: EC8A 		 ; sector (LOGSECT). This is the starting sector of this block.
2252: EC8A 		 ; The actual sector of interest is then added to this and the
2253: EC8A 		 ; resulting sector number is stored back in (BLKNMBR). This
2254: EC8A 		 ; will still have to be adjusted for the track number.
2255: EC8A 		 ;
2256: EC8A 		 LOGICAL:
2257: EC8A 	3AC3F5	 	LDA	BLKSHFT	;get log2(physical/logical sectors).
2258: EC8D 	2AE5F5	 	LHLD	BLKNMBR	;get physical sector desired.
2259: EC90 		 LOGICL1:
2260: EC90 	29	 	DAD	H	;compute logical sector number.
2261: EC91 	3D	 	DCR	A	;note logical sectors are 128 bytes long.
2262: EC92 	C290EC	 	JNZ	LOGICL1
2263: EC95 	22E7F5	 	SHLD	LOGSECT	;save logical sector.
2264: EC98 	3AC4F5	 	LDA	BLKMASK	;get block mask.
2265: EC9B 	4F	 	MOV	C,A
2266: EC9C 	3AE3F5	 	LDA	SAVNREC	;get next sector to access.
2267: EC9F 	A1	 	ANA	C	;extract the relative position within physical block.
2268: ECA0 	B5	 	ORA	L	;and add it too logical sector.
2269: ECA1 	6F	 	MOV	L,A
2270: ECA2 	22E5F5	 	SHLD	BLKNMBR	;and store.
2271: ECA5 	C9	 	RET
2272: ECA6 		 ;
2273: ECA6 		 ;   Set (HL) to point to extent byte in fcb.
2274: ECA6 		 ;
2275: ECA6 		 SETEXT:
2276: ECA6 	2A43EB	 	LHLD	ParamsDE
2277: ECA9 	110C00	 	LXI	D,12	;it is the twelth byte.
2278: ECAC 	19	 	DAD	D
2279: ECAD 	C9	 	RET
2280: ECAE 		 ;
2281: ECAE 		 ;   Set (HL) to point to record count byte in fcb and (DE) to
2282: ECAE 		 ; next record number byte.
2283: ECAE 		 ;
2284: ECAE 		 SETHLDE:
2285: ECAE 	2A43EB	 	LHLD	ParamsDE
2286: ECB1 	110F00	 	LXI	D,15	;record count byte (#15).
2287: ECB4 	19	 	DAD	D
2288: ECB5 	EB	 	XCHG
2289: ECB6 	211100	 	LXI	H,17	;next record number (#32).
2290: ECB9 	19	 	DAD	D
2291: ECBA 	C9	 	RET
2292: ECBB 		 ;
2293: ECBB 		 ;   Save current file data from fcb.
2294: ECBB 		 ;
2295: ECBB 		 STRDATA:
2296: ECBB 	CDAEEC	 	CALL	SETHLDE
2297: ECBE 	7E	 	MOV	A,M	;get and store record count byte.
2298: ECBF 	32E3F5	 	STA	SAVNREC
2299: ECC2 	EB	 	XCHG
2300: ECC3 	7E	 	MOV	A,M	;get and store next record number byte.
2301: ECC4 	32E1F5	 	STA	SAVNXT
2302: ECC7 	CDA6EC	 	CALL	SETEXT	;point to extent byte.
2303: ECCA 	3AC5F5	 	LDA	EXTMASK	;get extent mask.
2304: ECCD 	A6	 	ANA	M
2305: ECCE 	32E2F5	 	STA	SAVEXT	;and save extent here.
2306: ECD1 	C9	 	RET
2307: ECD2 		 ;
2308: ECD2 		 ;   Set the next record to access. If (MODE) is set to 2, then
2309: ECD2 		 ; the last record byte (SAVNREC) has the correct number to access.
2310: ECD2 		 ; For sequential access, (MODE) will be equal to 1.
2311: ECD2 		 ;
2312: ECD2 		 SETNREC:
2313: ECD2 	CDAEEC	 	CALL	SETHLDE
2314: ECD5 	3AD5F5	 	LDA	MODE	;get sequential flag (=1).
2315: ECD8 	FE02	 	CPI	2	;a 2 indicates that no adder is needed.
2316: ECDA 	C2DEEC	 	JNZ	STNREC1
2317: ECDD 	AF	 	XRA	A	;clear adder (random access?).
2318: ECDE 		 STNREC1:
2319: ECDE 	4F	 	MOV	C,A
2320: ECDF 	3AE3F5	 	LDA	SAVNREC	;get last record number.
2321: ECE2 	81	 	ADD	C	;increment record count.
2322: ECE3 	77	 	MOV	M,A	;and set fcb's next record byte.
2323: ECE4 	EB	 	XCHG
2324: ECE5 	3AE1F5	 	LDA	SAVNXT	;get next record byte from storage.
2325: ECE8 	77	 	MOV	M,A	;and put this into fcb as number of records used.
2326: ECE9 	C9	 	RET
2327: ECEA 		 ;
2328: ECEA 		 ;   Shift (HL) right (C) bits.
2329: ECEA 		 ;
2330: ECEA 		 SHIFTR:
2331: ECEA 	0C	 	INR	C
2332: ECEB 		 SHIFTR1:
2333: ECEB 	0D	 	DCR	C
2334: ECEC 	C8	 	RZ
2335: ECED 	7C	 	MOV	A,H
2336: ECEE 	B7	 	ORA	A
2337: ECEF 	1F	 	RAR
2338: ECF0 	67	 	MOV	H,A
2339: ECF1 	7D	 	MOV	A,L
2340: ECF2 	1F	 	RAR
2341: ECF3 	6F	 	MOV	L,A
2342: ECF4 	C3EBEC	 	JMP	SHIFTR1
2343: ECF7 		 ;
2344: ECF7 		 ;   Compute the check-sum for the directory buffer. Return
2345: ECF7 		 ; integer sum in (A).
2346: ECF7 		 ;
2347: ECF7 		 CHECKSUM:
2348: ECF7 	0E80	 	MVI	C,128	;length of buffer.
2349: ECF9 	2AB9F5	 	LHLD	DIRBUF	;get its location.
2350: ECFC 	AF	 	XRA	A	;clear summation byte.
2351: ECFD 		 CHKSUM1:
2352: ECFD 	86	 	ADD	M	;and compute sum ignoring carries.
2353: ECFE 	23	 	INX	H
2354: ECFF 	0D	 	DCR	C
2355: ED00 	C2FDEC	 	JNZ	CHKSUM1
2356: ED03 	C9	 	RET
2357: ED04 		 ;
2358: ED04 		 ;   Shift (HL) left (C) bits.
2359: ED04 		 ;
2360: ED04 		 SHIFTL:
2361: ED04 	0C	 	INR	C
2362: ED05 		 SHIFTL1:
2363: ED05 	0D	 	DCR	C
2364: ED06 	C8	 	RZ
2365: ED07 	29	 	DAD	H	;shift left 1 bit.
2366: ED08 	C305ED	 	JMP	SHIFTL1
2367: ED0B 		 ;
2368: ED0B 		 ;   Routine to set a bit in a 16 bit value contained in (BC).
2369: ED0B 		 ; The bit set depends on the current drive selection.
2370: ED0B 		 ;
2371: ED0B 		 SETBIT:
2372: ED0B 	C5	 	PUSH	B	;save 16 bit word.
2373: ED0C 	3A42EB	 	LDA	ACTIVE	;get active drive.
2374: ED0F 	4F	 	MOV	C,A
2375: ED10 	210100	 	LXI	H,1
2376: ED13 	CD04ED	 	CALL	SHIFTL	;shift bit 0 into place.
2377: ED16 	C1	 	POP	B	;now 'or' this with the original word.
2378: ED17 	79	 	MOV	A,C
2379: ED18 	B5	 	ORA	L
2380: ED19 	6F	 	MOV	L,A	;low byte done, do high byte.
2381: ED1A 	78	 	MOV	A,B
2382: ED1B 	B4	 	ORA	H
2383: ED1C 	67	 	MOV	H,A
2384: ED1D 	C9	 	RET
2385: ED1E 		 ;
2386: ED1E 		 ;   Extract the write protect status bit for the current drive.
2387: ED1E 		 ; The result is returned in (A), bit 0.
2388: ED1E 		 ;
2389: ED1E 		 GETWPRT:
2390: ED1E 	2AADF5	 	LHLD	WRTPRT	;get status bytes.
2391: ED21 	3A42EB	 	LDA	ACTIVE	;which drive is current?
2392: ED24 	4F	 	MOV	C,A
2393: ED25 	CDEAEC	 	CALL	SHIFTR	;shift status such that bit 0 is the
2394: ED28 	7D	 	MOV	A,L	;one of interest for this drive.
2395: ED29 	E601	 	ANI	01H	;and isolate it.
2396: ED2B 	C9	 	RET
2397: ED2C 		 ;
2398: ED2C 		 ;   Function to write protect the current disk.
2399: ED2C 		 ;
2400: ED2C 		 WRTPRTD:
2401: ED2C 	21ADF5	 	LXI	H,WRTPRT;point to status word.
2402: ED2F 	4E	 	MOV	C,M	;set (BC) equal to the status.
2403: ED30 	23	 	INX	H
2404: ED31 	46	 	MOV	B,M
2405: ED32 	CD0BED	 	CALL	SETBIT	;and set this bit according to current drive.
2406: ED35 	22ADF5	 	SHLD	WRTPRT	;then save.
2407: ED38 	2AC8F5	 	LHLD	DIRSIZE	;now save directory size limit.
2408: ED3B 	23	 	INX	H	;remember the last one.
2409: ED3C 	EB	 	XCHG
2410: ED3D 	2AB3F5	 	LHLD	SCRATCH1;and store it here.
2411: ED40 	73	 	MOV	M,E	;put low byte.
2412: ED41 	23	 	INX	H
2413: ED42 	72	 	MOV	M,D	;then high byte.
2414: ED43 	C9	 	RET
2415: ED44 		 ;
2416: ED44 		 ;   Check for a read only file.
2417: ED44 		 ;
2418: ED44 		 CHKROFL:
2419: ED44 	CD5EED	 	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2420: ED47 		 CKROF1:
2421: ED47 	110900	 	LXI	D,9	;look at bit 7 of the ninth byte.
2422: ED4A 	19	 	DAD	D
2423: ED4B 	7E	 	MOV	A,M
2424: ED4C 	17	 	RAL
2425: ED4D 	D0	 	RNC		;return if ok.
2426: ED4E 	210FE8	 	LXI	H,ROFILE;else, print error message and terminate.
2427: ED51 	C34AEB	 	JMP	JUMPHL
2428: ED54 		 ;
2429: ED54 		 ;   Check the write protect status of the active disk.
2430: ED54 		 ;
2431: ED54 		 CHKWPRT:
2432: ED54 	CD1EED	 	CALL	GETWPRT
2433: ED57 	C8	 	RZ		;return if ok.
2434: ED58 	210DE8	 	LXI	H,RODISK;else print message and terminate.
2435: ED5B 	C34AEB	 	JMP	JUMPHL
2436: ED5E 		 ;
2437: ED5E 		 ;   Routine to set (HL) pointing to the proper entry in the
2438: ED5E 		 ; directory buffer.
2439: ED5E 		 ;
2440: ED5E 		 FCB2HL:
2441: ED5E 	2AB9F5	 	LHLD	DIRBUF	;get address of buffer.
2442: ED61 	3AE9F5	 	LDA	FCBPOS	;relative position of file.
2443: ED64 		 ;
2444: ED64 		 ;   Routine to add (A) to (HL).
2445: ED64 		 ;
2446: ED64 		 ADDA2HL:
2447: ED64 	85	 	ADD	L
2448: ED65 	6F	 	MOV	L,A
2449: ED66 	D0	 	RNC
2450: ED67 	24	 	INR	H	;take care of any carry.
2451: ED68 	C9	 	RET
2452: ED69 		 ;
2453: ED69 		 ;   Routine to get the 's2' byte from the fcb supplied in
2454: ED69 		 ; the initial parameter specification.
2455: ED69 		 ;
2456: ED69 		 GETS2:
2457: ED69 	2A43EB	 	LHLD	ParamsDE	;get address of fcb.
2458: ED6C 	110E00	 	LXI	D,14	;relative position of 's2'.
2459: ED6F 	19	 	DAD	D
2460: ED70 	7E	 	MOV	A,M	;extract this byte.
2461: ED71 	C9	 	RET
2462: ED72 		 ;
2463: ED72 		 ;   Clear the 's2' byte in the fcb.
2464: ED72 		 ;
2465: ED72 		 CLEARS2:
2466: ED72 	CD69ED	 	CALL	GETS2	;this sets (HL) pointing to it.
2467: ED75 	3600	 	MVI	M,0	;now clear it.
2468: ED77 	C9	 	RET
2469: ED78 		 ;
2470: ED78 		 ;   Set bit 7 in the 's2' byte of the fcb.
2471: ED78 		 ;
2472: ED78 		 SETS2B7:
2473: ED78 	CD69ED	 	CALL	GETS2	;get the byte.
2474: ED7B 	F680	 	ORI	80H	;and set bit 7.
2475: ED7D 	77	 	MOV	M,A	;then store.
2476: ED7E 	C9	 	RET
2477: ED7F 		 ;
2478: ED7F 		 ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2479: ED7F 		 ; the difference. This checks to see if there are more file
2480: ED7F 		 ; names in the directory. We are at (FILEPOS) and there are
2481: ED7F 		 ; (SCRATCH1) of them to check.
2482: ED7F 		 ;
2483: ED7F 		 MOREFLS:
2484: ED7F 	2AEAF5	 	LHLD	FILEPOS	;we are here.
2485: ED82 	EB	 	XCHG
2486: ED83 	2AB3F5	 	LHLD	SCRATCH1;and don't go past here.
2487: ED86 	7B	 	MOV	A,E	;compute difference but don't keep.
2488: ED87 	96	 	SUB	M
2489: ED88 	23	 	INX	H
2490: ED89 	7A	 	MOV	A,D
2491: ED8A 	9E	 	SBB	M	;set carry if no more names.
2492: ED8B 	C9	 	RET
2493: ED8C 		 ;
2494: ED8C 		 ;   Call this routine to prevent (SCRATCH1) from being greater
2495: ED8C 		 ; than (FILEPOS).
2496: ED8C 		 ;
2497: ED8C 		 CHKNMBR:
2498: ED8C 	CD7FED	 	CALL	MOREFLS	;SCRATCH1 too big?
2499: ED8F 	D8	 	RC
2500: ED90 	13	 	INX	D	;yes, reset it to (FILEPOS).
2501: ED91 	72	 	MOV	M,D
2502: ED92 	2B	 	DCX	H
2503: ED93 	73	 	MOV	M,E
2504: ED94 	C9	 	RET
2505: ED95 		 ;
2506: ED95 		 ;   Compute (HL)=(DE)-(HL)
2507: ED95 		 ;
2508: ED95 		 SUBHL:
2509: ED95 	7B	 	MOV	A,E	;compute difference.
2510: ED96 	95	 	SUB	L
2511: ED97 	6F	 	MOV	L,A	;store low byte.
2512: ED98 	7A	 	MOV	A,D
2513: ED99 	9C	 	SBB	H
2514: ED9A 	67	 	MOV	H,A	;and then high byte.
2515: ED9B 	C9	 	RET
2516: ED9C 		 ;
2517: ED9C 		 ;   Set the directory checksum byte.
2518: ED9C 		 ;
2519: ED9C 		 SETDIR:
2520: ED9C 	0EFF	 	MVI	C,0FFH
2521: ED9E 		 ;
2522: ED9E 		 ;   Routine to set or compare the directory checksum byte. If
2523: ED9E 		 ; (C)=0ffh, then this will set the checksum byte. Else the byte
2524: ED9E 		 ; will be checked. If the check fails (the disk has been changed),
2525: ED9E 		 ; then this disk will be write protected.
2526: ED9E 		 ;
2527: ED9E 		 CHECKDIR:
2528: ED9E 	2AECF5	 	LHLD	CKSUMTBL
2529: EDA1 	EB	 	XCHG
2530: EDA2 	2ACCF5	 	LHLD	ALLOC1
2531: EDA5 	CD95ED	 	CALL	SUBHL
2532: EDA8 	D0	 	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2533: EDA9 	C5	 	PUSH	B
2534: EDAA 	CDF7EC	 	CALL	CHECKSUM;else compute checksum.
2535: EDAD 	2ABDF5	 	LHLD	CHKVECT	;get address of checksum table.
2536: EDB0 	EB	 	XCHG
2537: EDB1 	2AECF5	 	LHLD	CKSUMTBL
2538: EDB4 	19	 	DAD	D	;set (HL) to point to byte for this drive.
2539: EDB5 	C1	 	POP	B
2540: EDB6 	0C	 	INR	C	;set or check ?
2541: EDB7 	CAC4ED	 	JZ	CHKDIR1
2542: EDBA 	BE	 	CMP	M	;check them.
2543: EDBB 	C8	 	RZ		;return if they are the same.
2544: EDBC 	CD7FED	 	CALL	MOREFLS	;not the same, do we care?
2545: EDBF 	D0	 	RNC
2546: EDC0 	CD2CED	 	CALL	WRTPRTD	;yes, mark this as write protected.
2547: EDC3 	C9	 	RET
2548: EDC4 		 CHKDIR1:
2549: EDC4 	77	 	MOV	M,A	;just set the byte.
2550: EDC5 	C9	 	RET
2551: EDC6 		 ;
2552: EDC6 		 ;   Do a write to the directory of the current disk.
2553: EDC6 		 ;
2554: EDC6 		 DIRWRITE:
2555: EDC6 	CD9CED	 	CALL	SETDIR	;set checksum byte.
2556: EDC9 	CDE0ED	 	CALL	DIRDMA	;set directory dma address.
2557: EDCC 	0E01	 	MVI	C,1	;tell the bios to actually write.
2558: EDCE 	CDB8EB	 	CALL	DOWRITE	;then do the write.
2559: EDD1 	C3DAED	 	JMP	DEFDMA
2560: EDD4 		 ;
2561: EDD4 		 ;   Read from the directory.
2562: EDD4 		 ;
2563: EDD4 		 DIRREAD:
2564: EDD4 	CDE0ED	 	CALL	DIRDMA	;set the directory dma address.
2565: EDD7 	CDB2EB	 	CALL	DOREAD	;and read it.
2566: EDDA 		 ;
2567: EDDA 		 ;   Routine to set the dma address to the users choice.
2568: EDDA 		 ;
2569: EDDA 		 DEFDMA:
2570: EDDA 	21B1F5	 	LXI	H,USERDMA;reset the default dma address and return.
2571: EDDD 	C3E3ED	 	JMP	DIRDMA1
2572: EDE0 		 ;
2573: EDE0 		 ;   Routine to set the dma address for directory work.
2574: EDE0 		 ;
2575: EDE0 		 DIRDMA:
2576: EDE0 	21B9F5	 	LXI	H,DIRBUF
2577: EDE3 		 ;
2578: EDE3 		 ;   Set the dma address. On entry, (HL) points to
2579: EDE3 		 ; word containing the desired dma address.
2580: EDE3 		 ;
2581: EDE3 		 DIRDMA1:
2582: EDE3 	4E	 	MOV	C,M
2583: EDE4 	23	 	INX	H
2584: EDE5 	46	 	MOV	B,M	;setup (BC) and go to the bios to set it.
2585: EDE6 	C324F6	 	JMP	SETDMA
2586: EDE9 		 ;
2587: EDE9 		 ;   Move the directory buffer into user's dma space.
2588: EDE9 		 ;
2589: EDE9 		 MOVEDIR:
2590: EDE9 	2AB9F5	 	LHLD	DIRBUF	;buffer is located here, and
2591: EDEC 	EB	 	XCHG
2592: EDED 	2AB1F5	 	LHLD	USERDMA; put it here.
2593: EDF0 	0E80	 	MVI	C,128	;this is its length.
2594: EDF2 	C34FEB	 	JMP	DE2HL	;move it now and return.
2595: EDF5 		 ;
2596: EDF5 		 ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2597: EDF5 		 ;
2598: EDF5 		 CKFILPOS:
2599: EDF5 	21EAF5	 	LXI	H,FILEPOS
2600: EDF8 	7E	 	MOV	A,M
2601: EDF9 	23	 	INX	H
2602: EDFA 	BE	 	CMP	M	;are both bytes the same?
2603: EDFB 	C0	 	RNZ
2604: EDFC 	3C	 	INR	A	;yes, but are they each 0ffh?
2605: EDFD 	C9	 	RET
2606: EDFE 		 ;
2607: EDFE 		 ;   Set location (FILEPOS) to 0ffffh.
2608: EDFE 		 ;
2609: EDFE 		 STFILPOS:
2610: EDFE 	210000	 	LXI	H,0FFFFH
2611: EE01 	22EAF5	 	SHLD	FILEPOS
2612: EE04 	C9	 	RET
2613: EE05 		 ;
2614: EE05 		 ;   Move on to the next file position within the current
2615: EE05 		 ; directory buffer. If no more exist, set pointer to 0ffffh
2616: EE05 		 ; and the calling routine will check for this. Enter with (C)
2617: EE05 		 ; equal to 0ffh to cause the checksum byte to be set, else we
2618: EE05 		 ; will check this disk and set write protect if checksums are
2619: EE05 		 ; not the same (applies only if another directory sector must
2620: EE05 		 ; be read).
2621: EE05 		 ;
2622: EE05 		 NXENTRY:
2623: EE05 	2AC8F5	 	LHLD	DIRSIZE	;get directory entry size limit.
2624: EE08 	EB	 	XCHG
2625: EE09 	2AEAF5	 	LHLD	FILEPOS	;get current count.
2626: EE0C 	23	 	INX	H	;go on to the next one.
2627: EE0D 	22EAF5	 	SHLD	FILEPOS
2628: EE10 	CD95ED	 	CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
2629: EE13 	D219EE	 	JNC	NXENT1	;is there more room left?
2630: EE16 	C3FEED	 	JMP	STFILPOS;no. Set this flag and return.
2631: EE19 		 NXENT1:
2632: EE19 	3AEAF5	 	LDA	FILEPOS	;get file position within directory.
2633: EE1C 	E603	 	ANI	03H	;only look within this sector (only 4 entries fit).
2634: EE1E 	0605	 	MVI	B,5	;convert to relative position (32 bytes each).
2635: EE20 		 NXENT2:
2636: EE20 	87	 	ADD	A	;note that this is not efficient code.
2637: EE21 	05	 	DCR	B	;5 'ADD A's would be better.
2638: EE22 	C220EE	 	JNZ	NXENT2
2639: EE25 	32E9F5	 	STA	FCBPOS	;save it as position of fcb.
2640: EE28 	B7	 	ORA	A
2641: EE29 	C0	 	RNZ		;return if we are within buffer.
2642: EE2A 	C5	 	PUSH	B
2643: EE2B 	CDC3EB	 	CALL	TRKSEC	;we need the next directory sector.
2644: EE2E 	CDD4ED	 	CALL	DIRREAD
2645: EE31 	C1	 	POP	B
2646: EE32 	C39EED	 	JMP	CHECKDIR
2647: EE35 		 ;
2648: EE35 		 ;   Routine to to get a bit from the disk space allocation
2649: EE35 		 ; map. It is returned in (A), bit position 0. On entry to here,
2650: EE35 		 ; set (BC) to the block number on the disk to check.
2651: EE35 		 ; On return, (D) will contain the original bit position for
2652: EE35 		 ; this block number and (HL) will point to the address for it.
2653: EE35 		 ;
2654: EE35 		 CKBITMAP:
2655: EE35 	79	 	MOV	A,C	;determine bit number of interest.
2656: EE36 	E607	 	ANI	07H	;compute (D)=(E)=(C and 7)+1.
2657: EE38 	3C	 	INR	A
2658: EE39 	5F	 	MOV	E,A	;save particular bit number.
2659: EE3A 	57	 	MOV	D,A
2660: EE3B 		 ;
2661: EE3B 		 ;   compute (BC)=(BC)/8.
2662: EE3B 		 ;
2663: EE3B 	79	 	MOV	A,C
2664: EE3C 	0F	 	RRC		;now shift right 3 bits.
2665: EE3D 	0F	 	RRC
2666: EE3E 	0F	 	RRC
2667: EE3F 	E61F	 	ANI	1FH	;and clear bits 7,6,5.
2668: EE41 	4F	 	MOV	C,A
2669: EE42 	78	 	MOV	A,B
2670: EE43 	87	 	ADD	A	;now shift (B) into bits 7,6,5.
2671: EE44 	87	 	ADD	A
2672: EE45 	87	 	ADD	A
2673: EE46 	87	 	ADD	A
2674: EE47 	87	 	ADD	A
2675: EE48 	B1	 	ORA	C	;and add in (C).
2676: EE49 	4F	 	MOV	C,A	;ok, (C) ha been completed.
2677: EE4A 	78	 	MOV	A,B	;is there a better way of doing this?
2678: EE4B 	0F	 	RRC
2679: EE4C 	0F	 	RRC
2680: EE4D 	0F	 	RRC
2681: EE4E 	E61F	 	ANI	1FH
2682: EE50 	47	 	MOV	B,A	;and now (B) is completed.
2683: EE51 		 ;
2684: EE51 		 ;   use this as an offset into the disk space allocation
2685: EE51 		 ; table.
2686: EE51 		 ;
2687: EE51 	2ABFF5	 	LHLD	ALOCVECT
2688: EE54 	09	 	DAD	B
2689: EE55 	7E	 	MOV	A,M	;now get correct byte.
2690: EE56 		 CKBMAP1:
2691: EE56 	07	 	RLC		;get correct bit into position 0.
2692: EE57 	1D	 	DCR	E
2693: EE58 	C256EE	 	JNZ	CKBMAP1
2694: EE5B 	C9	 	RET
2695: EE5C 		 ;
2696: EE5C 		 ;   Set or clear the bit map such that block number (BC) will be marked
2697: EE5C 		 ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2698: EE5C 		 ; 1 then it will be set (don't use anyother values).
2699: EE5C 		 ;
2700: EE5C 		 STBITMAP:
2701: EE5C 	D5	 	PUSH	D
2702: EE5D 	CD35EE	 	CALL	CKBITMAP;get the byte of interest.
2703: EE60 	E6FE	 	ANI	0FEH	;clear the affected bit.
2704: EE62 	C1	 	POP	B
2705: EE63 	B1	 	ORA	C	;and now set it acording to (C).
2706: EE64 		 ;
2707: EE64 		 ;  entry to restore the original bit position and then store
2708: EE64 		 ; in table. (A) contains the value, (D) contains the bit
2709: EE64 		 ; position (1-8), and (HL) points to the address within the
2710: EE64 		 ; space allocation table for this byte.
2711: EE64 		 ;
2712: EE64 		 STBMAP1:
2713: EE64 	0F	 	RRC		;restore original bit position.
2714: EE65 	15	 	DCR	D
2715: EE66 	C264EE	 	JNZ	STBMAP1
2716: EE69 	77	 	MOV	M,A	;and stor byte in table.
2717: EE6A 	C9	 	RET
2718: EE6B 		 ;
2719: EE6B 		 ;   Set/clear space used bits in allocation map for this file.
2720: EE6B 		 ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2721: EE6B 		 ;
2722: EE6B 		 SETFILE:
2723: EE6B 	CD5EED	 	CALL	FCB2HL	;get address of fcb
2724: EE6E 	111000	 	LXI	D,16
2725: EE71 	19	 	DAD	D	;get to block number bytes.
2726: EE72 	C5	 	PUSH	B
2727: EE73 	0E11	 	MVI	C,17	;check all 17 bytes (max) of table.
2728: EE75 		 SETFL1:
2729: EE75 	D1	 	POP	D
2730: EE76 	0D	 	DCR	C	;done all bytes yet?
2731: EE77 	C8	 	RZ
2732: EE78 	D5	 	PUSH	D
2733: EE79 	3ADDF5	 	LDA	BIGDISK	;check disk size for 16 bit block numbers.
2734: EE7C 	B7	 	ORA	A
2735: EE7D 	CA88EE	 	JZ	SETFL2
2736: EE80 	C5	 	PUSH	B	;only 8 bit numbers. set (BC) to this one.
2737: EE81 	E5	 	PUSH	H
2738: EE82 	4E	 	MOV	C,M	;get low byte from table, always
2739: EE83 	0600	 	MVI	B,0	;set high byte to zero.
2740: EE85 	C38EEE	 	JMP	SETFL3
2741: EE88 		 SETFL2:
2742: EE88 	0D	 	DCR	C	;for 16 bit block numbers, adjust counter.
2743: EE89 	C5	 	PUSH	B
2744: EE8A 	4E	 	MOV	C,M	;now get both the low and high bytes.
2745: EE8B 	23	 	INX	H
2746: EE8C 	46	 	MOV	B,M
2747: EE8D 	E5	 	PUSH	H
2748: EE8E 		 SETFL3:
2749: EE8E 	79	 	MOV	A,C	;block used?
2750: EE8F 	B0	 	ORA	B
2751: EE90 	CA9DEE	 	JZ	SETFL4
2752: EE93 	2AC6F5	 	LHLD	DSKSIZE	;is this block number within the
2753: EE96 	7D	 	MOV	A,L	;space on the disk?
2754: EE97 	91	 	SUB	C
2755: EE98 	7C	 	MOV	A,H
2756: EE99 	98	 	SBB	B
2757: EE9A 	D45CEE	 	CNC	STBITMAP;yes, set the proper bit.
2758: EE9D 		 SETFL4:
2759: EE9D 	E1	 	POP	H	;point to next block number in fcb.
2760: EE9E 	23	 	INX	H
2761: EE9F 	C1	 	POP	B
2762: EEA0 	C375EE	 	JMP	SETFL1
2763: EEA3 		 ;
2764: EEA3 		 ;   Construct the space used allocation bit map for the active
2765: EEA3 		 ; drive. If a file name starts with '$' and it is under the
2766: EEA3 		 ; current user number, then (STATUS) is set to minus 1. Otherwise
2767: EEA3 		 ; it is not set at all.
2768: EEA3 		 ;
2769: EEA3 		 BITMAP:
2770: EEA3 	2AC6F5	 	LHLD	DSKSIZE	;compute size of allocation table.
2771: EEA6 	0E03	 	MVI	C,3
2772: EEA8 	CDEAEC	 	CALL	SHIFTR	;(HL)=(HL)/8.
2773: EEAB 	23	 	INX	H	;at lease 1 byte.
2774: EEAC 	44	 	MOV	B,H
2775: EEAD 	4D	 	MOV	C,L	;set (BC) to the allocation table length.
2776: EEAE 		 ;
2777: EEAE 		 ;   Initialize the bitmap for this drive. Right now, the first
2778: EEAE 		 ; two bytes are specified by the disk parameter block. However
2779: EEAE 		 ; a patch could be entered here if it were necessary to setup
2780: EEAE 		 ; this table in a special mannor. For example, the bios could
2781: EEAE 		 ; determine locations of 'bad blocks' and set them as already
2782: EEAE 		 ; 'used' in the map.
2783: EEAE 		 ;
2784: EEAE 	2ABFF5	 	LHLD	ALOCVECT;now zero out the table now.
2785: EEB1 		 BITMAP1:
2786: EEB1 	3600	 	MVI	M,0
2787: EEB3 	23	 	INX	H
2788: EEB4 	0B	 	DCX	B
2789: EEB5 	78	 	MOV	A,B
2790: EEB6 	B1	 	ORA	C
2791: EEB7 	C2B1EE	 	JNZ	BITMAP1
2792: EEBA 	2ACAF5	 	LHLD	ALLOC0	;get initial space used by directory.
2793: EEBD 	EB	 	XCHG
2794: EEBE 	2ABFF5	 	LHLD	ALOCVECT;and put this into map.
2795: EEC1 	73	 	MOV	M,E
2796: EEC2 	23	 	INX	H
2797: EEC3 	72	 	MOV	M,D
2798: EEC4 		 ;
2799: EEC4 		 ;   End of initialization portion.
2800: EEC4 		 ;
2801: EEC4 	CDA1EB	 	CALL	HOMEDRV	;now home the drive.
2802: EEC7 	2AB3F5	 	LHLD	SCRATCH1
2803: EECA 	3603	 	MVI	M,3	;force next directory request to read
2804: EECC 	23	 	INX	H	;in a sector.
2805: EECD 	3600	 	MVI	M,0
2806: EECF 	CDFEED	 	CALL	STFILPOS;clear initial file position also.
2807: EED2 		 BITMAP2:
2808: EED2 	0EFF	 	MVI	C,0FFH	;read next file name in directory
2809: EED4 	CD05EE	 	CALL	NXENTRY	;and set checksum byte.
2810: EED7 	CDF5ED	 	CALL	CKFILPOS;is there another file?
2811: EEDA 	C8	 	RZ
2812: EEDB 	CD5EED	 	CALL	FCB2HL	;yes, get its address.
2813: EEDE 	3EE5	 	MVI	A,0E5H
2814: EEE0 	BE	 	CMP	M	;empty file entry?
2815: EEE1 	CAD2EE	 	JZ	BITMAP2
2816: EEE4 	3A41EB	 	LDA	USERNO	;no, correct user number?
2817: EEE7 	BE	 	CMP	M
2818: EEE8 	C2F6EE	 	JNZ	BITMAP3
2819: EEEB 	23	 	INX	H
2820: EEEC 	7E	 	MOV	A,M	;yes, does name start with a '$'?
2821: EEED 	D624	 	SUI	DOLLAR		; '$'
2822: EEEF 	C2F6EE	 	JNZ	BITMAP3
2823: EEF2 	3D	 	DCR	A	;yes, set atatus to minus one.
2824: EEF3 	3245EB	 	STA	STATUS
2825: EEF6 		 BITMAP3:
2826: EEF6 	0E01	 	MVI	C,1	;now set this file's space as used in bit map.
2827: EEF8 	CD6BEE	 	CALL	SETFILE
2828: EEFB 	CD8CED	 	CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
2829: EEFE 	C3D2EE	 	JMP	BITMAP2
2830: EF01 		 ;
2831: EF01 		 ;   Set the status (STATUS) and return.
2832: EF01 		 ;
2833: EF01 		 STSTATUS:
2834: EF01 	3AD4F5	 	LDA	FNDSTAT
2835: EF04 	C301EB	 	JMP	SETSTAT
2836: EF07 		 ;
2837: EF07 		 ;   Check extents in (A) and (C). Set the zero flag if they
2838: EF07 		 ; are the same. The number of 16k chunks of disk space that
2839: EF07 		 ; the directory extent covers is expressad is (EXTMASK+1).
2840: EF07 		 ; No registers are modified.
2841: EF07 		 ;
2842: EF07 		 SAMEXT:
2843: EF07 	C5	 	PUSH	B
2844: EF08 	F5	 	PUSH	PSW
2845: EF09 	3AC5F5	 	LDA	EXTMASK	;get extent mask and use it to
2846: EF0C 	2F	 	CMA		;to compare both extent numbers.
2847: EF0D 	47	 	MOV	B,A	;save resulting mask here.
2848: EF0E 	79	 	MOV	A,C	;mask first extent and save in (C).
2849: EF0F 	A0	 	ANA	B
2850: EF10 	4F	 	MOV	C,A
2851: EF11 	F1	 	POP	PSW	;now mask second extent and compare
2852: EF12 	A0	 	ANA	B	;with the first one.
2853: EF13 	91	 	SUB	C
2854: EF14 	E61F	 	ANI	1FH	;(* only check buts 0-4 *)
2855: EF16 	C1	 	POP	B	;the zero flag is set if they are the same.
2856: EF17 	C9	 	RET		;restore (BC) and return.
2857: EF18 		 ;
2858: EF18 		 ;   Search for the first occurence of a file name. On entry,
2859: EF18 		 ; register (C) should contain the number of bytes of the fcb
2860: EF18 		 ; that must match.
2861: EF18 		 ;
2862: EF18 		 FINDFST:
2863: EF18 	3EFF	 	MVI	A,0FFH
2864: EF1A 	32D4F5	 	STA	FNDSTAT
2865: EF1D 	21D8F5	 	LXI	H,COUNTER;save character count.
2866: EF20 	71	 	MOV	M,C
2867: EF21 	2A43EB	 	LHLD	ParamsDE	;get filename to match.
2868: EF24 	22D9F5	 	SHLD	SAVEFCB	;and save.
2869: EF27 	CDFEED	 	CALL	STFILPOS;clear initial file position (set to 0ffffh).
2870: EF2A 	CDA1EB	 	CALL	HOMEDRV	;home the drive.
2871: EF2D 		 ;
2872: EF2D 		 ;   Entry to locate the next occurence of a filename within the
2873: EF2D 		 ; directory. The disk is not expected to have been changed. If
2874: EF2D 		 ; it was, then it will be write protected.
2875: EF2D 		 ;
2876: EF2D 		 FINDNXT:
2877: EF2D 	0E00	 	MVI	C,0	;write protect the disk if changed.
2878: EF2F 	CD05EE	 	CALL	NXENTRY	;get next filename entry in directory.
2879: EF32 	CDF5ED	 	CALL	CKFILPOS;is file position = 0ffffh?
2880: EF35 	CA94EF	 	JZ	FNDNXT6	;yes, exit now then.
2881: EF38 	2AD9F5	 	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2882: EF3B 	EB	 	XCHG
2883: EF3C 	1A	 	LDAX	D
2884: EF3D 	FEE5	 	CPI	0E5H	;empty directory entry?
2885: EF3F 	CA4AEF	 	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2886: EF42 	D5	 	PUSH	D
2887: EF43 	CD7FED	 	CALL	MOREFLS	;more files in directory?
2888: EF46 	D1	 	POP	D
2889: EF47 	D294EF	 	JNC	FNDNXT6	;no more. Exit now.
2890: EF4A 		 FNDNXT1:
2891: EF4A 	CD5EED	 	CALL	FCB2HL	;get address of this fcb in directory.
2892: EF4D 	3AD8F5	 	LDA	COUNTER	;get number of bytes (characters) to check.
2893: EF50 	4F	 	MOV	C,A
2894: EF51 	0600	 	MVI	B,0	;initialize byte position counter.
2895: EF53 		 FNDNXT2:
2896: EF53 	79	 	MOV	A,C	;are we done with the compare?
2897: EF54 	B7	 	ORA	A
2898: EF55 	CA83EF	 	JZ	FNDNXT5
2899: EF58 	1A	 	LDAX	D	;no, check next byte.
2900: EF59 	FE3F	 	CPI	QMARK		; '?'	;don't care about this character?
2901: EF5B 	CA7CEF	 	JZ	FNDNXT4
2902: EF5E 	78	 	MOV	A,B	;get bytes position in fcb.
2903: EF5F 	FE0D	 	CPI	13	;don't care about the thirteenth byte either.
2904: EF61 	CA7CEF	 	JZ	FNDNXT4
2905: EF64 	FE0C	 	CPI	12	;extent byte?
2906: EF66 	1A	 	LDAX	D
2907: EF67 	CA73EF	 	JZ	FNDNXT3
2908: EF6A 	96	 	SUB	M	;otherwise compare characters.
2909: EF6B 	E67F	 	ANI	7FH
2910: EF6D 	C22DEF	 	JNZ	FINDNXT	;not the same, check next entry.
2911: EF70 	C37CEF	 	JMP	FNDNXT4	;so far so good, keep checking.
2912: EF73 		 FNDNXT3:
2913: EF73 	C5	 	PUSH	B	;check the extent byte here.
2914: EF74 	4E	 	MOV	C,M
2915: EF75 	CD07EF	 	CALL	SAMEXT
2916: EF78 	C1	 	POP	B
2917: EF79 	C22DEF	 	JNZ	FINDNXT	;not the same, look some more.
2918: EF7C 		 ;
2919: EF7C 		 ;   So far the names compare. Bump pointers to the next byte
2920: EF7C 		 ; and continue until all (C) characters have been checked.
2921: EF7C 		 ;
2922: EF7C 		 FNDNXT4:
2923: EF7C 	13	 	INX	D	;bump pointers.
2924: EF7D 	23	 	INX	H
2925: EF7E 	04	 	INR	B
2926: EF7F 	0D	 	DCR	C	;adjust character counter.
2927: EF80 	C353EF	 	JMP	FNDNXT2
2928: EF83 		 FNDNXT5:
2929: EF83 	3AEAF5	 	LDA	FILEPOS	;return the position of this entry.
2930: EF86 	E603	 	ANI	03H
2931: EF88 	3245EB	 	STA	STATUS
2932: EF8B 	21D4F5	 	LXI	H,FNDSTAT
2933: EF8E 	7E	 	MOV	A,M
2934: EF8F 	17	 	RAL
2935: EF90 	D0	 	RNC
2936: EF91 	AF	 	XRA	A
2937: EF92 	77	 	MOV	M,A
2938: EF93 	C9	 	RET
2939: EF94 		 ;
2940: EF94 		 ;   Filename was not found. Set appropriate status.
2941: EF94 		 ;
2942: EF94 		 FNDNXT6:
2943: EF94 	CDFEED	 	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2944: EF97 	3EFF	 	MVI	A,0FFH	;say not located.
2945: EF99 	C301EB	 	JMP	SETSTAT
2946: EF9C 		 ;
2947: EF9C 		 ;   Erase files from the directory. Only the first byte of the
2948: EF9C 		 ; fcb will be affected. It is set to (E5).
2949: EF9C 		 ;
2950: EF9C 		 ERAFILE:
2951: EF9C 	CD54ED	 	CALL	CHKWPRT	;is disk write protected?
2952: EF9F 	0E0C	 	MVI	C,12	;only compare file names.
2953: EFA1 	CD18EF	 	CALL	FINDFST	;get first file name.
2954: EFA4 		 ERAFIL1:
2955: EFA4 	CDF5ED	 	CALL	CKFILPOS;any found?
2956: EFA7 	C8	 	RZ		;nope, we must be done.
2957: EFA8 	CD44ED	 	CALL	CHKROFL	;is file read only?
2958: EFAB 	CD5EED	 	CALL	FCB2HL	;nope, get address of fcb and
2959: EFAE 	36E5	 	MVI	M,0E5H	;set first byte to 'empty'.
2960: EFB0 	0E00	 	MVI	C,0	;clear the space from the bit map.
2961: EFB2 	CD6BEE	 	CALL	SETFILE
2962: EFB5 	CDC6ED	 	CALL	DIRWRITE;now write the directory sector back out.
2963: EFB8 	CD2DEF	 	CALL	FINDNXT	;find the next file name.
2964: EFBB 	C3A4EF	 	JMP	ERAFIL1	;and repeat process.
2965: EFBE 		 ;
2966: EFBE 		 ;   Look through the space allocation map (bit map) for the
2967: EFBE 		 ; next available block. Start searching at block number (BC-1).
2968: EFBE 		 ; The search procedure is to look for an empty block that is
2969: EFBE 		 ; before the starting block. If not empty, look at a later
2970: EFBE 		 ; block number. In this way, we return the closest empty block
2971: EFBE 		 ; on either side of the 'target' block number. This will speed
2972: EFBE 		 ; access on random devices. For serial devices, this should be
2973: EFBE 		 ; changed to look in the forward direction first and then start
2974: EFBE 		 ; at the front and search some more.
2975: EFBE 		 ;
2976: EFBE 		 ;   On return, (DE)= block number that is empty and (HL) =0
2977: EFBE 		 ; if no empry block was found.
2978: EFBE 		 ;
2979: EFBE 		 FNDSPACE:
2980: EFBE 	50	 	MOV	D,B	;set (DE) as the block that is checked.
2981: EFBF 	59	 	MOV	E,C
2982: EFC0 		 ;
2983: EFC0 		 ;   Look before target block. Registers (BC) are used as the lower
2984: EFC0 		 ; pointer and (DE) as the upper pointer.
2985: EFC0 		 ;
2986: EFC0 		 FNDSPA1:
2987: EFC0 	79	 	MOV	A,C	;is block 0 specified?
2988: EFC1 	B0	 	ORA	B
2989: EFC2 	CAD1EF	 	JZ	FNDSPA2
2990: EFC5 	0B	 	DCX	B	;nope, check previous block.
2991: EFC6 	D5	 	PUSH	D
2992: EFC7 	C5	 	PUSH	B
2993: EFC8 	CD35EE	 	CALL	CKBITMAP
2994: EFCB 	1F	 	RAR		;is this block empty?
2995: EFCC 	D2ECEF	 	JNC	FNDSPA3	;yes. use this.
2996: EFCF 		 ;
2997: EFCF 		 ;   Note that the above logic gets the first block that it finds
2998: EFCF 		 ; that is empty. Thus a file could be written 'backward' making
2999: EFCF 		 ; it very slow to access. This could be changed to look for the
3000: EFCF 		 ; first empty block and then continue until the start of this
3001: EFCF 		 ; empty space is located and then used that starting block.
3002: EFCF 		 ; This should help speed up access to some files especially on
3003: EFCF 		 ; a well used disk with lots of fairly small 'holes'.
3004: EFCF 		 ;
3005: EFCF 	C1	 	POP	B	;nope, check some more.
3006: EFD0 	D1	 	POP	D
3007: EFD1 		 ;
3008: EFD1 		 ;   Now look after target block.
3009: EFD1 		 ;
3010: EFD1 		 FNDSPA2:
3011: EFD1 	2AC6F5	 	LHLD	DSKSIZE	;is block (DE) within disk limits?
3012: EFD4 	7B	 	MOV	A,E
3013: EFD5 	95	 	SUB	L
3014: EFD6 	7A	 	MOV	A,D
3015: EFD7 	9C	 	SBB	H
3016: EFD8 	D2F4EF	 	JNC	FNDSPA4
3017: EFDB 	13	 	INX	D	;yes, move on to next one.
3018: EFDC 	C5	 	PUSH	B
3019: EFDD 	D5	 	PUSH	D
3020: EFDE 	42	 	MOV	B,D
3021: EFDF 	4B	 	MOV	C,E
3022: EFE0 	CD35EE	 	CALL	CKBITMAP;check it.
3023: EFE3 	1F	 	RAR		;empty?
3024: EFE4 	D2ECEF	 	JNC	FNDSPA3
3025: EFE7 	D1	 	POP	D	;nope, continue searching.
3026: EFE8 	C1	 	POP	B
3027: EFE9 	C3C0EF	 	JMP	FNDSPA1
3028: EFEC 		 ;
3029: EFEC 		 ;   Empty block found. Set it as used and return with (HL)
3030: EFEC 		 ; pointing to it (true?).
3031: EFEC 		 ;
3032: EFEC 		 FNDSPA3:
3033: EFEC 	17	 	RAL		;reset byte.
3034: EFED 	3C	 	INR	A	;and set bit 0.
3035: EFEE 	CD64EE	 	CALL	STBMAP1	;update bit map.
3036: EFF1 	E1	 	POP	H	;set return registers.
3037: EFF2 	D1	 	POP	D
3038: EFF3 	C9	 	RET
3039: EFF4 		 ;
3040: EFF4 		 ;   Free block was not found. If (BC) is not zero, then we have
3041: EFF4 		 ; not checked all of the disk space.
3042: EFF4 		 ;
3043: EFF4 		 FNDSPA4:
3044: EFF4 	79	 	MOV	A,C
3045: EFF5 	B0	 	ORA	B
3046: EFF6 	C2C0EF	 	JNZ	FNDSPA1
3047: EFF9 	210000	 	LXI	H,0	;set 'not found' status.
3048: EFFC 	C9	 	RET
3049: EFFD 		 ;
3050: EFFD 		 ;   Move a complete fcb entry into the directory and write it.
3051: EFFD 		 ;
3052: EFFD 		 FCBSET:
3053: EFFD 	0E00	 	MVI	C,0
3054: EFFF 	1E20	 	MVI	E,32	;length of each entry.
3055: F001 		 ;
3056: F001 		 ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3057: F001 		 ; fcb in directory starting at relative byte (C). This updated
3058: F001 		 ; directory buffer is then written to the disk.
3059: F001 		 ;
3060: F001 		 UPDATE:
3061: F001 	D5	 	PUSH	D
3062: F002 	0600	 	MVI	B,0	;set (BC) to relative byte position.
3063: F004 	2A43EB	 	LHLD	ParamsDE	;get address of fcb.
3064: F007 	09	 	DAD	B	;compute starting byte.
3065: F008 	EB	 	XCHG
3066: F009 	CD5EED	 	CALL	FCB2HL	;get address of fcb to update in directory.
3067: F00C 	C1	 	POP	B	;set (C) to number of bytes to change.
3068: F00D 	CD4FEB	 	CALL	DE2HL
3069: F010 		 UPDATE1:
3070: F010 	CDC3EB	 	CALL	TRKSEC	;determine the track and sector affected.
3071: F013 	C3C6ED	 	JMP	DIRWRITE	;then write this sector out.
3072: F016 		 ;
3073: F016 		 ;   Routine to change the name of all files on the disk with a
3074: F016 		 ; specified name. The fcb contains the current name as the
3075: F016 		 ; first 12 characters and the new name 16 bytes into the fcb.
3076: F016 		 ;
3077: F016 		 CHGNAMES:
3078: F016 	CD54ED	 	CALL	CHKWPRT	;check for a write protected disk.
3079: F019 	0E0C	 	MVI	C,12	;match first 12 bytes of fcb only.
3080: F01B 	CD18EF	 	CALL	FINDFST	;get first name.
3081: F01E 	2A43EB	 	LHLD	ParamsDE	;get address of fcb.
3082: F021 	7E	 	MOV	A,M	;get user number.
3083: F022 	111000	 	LXI	D,16	;move over to desired name.
3084: F025 	19	 	DAD	D
3085: F026 	77	 	MOV	M,A	;keep same user number.
3086: F027 		 CHGNAM1:
3087: F027 	CDF5ED	 	CALL	CKFILPOS;any matching file found?
3088: F02A 	C8	 	RZ		;no, we must be done.
3089: F02B 	CD44ED	 	CALL	CHKROFL	;check for read only file.
3090: F02E 	0E10	 	MVI	C,16	;start 16 bytes into fcb.
3091: F030 	1E0C	 	MVI	E,12	;and update the first 12 bytes of directory.
3092: F032 	CD01F0	 	CALL	UPDATE
3093: F035 	CD2DEF	 	CALL	FINDNXT	;get te next file name.
3094: F038 	C327F0	 	JMP	CHGNAM1	;and continue.
3095: F03B 		 ;
3096: F03B 		 ;   Update a files attributes. The procedure is to search for
3097: F03B 		 ; every file with the same name as shown in fcb (ignoring bit 7)
3098: F03B 		 ; and then to update it (which includes bit 7). No other changes
3099: F03B 		 ; are made.
3100: F03B 		 ;
3101: F03B 		 SAVEATTR:
3102: F03B 	0E0C	 	MVI	C,12	;match first 12 bytes.
3103: F03D 	CD18EF	 	CALL	FINDFST	;look for first filename.
3104: F040 		 SAVATR1:
3105: F040 	CDF5ED	 	CALL	CKFILPOS;was one found?
3106: F043 	C8	 	RZ		;nope, we must be done.
3107: F044 	0E00	 	MVI	C,0	;yes, update the first 12 bytes now.
3108: F046 	1E0C	 	MVI	E,12
3109: F048 	CD01F0	 	CALL	UPDATE	;update filename and write directory.
3110: F04B 	CD2DEF	 	CALL	FINDNXT	;and get the next file.
3111: F04E 	C340F0	 	JMP	SAVATR1	;then continue until done.
3112: F051 		 ;
3113: F051 		 ;  Open a file (name specified in fcb).
3114: F051 		 ;
3115: F051 		 OPENIT:
3116: F051 	0E0F	 	MVI	C,15	;compare the first 15 bytes.
3117: F053 	CD18EF	 	CALL	FINDFST	;get the first one in directory.
3118: F056 	CDF5ED	 	CALL	CKFILPOS;any at all?
3119: F059 	C8	 	RZ
3120: F05A 		 OPENIT1:
3121: F05A 	CDA6EC	 	CALL	SETEXT	;point to extent byte within users fcb.
3122: F05D 	7E	 	MOV	A,M	;and get it.
3123: F05E 	F5	 	PUSH	PSW	;save it and address.
3124: F05F 	E5	 	PUSH	H
3125: F060 	CD5EED	 	CALL	FCB2HL	;point to fcb in directory.
3126: F063 	EB	 	XCHG
3127: F064 	2A43EB	 	LHLD	ParamsDE	;this is the users copy.
3128: F067 	0E20	 	MVI	C,32	;move it into users space.
3129: F069 	D5	 	PUSH	D
3130: F06A 	CD4FEB	 	CALL	DE2HL
3131: F06D 	CD78ED	 	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
3132: F070 	D1	 	POP	D	;now get the extent byte from this fcb.
3133: F071 	210C00	 	LXI	H,12
3134: F074 	19	 	DAD	D
3135: F075 	4E	 	MOV	C,M	;into (C).
3136: F076 	210F00	 	LXI	H,15	;now get the record count byte into (B).
3137: F079 	19	 	DAD	D
3138: F07A 	46	 	MOV	B,M
3139: F07B 	E1	 	POP	H	;keep the same extent as the user had originally.
3140: F07C 	F1	 	POP	PSW
3141: F07D 	77	 	MOV	M,A
3142: F07E 	79	 	MOV	A,C	;is it the same as in the directory fcb?
3143: F07F 	BE	 	CMP	M
3144: F080 	78	 	MOV	A,B	;if yes, then use the same record count.
3145: F081 	CA8BF0	 	JZ	OPENIT2
3146: F084 	3E00	 	MVI	A,0	;if the user specified an extent greater than
3147: F086 	DA8BF0	 	JC	OPENIT2	;the one in the directory, then set record count to 0.
3148: F089 	3E80	 	MVI	A,128	;otherwise set to maximum.
3149: F08B 		 OPENIT2:
3150: F08B 	2A43EB	 	LHLD	ParamsDE	;set record count in users fcb to (A).
3151: F08E 	110F00	 	LXI	D,15
3152: F091 	19	 	DAD	D	;compute relative position.
3153: F092 	77	 	MOV	M,A	;and set the record count.
3154: F093 	C9	 	RET
3155: F094 		 ;
3156: F094 		 ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3157: F094 		 ; point to a zero value (16 bit).
3158: F094 		 ;   Return with zero flag set it (DE) was moved. Registers (DE)
3159: F094 		 ; and (HL) are not changed. However (A) is.
3160: F094 		 ;
3161: F094 		 MOVEWORD:
3162: F094 	7E	 	MOV	A,M	;check for a zero word.
3163: F095 	23	 	INX	H
3164: F096 	B6	 	ORA	M	;both bytes zero?
3165: F097 	2B	 	DCX	H
3166: F098 	C0	 	RNZ		;nope, just return.
3167: F099 	1A	 	LDAX	D	;yes, move two bytes from (DE) into
3168: F09A 	77	 	MOV	M,A	;this zero space.
3169: F09B 	13	 	INX	D
3170: F09C 	23	 	INX	H
3171: F09D 	1A	 	LDAX	D
3172: F09E 	77	 	MOV	M,A
3173: F09F 	1B	 	DCX	D	;don't disturb these registers.
3174: F0A0 	2B	 	DCX	H
3175: F0A1 	C9	 	RET
3176: F0A2 		 ;
3177: F0A2 		 ;   Get here to close a file specified by (fcb).
3178: F0A2 		 ;
3179: F0A2 		 CLOSEIT:
3180: F0A2 	AF	 	XRA	A	;clear status and file position bytes.
3181: F0A3 	3245EB	 	STA	STATUS
3182: F0A6 	32EAF5	 	STA	FILEPOS
3183: F0A9 	32EBF5	 	STA	FILEPOS+1
3184: F0AC 	CD1EED	 	CALL	GETWPRT	;get write protect bit for this drive.
3185: F0AF 	C0	 	RNZ		;just return if it is set.
3186: F0B0 	CD69ED	 	CALL	GETS2	;else get the 's2' byte.
3187: F0B3 	E680	 	ANI	80H	;and look at bit 7 (file unmodified?).
3188: F0B5 	C0	 	RNZ		;just return if set.
3189: F0B6 	0E0F	 	MVI	C,15	;else look up this file in directory.
3190: F0B8 	CD18EF	 	CALL	FINDFST
3191: F0BB 	CDF5ED	 	CALL	CKFILPOS;was it found?
3192: F0BE 	C8	 	RZ		;just return if not.
3193: F0BF 	011000	 	LXI	B,16	;set (HL) pointing to records used section.
3194: F0C2 	CD5EED	 	CALL	FCB2HL
3195: F0C5 	09	 	DAD	B
3196: F0C6 	EB	 	XCHG
3197: F0C7 	2A43EB	 	LHLD	ParamsDE	;do the same for users specified fcb.
3198: F0CA 	09	 	DAD	B
3199: F0CB 	0E10	 	MVI	C,16	;this many bytes are present in this extent.
3200: F0CD 		 CLOSEIT1:
3201: F0CD 	3ADDF5	 	LDA	BIGDISK	;8 or 16 bit record numbers?
3202: F0D0 	B7	 	ORA	A
3203: F0D1 	CAE8F0	 	JZ	CLOSEIT4
3204: F0D4 	7E	 	MOV	A,M	;just 8 bit. Get one from users fcb.
3205: F0D5 	B7	 	ORA	A
3206: F0D6 	1A	 	LDAX	D	;now get one from directory fcb.
3207: F0D7 	C2DBF0	 	JNZ	CLOSEIT2
3208: F0DA 	77	 	MOV	M,A	;users byte was zero. Update from directory.
3209: F0DB 		 CLOSEIT2:
3210: F0DB 	B7	 	ORA	A
3211: F0DC 	C2E1F0	 	JNZ	CLOSEIT3
3212: F0DF 	7E	 	MOV	A,M	;directories byte was zero, update from users fcb.
3213: F0E0 	12	 	STAX	D
3214: F0E1 		 CLOSEIT3:
3215: F0E1 	BE	 	CMP	M	;if neither one of these bytes were zero,
3216: F0E2 	C21FF1	 	JNZ	CLOSEIT7	;then close error if they are not the same.
3217: F0E5 	C3FDF0	 	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3218: F0E8 		 CLOSEIT4:
3219: F0E8 	CD94F0	 	CALL	MOVEWORD;update users fcb if it is zero.
3220: F0EB 	EB	 	XCHG
3221: F0EC 	CD94F0	 	CALL	MOVEWORD;update directories fcb if it is zero.
3222: F0EF 	EB	 	XCHG
3223: F0F0 	1A	 	LDAX	D	;if these two values are no different,
3224: F0F1 	BE	 	CMP	M	;then a close error occured.
3225: F0F2 	C21FF1	 	JNZ	CLOSEIT7
3226: F0F5 	13	 	INX	D	;check second byte.
3227: F0F6 	23	 	INX	H
3228: F0F7 	1A	 	LDAX	D
3229: F0F8 	BE	 	CMP	M
3230: F0F9 	C21FF1	 	JNZ	CLOSEIT7
3231: F0FC 	0D	 	DCR	C	;remember 16 bit values.
3232: F0FD 		 CLOSEIT5:
3233: F0FD 	13	 	INX	D	;bump to next item in table.
3234: F0FE 	23	 	INX	H
3235: F0FF 	0D	 	DCR	C	;there are 16 entries only.
3236: F100 	C2CDF0	 	JNZ	CLOSEIT1;continue if more to do.
3237: F103 	01ECFF	 	LXI	B,0FFECH;backup 20 places (extent byte).
3238: F106 	09	 	DAD	B
3239: F107 	EB	 	XCHG
3240: F108 	09	 	DAD	B
3241: F109 	1A	 	LDAX	D
3242: F10A 	BE	 	CMP	M	;directory's extent already greater than the
3243: F10B 	DA17F1	 	JC	CLOSEIT6	;users extent?
3244: F10E 	77	 	MOV	M,A	;no, update directory extent.
3245: F10F 	010300	 	LXI	B,3	;and update the record count byte in
3246: F112 	09	 	DAD	B	;directories fcb.
3247: F113 	EB	 	XCHG
3248: F114 	09	 	DAD	B
3249: F115 	7E	 	MOV	A,M	;get from user.
3250: F116 	12	 	STAX	D	;and put in directory.
3251: F117 		 CLOSEIT6:
3252: F117 	3EFF	 	MVI	A,0FFH	;set 'was open and is now closed' byte.
3253: F119 	32D2F5	 	STA	CLOSEFLG
3254: F11C 	C310F0	 	JMP	UPDATE1	;update the directory now.
3255: F11F 		 CLOSEIT7:
3256: F11F 	2145EB	 	LXI	H,STATUS;set return status and then return.
3257: F122 	35	 	DCR	M
3258: F123 	C9	 	RET
3259: F124 		 ;
3260: F124 		 ;   Routine to get the next empty space in the directory. It
3261: F124 		 ; will then be cleared for use.
3262: F124 		 ;
3263: F124 		 GETEMPTY:
3264: F124 	CD54ED	 	CALL	CHKWPRT	;make sure disk is not write protected.
3265: F127 	2A43EB	 	LHLD	ParamsDE	;save current parameters (fcb).
3266: F12A 	E5	 	PUSH	H
3267: F12B 	21ACF5	 	LXI	H,EMPTYFCB;use special one for empty space.
3268: F12E 	2243EB	 	SHLD	ParamsDE
3269: F131 	0E01	 	MVI	C,1	;search for first empty spot in directory.
3270: F133 	CD18EF	 	CALL	FINDFST	;(* only check first byte *)
3271: F136 	CDF5ED	 	CALL	CKFILPOS;none?
3272: F139 	E1	 	POP	H
3273: F13A 	2243EB	 	SHLD	ParamsDE	;restore original fcb address.
3274: F13D 	C8	 	RZ		;return if no more space.
3275: F13E 	EB	 	XCHG
3276: F13F 	210F00	 	LXI	H,15	;point to number of records for this file.
3277: F142 	19	 	DAD	D
3278: F143 	0E11	 	MVI	C,17	;and clear all of this space.
3279: F145 	AF	 	XRA	A
3280: F146 		 GETMT1:
3281: F146 	77	 	MOV	M,A
3282: F147 	23	 	INX	H
3283: F148 	0D	 	DCR	C
3284: F149 	C246F1	 	JNZ	GETMT1
3285: F14C 	210D00	 	LXI	H,13	;clear the 's1' byte also.
3286: F14F 	19	 	DAD	D
3287: F150 	77	 	MOV	M,A
3288: F151 	CD8CED	 	CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
3289: F154 	CDFDEF	 	CALL	FCBSET	;write out this fcb entry to directory.
3290: F157 	C378ED	 	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
3291: F15A 		 ;
3292: F15A 		 ;   Routine to close the current extent and open the next one
3293: F15A 		 ; for reading.
3294: F15A 		 ;
3295: F15A 		 GETNEXT:
3296: F15A 	AF	 	XRA	A
3297: F15B 	32D2F5	 	STA	CLOSEFLG;clear close flag.
3298: F15E 	CDA2F0	 	CALL	CLOSEIT	;close this extent.
3299: F161 	CDF5ED	 	CALL	CKFILPOS
3300: F164 	C8	 	RZ		;not there???
3301: F165 	2A43EB	 	LHLD	ParamsDE	;get extent byte.
3302: F168 	010C00	 	LXI	B,12
3303: F16B 	09	 	DAD	B
3304: F16C 	7E	 	MOV	A,M	;and increment it.
3305: F16D 	3C	 	INR	A
3306: F16E 	E61F	 	ANI	1FH	;keep within range 0-31.
3307: F170 	77	 	MOV	M,A
3308: F171 	CA83F1	 	JZ	GTNEXT1	;overflow?
3309: F174 	47	 	MOV	B,A	;mask extent byte.
3310: F175 	3AC5F5	 	LDA	EXTMASK
3311: F178 	A0	 	ANA	B
3312: F179 	21D2F5	 	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3313: F17C 	A6	 	ANA	M
3314: F17D 	CA8EF1	 	JZ	GTNEXT2	;if zero, we must read in next extent.
3315: F180 	C3ACF1	 	JMP	GTNEXT3	;else, it is already in memory.
3316: F183 		 GTNEXT1:
3317: F183 	010200	 	LXI	B,2	;Point to the 's2' byte.
3318: F186 	09	 	DAD	B
3319: F187 	34	 	INR	M	;and bump it.
3320: F188 	7E	 	MOV	A,M	;too many extents?
3321: F189 	E60F	 	ANI	0FH
3322: F18B 	CAB6F1	 	JZ	GTNEXT5	;yes, set error code.
3323: F18E 		 ;
3324: F18E 		 ;   Get here to open the next extent.
3325: F18E 		 ;
3326: F18E 		 GTNEXT2:
3327: F18E 	0E0F	 	MVI	C,15	;set to check first 15 bytes of fcb.
3328: F190 	CD18EF	 	CALL	FINDFST	;find the first one.
3329: F193 	CDF5ED	 	CALL	CKFILPOS;none available?
3330: F196 	C2ACF1	 	JNZ	GTNEXT3
3331: F199 	3AD3F5	 	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3332: F19C 	3C	 	INR	A	;0ffh means reading (so not possible).
3333: F19D 	CAB6F1	 	JZ	GTNEXT5	;or an error.
3334: F1A0 	CD24F1	 	CALL	GETEMPTY;we are writing, get an empty entry.
3335: F1A3 	CDF5ED	 	CALL	CKFILPOS;none?
3336: F1A6 	CAB6F1	 	JZ	GTNEXT5	;error if true.
3337: F1A9 	C3AFF1	 	JMP	GTNEXT4	;else we are almost done.
3338: F1AC 		 GTNEXT3:
3339: F1AC 	CD5AF0	 	CALL	OPENIT1	;open this extent.
3340: F1AF 		 GTNEXT4:
3341: F1AF 	CDBBEC	 	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3342: F1B2 	AF	 	XRA	A	;clear status and return.
3343: F1B3 	C301EB	 	JMP	SETSTAT
3344: F1B6 		 ;
3345: F1B6 		 ;   Error in extending the file. Too many extents were needed
3346: F1B6 		 ; or not enough space on the disk.
3347: F1B6 		 ;
3348: F1B6 		 GTNEXT5:
3349: F1B6 	CD05EB	 	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3350: F1B9 	C378ED	 	JMP	SETS2B7	;so this is not written on a close.
3351: F1BC 		 ;
3352: F1BC 		 ;   Read a sequential file.
3353: F1BC 		 ;
3354: F1BC 		 RDSEQ:
3355: F1BC 	3E01	 	MVI	A,1	;set sequential access mode.
3356: F1BE 	32D5F5	 	STA	MODE
3357: F1C1 		 RDSEQ1:
3358: F1C1 	3EFF	 	MVI	A,0FFH	;don't allow reading unwritten space.
3359: F1C3 	32D3F5	 	STA	RDWRTFLG
3360: F1C6 	CDBBEC	 	CALL	STRDATA	;put rec# and ext# into fcb.
3361: F1C9 	3AE3F5	 	LDA	SAVNREC	;get next record to read.
3362: F1CC 	21E1F5	 	LXI	H,SAVNXT;get number of records in extent.
3363: F1CF 	BE	 	CMP	M	;within this extent?
3364: F1D0 	DAE6F1	 	JC	RDSEQ2
3365: F1D3 	FE80	 	CPI	128	;no. Is this extent fully used?
3366: F1D5 	C2FBF1	 	JNZ	RDSEQ3	;no. End-of-file.
3367: F1D8 	CD5AF1	 	CALL	GETNEXT	;yes, open the next one.
3368: F1DB 	AF	 	XRA	A	;reset next record to read.
3369: F1DC 	32E3F5	 	STA	SAVNREC
3370: F1DF 	3A45EB	 	LDA	STATUS	;check on open, successful?
3371: F1E2 	B7	 	ORA	A
3372: F1E3 	C2FBF1	 	JNZ	RDSEQ3	;no, error.
3373: F1E6 		 RDSEQ2:
3374: F1E6 	CD77EC	 	CALL	COMBLK	;ok. compute block number to read.
3375: F1E9 	CD84EC	 	CALL	CHKBLK	;check it. Within bounds?
3376: F1EC 	CAFBF1	 	JZ	RDSEQ3	;no, error.
3377: F1EF 	CD8AEC	 	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
3378: F1F2 	CDD1EB	 	CALL	TRKSEC1	;set the track and sector for this block #.
3379: F1F5 	CDB2EB	 	CALL	DOREAD	;and read it.
3380: F1F8 	C3D2EC	 	JMP	SETNREC	;and set the next record to be accessed.
3381: F1FB 		 ;
3382: F1FB 		 ;   Read error occured. Set status and return.
3383: F1FB 		 ;
3384: F1FB 		 RDSEQ3:
3385: F1FB 	C305EB	 	JMP	IOERR1
3386: F1FE 		 ;
3387: F1FE 		 ;   Write the next sequential record.
3388: F1FE 		 ;
3389: F1FE 		 WTSEQ:
3390: F1FE 	3E01	 	MVI	A,1	;set sequential access mode.
3391: F200 	32D5F5	 	STA	MODE
3392: F203 		 WTSEQ1:
3393: F203 	3E00	 	MVI	A,0	;allow an addition empty extent to be opened.
3394: F205 	32D3F5	 	STA	RDWRTFLG
3395: F208 	CD54ED	 	CALL	CHKWPRT	;check write protect status.
3396: F20B 	2A43EB	 	LHLD	ParamsDE
3397: F20E 	CD47ED	 	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3398: F211 	CDBBEC	 	CALL	STRDATA	;put updated data into fcb.
3399: F214 	3AE3F5	 	LDA	SAVNREC	;get record number to write.
3400: F217 	FE80	 	CPI	128	;within range?
3401: F219 	D205EB	 	JNC	IOERR1	;no, error(?).
3402: F21C 	CD77EC	 	CALL	COMBLK	;compute block number.
3403: F21F 	CD84EC	 	CALL	CHKBLK	;check number.
3404: F222 	0E00	 	MVI	C,0	;is there one to write to?
3405: F224 	C26EF2	 	JNZ	WTSEQ6	;yes, go do it.
3406: F227 	CD3EEC	 	CALL	GETBLOCK;get next block number within fcb to use.
3407: F22A 	32D7F5	 	STA	RELBLOCK;and save.
3408: F22D 	010000	 	LXI	B,0	;start looking for space from the start
3409: F230 	B7	 	ORA	A	;if none allocated as yet.
3410: F231 	CA3BF2	 	JZ	WTSEQ2
3411: F234 	4F	 	MOV	C,A	;extract previous block number from fcb
3412: F235 	0B	 	DCX	B	;so we can be closest to it.
3413: F236 	CD5EEC	 	CALL	EXTBLK
3414: F239 	44	 	MOV	B,H
3415: F23A 	4D	 	MOV	C,L
3416: F23B 		 WTSEQ2:
3417: F23B 	CDBEEF	 	CALL	FNDSPACE;find the next empty block nearest number (BC).
3418: F23E 	7D	 	MOV	A,L	;check for a zero number.
3419: F23F 	B4	 	ORA	H
3420: F240 	C248F2	 	JNZ	WTSEQ3
3421: F243 	3E02	 	MVI	A,2	;no more space?
3422: F245 	C301EB	 	JMP	SETSTAT
3423: F248 		 WTSEQ3:
3424: F248 	22E5F5	 	SHLD	BLKNMBR	;save block number to access.
3425: F24B 	EB	 	XCHG		;put block number into (DE).
3426: F24C 	2A43EB	 	LHLD	ParamsDE	;now we must update the fcb for this
3427: F24F 	011000	 	LXI	B,16	;newly allocated block.
3428: F252 	09	 	DAD	B
3429: F253 	3ADDF5	 	LDA	BIGDISK	;8 or 16 bit block numbers?
3430: F256 	B7	 	ORA	A
3431: F257 	3AD7F5	 	LDA	RELBLOCK	;(* update this entry *)
3432: F25A 	CA64F2	 	JZ	WTSEQ4	;zero means 16 bit ones.
3433: F25D 	CD64ED	 	CALL	ADDA2HL	;(HL)=(HL)+(A)
3434: F260 	73	 	MOV	M,E	;store new block number.
3435: F261 	C36CF2	 	JMP	WTSEQ5
3436: F264 		 WTSEQ4:
3437: F264 	4F	 	MOV	C,A	;compute spot in this 16 bit table.
3438: F265 	0600	 	MVI	B,0
3439: F267 	09	 	DAD	B
3440: F268 	09	 	DAD	B
3441: F269 	73	 	MOV	M,E	;stuff block number (DE) there.
3442: F26A 	23	 	INX	H
3443: F26B 	72	 	MOV	M,D
3444: F26C 		 WTSEQ5:
3445: F26C 	0E02	 	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3446: F26E 		 WTSEQ6:
3447: F26E 	3A45EB	 	LDA	STATUS	;are we ok so far?
3448: F271 	B7	 	ORA	A
3449: F272 	C0	 	RNZ
3450: F273 	C5	 	PUSH	B	;yes, save write flag for bios (register C).
3451: F274 	CD8AEC	 	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3452: F277 	3AD5F5	 	LDA	MODE	;get access mode flag (1=sequential,
3453: F27A 	3D	 	DCR	A	;0=random, 2=special?).
3454: F27B 	3D	 	DCR	A
3455: F27C 	C2BBF2	 	JNZ	WTSEQ9
3456: F27F 		 ;
3457: F27F 		 ;   Special random i/o from function #40. Maybe for M/PM, but the
3458: F27F 		 ; current block, if it has not been written to, will be zeroed
3459: F27F 		 ; out and then written (reason?).
3460: F27F 		 ;
3461: F27F 	C1	 	POP	B
3462: F280 	C5	 	PUSH	B
3463: F281 	79	 	MOV	A,C	;get write status flag (2=writing unused space).
3464: F282 	3D	 	DCR	A
3465: F283 	3D	 	DCR	A
3466: F284 	C2BBF2	 	JNZ	WTSEQ9
3467: F287 	E5	 	PUSH	H
3468: F288 	2AB9F5	 	LHLD	DIRBUF	;zero out the directory buffer.
3469: F28B 	57	 	MOV	D,A	;note that (A) is zero here.
3470: F28C 		 WTSEQ7:
3471: F28C 	77	 	MOV	M,A
3472: F28D 	23	 	INX	H
3473: F28E 	14	 	INR	D	;do 128 bytes.
3474: F28F 	F28CF2	 	JP	WTSEQ7
3475: F292 	CDE0ED	 	CALL	DIRDMA	;tell the bios the dma address for directory access.
3476: F295 	2AE7F5	 	LHLD	LOGSECT	;get sector that starts current block.
3477: F298 	0E02	 	MVI	C,2	;set 'writing to unused space' flag.
3478: F29A 		 WTSEQ8:
3479: F29A 	22E5F5	 	SHLD	BLKNMBR	;save sector to write.
3480: F29D 	C5	 	PUSH	B
3481: F29E 	CDD1EB	 	CALL	TRKSEC1	;determine its track and sector numbers.
3482: F2A1 	C1	 	POP	B
3483: F2A2 	CDB8EB	 	CALL	DOWRITE	;now write out 128 bytes of zeros.
3484: F2A5 	2AE5F5	 	LHLD	BLKNMBR	;get sector number.
3485: F2A8 	0E00	 	MVI	C,0	;set normal write flag.
3486: F2AA 	3AC4F5	 	LDA	BLKMASK	;determine if we have written the entire
3487: F2AD 	47	 	MOV	B,A	;physical block.
3488: F2AE 	A5	 	ANA	L
3489: F2AF 	B8	 	CMP	B
3490: F2B0 	23	 	INX	H	;prepare for the next one.
3491: F2B1 	C29AF2	 	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3492: F2B4 	E1	 	POP	H	;reset next sector number.
3493: F2B5 	22E5F5	 	SHLD	BLKNMBR
3494: F2B8 	CDDAED	 	CALL	DEFDMA	;and reset dma address.
3495: F2BB 		 ;
3496: F2BB 		 ;   Normal disk write. Set the desired track and sector then
3497: F2BB 		 ; do the actual write.
3498: F2BB 		 ;
3499: F2BB 		 WTSEQ9:
3500: F2BB 	CDD1EB	 	CALL	TRKSEC1	;determine track and sector for this write.
3501: F2BE 	C1	 	POP	B	;get write status flag.
3502: F2BF 	C5	 	PUSH	B
3503: F2C0 	CDB8EB	 	CALL	DOWRITE	;and write this out.
3504: F2C3 	C1	 	POP	B
3505: F2C4 	3AE3F5	 	LDA	SAVNREC	;get number of records in file.
3506: F2C7 	21E1F5	 	LXI	H,SAVNXT;get last record written.
3507: F2CA 	BE	 	CMP	M
3508: F2CB 	DAD2F2	 	JC	WTSEQ10
3509: F2CE 	77	 	MOV	M,A	;we have to update record count.
3510: F2CF 	34	 	INR	M
3511: F2D0 	0E02	 	MVI	C,2
3512: F2D2 		 ;
3513: F2D2 		 ;*   This area has been patched to correct disk update problem
3514: F2D2 		 ;* when using blocking and de-blocking in the BIOS.
3515: F2D2 		 ;
3516: F2D2 		 WTSEQ10:
3517: F2D2 	00	 	NOP		;was 'dcr c'
3518: F2D3 	00	 	NOP		;was 'dcr c'
3519: F2D4 	210000	 	LXI	H,0	;was 'jnz wtseq99'
3520: F2D7 		 ;
3521: F2D7 		 ; *   End of patch.
3522: F2D7 		 ;
3523: F2D7 	F5	 	PUSH	PSW
3524: F2D8 	CD69ED	 	CALL	GETS2	;set 'extent written to' flag.
3525: F2DB 	E67F	 	ANI	7FH	;(* clear bit 7 *)
3526: F2DD 	77	 	MOV	M,A
3527: F2DE 	F1	 	POP	PSW	;get record count for this extent.
3528: F2DF 		 WTSEQ99:
3529: F2DF 	FE7F	 	CPI	127	;is it full?
3530: F2E1 	C200F3	 	JNZ	WTSEQ12
3531: F2E4 	3AD5F5	 	LDA	MODE	;yes, are we in sequential mode?
3532: F2E7 	FE01	 	CPI	1
3533: F2E9 	C200F3	 	JNZ	WTSEQ12
3534: F2EC 	CDD2EC	 	CALL	SETNREC	;yes, set next record number.
3535: F2EF 	CD5AF1	 	CALL	GETNEXT	;and get next empty space in directory.
3536: F2F2 	2145EB	 	LXI	H,STATUS;ok?
3537: F2F5 	7E	 	MOV	A,M
3538: F2F6 	B7	 	ORA	A
3539: F2F7 	C2FEF2	 	JNZ	WTSEQ11
3540: F2FA 	3D	 	DCR	A	;yes, set record count to -1.
3541: F2FB 	32E3F5	 	STA	SAVNREC
3542: F2FE 		 WTSEQ11:
3543: F2FE 	3600	 	MVI	M,0	;clear status.
3544: F300 		 WTSEQ12:
3545: F300 	C3D2EC	 	JMP	SETNREC	;set next record to access.
3546: F303 		 ;
3547: F303 		 ;   For random i/o, set the fcb for the desired record number
3548: F303 		 ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3549: F303 		 ; used as follows:
3550: F303 		 ;
3551: F303 		 ;       fcb+35            fcb+34            fcb+33
3552: F303 		 ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3553: F303 		 ;  |7             0 | 7             0 | 7             0|
3554: F303 		 ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3555: F303 		 ;  |    overflow   | | extra |  extent   |   record #  |
3556: F303 		 ;  | ______________| |_extent|__number___|_____________|
3557: F303 		 ;                     also 's2'
3558: F303 		 ;
3559: F303 		 ;   On entry, register (C) contains 0ffh if this is a read
3560: F303 		 ; and thus we can not access unwritten disk space. Otherwise,
3561: F303 		 ; another extent will be opened (for writing) if required.
3562: F303 		 ;
3563: F303 		 POSITION:
3564: F303 	AF	 	XRA	A	;set random i/o flag.
3565: F304 	32D5F5	 	STA	MODE
3566: F307 		 ;
3567: F307 		 ;   Special entry (function #40). M/PM ?
3568: F307 		 ;
3569: F307 		 POSITN1:
3570: F307 	C5	 	PUSH	B	;save read/write flag.
3571: F308 	2A43EB	 	LHLD	ParamsDE	;get address of fcb.
3572: F30B 	EB	 	XCHG
3573: F30C 	212100	 	LXI	H,33	;now get byte 'r0'.
3574: F30F 	19	 	DAD	D
3575: F310 	7E	 	MOV	A,M
3576: F311 	E67F	 	ANI	7FH	;keep bits 0-6 for the record number to access.
3577: F313 	F5	 	PUSH	PSW
3578: F314 	7E	 	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3579: F315 	17	 	RAL
3580: F316 	23	 	INX	H
3581: F317 	7E	 	MOV	A,M
3582: F318 	17	 	RAL
3583: F319 	E61F	 	ANI	1FH	;and save this in bits 0-4 of (C).
3584: F31B 	4F	 	MOV	C,A	;this is the extent byte.
3585: F31C 	7E	 	MOV	A,M	;now get the extra extent byte.
3586: F31D 	1F	 	RAR
3587: F31E 	1F	 	RAR
3588: F31F 	1F	 	RAR
3589: F320 	1F	 	RAR
3590: F321 	E60F	 	ANI	0FH
3591: F323 	47	 	MOV	B,A	;and save it in (B).
3592: F324 	F1	 	POP	PSW	;get record number back to (A).
3593: F325 	23	 	INX	H	;check overflow byte 'r2'.
3594: F326 	6E	 	MOV	L,M
3595: F327 	2C	 	INR	L
3596: F328 	2D	 	DCR	L
3597: F329 	2E06	 	MVI	L,6	;prepare for error.
3598: F32B 	C28BF3	 	JNZ	POSITN5	;out of disk space error.
3599: F32E 	212000	 	LXI	H,32	;store record number into fcb.
3600: F331 	19	 	DAD	D
3601: F332 	77	 	MOV	M,A
3602: F333 	210C00	 	LXI	H,12	;and now check the extent byte.
3603: F336 	19	 	DAD	D
3604: F337 	79	 	MOV	A,C
3605: F338 	96	 	SUB	M	;same extent as before?
3606: F339 	C247F3	 	JNZ	POSITN2
3607: F33C 	210E00	 	LXI	H,14	;yes, check extra extent byte 's2' also.
3608: F33F 	19	 	DAD	D
3609: F340 	78	 	MOV	A,B
3610: F341 	96	 	SUB	M
3611: F342 	E67F	 	ANI	7FH
3612: F344 	CA7FF3	 	JZ	POSITN3;same, we are almost done then.
3613: F347 		 ;
3614: F347 		 ;  Get here when another extent is required.
3615: F347 		 ;
3616: F347 		 POSITN2:
3617: F347 	C5	 	PUSH	B
3618: F348 	D5	 	PUSH	D
3619: F349 	CDA2F0	 	CALL	CLOSEIT	;close current extent.
3620: F34C 	D1	 	POP	D
3621: F34D 	C1	 	POP	B
3622: F34E 	2E03	 	MVI	L,3	;prepare for error.
3623: F350 	3A45EB	 	LDA	STATUS
3624: F353 	3C	 	INR	A
3625: F354 	CA84F3	 	JZ	POSITN4	;close error.
3626: F357 	210C00	 	LXI	H,12	;put desired extent into fcb now.
3627: F35A 	19	 	DAD	D
3628: F35B 	71	 	MOV	M,C
3629: F35C 	210E00	 	LXI	H,14	;and store extra extent byte 's2'.
3630: F35F 	19	 	DAD	D
3631: F360 	70	 	MOV	M,B
3632: F361 	CD51F0	 	CALL	OPENIT	;try and get this extent.
3633: F364 	3A45EB	 	LDA	STATUS	;was it there?
3634: F367 	3C	 	INR	A
3635: F368 	C27FF3	 	JNZ	POSITN3
3636: F36B 	C1	 	POP	B	;no. can we create a new one (writing?).
3637: F36C 	C5	 	PUSH	B
3638: F36D 	2E04	 	MVI	L,4	;prepare for error.
3639: F36F 	0C	 	INR	C
3640: F370 	CA84F3	 	JZ	POSITN4	;nope, reading unwritten space error.
3641: F373 	CD24F1	 	CALL	GETEMPTY;yes we can, try to find space.
3642: F376 	2E05	 	MVI	L,5	;prepare for error.
3643: F378 	3A45EB	 	LDA	STATUS
3644: F37B 	3C	 	INR	A
3645: F37C 	CA84F3	 	JZ	POSITN4	;out of space?
3646: F37F 		 ;
3647: F37F 		 ;   Normal return location. Clear error code and return.
3648: F37F 		 ;
3649: F37F 		 POSITN3:
3650: F37F 	C1	 	POP	B	;restore stack.
3651: F380 	AF	 	XRA	A	;and clear error code byte.
3652: F381 	C301EB	 	JMP	SETSTAT
3653: F384 		 ;
3654: F384 		 ;   Error. Set the 's2' byte to indicate this (why?).
3655: F384 		 ;
3656: F384 		 POSITN4:
3657: F384 	E5	 	PUSH	H
3658: F385 	CD69ED	 	CALL	GETS2
3659: F388 	36C0	 	MVI	M,0C0H
3660: F38A 	E1	 	POP	H
3661: F38B 		 ;
3662: F38B 		 ;   Return with error code (presently in L).
3663: F38B 		 ;
3664: F38B 		 POSITN5:
3665: F38B 	C1	 	POP	B
3666: F38C 	7D	 	MOV	A,L	;get error code.
3667: F38D 	3245EB	 	STA	STATUS
3668: F390 	C378ED	 	JMP	SETS2B7
3669: F393 		 ;
3670: F393 		 ;   Read a random record.
3671: F393 		 ;
3672: F393 		 READRAN:
3673: F393 	0EFF	 	MVI	C,0FFH	;set 'read' status.
3674: F395 	CD03F3	 	CALL	POSITION;position the file to proper record.
3675: F398 	CCC1F1	 	CZ	RDSEQ1	;and read it as usual (if no errors).
3676: F39B 	C9	 	RET
3677: F39C 		 ;
3678: F39C 		 ;   Write to a random record.
3679: F39C 		 ;
3680: F39C 		 WRITERAN:
3681: F39C 	0E00	 	MVI	C,0	;set 'writing' flag.
3682: F39E 	CD03F3	 	CALL	POSITION;position the file to proper record.
3683: F3A1 	CC03F2	 	CZ	WTSEQ1	;and write as usual (if no errors).
3684: F3A4 	C9	 	RET
3685: F3A5 		 ;
3686: F3A5 		 ;   Compute the random record number. Enter with (HL) pointing
3687: F3A5 		 ; to a fcb an (DE) contains a relative location of a record
3688: F3A5 		 ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3689: F3A5 		 ; byte, and (A) the 'r2' byte.
3690: F3A5 		 ;
3691: F3A5 		 ;   On return, the zero flag is set if the record is within
3692: F3A5 		 ; bounds. Otherwise, an overflow occured.
3693: F3A5 		 ;
3694: F3A5 		 COMPRAND:
3695: F3A5 	EB	 	XCHG		;save fcb pointer in (DE).
3696: F3A6 	19	 	DAD	D	;compute relative position of record #.
3697: F3A7 	4E	 	MOV	C,M	;get record number into (BC).
3698: F3A8 	0600	 	MVI	B,0
3699: F3AA 	210C00	 	LXI	H,12	;now get extent.
3700: F3AD 	19	 	DAD	D
3701: F3AE 	7E	 	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3702: F3AF 	0F	 	RRC		;move lower bit into bit 7.
3703: F3B0 	E680	 	ANI	80H	;and ignore all other bits.
3704: F3B2 	81	 	ADD	C	;add to our record number.
3705: F3B3 	4F	 	MOV	C,A
3706: F3B4 	3E00	 	MVI	A,0	;take care of any carry.
3707: F3B6 	88	 	ADC	B
3708: F3B7 	47	 	MOV	B,A
3709: F3B8 	7E	 	MOV	A,M	;now get the upper bits of extent into
3710: F3B9 	0F	 	RRC		;bit positions 0-3.
3711: F3BA 	E60F	 	ANI	0FH	;and ignore all others.
3712: F3BC 	80	 	ADD	B	;add this in to 'r1' byte.
3713: F3BD 	47	 	MOV	B,A
3714: F3BE 	210E00	 	LXI	H,14	;get the 's2' byte (extra extent).
3715: F3C1 	19	 	DAD	D
3716: F3C2 	7E	 	MOV	A,M
3717: F3C3 	87	 	ADD	A	;and shift it left 4 bits (bits 4-7).
3718: F3C4 	87	 	ADD	A
3719: F3C5 	87	 	ADD	A
3720: F3C6 	87	 	ADD	A
3721: F3C7 	F5	 	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3722: F3C8 	80	 	ADD	B	;now add extra extent into 'r1'.
3723: F3C9 	47	 	MOV	B,A
3724: F3CA 	F5	 	PUSH	PSW	;and save carry (overflow byte 'r2').
3725: F3CB 	E1	 	POP	H	;bit 0 of (L) is the overflow indicator.
3726: F3CC 	7D	 	MOV	A,L
3727: F3CD 	E1	 	POP	H	;and same for first carry flag.
3728: F3CE 	B5	 	ORA	L	;either one of these set?
3729: F3CF 	E601	 	ANI	01H	;only check the carry flags.
3730: F3D1 	C9	 	RET
3731: F3D2 		 ;
3732: F3D2 		 ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3733: F3D2 		 ; reflect the last record used for a random (or other) file.
3734: F3D2 		 ; This reads the directory and looks at all extents computing
3735: F3D2 		 ; the largerst record number for each and keeping the maximum
3736: F3D2 		 ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3737: F3D2 		 ; maximum record number. This is used to compute the space used
3738: F3D2 		 ; by a random file.
3739: F3D2 		 ;
3740: F3D2 		 RANSIZE:
3741: F3D2 	0E0C	 	MVI	C,12	;look thru directory for first entry with
3742: F3D4 	CD18EF	 	CALL	FINDFST	;this name.
3743: F3D7 	2A43EB	 	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3744: F3DA 	112100	 	LXI	D,33
3745: F3DD 	19	 	DAD	D
3746: F3DE 	E5	 	PUSH	H
3747: F3DF 	72	 	MOV	M,D	;note that (D)=0.
3748: F3E0 	23	 	INX	H
3749: F3E1 	72	 	MOV	M,D
3750: F3E2 	23	 	INX	H
3751: F3E3 	72	 	MOV	M,D
3752: F3E4 		 RANSIZ1:
3753: F3E4 	CDF5ED	 	CALL	CKFILPOS;is there an extent to process?
3754: F3E7 	CA0CF4	 	JZ	RANSIZ3	;no, we are done.
3755: F3EA 	CD5EED	 	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3756: F3ED 	110F00	 	LXI	D,15	;point to last record in extent.
3757: F3F0 	CDA5F3	 	CALL	COMPRAND;and compute random parameters.
3758: F3F3 	E1	 	POP	H
3759: F3F4 	E5	 	PUSH	H	;now check these values against those
3760: F3F5 	5F	 	MOV	E,A	;already in fcb.
3761: F3F6 	79	 	MOV	A,C	;the carry flag will be set if those
3762: F3F7 	96	 	SUB	M	;in the fcb represent a larger size than
3763: F3F8 	23	 	INX	H	;this extent does.
3764: F3F9 	78	 	MOV	A,B
3765: F3FA 	9E	 	SBB	M
3766: F3FB 	23	 	INX	H
3767: F3FC 	7B	 	MOV	A,E
3768: F3FD 	9E	 	SBB	M
3769: F3FE 	DA06F4	 	JC	RANSIZ2
3770: F401 	73	 	MOV	M,E	;we found a larger (in size) extent.
3771: F402 	2B	 	DCX	H	;stuff these values into fcb.
3772: F403 	70	 	MOV	M,B
3773: F404 	2B	 	DCX	H
3774: F405 	71	 	MOV	M,C
3775: F406 		 RANSIZ2:
3776: F406 	CD2DEF	 	CALL	FINDNXT	;now get the next extent.
3777: F409 	C3E4F3	 	JMP	RANSIZ1	;continue til all done.
3778: F40C 		 RANSIZ3:
3779: F40C 	E1	 	POP	H	;we are done, restore the stack and
3780: F40D 	C9	 	RET		;return.
3781: F40E 		 ;
3782: F40E 		 ;   Function to return the random record position of a given
3783: F40E 		 ; file which has been read in sequential mode up to now.
3784: F40E 		 ;
3785: F40E 		 SETRAN:
3786: F40E 	2A43EB	 	LHLD	ParamsDE	;point to fcb.
3787: F411 	112000	 	LXI	D,32	;and to last used record.
3788: F414 	CDA5F3	 	CALL	COMPRAND;compute random position.
3789: F417 	212100	 	LXI	H,33	;now stuff these values into fcb.
3790: F41A 	19	 	DAD	D
3791: F41B 	71	 	MOV	M,C	;move 'r0'.
3792: F41C 	23	 	INX	H
3793: F41D 	70	 	MOV	M,B	;and 'r1'.
3794: F41E 	23	 	INX	H
3795: F41F 	77	 	MOV	M,A	;and lastly 'r2'.
3796: F420 	C9	 	RET
3797: F421 		 ;
3798: F421 		 ;   This routine select the drive specified in (ACTIVE) and
3799: F421 		 ; update the login vector and bitmap table if this drive was
3800: F421 		 ; not already active.
3801: F421 		 ;
3802: F421 		 LOGINDRV:
3803: F421 	2AAFF5	 	LHLD	LOGIN	;get the login vector.
3804: F424 	3A42EB	 	LDA	ACTIVE	;get the default drive.
3805: F427 	4F	 	MOV	C,A
3806: F428 	CDEAEC	 	CALL	SHIFTR	;position active bit for this drive
3807: F42B 	E5	 	PUSH	H	;into bit 0.
3808: F42C 	EB	 	XCHG
3809: F42D 	CD59EB	 	CALL	SELECT	;select this drive.
3810: F430 	E1	 	POP	H
3811: F431 	CC47EB	 	CZ	SLCTERR	;valid drive?
3812: F434 	7D	 	MOV	A,L	;is this a newly activated drive?
3813: F435 	1F	 	RAR
3814: F436 	D8	 	RC
3815: F437 	2AAFF5	 	LHLD	LOGIN	;yes, update the login vector.
3816: F43A 	4D	 	MOV	C,L
3817: F43B 	44	 	MOV	B,H
3818: F43C 	CD0BED	 	CALL	SETBIT
3819: F43F 	22AFF5	 	SHLD	LOGIN	;and save.
3820: F442 	C3A3EE	 	JMP	BITMAP	;now update the bitmap.
3821: F445 		 ;
3822: F445 		 ;   Function to set the active disk number.
3823: F445 		 ;
3824: F445 		 SETDSK:
3825: F445 	3AD6F5	 	LDA	ParamE	;get parameter passed and see if this
3826: F448 	2142EB	 	LXI	H,ACTIVE;represents a change in drives.
3827: F44B 	BE	 	CMP	M
3828: F44C 	C8	 	RZ
3829: F44D 	77	 	MOV	M,A	;yes it does, log it in.
3830: F44E 	C321F4	 	JMP	LOGINDRV
3831: F451 		 ;
3832: F451 		 ;   This is the 'auto disk select' routine. The firsst byte
3833: F451 		 ; of the fcb is examined for a drive specification. If non
3834: F451 		 ; zero then the drive will be selected and loged in.
3835: F451 		 ;
3836: F451 		 AUTOSEL:
3837: F451 	3EFF	 	MVI	A,0FFH	;say 'auto-select activated'.
3838: F453 	32DEF5	 	STA	AUTO
3839: F456 	2A43EB	 	LHLD	ParamsDE	;get drive specified.
3840: F459 	7E	 	MOV	A,M
3841: F45A 	E61F	 	ANI	1FH	;look at lower 5 bits.
3842: F45C 	3D	 	DCR	A	;adjust for (1=A, 2=B) etc.
3843: F45D 	32D6F5	 	STA	ParamE	;and save for the select routine.
3844: F460 	FE1E	 	CPI	1EH	;check for 'no change' condition.
3845: F462 	D275F4	 	JNC	AUTOSL1	;yes, don't change.
3846: F465 	3A42EB	 	LDA	ACTIVE	;we must change, save currently active
3847: F468 	32DFF5	 	STA	OLDDRV	;drive.
3848: F46B 	7E	 	MOV	A,M	;and save first byte of fcb also.
3849: F46C 	32E0F5	 	STA	AUTOFLAG;this must be non-zero.
3850: F46F 	E6E0	 	ANI	0E0H	;whats this for (bits 6,7 are used for
3851: F471 	77	 	MOV	M,A	;something)?
3852: F472 	CD45F4	 	CALL	SETDSK	;select and log in this drive.
3853: F475 		 AUTOSL1:
3854: F475 	3A41EB	 	LDA	USERNO	;move user number into fcb.
3855: F478 	2A43EB	 	LHLD	ParamsDE	;(* upper half of first byte *)
3856: F47B 	B6	 	ORA	M
3857: F47C 	77	 	MOV	M,A
3858: F47D 	C9	 	RET		;and return (all done).
3859: F47E 		 ;
3860: F47E 		 ;   Function to return the current cp/m version number.
3861: F47E 		 ;
3862: F47E 		 GETVER:
3863: F47E 	3E22	 	MVI	A,022h	;version 2.2
3864: F480 	C301EB	 	JMP	SETSTAT
3865: F483 		 ;
3866: F483 		 ;   Function to reset the disk system.
3867: F483 		 ;
3868: F483 		 RSTDSK:
3869: F483 	210000	 	LXI	H,0	;clear write protect status and log
3870: F486 	22ADF5	 	SHLD	WRTPRT	;in vector.
3871: F489 	22AFF5	 	SHLD	LOGIN
3872: F48C 	AF	 	XRA	A	;select drive 'A'.
3873: F48D 	3242EB	 	STA	ACTIVE
3874: F490 	218000	 	LXI	H,TBUFF	;setup default dma address.
3875: F493 	22B1F5	 	SHLD	USERDMA
3876: F496 	CDDAED	 	CALL	DEFDMA
3877: F499 	C321F4	 	JMP	LOGINDRV;now log in drive 'A'.
3878: F49C 		 ;
3879: F49C 		 ;   Function to open a specified file.
3880: F49C 		 ;
3881: F49C 		 OPENFIL:
3882: F49C 	CD72ED	 	CALL	CLEARS2	;clear 's2' byte.
3883: F49F 	CD51F4	 	CALL	AUTOSEL	;select proper disk.
3884: F4A2 	C351F0	 	JMP	OPENIT	;and open the file.
3885: F4A5 		 ;
3886: F4A5 		 ;   Function to close a specified file.
3887: F4A5 		 ;
3888: F4A5 		 CLOSEFIL:
3889: F4A5 	CD51F4	 	CALL	AUTOSEL	;select proper disk.
3890: F4A8 	C3A2F0	 	JMP	CLOSEIT	;and close the file.
3891: F4AB 		 ;
3892: F4AB 		 ;   Function to return the first occurence of a specified file
3893: F4AB 		 ; name. If the first byte of the fcb is '?' then the name will
3894: F4AB 		 ; not be checked (get the first entry no matter what).
3895: F4AB 		 ;
3896: F4AB 		 GETFST:
3897: F4AB 	0E00	 	MVI	C,0	;prepare for special search.
3898: F4AD 	EB	 	XCHG
3899: F4AE 	7E	 	MOV	A,M	;is first byte a '?'?
3900: F4AF 	FE3F	 	CPI	QMARK		;'?'
3901: F4B1 	CAC2F4	 	JZ	GETFST1	;yes, just get very first entry (zero length match).
3902: F4B4 	CDA6EC	 	CALL	SETEXT	;get the extension byte from fcb.
3903: F4B7 	7E	 	MOV	A,M	;is it '?'? if yes, then we want
3904: F4B8 	FE3F	 	CPI	QMARK		; '?'	;an entry with a specific 's2' byte.
3905: F4BA 	C472ED	 	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
3906: F4BD 	CD51F4	 	CALL	AUTOSEL	;select proper drive.
3907: F4C0 	0E0F	 	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
3908: F4C2 		 GETFST1:
3909: F4C2 	CD18EF	 	CALL	FINDFST	;find an entry and then move it into
3910: F4C5 	C3E9ED	 	JMP	MOVEDIR	;the users dma space.
3911: F4C8 		 ;
3912: F4C8 		 ;   Function to return the next occurence of a file name.
3913: F4C8 		 ;
3914: F4C8 		 GETNXT:
3915: F4C8 	2AD9F5	 	LHLD	SAVEFCB	;restore pointers. note that no
3916: F4CB 	2243EB	 	SHLD	ParamsDE	;other dbos calls are allowed.
3917: F4CE 	CD51F4	 	CALL	AUTOSEL	;no error will be returned, but the
3918: F4D1 	CD2DEF	 	CALL	FINDNXT	;results will be wrong.
3919: F4D4 	C3E9ED	 	JMP	MOVEDIR
3920: F4D7 		 ;
3921: F4D7 		 ;   Function to delete a file by name.
3922: F4D7 		 ;
3923: F4D7 		 DELFILE:
3924: F4D7 	CD51F4	 	CALL	AUTOSEL	;select proper drive.
3925: F4DA 	CD9CEF	 	CALL	ERAFILE	;erase the file.
3926: F4DD 	C301EF	 	JMP	STSTATUS;set status and return.
3927: F4E0 		 ;
3928: F4E0 		 ;   Function to execute a sequential read of the specified
3929: F4E0 		 ; record number.
3930: F4E0 		 ;
3931: F4E0 		 READSEQ:
3932: F4E0 	CD51F4	 	CALL	AUTOSEL	;select proper drive then read.
3933: F4E3 	C3BCF1	 	JMP	RDSEQ
3934: F4E6 		 ;
3935: F4E6 		 ;   Function to write the net sequential record.
3936: F4E6 		 ;
3937: F4E6 		 WRTSEQ:
3938: F4E6 	CD51F4	 	CALL	AUTOSEL	;select proper drive then write.
3939: F4E9 	C3FEF1	 	JMP	WTSEQ
3940: F4EC 		 ;
3941: F4EC 		 ;   Create a file function.
3942: F4EC 		 ;
3943: F4EC 		 FCREATE:
3944: F4EC 	CD72ED	 	CALL	CLEARS2	;clear the 's2' byte on all creates.
3945: F4EF 	CD51F4	 	CALL	AUTOSEL	;select proper drive and get the next
3946: F4F2 	C324F1	 	JMP	GETEMPTY;empty directory space.
3947: F4F5 		 ;
3948: F4F5 		 ;   Function to rename a file.
3949: F4F5 		 ;
3950: F4F5 		 RENFILE:
3951: F4F5 	CD51F4	 	CALL	AUTOSEL	;select proper drive and then switch
3952: F4F8 	CD16F0	 	CALL	CHGNAMES;file names.
3953: F4FB 	C301EF	 	JMP	STSTATUS
3954: F4FE 		 ;
3955: F4FE 		 ;   Function to return the login vector.
3956: F4FE 		 ;
3957: F4FE 		 GETLOG:
3958: F4FE 	2AAFF5	 	LHLD	LOGIN
3959: F501 	C329F5	 	JMP	GETPRM1
3960: F504 		 ;
3961: F504 		 ;   Function to return the current disk assignment.
3962: F504 		 ;
3963: F504 		 GETCRNT:
3964: F504 	3A42EB	 	LDA	ACTIVE
3965: F507 	C301EB	 	JMP	SETSTAT
3966: F50A 		 ;
3967: F50A 		 ;   Function to set the dma address.
3968: F50A 		 ;
3969: F50A 		 PUTDMA:
3970: F50A 	EB	 	XCHG
3971: F50B 	22B1F5	 	SHLD	USERDMA	;save in our space and then get to
3972: F50E 	C3DAED	 	JMP	DEFDMA	;the bios with this also.
3973: F511 		 ;
3974: F511 		 ;   Function to return the allocation vector.
3975: F511 		 ;
3976: F511 		 GETALOC:
3977: F511 	2ABFF5	 	LHLD	ALOCVECT
3978: F514 	C329F5	 	JMP	GETPRM1
3979: F517 		 ;
3980: F517 		 ;   Function to return the read-only status vector.
3981: F517 		 ;
3982: F517 		 GETROV:
3983: F517 	2AADF5	 	LHLD	WRTPRT
3984: F51A 	C329F5	 	JMP	GETPRM1
3985: F51D 		 ;
3986: F51D 		 ;   Function to set the file attributes (read-only, system).
3987: F51D 		 ;
3988: F51D 		 SETATTR:
3989: F51D 	CD51F4	 	CALL	AUTOSEL	;select proper drive then save attributes.
3990: F520 	CD3BF0	 	CALL	SAVEATTR
3991: F523 	C301EF	 	JMP	STSTATUS
3992: F526 		 ;
3993: F526 		 ;   Function to return the address of the disk parameter block
3994: F526 		 ; for the current drive.
3995: F526 		 ;
3996: F526 		 GETPARM:
3997: F526 	2ABBF5	 	LHLD	DISKPB
3998: F529 		 GETPRM1:
3999: F529 	2245EB	 	SHLD	STATUS
4000: F52C 	C9	 	RET
4001: F52D 		 ;
4002: F52D 		 ;   Function to get or set the user number. If (E) was (FF)
4003: F52D 		 ; then this is a request to return the current user number.
4004: F52D 		 ; Else set the user number from (E).
4005: F52D 		 ;
4006: F52D 		 GETUSER:
4007: F52D 	3AD6F5	 	LDA	ParamE	;get parameter.
4008: F530 	FEFF	 	CPI	0FFH	;get user number?
4009: F532 	C23BF5	 	JNZ	SETUSER
4010: F535 	3A41EB	 	LDA	USERNO	;yes, just do it.
4011: F538 	C301EB	 	JMP	SETSTAT
4012: F53B 		 SETUSER:
4013: F53B 	E61F	 	ANI	1FH	;no, we should set it instead. keep low
4014: F53D 	3241EB	 	STA	USERNO	;bits (0-4) only.
4015: F540 	C9	 	RET
4016: F541 		 ;
4017: F541 		 ;   Function to read a random record from a file.
4018: F541 		 ;
4019: F541 		 RDRANDOM:
4020: F541 	CD51F4	 	CALL	AUTOSEL	;select proper drive and read.
4021: F544 	C393F3	 	JMP	READRAN
4022: F547 		 ;
4023: F547 		 ;   Function to compute the file size for random files.
4024: F547 		 ;
4025: F547 		 WTRANDOM:
4026: F547 	CD51F4	 	CALL	AUTOSEL	;select proper drive and write.
4027: F54A 	C39CF3	 	JMP	WRITERAN
4028: F54D 		 ;
4029: F54D 		 ;   Function to compute the size of a random file.
4030: F54D 		 ;
4031: F54D 		 FILESIZE:
4032: F54D 	CD51F4	 	CALL	AUTOSEL	;select proper drive and check file length
4033: F550 	C3D2F3	 	JMP	RANSIZE
4034: F553 		 ;
4035: F553 		 ;   Function #37. This allows a program to log off any drives.
4036: F553 		 ; On entry, set (DE) to contain a word with bits set for those
4037: F553 		 ; drives that are to be logged off. The log-in vector and the
4038: F553 		 ; write protect vector will be updated. This must be a M/PM
4039: F553 		 ; special function.
4040: F553 		 ;
4041: F553 		 LOGOFF:
4042: F553 	2A43EB	 	LHLD	ParamsDE	;get drives to log off.
4043: F556 	7D	 	MOV	A,L	;for each bit that is set, we want
4044: F557 	2F	 	CMA		;to clear that bit in (LOGIN)
4045: F558 	5F	 	MOV	E,A	;and (WRTPRT).
4046: F559 	7C	 	MOV	A,H
4047: F55A 	2F	 	CMA
4048: F55B 	2AAFF5	 	LHLD	LOGIN	;reset the login vector.
4049: F55E 	A4	 	ANA	H
4050: F55F 	57	 	MOV	D,A
4051: F560 	7D	 	MOV	A,L
4052: F561 	A3	 	ANA	E
4053: F562 	5F	 	MOV	E,A
4054: F563 	2AADF5	 	LHLD	WRTPRT
4055: F566 	EB	 	XCHG
4056: F567 	22AFF5	 	SHLD	LOGIN	;and save.
4057: F56A 	7D	 	MOV	A,L	;now do the write protect vector.
4058: F56B 	A3	 	ANA	E
4059: F56C 	6F	 	MOV	L,A
4060: F56D 	7C	 	MOV	A,H
4061: F56E 	A2	 	ANA	D
4062: F56F 	67	 	MOV	H,A
4063: F570 	22ADF5	 	SHLD	WRTPRT	;and save. all done.
4064: F573 	C9	 	RET
4065: F574 		 ;
4066: F574 		 ;   Get here to return to the user.
4067: F574 		 ;
4068: F574 		 BDOSExit:
4069: F574 	3ADEF5	 	LDA	AUTO	;was auto select activated?
4070: F577 	B7	 	ORA	A
4071: F578 	CA91F5	 	JZ	BDOSExit1
4072: F57B 	2A43EB	 	LHLD	ParamsDE	;yes, but was a change made?
4073: F57E 	3600	 	MVI	M,0	;(* reset first byte of fcb *)
4074: F580 	3AE0F5	 	LDA	AUTOFLAG
4075: F583 	B7	 	ORA	A
4076: F584 	CA91F5	 	JZ	BDOSExit1
4077: F587 	77	 	MOV	M,A	;yes, reset first byte properly.
4078: F588 	3ADFF5	 	LDA	OLDDRV	;and get the old drive and select it.
4079: F58B 	32D6F5	 	STA	ParamE
4080: F58E 	CD45F4	 	CALL	SETDSK
4081: F591 		 BDOSExit1:
4082: F591 	2A0FEB	 	LHLD	UserStack;reset the users stack pointer.
4083: F594 	F9	 	SPHL
4084: F595 	2A45EB	 	LHLD	STATUS	;get return status.
4085: F598 	7D	 	MOV	A,L	;force version 1.4 compatability.
4086: F599 	44	 	MOV	B,H
4087: F59A 	C9	 	RET		;and go back to user.
4088: F59B 		 ;
4089: F59B 		 ;   Function #40. This is a special entry to do random i/o.
4090: F59B 		 ; For the case where we are writing to unused disk space, this
4091: F59B 		 ; space will be zeroed out first. This must be a M/PM special
4092: F59B 		 ; purpose function, because why would any normal program even
4093: F59B 		 ; care about the previous contents of a sector about to be
4094: F59B 		 ; written over.
4095: F59B 		 ;
4096: F59B 		 WTSPECL:
4097: F59B 	CD51F4	 	CALL	AUTOSEL	;select proper drive.
4098: F59E 	3E02	 	MVI	A,2	;use special write mode.
4099: F5A0 	32D5F5	 	STA	MODE
4100: F5A3 	0E00	 	MVI	C,0	;set write indicator.
4101: F5A5 	CD07F3	 	CALL	POSITN1	;position the file.
4102: F5A8 	CC03F2	 	CZ	WTSEQ1	;and write (if no errors).
4103: F5AB 	C9	 	RET
4104: F5AC 		 ;
4105: F5AC 		 ;**************************************************************
4106: F5AC 		 ;*
4107: F5AC 		 ;*     BDOS data storage pool.
4108: F5AC 		 ;*
4109: F5AC 		 ;**************************************************************
4110: F5AC 		 ;
4111: F5AC 	E5	 EMPTYFCB:	DB	0E5H	;empty directory segment indicator.
4112: F5AD 	0000	 WRTPRT:		DW	0	;write protect status for all 16 drives.
4113: F5AF 	0000	 LOGIN:		DW	0	;drive active word (1 bit per drive).
4114: F5B1 	8000	 USERDMA:	DW	080H	;user's dma address (defaults to 80h).
4115: F5B3 		 ;
4116: F5B3 		 ;   Scratch areas from parameter block.
4117: F5B3 		 ;
4118: F5B3 	0000	 SCRATCH1:	DW	0	;relative position within dir segment for file (0-3).
4119: F5B5 	0000	 SCRATCH2:	DW	0	;last selected track number.
4120: F5B7 	0000	 SCRATCH3:	DW	0	;last selected sector number.
4121: F5B9 		 ;
4122: F5B9 		 ;   Disk storage areas from parameter block.
4123: F5B9 		 ;
4124: F5B9 	0000	 DIRBUF:		DW	0	;address of directory buffer to use.
4125: F5BB 	0000	 DISKPB:		DW	0	;contains address of disk parameter block.
4126: F5BD 	0000	 CHKVECT:	DW	0	;address of check vector.
4127: F5BF 	0000	 ALOCVECT:	DW	0	;address of allocation vector (bit map).
4128: F5C1 		 ;
4129: F5C1 		 ;   Parameter block returned from the bios.
4130: F5C1 		 ;
4131: F5C1 	0000	 SECTORS:	DW	0	;sectors per track from bios.
4132: F5C3 	00	 BLKSHFT:	DB	0	;block shift.
4133: F5C4 	00	 BLKMASK:	DB	0	;block mask.
4134: F5C5 	00	 EXTMASK:	DB	0	;extent mask.
4135: F5C6 	0000	 DSKSIZE:	DW	0	;disk size from bios (number of blocks-1).
4136: F5C8 	0000	 DIRSIZE:	DW	0	;directory size.
4137: F5CA 	0000	 ALLOC0:		DW	0	;storage for first bytes of bit map (dir space used).
4138: F5CC 	0000	 ALLOC1:		DW	0
4139: F5CE 	0000	 OFFSET:		DW	0	;first usable track number.
4140: F5D0 	0000	 XLATE:		DW	0	;sector translation table address.
4141: F5D2 		 ;
4142: F5D2 		 ;
4143: F5D2 	00	 CLOSEFLG:	DB	0	;close flag (=0ffh is extent written ok).
4144: F5D3 	00	 RDWRTFLG:	DB	0	;read/write flag (0ffh=read, 0=write).
4145: F5D4 	00	 FNDSTAT:	DB	0	;filename found status (0=found first entry).
4146: F5D5 	00	 MODE:		DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4147: F5D6 	00	 ParamE:		DB	0	;storage for register (E) on entry to bdos.
4148: F5D7 	00	 RELBLOCK:	DB	0	;relative position within fcb of block number written.
4149: F5D8 	00	 COUNTER:	DB	0	;byte counter for directory name searches.
4150: F5D9 	00000000	 SAVEFCB:	DW	0,0	;save space for address of fcb (for directory searches).
4151: F5DD 	00	 BIGDISK:	DB	0	;if =0 then disk is > 256 blocks long.
4152: F5DE 	00	 AUTO:		DB	0	;if non-zero, then auto select activated.
4153: F5DF 	00	 OLDDRV:		DB	0	;on auto select, storage for previous drive.
4154: F5E0 	00	 AUTOFLAG:	DB	0	;if non-zero, then auto select changed drives.
4155: F5E1 	00	 SAVNXT:		DB	0	;storage for next record number to access.
4156: F5E2 	00	 SAVEXT:		DB	0	;storage for extent number of file.
4157: F5E3 	0000	 SAVNREC:	DW	0	;storage for number of records in file.
4158: F5E5 	0000	 BLKNMBR:	DW	0	;block number (physical sector) used within a file or logical sector.
4159: F5E7 	0000	 LOGSECT:	DW	0	;starting logical (128 byte) sector of block (physical sector).
4160: F5E9 	00	 FCBPOS:		DB	0	;relative position within buffer for fcb of file of interest.
4161: F5EA 	0000	 FILEPOS:	DW	0	;files position within directory (0 to max entries -1).
4162: F5EC 		 ;
4163: F5EC 		 ;   Disk directory buffer checksum bytes. One for each of the
4164: F5EC 		 ; 16 possible drives.
4165: F5EC 		 ;
4166: F5EC 		 CKSUMTBL:
4167: F5EC 	00000000000000000000000000000000	 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4168: F5FC 		 ;
4169: F5FC 		 ;   Extra space ?
4170: F5FC 		 ;
4171: F5FC 	00000000	 	DB	0,0,0,0
4172: F600 		 ;
4173: F600 		 ;**************************************************************
4174: F600 		 ;*
4175: F600 		 ;*        B I O S   J U M P   T A B L E
4176: F600 		 ;*
4177: F600 		 ;**************************************************************
4178: F600 		 ;
4179: F600 		 BIOSEntry	Equ	0F600H		; start of bios
4180: F600 		 
4181: F600 	C300F6	 BOOT:	JMP	BIOSEntry + 000H	
4182: F603 	C303F6	 WBOOT:	JMP	BIOSEntry + 003H
4183: F606 	C306F6	 CONST:	JMP	BIOSEntry + 006H
4184: F609 	C309F6	 CONIN:	JMP	BIOSEntry + 009H
4185: F60C 	C30CF6	 CONOUT:	JMP	BIOSEntry + 00CH
4186: F60F 	C30FF6	 LIST:	JMP	BIOSEntry + 00FH
4187: F612 	C312F6	 PUNCH:	JMP	BIOSEntry + 012H
4188: F615 	C315F6	 READER:	JMP	BIOSEntry + 015H
4189: F618 	C318F6	 HOME:	JMP	BIOSEntry + 018H
4190: F61B 	C31BF6	 SELDSK:	JMP	BIOSEntry + 01BH
4191: F61E 	C31EF6	 SETTRK:	JMP	BIOSEntry + 01EH
4192: F621 	C321F6	 SETSEC:	JMP	BIOSEntry + 021H
4193: F624 	C324F6	 SETDMA:	JMP	BIOSEntry + 024H
4194: F627 	C327F6	 READ:	JMP	BIOSEntry + 027H
4195: F62A 	C32AF6	 WRITE:	JMP	BIOSEntry + 02AH
4196: F62D 	C32DF6	 PRSTAT:	JMP	BIOSEntry + 02DH
4197: F630 	C330F6	 SECTRN:	JMP	BIOSEntry + 030H
4198: F633 		 ;
4199: F633 		 ;*
4200: F633 		 ;******************   E N D   O F   C P / M   *****************
4201: F633 		 ;*
4202: F633 		 




                                    Xref


0000	0000	$                             		  1512,

1974	EB42	ACTIVE                        		  1550,  2008,  2373,  2391,  3804,  3826,  3846,  3873,  3964,
2446	ED64	ADDA2HL                       		  3433,
0498	E259	ADDHL                         		  0516,  0869,  1062,
4137	F5CA	ALLOC0                        		  2792,
4138	F5CC	ALLOC1                        		  2530,
4127	F5BF	ALOCVECT                      		  2687,  2784,  2794,  3977,
0052	002A	ASTRK                         		  0556,  0588,
0054	0040	ATSIGN                        		  1676,
4152	F5DE	AUTO                          		  1445,  3838,  4069,
4154	F5E0	AUTOFLAG                      		  1444,  3849,  4074,
3836	F451	AUTOSEL                       		  3883,  3889,  3906,  3917,  3924,  3932,  3938,  3945,  3951,  3989,  4020,  4026,  4032,  4097,
3853	F475	AUTOSL1                       		  3845,

1698	E9A4	BACKUP                        		  1813,  1853,
1702	E9AC	BACKUP1                       		  1699,
1353	E77A	BADLOAD                       		  1350,
1419	E809	BADSCTR                       		  2081,
1540	E8CA	BADSEC                        		  1517,
1541	E8D5	BADSEL                        		  1524,
1420	E80B	BADSLCT                       		  1981,
1380	E7AB	BATCH                         		  0289,  0407,  0715,  1339,
1382	E7AC	BATCHFCB                      		  0301,  0304,  0306,  0307,  0317,  0321,  0414,
1539	E8C6	BDOSDRV                       		  1552,
1414	E806	BDOSENTRY                     		
1538	E8BA	BDOSERR                       		  1553,
4068	F574	BDOSEXIT                      		  1446,
4081	F591	BDOSEXIT1                     		  1913,  4071,  4076,
1432	E811	BDOSSETUP                     		  1415,
1971	EB41	BDOSSTACK                     		  1442,
4151	F5DD	BIGDISK                       		  2043,  2218,  2733,  3201,  3429,
4179	F600	BIOSENTRY                     		  4181,  4182,  4183,  4184,  4185,  4186,  4187,  4188,  4189,  4190,  4191,  4192,  4193,  4194,  4195,  4196,  4197,
2769	EEA3	BITMAP                        		  3820,
2785	EEB1	BITMAP1                       		  2791,
2807	EED2	BITMAP2                       		  2815,  2829,
2825	EEF6	BITMAP3                       		  2818,  2822,
0041	0020	BLANK                         		  0113,  0443,  0466,  0491,  0573,  0605,  0677,  0811,  0838,  0914,  0966,  0975,  0978,  1220,  1234,  1250,  1310,  1367,  1594,  1648,  1687,  1700,  1718,
4133	F5C4	BLKMASK                       		  2264,  3486,
4158	F5E5	BLKNMBR                       		  2091,  2098,  2239,  2245,  2258,  2270,  3424,  3479,  3484,  3493,
4132	F5C3	BLKSHFT                       		  2185,  2257,
4181	F600	BOOT                          		
0042	007B	BRACKETLEFT                   		  0279,
0043	007D	BRACKETRIGHT                  		
0028	0008	BS                            		  1592,  1655,  1703,  1765,

0053	005E	CARET                         		  1673,
0063	E000	CBASE                         		  0776,  0777,  1274,
1376	E7AB	CCPSTACK                      		  0704,  0728,
1391	E7EF	CDRIVE                        		  0261,  0269,  0297,  0324,  0416,  0539,  0719,  0743,  0884,  0897,  0900,  1240,
1962	EB0E	CHARBUF                       		  1562,  1603,  1618,
0462	E230	CHECK                         		  0553,  0567,  0585,  0599,
2527	ED9E	CHECKDIR                      		  2646,
2347	ECF7	CHECKSUM                      		  2534,
1393	E7F0	CHGDRV                        		  0520,  0544,  0746,  0804,  0880,  0893,  1151,  1175,  1236,  1290,  1368,
3086	F027	CHGNAM1                       		  3094,
3077	F016	CHGNAMES                      		  3952,
2244	EC84	CHKBLK                        		  3375,  3403,
1585	E914	CHKCHAR                       		  1573,  1670,
0377	E1C2	CHKCON                        		  0332,  0992,  1067,
2548	EDC4	CHKDIR1                       		  2541,
2497	ED8C	CHKNMBR                       		  2828,  3288,
2418	ED44	CHKROFL                       		  2957,  3089,
2351	ECFD	CHKSUM1                       		  2355,
4126	F5BD	CHKVECT                       		  2535,
2431	ED54	CHKWPRT                       		  2951,  3078,  3264,  3395,
2654	EE35	CKBITMAP                      		  2702,  2993,  3022,
2690	EE56	CKBMAP1                       		  2693,
1617	E942	CKCON1                        		  1611,
1619	E945	CKCON2                        		  1605,
1602	E923	CKCONSOL                      		  1632,  1942,
2598	EDF5	CKFILPOS                      		  2810,  2879,  2955,  3087,  3105,  3118,  3191,  3271,  3299,  3329,  3335,  3753,
2420	ED47	CKROF1                        		  3397,
4166	F5EC	CKSUMTBL                      		  2092,  2528,  2537,
0692	E358	CLEARBUF                      		  0065,
2465	ED72	CLEARS2                       		  3882,  3905,  3944,
0171	E0DA	CLOSE                         		  0322,  1127,
3888	F4A5	CLOSEFIL                      		  1486,
4143	F5D2	CLOSEFLG                      		  3253,  3297,  3312,
3179	F0A2	CLOSEIT                       		  3298,  3619,  3890,
3200	F0CD	CLOSEIT1                      		  3236,
3209	F0DB	CLOSEIT2                      		  3207,
3214	F0E1	CLOSEIT3                      		  3211,
3218	F0E8	CLOSEIT4                      		  3203,
3232	F0FD	CLOSEIT5                      		  3217,
3251	F117	CLOSEIT6                      		  3243,
3255	F11F	CLOSEIT7                      		  3216,  3225,  3230,
0768	E3C1	CMDADR                        		  0755,
0639	E310	CMDTBL                        		  0660,
0727	E382	CMMND1                        		  0340,  0457,  1015,  1019,  1342,  1371,
0739	E398	CMMND2                        		  0723,
0026	0003	CNTRLC                        		  1519,  1613,  1873,
0027	0005	CNTRLE                        		  1785,
0033	0010	CNTRLP                        		  1794,
0034	0012	CNTRLR                        		  1822,
0035	0013	CNTRLS                        		  1610,
0036	0015	CNTRLU                        		  1816,
0037	0018	CNTRLX                        		  1804,
0038	001A	CNTRLZ                        		  1064,
0048	003A	COLON                         		  0475,  0535,  0952,  0957,
2234	EC77	COMBLK                        		  3374,  3402,
1355	E783	COMFILE                       		  1256,
0703	E35C	COMMAND                       		  0064,
3694	F3A5	COMPRAND                      		  3757,  3788,
4184	F609	CONIN                         		  1567,  1609,  1612,  1914,
4185	F60C	CONOUT                        		  1635,  1701,  1704,  1909,
4183	F606	CONST                         		  1606,  1908,  1911,
0514	E260	CONVERT                       		  1295,
0507	E25E	CONVFST                       		  0744,  0803,  0910,  1007,  1039,  1090,  1149,  1171,  1289,  1365,
0538	E289	CONVRT1                       		  0530,
0542	E290	CONVRT2                       		  0536,
0550	E296	CONVRT3                       		  0541,
0552	E298	CONVRT4                       		  0565,
0560	E2A9	CONVRT5                       		  0557,
0563	E2AB	CONVRT6                       		  0559,
0566	E2AF	CONVRT7                       		  0570,
0571	E2B9	CONVRT8                       		  0554,  0575,
4149	F5D8	COUNTER                       		  2865,  2892,
0032	000D	CR                            		  0105,  1586,  1725,  1761,  1884,
0230	E109	CREATE                        		  1097,
0104	E098	CRLF                          		  0121,  0439,  0455,  0729,  0946,  1044,  1332,
1960	EB0C	CURPOS                        		  1644,  1689,  1714,  1746,  1771,  1809,  1849,

1994	EB4F	DE2HL                         		  2035,  2040,  2594,  3068,  3130,
1996	EB50	DE2HL1                        		  2003,
0802	E3F8	DECODE                        		  1088,  1215,
0809	E408	DECODE1                       		  0834,
0830	E42A	DECODE2                       		
0836	E433	DECODE3                       		  0812,  0843,
0841	E43A	DECODE4                       		
2569	EDDA	DEFDMA                        		  2559,  3494,  3876,  3972,
0039	007F	DEL                           		  1645,  1775,
0406	E1DD	DELBATCH                      		  0339,  0346,  0456,
0196	E0EF	DELETE                        		  0415,  1025,  1095,
3923	F4D7	DELFILE                       		  1489,
4124	F5B9	DIRBUF                        		  2033,  2349,  2441,  2576,  2590,  3468,
1910	EAE0	DIRC1                         		  1906,
1903	EAD4	DIRCIO                        		  1475,
2575	EDE0	DIRDMA                        		  2556,  2564,  3475,
2581	EDE3	DIRDMA1                       		  2571,
0909	E477	DIRECT                        		  0769,
0917	E488	DIRECT1                       		  0921,
0922	E48F	DIRECT2                       		  0915,
0927	E498	DIRECT3                       		  0995,
0955	E4CC	DIRECT4                       		  0945,
0959	E4D4	DIRECT5                       		  0954,
0962	E4D9	DIRECT6                       		  0986,  0988,
0989	E50E	DIRECT7                       		  0976,  0984,
0991	E50F	DIRECT8                       		  0938,
0996	E51B	DIRECT9                       		  0928,  0993,
2563	EDD4	DIRREAD                       		  2644,
4136	F5C8	DIRSIZE                       		  2407,  2623,
2554	EDC6	DIRWRITE                      		  2962,  3071,
4125	F5BB	DISKPB                        		  2036,  3997,
1543	E8E1	DISKRO                        		  1528,
0400	E1D8	DMASET                        		  0741,  1115,  1267,
0056	0024	DOLLAR                        		  1734,  2821,
2070	EBB2	DOREAD                        		  2565,  3379,
2076	EBB8	DOWRITE                       		  2558,  3483,  3503,
0977	E4F7	DRECT63                       		  0971,
0979	E4F9	DRECT65                       		  0967,
0877	E454	DSELECT                       		  0911,  1023,  1041,  1092,  1153,  1254,
0141	E0BD	DSKSEL                        		  0300,  0326,  0413,  0417,  0720,  0887,  0901,  1242,  1341,
4135	F5C6	DSKSIZE                       		  2041,  2752,  2770,  3011,

4111	F5AC	EMPTYFCB                      		  3267,
0019	0005	ENTRY                         		  0091,  0137,  0144,  0150,  0198,  0204,  0239,  0251,  0350,  0379,  0383,  0391,  0402,
0149	E0C3	ENTRY1                        		  0159,  0173,  0180,  0186,  0232,
0203	E0F4	ENTRY2                        		  0213,  0226,
0045	003D	EQUALS                        		  0469,  1163,
2954	EFA4	ERAFIL1                       		  2964,
2950	EF9C	ERAFILE                       		  3925,
1006	E51F	ERASE                         		  0769,
1022	E542	ERASE1                        		  1009,
1516	E899	ERROR1                        		  1419,
1523	E8A5	ERROR2                        		  1420,
1527	E8AB	ERROR3                        		  1421,
1531	E8B1	ERROR4                        		  1422,
1534	E8B4	ERROR5                        		  1525,  1529,
1205	E682	EXISTS                        		  1202,
2213	EC5E	EXTBLK                        		  2238,  3413,
2224	EC71	EXTBLK1                       		  2220,
4134	F5C5	EXTMASK                       		  2303,  2845,  3310,
0866	E44B	EXTRACT                       		  0936,  0964,  0973,

1387	E7CD	FCB                           		  0165,  0166,  0191,  0218,  0515,  0666,  0807,  0879,  0912,  1024,  1093,  1100,  1116,  1126,  1156,  1157,  1185,  1189,  1219,  1233,  1248,  1268,  1293,  1298,  1300,  1302,  1366,
2440	ED5E	FCB2HL                        		  2419,  2723,  2812,  2891,  2958,  3066,  3125,  3194,  3755,
4160	F5E9	FCBPOS                        		  2442,  2639,
3052	EFFD	FCBSET                        		  3289,
3943	F4EC	FCREATE                       		  1492,
0031	000C	FF                            		
4161	F5EA	FILEPOS                       		  2088,  2484,  2599,  2611,  2625,  2627,  2632,  2929,  3182,  3183,
1542	E8DC	FILERO                        		  1532,
4031	F54D	FILESIZE                      		  1505,
2862	EF18	FINDFST                       		  2953,  3080,  3103,  3117,  3190,  3270,  3328,  3742,  3909,
2876	EF2D	FINDNXT                       		  2910,  2917,  2963,  3093,  3110,  3776,  3918,
2890	EF4A	FNDNXT1                       		  2885,
2895	EF53	FNDNXT2                       		  2927,
2912	EF73	FNDNXT3                       		  2907,
2922	EF7C	FNDNXT4                       		  2901,  2904,  2911,
2928	EF83	FNDNXT5                       		  2898,
2942	EF94	FNDNXT6                       		  2880,  2889,
2986	EFC0	FNDSPA1                       		  3027,  3046,
3010	EFD1	FNDSPA2                       		  2989,
3032	EFEC	FNDSPA3                       		  2995,  3024,
3043	EFF4	FNDSPA4                       		  3016,
2979	EFBE	FNDSPACE                      		  3417,
4145	F5D4	FNDSTAT                       		  2834,  2864,  2932,
1512	0028	FUNCTIONCOUNT                 		  1449,
1468	E847	FUNCTIONVECTOR                		  1512,  1452,

3976	F511	GETALOC                       		  1497,
1362	E786	GETBACK                       		  0998,  1028,  1065,  1068,  1075,  1138,  1191,  1197,  1204,  1352,
1364	E789	GETBACK1                      		  1223,  1238,  1243,
2188	EC45	GETBLK1                       		  2192,
2198	EC53	GETBLK2                       		  2203,
2204	EC5C	GETBLK3                       		  2200,
2184	EC3E	GETBLOCK                      		  2235,  3406,
1561	E8FB	GETCHAR                       		  1572,  1757,
1889	EAC8	GETCON                        		  1470,
3963	F504	GETCRNT                       		  1495,
1941	EAFE	GETCSTS                       		  1480,
0389	E1D0	GETDSK                        		  0730,  0742,  0948,
1571	E906	GETECHO                       		  1890,
3263	F124	GETEMPTY                      		  3334,  3641,  3946,
0579	E2C0	GETEXT                        		  0568,
0584	E2C8	GETEXT1                       		  0597,
0592	E2D9	GETEXT2                       		  0589,
0595	E2DB	GETEXT3                       		  0591,
0598	E2DF	GETEXT4                       		  0602,
0603	E2E9	GETEXT5                       		  0582,  0586,  0607,
0608	E2F0	GETEXT6                       		  0600,
0610	E2F2	GETEXT7                       		  0614,
0623	E301	GETEXT8                       		  0631,
0629	E309	GETEXT9                       		  0627,
3896	F4AB	GETFST                        		  1487,
3908	F4C2	GETFST1                       		  3901,
0288	E139	GETINP                        		  0735,  1012,
0345	E196	GETINP1                       		  0291,  0303,  0309,  0323,
0355	E1A7	GETINP2                       		  0333,
0358	E1AB	GETINP3                       		  0367,
0368	E1BA	GETINP4                       		  0362,
1919	EAED	GETIOB                        		  1476,
3957	F4FE	GETLOG                        		  1494,
3280	F146	GETMT1                        		  3284,
3295	F15A	GETNEXT                       		  3367,  3535,
3914	F4C8	GETNXT                        		  1488,
3996	F526	GETPARM                       		  1501,
3998	F529	GETPRM1                       		  3959,  3978,  3984,
1895	EACE	GETRDR                        		  1472,
3982	F517	GETROV                        		  1499,
2456	ED69	GETS2                         		  2466,  2473,  3186,  3524,  3658,
0249	E115	GETSETUC                      		  0713,  1222,
4006	F52D	GETUSER                       		  1502,
0243	E113	GETUSR                        		  0256,
3862	F47E	GETVER                        		  1481,
2389	ED1E	GETWPRT                       		  2432,  3184,
0051	003E	GRTTHAN                       		  0481,  0733,
3316	F183	GTNEXT1                       		  3308,
3326	F18E	GTNEXT2                       		  3314,
3338	F1AC	GTNEXT3                       		  3315,  3330,
3340	F1AF	GTNEXT4                       		  3337,
3348	F1B6	GTNEXT5                       		  3322,  3333,  3336,

0774	E3CF	HALT                          		  0429,
0855	E442	HL2DE                         		  0316,  0861,  1159,  1304,
4189	F618	HOME                          		  2056,
2055	EBA1	HOMEDRV                       		  2801,  2870,

0071	E006	INBUFF                        		  0081,  0313,  0330,  0349,  0356,  0370,  0694,  0721,  1013,  1305,
0080	E088	INPOINT                       		  0371,  0521,  0616,  1021,  1160,  1170,
0017	0003	IOBYTE                        		  1920,  1926,
1954	EB05	IOERR1                        		  3349,  3385,  3401,
2078	EBBB	IORET                         		  2072,

1985	EB4A	JUMPHL                        		  2082,  2427,  2435,

0050	003C	LESSTH                        		  0479,
0030	000A	LF                            		  0107,  1588,  1660,  1727,  1763,
4186	F60F	LIST                          		  1474,  1640,
2256	EC8A	LOGICAL                       		  3377,  3451,
2259	EC90	LOGICL1                       		  2262,
4113	F5AF	LOGIN                         		  3803,  3815,  3819,  3871,  3958,  4048,  4056,
3802	F421	LOGINDRV                      		  3830,  3877,
4041	F553	LOGOFF                        		  1507,
4159	F5E7	LOGSECT                       		  2263,  3476,

0015	0040	MEM                           		  0061,
4146	F5D5	MODE                          		  2314,  3356,  3391,  3452,  3531,  3565,  4099,
2483	ED7F	MOREFLS                       		  2498,  2544,  2887,
0850	E440	MOVE3                         		  1257,
0268	E129	MOVECD                        		  0351,  1241,  1340,
2589	EDE9	MOVEDIR                       		  3910,  3919,
3161	F094	MOVEWORD                      		  3219,  3221,

0082	E08A	NAMEPNT                       		  0440,  0525,
1395	E7F1	NBYTES                        		  1045,  1048,
1709	E9B1	NEWLINE                       		  1818,  1826,
1713	E9B9	NEWLN1                        		  1720,
0794	E3F0	NOFILE                        		  0792,
0487	E24F	NONBLANK                      		  0494,  0523,  1162,
0791	E3EA	NONE                          		  0926,  1027,  1196,
1139	E607	NOSPACE                       		  1134,
0638	0006	NUMCMDS                       		  0664,
2631	EE19	NXENT1                        		  2629,
2635	EE20	NXENT2                        		  2638,
2622	EE05	NXENTRY                       		  2809,  2878,

4139	F5CE	OFFSET                        		  2152,
4153	F5DF	OLDDRV                        		  3847,  4078,
0157	E0CB	OPEN                          		  0167,  0302,
0163	E0D0	OPENFCB                       		  1042,  1258,
3881	F49C	OPENFIL                       		  1485,
3115	F051	OPENIT                        		  3632,  3884,
3120	F05A	OPENIT1                       		  3339,
3149	F08B	OPENIT2                       		  3145,  3147,
1627	E948	OUTCHAR                       		  1674,  1685,  1688,  1711,  1719,  1726,  1728,  1885,
1642	E962	OUTCHR1                       		  1630,
1659	E979	OUTCHR2                       		  1656,
1682	E990	OUTCON                        		  1471,  1577,  1671,  1739,
1686	E996	OUTCON1                       		  1692,
1724	E9C9	OUTCRLF                       		  1549,  1712,  1789,
1958	EB0A	OUTFLAG                       		  1628,  1772,  1846,  1851,  1854,

4147	F5D6	PARAME                        		  1437,  3825,  3843,  4007,  4079,
1975	EB43	PARAMSDE                      		  1434,  1460,  1748,  2214,  2276,  2285,  2457,  2867,  3063,  3081,  3127,  3150,  3197,  3265,  3268,  3273,  3301,  3396,  3426,  3571,  3743,  3786,  3839,  3855,  3916,  4042,  4072,
0650	E328	PATTRN1                       		  0423,
1405	E800	PATTRN2                       		  0424,
0047	002E	PERIOD                        		  0473,  0581,
0119	E0A7	PLINE                         		  0784,  0793,  1011,  1135,  1203,  1351,
0123	E0AC	PLINE2                        		  0131,  0331,
3563	F303	POSITION                      		  3674,  3682,
3569	F307	POSITN1                       		  4101,
3616	F347	POSITN2                       		  3606,
3649	F37F	POSITN3                       		  3612,  3635,
3656	F384	POSITN4                       		  3625,  3640,  3645,
3664	F38B	POSITN5                       		  3598,
0055	0023	POUNDSN                       		  1710,
0088	E08C	PRINT                         		  0097,  0129,  0448,  0454,  0732,  0734,  1066,
0095	E092	PRINTB                        		  0106,  0108,  0114,  0951,  0953,  0958,  0980,
4196	F62D	PRSTAT                        		
1547	E8E5	PRTERR                        		  1518,  1535,
1961	EB0D	PRTFLAG                       		  1638,  1797,
1732	E9D3	PRTMESG                       		  1554,  1556,  1741,  1937,
1933	EAF8	PRTSTR                        		  1478,
4187	F612	PUNCH                         		  1473,
3969	F50A	PUTDMA                        		  1496,

0044	003F	QMARK                         		  0453,  0558,  0590,  0626,  0918,  2900,  3900,  3904,

3752	F3E4	RANSIZ1                       		  3777,
3775	F406	RANSIZ2                       		  3769,
3778	F40C	RANSIZ3                       		  3754,
3740	F3D2	RANSIZE                       		  4033,
1753	E9EF	RDBUF1                        		  1769,  1779,  1802,  1880,
1824	EA70	RDBUF10                       		  1773,
1831	EA78	RDBUF11                       		  1843,
1844	EA8A	RDBUF12                       		  1834,
1852	EA99	RDBUF13                       		  1856,
1861	EAA6	RDBUF14                       		  1823,
1865	EAA9	RDBUF15                       		  1783,
1878	EABD	RDBUF16                       		  1875,
1881	EAC1	RDBUF17                       		  1762,  1764,
1756	E9F1	RDBUF2                        		  1792,  1848,  1857,
1774	EA16	RDBUF3                        		  1766,
1784	EA26	RDBUF4                        		  1776,
1793	EA37	RDBUF5                        		  1786,
1803	EA48	RDBUF6                        		  1795,
1807	EA4E	RDBUF7                        		  1814,
1815	EA5F	RDBUF8                        		  1805,
1821	EA6B	RDBUF9                        		  1817,
1745	E9E1	RDBUFF                        		  1479,  1811,  1820,
0785	E3DF	RDERR                         		  0783,
0782	E3D9	RDERROR                       		  1076,
4019	F541	RDRANDOM                      		  1503,
0211	E0F9	RDREC                         		  0219,  0308,  1269,
3354	F1BC	RDSEQ                         		  3933,
3357	F1C1	RDSEQ1                        		  3675,
3373	F1E6	RDSEQ2                        		  3364,
3384	F1FB	RDSEQ3                        		  3366,  3372,  3376,
4144	F5D3	RDWRTFLG                      		  3331,  3359,  3394,
4194	F627	READ                          		  2071,
4188	F615	READER                        		  1896,
0217	E0FE	READFCB                       		  1054,
3672	F393	READRAN                       		  4021,
3931	F4E0	READSEQ                       		  1490,
4148	F5D7	RELBLOCK                      		  3407,  3431,
0237	E10E	RENAM                         		  1190,
1148	E610	RENAME                        		  0770,
1167	E63F	RENAME1                       		  1164,
1182	E659	RENAME2                       		  1178,
1186	E65E	RENAME3                       		
1195	E66D	RENAME4                       		  1188,
1198	E673	RENAME5                       		  1166,  1172,  1181,
1201	E679	RENAME6                       		  1155,
3950	F4F5	RENFILE                       		  1493,
0135	E0B8	RESDSK                        		  0714,
0892	E466	RESETDR                       		  1078,  1199,  1288,  1347,  1363,
1949	EB04	RETURN                        		  1508,  1509,
1421	E80D	RODISK                        		  2434,
1422	E80F	ROFILE                        		  2426,
3868	F483	RSTDSK                        		  1483,
1389	E7EE	RTNCODE                       		  0151,  0929,

2842	EF07	SAMEXT                        		  2915,
3104	F040	SAVATR1                       		  3111,
1087	E5AD	SAVE                          		  0769,
1106	E5D4	SAVE1                         		  1121,
1125	E5F1	SAVE2                         		  1109,
1133	E5FB	SAVE3                         		  1098,  1120,
1136	E601	SAVE4                         		  1129,
3101	F03B	SAVEATTR                      		  3990,
4150	F5D9	SAVEFCB                       		  2868,  2881,  3915,
4156	F5E2	SAVEXT                        		  2197,  2305,
4157	F5E3	SAVNREC                       		  2187,  2266,  2298,  2320,  3361,  3369,  3399,  3505,  3541,
4155	F5E1	SAVNXT                        		  2301,  2324,  3362,  3506,
4118	F5B3	SCRATCH1                      		  2022,  2410,  2486,  2802,
4119	F5B5	SCRATCH2                      		  2025,  2058,  2106,  2158,
4120	F5B7	SCRATCH3                      		  2028,  2062,  2102,  2163,
0659	E32E	SEARCH                        		  0749,
0662	E333	SEARCH1                       		  0687,
0668	E33C	SEARCH2                       		  0675,
0681	E34F	SEARCH3                       		  0671,  0684,
0685	E354	SEARCH4                       		  0678,
4131	F5C1	SECTORS                       		  2038,  2118,  2130,
4197	F630	SECTRN                        		  2176,
4190	F61B	SELDSK                        		  2010,
2007	EB59	SELECT                        		  3809,
2048	EB9D	SELECT1                       		  2046,
0049	003B	SEMIC                         		  0477,
3988	F51D	SETATTR                       		  1500,
2371	ED0B	SETBIT                        		  2405,  3818,
0255	E11A	SETCDRV                       		  0347,  1334,
2519	ED9C	SETDIR                        		  2555,
4193	F624	SETDMA                        		  2585,
3824	F445	SETDSK                        		  1484,  3852,  4080,
2275	ECA6	SETEXT                        		  2302,  3121,  3902,
2722	EE6B	SETFILE                       		  2827,  2961,
2728	EE75	SETFL1                        		  2762,
2741	EE88	SETFL2                        		  2735,
2748	EE8E	SETFL3                        		  2740,
2758	EE9D	SETFL4                        		  2751,
2284	ECAE	SETHLDE                       		  2296,  2313,
1925	EAF3	SETIOB                        		  1477,
2312	ECD2	SETNREC                       		  3380,  3534,  3545,
3785	F40E	SETRAN                        		  1506,
2472	ED78	SETS2B7                       		  3131,  3290,  3350,  3668,
4192	F621	SETSEC                        		  2179,
1947	EB01	SETSTAT                       		  1891,  1897,  1915,  1921,  1956,  2835,  2945,  3343,  3422,  3652,  3864,  3965,  4011,
4191	F61E	SETTRK                        		  2156,
4012	F53B	SETUSER                       		  4009,
2360	ED04	SHIFTL                        		  2376,
2362	ED05	SHIFTL1                       		  2366,
2330	ECEA	SHIFTR                        		  2090,  2393,  2772,  3806,
2332	ECEB	SHIFTR1                       		  2342,
1668	E97F	SHOWIT                        		  1840,  1869,
1980	EB47	SLCTERR                       		  3811,
0112	E0A2	SPACE                         		  0956,  0960,  0987,
0190	E0E9	SRCHFCB                       		  0925,  1154,  1187,
0178	E0DF	SRCHFST                       		  0192,
0184	E0E4	SRCHNXT                       		  0994,
1959	EB0B	STARTING                      		  1715,  1747,  1791,  1808,
1976	EB45	STATUS                        		  1439,  1948,  2824,  2931,  3181,  3256,  3370,  3447,  3536,  3623,  3633,  3643,  3667,  3999,  4084,
2700	EE5C	STBITMAP                      		  2757,
2712	EE64	STBMAP1                       		  2715,  3035,
0395	E1D5	STDDMA                        		  1137,  1333,
2609	EDFE	STFILPOS                      		  2630,  2806,  2869,  2943,
2318	ECDE	STNREC1                       		  2316,
2295	ECBB	STRDATA                       		  3341,  3360,  3398,
2833	EF01	STSTATUS                      		  3926,  3953,  3991,
2508	ED95	SUBHL                         		  2531,  2628,
0438	E209	SYNERR                        		  0467,  0745,  0806,  0816,  0820,  0826,  0828,  0831,  0839,  1040,  1079,  1091,  1150,  1200,  1217,  1221,  1251,  1348,  1370,
0441	E20F	SYNERR1                       		  0451,
0452	E222	SYNERR2                       		  0444,  0446,

0029	0009	TAB                           		  1590,  1684,
0022	0100	TBASE                         		  1105,  1263,  1335,
0021	0080	TBUFF                         		  0314,  0396,  0740,  0867,  1061,  1319,  1331,  3874,
0018	0004	TDRIVE                        		  0263,  0270,
0020	005C	TFCB                          		  1301,
2087	EBC3	TRKSEC                        		  2643,  3070,
2097	EBD1	TRKSEC1                       		  3378,  3481,  3500,
2111	EBE4	TRKSEC2                       		  2127,
2128	EBFA	TRKSEC3                       		  2116,  2141,
2146	EC0F	TRKSEC4                       		  2132,  2137,
1038	E55D	TYPE                          		  0769,
1047	E574	TYPE1                         		  1069,
1049	E577	TYPE2                         		
1059	E587	TYPE3                         		  1052,
1073	E5A0	TYPE4                         		  1056,
1077	E5A7	TYPE5                         		  1043,

1231	E6A5	UNKNOWN                       		  0748,  0770,
1349	E771	UNKWN0                        		  1279,  1287,
1247	E6C4	UNKWN1                        		  1235,
1252	E6CD	UNKWN2                        		
1264	E6E1	UNKWN3                        		  1280,
1284	E701	UNKWN4                        		  1270,
1306	E730	UNKWN5                        		  1313,
1317	E73E	UNKWN6                        		  1309,  1311,
1320	E743	UNKWN7                        		  1328,
1329	E74F	UNKWN8                        		  1324,
1346	E76B	UNKWN9                        		  1259,
3060	F001	UPDATE                        		  3092,  3109,
3069	F010	UPDATE1                       		  3254,
0276	E130	UPPER                         		  0364,
0046	005F	USCORE                        		  0471,  1165,
1214	E68E	USER                          		  0770,
4114	F5B1	USERDMA                       		  2570,  2592,  3875,  3971,
1973	EB41	USERNO                        		  2816,  3854,  4010,  4014,
1966	EB0F	USERSTACK                     		  1441,  4082,

0422	E1F5	VERIFY                        		  1232,
0426	E1FD	VERIFY1                       		  0433,

4182	F603	WBOOT                         		  1469,
4195	F62A	WRITE                         		  2077,
3680	F39C	WRITERAN                      		  4027,
4112	F5AD	WRTPRT                        		  2390,  2401,  2406,  3870,  3983,  4054,  4063,
2400	ED2C	WRTPRTD                       		  1498,  2546,
0224	E104	WRTREC                        		  1117,
3937	F4E6	WRTSEQ                        		  1491,
4025	F547	WTRANDOM                      		  1504,
3389	F1FE	WTSEQ                         		  3939,
3392	F203	WTSEQ1                        		  3683,  4102,
3516	F2D2	WTSEQ10                       		  3508,
3542	F2FE	WTSEQ11                       		  3539,
3544	F300	WTSEQ12                       		  3530,  3533,
3416	F23B	WTSEQ2                        		  3410,
3423	F248	WTSEQ3                        		  3420,
3436	F264	WTSEQ4                        		  3432,
3444	F26C	WTSEQ5                        		  3435,
3446	F26E	WTSEQ6                        		  3405,
3470	F28C	WTSEQ7                        		  3474,
3478	F29A	WTSEQ8                        		  3491,
3499	F2BB	WTSEQ9                        		  3455,  3466,
3528	F2DF	WTSEQ99                       		
4096	F59B	WTSPECL                       		  1510,

4140	F5D0	XLATE                         		  2032,  2174,

1029	E552	YESNO                         		  1010,
