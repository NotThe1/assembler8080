0001: 0000                                    
0002: 0000                ;**************************************************************
0003: 0000                ;*                  
0004: 0000                ;*             C P / M   version   2 . 2
0005: 0000                ;*                  
0006: 0000                ;*   Reconstructed from memory image on February 27, 1981
0007: 0000                ;*                  
0008: 0000                ;*                by Clark A. Calkins
0009: 0000                ;*                  
0010: 0000                ;**************************************************************
0011: 0000                ;                   
0012: 0000                ;   Set memory limit here. This is the amount of contiguous
0013: 0000                ; ram starting from 0000. CP/M will reside at the end of this space.
0014: 0000                ;                   
0015: 0000                MEM	EQU	64	;for a 64k system 
0016: 0000                ;                   
0017: 0000                IOBYTE	EQU	3	;i/o definition byte.
0018: 0000                TDRIVE	EQU	4	;current drive name and user number.
0019: 0000                ENTRY	EQU	5	;entry point for the cp/m bdos.
0020: 0000                TFCB	EQU	5CH	;default file control block.
0021: 0000                Pg0Buffer	EQU	80H	;i/o buffer and command line storage.
0022: 0000                TBASE	EQU	100H	;transiant program storage area.
0023: 0000                ;                   
0024: 0000                ;   Set control character equates.
0025: 0000                ;                   
0026: 0000                CNTRLC	EQU	3	;control-c
0027: 0000                CNTRLE	EQU	05H	;control-e
0028: 0000                BS	EQU	08H	;backspace
0029: 0000                TAB	EQU	09H	;tab    
0030: 0000                LF	EQU	0AH	;line feed
0031: 0000                FF	EQU	0CH	;form feed
0032: 0000                CR	EQU	0DH	;carriage return
0033: 0000                CNTRLP	EQU	10H	;control-p
0034: 0000                CNTRLR	EQU	12H	;control-r
0035: 0000                CNTRLS	EQU	13H	;control-s
0036: 0000                CNTRLU	EQU	15H	;control-u
0037: 0000                CNTRLX	EQU	18H	;control-x
0038: 0000                CNTRLZ	EQU	1AH	;control-z (end-of-file mark)
0039: 0000                DEL	EQU	7FH	;rubout 
0040: 0000                ;                   
0041: 0000                BLANK	EQU	020H	; Space/Blank
0042: 0000                BRACKETLEFT		EQU	07BH	; {
0043: 0000                BRACKETRIGHT	EQU	07DH	; }
0044: 0000                QMARK	EQU		03FH		; ?
0045: 0000                EQUALS	EQU		03DH		; =
0046: 0000                USCORE	EQU		05FH		; _
0047: 0000                PERIOD	EQU		02EH		; .
0048: 0000                COLON	EQU		03AH		; :
0049: 0000                SEMIC	EQU		03BH		; ;
0050: 0000                LESSTH	EQU		03CH		; <
0051: 0000                GRTTHAN	EQU		03EH		; >
0052: 0000                ASTRK	EQU		02AH		; *
0053: 0000                CARET	EQU		05EH		; ^
0054: 0000                ATSIGN	EQU		040H		; @
0055: 0000                POUNDSN	EQU		023H		; #
0056: 0000                DOLLAR	EQU		024H		; $
0057: 0000                                    
0058: 0000                ;                   
0059: 0000                ;   Set origin for CP/M
0060: 0000                ;                   
0061: 0000                	ORG	(MEM-8)*1024   
0062: E000                CodeStart:          
0063: E000                ;                   
0064: E000                CBASE:              
0065: E000     C35CE3     	JMP	COMMAND	;execute command processor (ccp).
0066: E003     C358E3     	JMP	CLEARBUF	;entry to empty input buffer before starting ccp.
0067: E006                                    
0068: E006                ;                   
0069: E006                ;   Standard cp/m ccp input buffer. Format is (max length),
0070: E006                ; (actual length), (char #1), (char #2), (char #3), etc.
0071: E006                ;                   
0072: E006                INBUFF:             
0073: E006     7F         	DB	127	;length of input buffer.
0074: E007     00         	DB	0	;current length of contents.
0075: E008     434F50595249474854 	DB	'Copyright'     
0076: E011     203139373920284329204259204449474954414C205245534541524348202020202020 	DB	' 1979 (c) by Digital Research      '
0077: E034     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0078: E04B     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0079: E062     0000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0080: E079     000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0081: E088                INPOINT:            
0082: E088     08E0       	DW	INBUFF+2;input line pointer
0083: E08A                NAMEPNT:            
0084: E08A     0000       	DW	0	;input line pointer used for error message. Points to
0085: E08C                ;			;start of name in error.
0086: E08C                ;                   
0087: E08C                ;   Routine to print (A) on the console. All registers used.
0088: E08C                ;                   
0089: E08C                PRINT:              
0090: E08C     5F         	MOV	E,A	;setup bdos call.
0091: E08D     0E02       	MVI	C,2            
0092: E08F     C30500     	JMP	ENTRY          
0093: E092                ;                   
0094: E092                ;   Routine to print (A) on the console and to save (BC).
0095: E092                ;                   
0096: E092                PRINTB:             
0097: E092     C5         	PUSH	B             
0098: E093     CD8CE0     	CALL	PRINT         
0099: E096     C1         	POP	B              
0100: E097     C9         	RET                
0101: E098                ;                   
0102: E098                ;   Routine to send a carriage return, line feed combination
0103: E098                ; to the console.   
0104: E098                ;                   
0105: E098                CRLF:               
0106: E098     3E0D       	MVI	A,CR           
0107: E09A     CD92E0     	CALL	PRINTB        
0108: E09D     3E0A       	MVI	A,LF           
0109: E09F     C392E0     	JMP	PRINTB         
0110: E0A2                ;                   
0111: E0A2                ;   Routine to send one space to the console and save (BC).
0112: E0A2                ;                   
0113: E0A2                SPACE:              
0114: E0A2     3E20       	MVI	A,BLANK		; blank/Space
0115: E0A4     C392E0     	JMP	PRINTB         
0116: E0A7                ;                   
0117: E0A7                ;   Routine to print character string pointed to be (BC) on the
0118: E0A7                ; console. It must terminate with a null byte.
0119: E0A7                ;                   
0120: E0A7                PLINE:              
0121: E0A7     C5         	PUSH	B             
0122: E0A8     CD98E0     	CALL	CRLF          
0123: E0AB     E1         	POP	H              
0124: E0AC                PLINE2:             
0125: E0AC     7E         	MOV	A,M            
0126: E0AD     B7         	ORA	A              
0127: E0AE     C8         	RZ                 
0128: E0AF     23         	INX	H              
0129: E0B0     E5         	PUSH	H             
0130: E0B1     CD8CE0     	CALL	PRINT         
0131: E0B4     E1         	POP	H              
0132: E0B5     C3ACE0     	JMP	PLINE2         
0133: E0B8                ;                   
0134: E0B8                ;   Routine to reset the disk system.
0135: E0B8                ;                   
0136: E0B8                RESDSK:             
0137: E0B8     0E0D       	MVI	C,13           
0138: E0BA     C30500     	JMP	ENTRY          
0139: E0BD                ;                   
0140: E0BD                ;   Routine to select disk (A).
0141: E0BD                ;                   
0142: E0BD                DSKSEL:             
0143: E0BD     5F         	MOV	E,A            
0144: E0BE     0E0E       	MVI	C,14           
0145: E0C0     C30500     	JMP	ENTRY          
0146: E0C3                ;                   
0147: E0C3                ;   Routine to call bdos and save the return code. The zero
0148: E0C3                ; flag is set on a return of 0ffh.
0149: E0C3                ;                   
0150: E0C3                ENTRY1:             
0151: E0C3     CD0500     	CALL	ENTRY         
0152: E0C6     32EEE7     	STA	RTNCODE	;save return code.
0153: E0C9     3C         	INR	A	;set zero if 0ffh returned.
0154: E0CA     C9         	RET                
0155: E0CB                ;                   
0156: E0CB                ;   Routine to open a file. (DE) must point to the FCB.
0157: E0CB                ;                   
0158: E0CB                OPEN:               
0159: E0CB     0E0F       	MVI	C,15           
0160: E0CD     C3C3E0     	JMP	ENTRY1         
0161: E0D0                ;                   
0162: E0D0                ;   Routine to open file at (FCB).
0163: E0D0                ;                   
0164: E0D0                OPENFCB:            
0165: E0D0     AF         	XRA	A	;clear the record number byte at fcb+32
0166: E0D1     32EDE7     	STA	FCB+32         
0167: E0D4     11CDE7     	LXI	D,FCB          
0168: E0D7     C3CBE0     	JMP	OPEN           
0169: E0DA                ;                   
0170: E0DA                ;   Routine to close a file. (DE) points to FCB.
0171: E0DA                ;                   
0172: E0DA                CLOSE:              
0173: E0DA     0E10       	MVI	C,16           
0174: E0DC     C3C3E0     	JMP	ENTRY1         
0175: E0DF                ;                   
0176: E0DF                ;   Routine to search for the first file with ambigueous name
0177: E0DF                ; (DE).             
0178: E0DF                ;                   
0179: E0DF                SRCHFST:            
0180: E0DF     0E11       	MVI	C,17           
0181: E0E1     C3C3E0     	JMP	ENTRY1         
0182: E0E4                ;                   
0183: E0E4                ;   Search for the next ambigeous file name.
0184: E0E4                ;                   
0185: E0E4                SRCHNXT:            
0186: E0E4     0E12       	MVI	C,18           
0187: E0E6     C3C3E0     	JMP	ENTRY1         
0188: E0E9                ;                   
0189: E0E9                ;   Search for file at (FCB).
0190: E0E9                ;                   
0191: E0E9                SRCHFCB:            
0192: E0E9     11CDE7     	LXI	D,FCB          
0193: E0EC     C3DFE0     	JMP	SRCHFST        
0194: E0EF                ;                   
0195: E0EF                ;   Routine to delete a file pointed to by (DE).
0196: E0EF                ;                   
0197: E0EF                DELETE:             
0198: E0EF     0E13       	MVI	C,19           
0199: E0F1     C30500     	JMP	ENTRY          
0200: E0F4                ;                   
0201: E0F4                ;   Routine to call the bdos and set the zero flag if a zero
0202: E0F4                ; status is returned.
0203: E0F4                ;                   
0204: E0F4                ENTRY2:             
0205: E0F4     CD0500     	CALL	ENTRY         
0206: E0F7     B7         	ORA	A	;set zero flag if appropriate.
0207: E0F8     C9         	RET                
0208: E0F9                ;                   
0209: E0F9                ;   Routine to read the next record from a sequential file.
0210: E0F9                ; (DE) points to the FCB.
0211: E0F9                ;                   
0212: E0F9                RDREC:              
0213: E0F9     0E14       	MVI	C,20           
0214: E0FB     C3F4E0     	JMP	ENTRY2         
0215: E0FE                ;                   
0216: E0FE                ;   Routine to read file at (FCB).
0217: E0FE                ;                   
0218: E0FE                READFCB:            
0219: E0FE     11CDE7     	LXI	D,FCB          
0220: E101     C3F9E0     	JMP	RDREC          
0221: E104                ;                   
0222: E104                ;   Routine to write the next record of a sequential file.
0223: E104                ; (DE) points to the FCB.
0224: E104                ;                   
0225: E104                WRTREC:             
0226: E104     0E15       	MVI	C,21           
0227: E106     C3F4E0     	JMP	ENTRY2         
0228: E109                ;                   
0229: E109                ;   Routine to create the file pointed to by (DE).
0230: E109                ;                   
0231: E109                CREATE:             
0232: E109     0E16       	MVI	C,22           
0233: E10B     C3C3E0     	JMP	ENTRY1         
0234: E10E                ;                   
0235: E10E                ;   Routine to rename the file pointed to by (DE). Note that
0236: E10E                ; the new name starts at (DE+16).
0237: E10E                ;                   
0238: E10E                RENAM:              
0239: E10E     0E17       	MVI	C,23           
0240: E110     C30500     	JMP	ENTRY          
0241: E113                ;                   
0242: E113                ;   Get the current user code.
0243: E113                ;                   
0244: E113                GETUSR:             
0245: E113     1EFF       	MVI	E,0FFH         
0246: E115                ;                   
0247: E115                ;   Routine to get or set the current user code.
0248: E115                ; If (E) is FF then this is a GET, else it is a SET.
0249: E115                ;                   
0250: E115                GETSETUC:           
0251: E115     0E20       MVI	C,32            
0252: E117     C30500     	JMP	ENTRY          
0253: E11A                ;                   
0254: E11A                ;   Routine to set the current drive byte at (TDRIVE).
0255: E11A                ;                   
0256: E11A                SETCDRV:            
0257: E11A     CD13E1     	CALL	GETUSR	;get user number
0258: E11D     87         	ADD	A	;and shift into the upper 4 bits.
0259: E11E     87         	ADD	A              
0260: E11F     87         	ADD	A              
0261: E120     87         	ADD	A              
0262: E121     21EFE7     	LXI	H,CDRIVE;now add in the current drive number.
0263: E124     B6         	ORA	M              
0264: E125     320400     	STA	TDRIVE	;and save.
0265: E128     C9         	RET                
0266: E129                ;                   
0267: E129                ;   Move currently active drive down to (TDRIVE).
0268: E129                ;                   
0269: E129                MOVECD:             
0270: E129     3AEFE7     	LDA	CDRIVE         
0271: E12C     320400     	STA	TDRIVE         
0272: E12F     C9         	RET                
0273: E130                ;                   
0274: E130                ;   Routine to convert (A) into upper case ascii. Only letters
0275: E130                ; are affected.     
0276: E130                ;                   
0277: E130                UPPER:              
0278: E130     FE61       	CPI	061H	; 'a'	;check for letters in the range of 'a' to 'z'.
0279: E132     D8         	RC                 
0280: E133     FE7B       	CPI	BRACKETLEFT		;'{'
0281: E135     D0         	RNC                
0282: E136     E65F       	ANI	5FH	;convert it if found.
0283: E138     C9         	RET                
0284: E139                ;                   
0285: E139                ;   Routine to get a line of input. We must check to see if the
0286: E139                ; user is in (BATCH) mode. If so, then read the input from file
0287: E139                ; ($$$.SUB). At the end, reset to console input.
0288: E139                ;                   
0289: E139                GETINP:             
0290: E139     3AABE7     	LDA	BATCH	;if =0, then use console input.
0291: E13C     B7         	ORA	A              
0292: E13D     CA96E1     	JZ	GETINP1         
0293: E140                ;                   
0294: E140                ;   Use the submit file ($$$.sub) which is prepared by a
0295: E140                ; SUBMIT run. It must be on drive (A) and it will be deleted
0296: E140                ; if and error occures (like eof).
0297: E140                ;                   
0298: E140     3AEFE7     	LDA	CDRIVE	;select drive 0 if need be.
0299: E143     B7         	ORA	A              
0300: E144     3E00       	MVI	A,0	;always use drive A for submit.
0301: E146     C4BDE0     	CNZ	DSKSEL	;select it if required.
0302: E149     11ACE7     	LXI	D,BATCHFCB     
0303: E14C     CDCBE0     	CALL	OPEN	;look for it.
0304: E14F     CA96E1     	JZ	GETINP1	;if not there, use normal input.
0305: E152     3ABBE7     	LDA	BATCHFCB+15;get last record number+1.
0306: E155     3D         	DCR	A              
0307: E156     32CCE7     	STA	BATCHFCB+32    
0308: E159     11ACE7     	LXI	D,BATCHFCB     
0309: E15C     CDF9E0     	CALL	RDREC	;read last record.
0310: E15F     C296E1     	JNZ	GETINP1	;quit on end of file.
0311: E162                ;                   
0312: E162                ;   Move this record into input buffer.
0313: E162                ;                   
0314: E162     1107E0     	LXI	D,INBUFF+1     
0315: E165     218000     	LXI	H,Pg0Buffer	;data was read into buffer here.
0316: E168     0680       	MVI	B,128	;all 128 characters may be used.
0317: E16A     CD42E4     	CALL	HL2DE	;(HL) to (DE), (B) bytes.
0318: E16D     21BAE7     	LXI	H,BATCHFCB+14  
0319: E170     3600       	MVI	M,0	;zero out the 's2' byte.
0320: E172     23         	INX	H	;and decrement the record count.
0321: E173     35         	DCR	M              
0322: E174     11ACE7     	LXI	D,BATCHFCB;close the batch file now.
0323: E177     CDDAE0     	CALL	CLOSE         
0324: E17A     CA96E1     	JZ	GETINP1	;quit on an error.
0325: E17D     3AEFE7     	LDA	CDRIVE	;re-select previous drive if need be.
0326: E180     B7         	ORA	A              
0327: E181     C4BDE0     	CNZ	DSKSEL	;don't do needless selects.
0328: E184                ;                   
0329: E184                ;   Print line just read on console.
0330: E184                ;                   
0331: E184     2108E0     	LXI	H,INBUFF+2     
0332: E187     CDACE0     	CALL	PLINE2        
0333: E18A     CDC2E1     	CALL	CHKCON	;check console, quit on a key.
0334: E18D     CAA7E1     	JZ	GETINP2	;jump if no key is pressed.
0335: E190                ;                   
0336: E190                ;   Terminate the submit job on any keyboard input. Delete this
0337: E190                ; file such that it is not re-started and jump to normal keyboard
0338: E190                ; input section.    
0339: E190                ;                   
0340: E190     CDDDE1     	CALL	DELBATCH;delete the batch file.
0341: E193     C382E3     	JMP	CMMND1	;and restart command input.
0342: E196                ;                   
0343: E196                ;   Get here for normal keyboard input. Delete the submit file
0344: E196                ; incase there was one.
0345: E196                ;                   
0346: E196                GETINP1:            
0347: E196     CDDDE1     	CALL	DELBATCH;delete file ($$$.sub).
0348: E199     CD1AE1     	CALL	SETCDRV	;reset active disk.
0349: E19C     0E0A       	MVI	C,10	;get line from console device.
0350: E19E     1106E0     	LXI	D,INBUFF       
0351: E1A1     CD0500     	CALL	ENTRY         
0352: E1A4     CD29E1     	CALL	MOVECD	;reset current drive (again).
0353: E1A7                ;                   
0354: E1A7                ;   Convert input line to upper case.
0355: E1A7                ;                   
0356: E1A7                GETINP2:            
0357: E1A7     2107E0     	LXI	H,INBUFF+1     
0358: E1AA     46         	MOV	B,M	;(B)=character counter.
0359: E1AB                GETINP3:            
0360: E1AB     23         	INX	H              
0361: E1AC     78         	MOV	A,B	;end of the line?
0362: E1AD     B7         	ORA	A              
0363: E1AE     CABAE1     	JZ	GETINP4         
0364: E1B1     7E         	MOV	A,M	;convert to upper case.
0365: E1B2     CD30E1     	CALL	UPPER         
0366: E1B5     77         	MOV	M,A            
0367: E1B6     05         	DCR	B	;adjust character count.
0368: E1B7     C3ABE1     	JMP	GETINP3        
0369: E1BA                GETINP4:            
0370: E1BA     77         	MOV	M,A	;add trailing null.
0371: E1BB     2108E0     	LXI	H,INBUFF+2     
0372: E1BE     2288E0     	SHLD	INPOINT	;reset input line pointer.
0373: E1C1     C9         	RET                
0374: E1C2                ;                   
0375: E1C2                ;   Routine to check the console for a key pressed. The zero
0376: E1C2                ; flag is set is none, else the character is returned in (A).
0377: E1C2                ;                   
0378: E1C2                CHKCON:             
0379: E1C2     0E0B       	MVI	C,11	;check console.
0380: E1C4     CD0500     	CALL	ENTRY         
0381: E1C7     B7         	ORA	A              
0382: E1C8     C8         	RZ		;return if nothing.
0383: E1C9     0E01       	MVI	C,1	;else get character.
0384: E1CB     CD0500     	CALL	ENTRY         
0385: E1CE     B7         	ORA	A	;clear zero flag and return.
0386: E1CF     C9         	RET                
0387: E1D0                ;                   
0388: E1D0                ;   Routine to get the currently active drive number.
0389: E1D0                ;                   
0390: E1D0                GETDSK:             
0391: E1D0     0E19       	MVI	C,25           
0392: E1D2     C30500     	JMP	ENTRY          
0393: E1D5                ;                   
0394: E1D5                ;   Set the stabdard dma address.
0395: E1D5                ;                   
0396: E1D5                STDDMA:             
0397: E1D5     118000     	LXI	D,Pg0Buffer    
0398: E1D8                ;                   
0399: E1D8                ;   Routine to set the dma address to (DE).
0400: E1D8                ;                   
0401: E1D8                DMASET:             
0402: E1D8     0E1A       	MVI	C,26           
0403: E1DA     C30500     	JMP	ENTRY          
0404: E1DD                ;                   
0405: E1DD                ;  Delete the batch file created by SUBMIT.
0406: E1DD                ;                   
0407: E1DD                DELBATCH:           
0408: E1DD     21ABE7     LXI	H,BATCH	;is batch active?
0409: E1E0     7E         	MOV	A,M            
0410: E1E1     B7         	ORA	A              
0411: E1E2     C8         	RZ                 
0412: E1E3     3600       	MVI	M,0	;yes, de-activate it.
0413: E1E5     AF         	XRA	A              
0414: E1E6     CDBDE0     	CALL	DSKSEL	;select drive 0 for sure.
0415: E1E9     11ACE7     	LXI	D,BATCHFCB;and delete this file.
0416: E1EC     CDEFE0     	CALL	DELETE        
0417: E1EF     3AEFE7     	LDA	CDRIVE	;reset current drive.
0418: E1F2     C3BDE0     	JMP	DSKSEL         
0419: E1F5                ;                   
0420: E1F5                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
0421: E1F5                ; the same or we halt....
0422: E1F5                ;                   
0423: E1F5                VERIFY:             
0424: E1F5     1128E3     	LXI	D,PATTRN1;these are the serial number bytes.
0425: E1F8     2100E8     	LXI	H,PATTRN2;ditto, but how could they be different?
0426: E1FB     0606       	MVI	B,6	;6 bytes each.
0427: E1FD                VERIFY1:            
0428: E1FD     1A         	LDAX	D             
0429: E1FE     BE         	CMP	M              
0430: E1FF     C2CFE3     	JNZ	HALT	;jump to halt routine.
0431: E202     13         	INX	D              
0432: E203     23         	INX	H              
0433: E204     05         	DCR	B              
0434: E205     C2FDE1     	JNZ	VERIFY1        
0435: E208     C9         	RET                
0436: E209                ;                   
0437: E209                ;   Print back file name with a '?' to indicate a syntax error.
0438: E209                ;                   
0439: E209                SYNERR:             
0440: E209     CD98E0     	CALL	CRLF	;end current line.
0441: E20C     2A8AE0     	LHLD	NAMEPNT	;this points to name in error.
0442: E20F                SYNERR1:            
0443: E20F     7E         	MOV	A,M	;print it until a space or null is found.
0444: E210     FE20       	CPI	BLANK		; Space 
0445: E212     CA22E2     	JZ	SYNERR2         
0446: E215     B7         	ORA	A              
0447: E216     CA22E2     	JZ	SYNERR2         
0448: E219     E5         	PUSH	H             
0449: E21A     CD8CE0     	CALL	PRINT         
0450: E21D     E1         	POP	H              
0451: E21E     23         	INX	H              
0452: E21F     C30FE2     	JMP	SYNERR1        
0453: E222                SYNERR2:            
0454: E222     3E3F       	MVI	A,QMARK		;add trailing '?'.
0455: E224     CD8CE0     	CALL	PRINT         
0456: E227     CD98E0     	CALL	CRLF          
0457: E22A     CDDDE1     	CALL	DELBATCH;delete any batch file.
0458: E22D     C382E3     	JMP	CMMND1	;and restart from console input.
0459: E230                ;                   
0460: E230                ;   Check character at (DE) for legal command input. Note that the
0461: E230                ; zero flag is set if the character is a delimiter.
0462: E230                ;                   
0463: E230                CHECK:              
0464: E230     1A         	LDAX	D             
0465: E231     B7         	ORA	A              
0466: E232     C8         	RZ                 
0467: E233     FE20       	CPI	BLANK	;control characters are not legal here.
0468: E235     DA09E2     	JC	SYNERR          
0469: E238     C8         	RZ		;check for valid delimiter.
0470: E239     FE3D       	CPI	EQUALS		; '='  
0471: E23B     C8         	RZ                 
0472: E23C     FE5F       	CPI	USCORE		; '_'  
0473: E23E     C8         	RZ                 
0474: E23F     FE2E       	CPI	PERIOD		; '.'  
0475: E241     C8         	RZ                 
0476: E242     FE3A       	CPI	COLON		; ':'   
0477: E244     C8         	RZ                 
0478: E245     FE3B       	CPI	SEMIC		; ';'   
0479: E247     C8         	RZ                 
0480: E248     FE3C       	CPI	LESSTH		; '<'  
0481: E24A     C8         	RZ                 
0482: E24B     FE3E       	CPI	GRTTHAN		; '>' 
0483: E24D     C8         	RZ                 
0484: E24E     C9         	RET                
0485: E24F                ;                   
0486: E24F                ;   Get the next non-blank character from (DE).
0487: E24F                ;                   
0488: E24F                NONBLANK:           
0489: E24F     1A         LDAX	D              
0490: E250     B7         	ORA	A	;string ends with a null.
0491: E251     C8         	RZ                 
0492: E252     FE20       	CPI	BLANK          
0493: E254     C0         	RNZ                
0494: E255     13         	INX	D              
0495: E256     C34FE2     	JMP	NONBLANK       
0496: E259                ;                   
0497: E259                ;   Add (HL)=(HL)+(A)
0498: E259                ;                   
0499: E259                ADDHL:              
0500: E259     85         	ADD	L              
0501: E25A     6F         	MOV	L,A            
0502: E25B     D0         	RNC	;take care of any carry.
0503: E25C     24         	INR	H              
0504: E25D     C9         	RET                
0505: E25E                ;                   
0506: E25E                ;   Convert the first name in (FCB).
0507: E25E                ;                   
0508: E25E                CONVFST:            
0509: E25E     3E00       	MVI	A,0            
0510: E260                ;                   
0511: E260                ;   Format a file name (convert * to '?', etc.). On return,
0512: E260                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
0513: E260                ; the position within the fcb for the name (either 0 or 16).
0514: E260                ;                   
0515: E260                CONVERT:            
0516: E260     21CDE7     	LXI	H,FCB          
0517: E263     CD59E2     	CALL	ADDHL         
0518: E266     E5         	PUSH	H             
0519: E267     E5         	PUSH	H             
0520: E268     AF         	XRA	A              
0521: E269     32F0E7     	STA	CHGDRV	;initialize drive change flag.
0522: E26C     2A88E0     	LHLD	INPOINT	;set (HL) as pointer into input line.
0523: E26F     EB         	XCHG               
0524: E270     CD4FE2     	CALL	NONBLANK;get next non-blank character.
0525: E273     EB         	XCHG               
0526: E274     228AE0     	SHLD	NAMEPNT	;save pointer here for any error message.
0527: E277     EB         	XCHG               
0528: E278     E1         	POP	H              
0529: E279     1A         	LDAX	D	;get first character.
0530: E27A     B7         	ORA	A              
0531: E27B     CA89E2     	JZ	CONVRT1         
0532: E27E     DE40       	SBI	040H		;'A'-1	;might be a drive name, convert to binary.
0533: E280     47         	MOV	B,A	;and save. 
0534: E281     13         	INX	D	;check next character for a ':'.
0535: E282     1A         	LDAX	D             
0536: E283     FE3A       	CPI	COLON		;':'    
0537: E285     CA90E2     	JZ	CONVRT2         
0538: E288     1B         	DCX	D	;nope, move pointer back to the start of the line.
0539: E289                CONVRT1:            
0540: E289     3AEFE7     	LDA	CDRIVE         
0541: E28C     77         	MOV	M,A            
0542: E28D     C396E2     	JMP	CONVRT3        
0543: E290                CONVRT2:            
0544: E290     78         	MOV	A,B            
0545: E291     32F0E7     	STA	CHGDRV	;set change in drives flag.
0546: E294     70         	MOV	M,B            
0547: E295     13         	INX	D              
0548: E296                ;                   
0549: E296                ;   Convert the basic file name.
0550: E296                ;                   
0551: E296                CONVRT3:            
0552: E296     0608       	MVI	B,08H          
0553: E298                CONVRT4:            
0554: E298     CD30E2     	CALL	CHECK         
0555: E29B     CAB9E2     	JZ	CONVRT8         
0556: E29E     23         	INX	H              
0557: E29F     FE2A       	CPI	ASTRK		; '*'	;note that an '*' will fill the remaining
0558: E2A1     C2A9E2     	JNZ	CONVRT5	;field with '?'.
0559: E2A4     363F       	MVI	M,QMARK		; '?' 
0560: E2A6     C3ABE2     	JMP	CONVRT6        
0561: E2A9                CONVRT5:            
0562: E2A9     77         	MOV	M,A            
0563: E2AA     13         	INX	D              
0564: E2AB                CONVRT6:            
0565: E2AB     05         	DCR	B              
0566: E2AC     C298E2     	JNZ	CONVRT4        
0567: E2AF                CONVRT7:            
0568: E2AF     CD30E2     	CALL	CHECK	;get next delimiter.
0569: E2B2     CAC0E2     	JZ	GETEXT          
0570: E2B5     13         	INX	D              
0571: E2B6     C3AFE2     	JMP	CONVRT7        
0572: E2B9                CONVRT8:            
0573: E2B9     23         	INX	H	;blank fill the file name.
0574: E2BA     3620       	MVI	M,BLANK        
0575: E2BC     05         	DCR	B              
0576: E2BD     C2B9E2     	JNZ	CONVRT8        
0577: E2C0                ;                   
0578: E2C0                ;   Get the extension and convert it.
0579: E2C0                ;                   
0580: E2C0                GETEXT:             
0581: E2C0     0603       	MVI	B,03H          
0582: E2C2     FE2E       	CPI	PERIOD		; '.'  
0583: E2C4     C2E9E2     	JNZ	GETEXT5        
0584: E2C7     13         	INX	D              
0585: E2C8                GETEXT1:            
0586: E2C8     CD30E2     	CALL	CHECK         
0587: E2CB     CAE9E2     	JZ	GETEXT5         
0588: E2CE     23         	INX	H              
0589: E2CF     FE2A       	CPI	ASTRK		; '*'   
0590: E2D1     C2D9E2     	JNZ	GETEXT2        
0591: E2D4     363F       	MVI	M,QMARK		;'?'  
0592: E2D6     C3DBE2     	JMP	GETEXT3        
0593: E2D9                GETEXT2:            
0594: E2D9     77         	MOV	M,A            
0595: E2DA     13         	INX	D              
0596: E2DB                GETEXT3:            
0597: E2DB     05         	DCR	B              
0598: E2DC     C2C8E2     	JNZ	GETEXT1        
0599: E2DF                GETEXT4:            
0600: E2DF     CD30E2     	CALL	CHECK         
0601: E2E2     CAF0E2     	JZ	GETEXT6         
0602: E2E5     13         	INX	D              
0603: E2E6     C3DFE2     	JMP	GETEXT4        
0604: E2E9                GETEXT5:            
0605: E2E9     23         	INX	H              
0606: E2EA     3620       	MVI	M,BLANK        
0607: E2EC     05         	DCR	B              
0608: E2ED     C2E9E2     	JNZ	GETEXT5        
0609: E2F0                GETEXT6:            
0610: E2F0     0603       	MVI	B,3            
0611: E2F2                GETEXT7:            
0612: E2F2     23         	INX	H              
0613: E2F3     3600       	MVI	M,0            
0614: E2F5     05         	DCR	B              
0615: E2F6     C2F2E2     	JNZ	GETEXT7        
0616: E2F9     EB         	XCHG               
0617: E2FA     2288E0     	SHLD	INPOINT	;save input line pointer.
0618: E2FD     E1         	POP	H              
0619: E2FE                ;                   
0620: E2FE                ;   Check to see if this is an ambigeous file name specification.
0621: E2FE                ; Set the (A) register to non zero if it is.
0622: E2FE                ;                   
0623: E2FE     010B00     	LXI	B,11	;set name length.
0624: E301                GETEXT8:            
0625: E301     23         	INX	H              
0626: E302     7E         	MOV	A,M            
0627: E303     FE3F       	CPI	QMARK		; '?'	;any question marks?
0628: E305     C209E3     	JNZ	GETEXT9        
0629: E308     04         	INR	B	;count them. 
0630: E309                GETEXT9:            
0631: E309     0D         	DCR	C              
0632: E30A     C201E3     	JNZ	GETEXT8        
0633: E30D     78         	MOV	A,B            
0634: E30E     B7         	ORA	A              
0635: E30F     C9         	RET                
0636: E310                ;                   
0637: E310                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
0638: E310                ;                   
0639: E310                NUMCMDS	EQU	6	;number of commands
0640: E310                CMDTBL:             
0641: E310     44495220   	DB	'DIR '          
0642: E314     45524120   	DB	'ERA '          
0643: E318     54595045   	DB	'TYPE'          
0644: E31C     53415645   	DB	'SAVE'          
0645: E320     52454E20   	DB	'REN '          
0646: E324     55534552   	DB	'USER'          
0647: E328                ;                   
0648: E328                ;   The following six bytes must agree with those at (PATTRN2)
0649: E328                ; or cp/m will HALT. Why?
0650: E328                ;                   
0651: E328                PATTRN1:            
0652: E328     001600000000 	DB	0,22,0,0,0,0;(* serial number bytes *).
0653: E32E                ;                   
0654: E32E                ;   Search the command table for a match with what has just
0655: E32E                ; been entered. If a match is found, then we jump to the
0656: E32E                ; proper section. Else jump to (UNKNOWN).
0657: E32E                ; On return, the (C) register is set to the command number
0658: E32E                ; that matched (or NUMCMDS+1 if no match).
0659: E32E                ;                   
0660: E32E                SEARCH:             
0661: E32E     2110E3     	LXI	H,CMDTBL       
0662: E331     0E00       	MVI	C,0            
0663: E333                SEARCH1:            
0664: E333     79         	MOV	A,C            
0665: E334     FE06       	CPI	NUMCMDS	;this commands exists.
0666: E336     D0         	RNC                
0667: E337     11CEE7     	LXI	D,FCB+1	;check this one.
0668: E33A     0604       	MVI	B,4	;max command length.
0669: E33C                SEARCH2:            
0670: E33C     1A         	LDAX	D             
0671: E33D     BE         	CMP	M              
0672: E33E     C24FE3     	JNZ	SEARCH3	;not a match.
0673: E341     13         	INX	D              
0674: E342     23         	INX	H              
0675: E343     05         	DCR	B              
0676: E344     C23CE3     	JNZ	SEARCH2        
0677: E347     1A         	LDAX	D	;allow a 3 character command to match.
0678: E348     FE20       	CPI	BLANK          
0679: E34A     C254E3     	JNZ	SEARCH4        
0680: E34D     79         	MOV	A,C	;set return register for this command.
0681: E34E     C9         	RET                
0682: E34F                SEARCH3:            
0683: E34F     23         	INX	H              
0684: E350     05         	DCR	B              
0685: E351     C24FE3     	JNZ	SEARCH3        
0686: E354                SEARCH4:            
0687: E354     0C         	INR	C              
0688: E355     C333E3     	JMP	SEARCH1        
0689: E358                ;                   
0690: E358                ;   Set the input buffer to empty and then start the command
0691: E358                ; processor (ccp).  
0692: E358                ;                   
0693: E358                CLEARBUF:           
0694: E358     AF         XRA	A               
0695: E359     3207E0     	STA	INBUFF+1;second byte is actual length.
0696: E35C                ;                   
0697: E35C                ;**************************************************************
0698: E35C                ;*                  
0699: E35C                ;*                  
0700: E35C                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
0701: E35C                ;*                  
0702: E35C                ;**************************************************************
0703: E35C                ;*                  
0704: E35C                COMMAND:            
0705: E35C     31ABE7     	LXI	SP,CCPSTACK;setup stack area.
0706: E35F     C5         	PUSH	B	;note that (C) should be equal to:
0707: E360     79         	MOV	A,C	;(uuuudddd) where 'uuuu' is the user number
0708: E361     1F         	RAR		;and 'dddd' is the drive number.
0709: E362     1F         	RAR                
0710: E363     1F         	RAR                
0711: E364     1F         	RAR                
0712: E365     E60F       	ANI	0FH	;isolate the user number.
0713: E367     5F         	MOV	E,A            
0714: E368     CD15E1     	CALL	GETSETUC;and set it.
0715: E36B     CDB8E0     	CALL	RESDSK	;reset the disk system.
0716: E36E     32ABE7     	STA	BATCH	;clear batch mode flag.
0717: E371     C1         	POP	B              
0718: E372     79         	MOV	A,C            
0719: E373     E60F       	ANI	0FH	;isolate the drive number.
0720: E375     32EFE7     	STA	CDRIVE	;and save.
0721: E378     CDBDE0     	CALL	DSKSEL	;...and select.
0722: E37B     3A07E0     	LDA	INBUFF+1       
0723: E37E     B7         	ORA	A	;anything in input buffer already?
0724: E37F     C298E3     	JNZ	CMMND2	;yes, we just process it.
0725: E382                ;                   
0726: E382                ;   Entry point to get a command line from the console.
0727: E382                ;                   
0728: E382                CMMND1:             
0729: E382     31ABE7     	LXI	SP,CCPSTACK;set stack straight.
0730: E385     CD98E0     	CALL	CRLF	;start a new line on the screen.
0731: E388     CDD0E1     	CALL	GETDSK	;get current drive.
0732: E38B     C661       	ADI	061H		; 'a'    
0733: E38D     CD8CE0     	CALL	PRINT	;print current drive.
0734: E390     3E3E       	MVI	A,GRTTHAN	; '>'
0735: E392     CD8CE0     	CALL	PRINT	;and add prompt.
0736: E395     CD39E1     	CALL	GETINP	;get line from user.
0737: E398                ;                   
0738: E398                ;   Process command line here.
0739: E398                ;                   
0740: E398                CMMND2:             
0741: E398     118000     	LXI	D,Pg0Buffer    
0742: E39B     CDD8E1     	CALL	DMASET	;set standard dma address.
0743: E39E     CDD0E1     	CALL	GETDSK        
0744: E3A1     32EFE7     	STA	CDRIVE	;set current drive.
0745: E3A4     CD5EE2     	CALL	CONVFST	;convert name typed in.
0746: E3A7     C409E2     	CNZ	SYNERR	;wild cards are not allowed.
0747: E3AA     3AF0E7     	LDA	CHGDRV	;if a change in drives was indicated,
0748: E3AD     B7         	ORA	A	;then treat this as an unknown command
0749: E3AE     C2A5E6     	JNZ	UNKNOWN	;which gets executed.
0750: E3B1     CD2EE3     	CALL	SEARCH	;else search command table for a match.
0751: E3B4                ;                   
0752: E3B4                ;   Note that an unknown command returns
0753: E3B4                ; with (A) pointing to the last address
0754: E3B4                ; in our table which is (UNKNOWN).
0755: E3B4                ;                   
0756: E3B4     21C1E3     	LXI	H,CMDADR;now, look thru our address table for command (A).
0757: E3B7     5F         	MOV	E,A	;set (DE) to command number.
0758: E3B8     1600       	MVI	D,0            
0759: E3BA     19         	DAD	D              
0760: E3BB     19         	DAD	D	;(HL)=(CMDADR)+2*(command number).
0761: E3BC     7E         	MOV	A,M	;now pick out this address.
0762: E3BD     23         	INX	H              
0763: E3BE     66         	MOV	H,M            
0764: E3BF     6F         	MOV	L,A            
0765: E3C0     E9         	PCHL		;now execute it.
0766: E3C1                ;                   
0767: E3C1                ;   CP/M command address table.
0768: E3C1                ;                   
0769: E3C1                CMDADR:             
0770: E3C1     77E41FE55DE5ADE5 	DW	DIRECT,ERASE,TYPE,SAVE
0771: E3C9     10E68EE6A5E6 	DW	RENAME,USER,UNKNOWN
0772: E3CF                ;                   
0773: E3CF                ;   Halt the system. Reason for this is unknown at present.
0774: E3CF                ;                   
0775: E3CF                HALT:               
0776: E3CF     21F376     	LXI	H,76F3H	;'DI HLT' instructions.
0777: E3D2     2200E0     	SHLD	CBASE         
0778: E3D5     2100E0     	LXI	H,CBASE        
0779: E3D8     E9         	PCHL               
0780: E3D9                ;                   
0781: E3D9                ;   Read error while TYPEing a file.
0782: E3D9                ;                   
0783: E3D9                RDERROR:            
0784: E3D9     01DFE3     	LXI	B,RDERR        
0785: E3DC     C3A7E0     	JMP	PLINE          
0786: E3DF                RDERR:              
0787: E3DF     52454144204552524F5200 	DB	'Read error',0  
0788: E3EA                ;                   
0789: E3EA                ;   Required file was not located.
0790: E3EA                ;                   
0791: E3EA                                    
0792: E3EA                NONE:               
0793: E3EA     01F0E3     	LXI	B,NOFILE       
0794: E3ED     C3A7E0     	JMP	PLINE          
0795: E3F0                NOFILE:             
0796: E3F0     4E4F2046494C4500 	DB	'No file',0     
0797: E3F8                ;                   
0798: E3F8                ;   Decode a command of the form 'A>filename number{ filename}.
0799: E3F8                ; Note that a drive specifier is not allowed on the first file
0800: E3F8                ; name. On return, the number is in register (A). Any error
0801: E3F8                ; causes 'filename?' to be printed and the command is aborted.
0802: E3F8                ;                   
0803: E3F8                DECODE:             
0804: E3F8     CD5EE2     	CALL	CONVFST	;convert filename.
0805: E3FB     3AF0E7     	LDA	CHGDRV	;do not allow a drive to be specified.
0806: E3FE     B7         	ORA	A              
0807: E3FF     C209E2     	JNZ	SYNERR         
0808: E402     21CEE7     	LXI	H,FCB+1	;convert number now.
0809: E405     010B00     	LXI	B,11	;(B)=sum register, (C)=max digit count.
0810: E408                DECODE1:            
0811: E408     7E         	MOV	A,M            
0812: E409     FE20       	CPI	BLANK	;a space terminates the numeral.
0813: E40B     CA33E4     	JZ	DECODE3         
0814: E40E     23         	INX	H              
0815: E40F     D630       	SUI	030H		 ;'0'	make binary from ascii. ZERO ????
0816: E411     FE0A       	CPI	10	;legal digit?
0817: E413     D209E2     	JNC	SYNERR         
0818: E416     57         	MOV	D,A	;yes, save it in (D).
0819: E417     78         	MOV	A,B	;compute (B)=(B)*10 and check for overflow.
0820: E418     E6E0       	ANI	0E0H           
0821: E41A     C209E2     	JNZ	SYNERR         
0822: E41D     78         	MOV	A,B            
0823: E41E     07         	RLC                
0824: E41F     07         	RLC                
0825: E420     07         	RLC	;(A)=(B)*8     
0826: E421     80         	ADD	B	;.......*9   
0827: E422     DA09E2     	JC	SYNERR          
0828: E425     80         	ADD	B	;.......*10  
0829: E426     DA09E2     	JC	SYNERR          
0830: E429     82         	ADD	D	;add in new digit now.
0831: E42A                DECODE2:            
0832: E42A     DA09E2     	JC	SYNERR          
0833: E42D     47         	MOV	B,A	;and save result.
0834: E42E     0D         	DCR	C	;only look at 11 digits.
0835: E42F     C208E4     	JNZ	DECODE1        
0836: E432     C9         	RET                
0837: E433                DECODE3:            
0838: E433     7E         	MOV	A,M	;spaces must follow (why?).
0839: E434     FE20       	CPI	BLANK          
0840: E436     C209E2     	JNZ	SYNERR         
0841: E439     23         	INX	H              
0842: E43A                DECODE4:            
0843: E43A     0D         	DCR	C              
0844: E43B     C233E4     	JNZ	DECODE3        
0845: E43E     78         	MOV	A,B	;set (A)=the numeric value entered.
0846: E43F     C9         	RET                
0847: E440                ;                   
0848: E440                ;   Move 3 bytes from (HL) to (DE). Note that there is only
0849: E440                ; one reference to this at (A2D5h).
0850: E440                ;                   
0851: E440                MOVE3:              
0852: E440     0603       	MVI	B,3            
0853: E442                ;                   
0854: E442                ;   Move (B) bytes from (HL) to (DE).
0855: E442                ;                   
0856: E442                HL2DE:              
0857: E442     7E         	MOV	A,M            
0858: E443     12         	STAX	D             
0859: E444     23         	INX	H              
0860: E445     13         	INX	D              
0861: E446     05         	DCR	B              
0862: E447     C242E4     	JNZ	HL2DE          
0863: E44A     C9         	RET                
0864: E44B                ;                   
0865: E44B                ;   Compute (HL)=(Pg0Buffer)+(A)+(C) and get the byte that's here.
0866: E44B                ;                   
0867: E44B                EXTRACT:            
0868: E44B     218000     	LXI	H,Pg0Buffer    
0869: E44E     81         	ADD	C              
0870: E44F     CD59E2     	CALL	ADDHL         
0871: E452     7E         	MOV	A,M            
0872: E453     C9         	RET                
0873: E454                ;                   
0874: E454                ;  Check drive specified. If it means a change, then the new
0875: E454                ; drive will be selected. In any case, the drive byte of the
0876: E454                ; fcb will be set to null (means use current drive).
0877: E454                ;                   
0878: E454                DSELECT:            
0879: E454     AF         	XRA	A	;null out first byte of fcb.
0880: E455     32CDE7     	STA	FCB            
0881: E458     3AF0E7     	LDA	CHGDRV	;a drive change indicated?
0882: E45B     B7         	ORA	A              
0883: E45C     C8         	RZ                 
0884: E45D     3D         	DCR	A	;yes, is it the same as the current drive?
0885: E45E     21EFE7     	LXI	H,CDRIVE       
0886: E461     BE         	CMP	M              
0887: E462     C8         	RZ                 
0888: E463     C3BDE0     	JMP	DSKSEL	;no. Select it then.
0889: E466                ;                   
0890: E466                ;   Check the drive selection and reset it to the previous
0891: E466                ; drive if it was changed for the preceeding command.
0892: E466                ;                   
0893: E466                RESETDR:            
0894: E466     3AF0E7     	LDA	CHGDRV	;drive change indicated?
0895: E469     B7         	ORA	A              
0896: E46A     C8         	RZ                 
0897: E46B     3D         	DCR	A	;yes, was it a different drive?
0898: E46C     21EFE7     	LXI	H,CDRIVE       
0899: E46F     BE         	CMP	M              
0900: E470     C8         	RZ                 
0901: E471     3AEFE7     	LDA	CDRIVE	;yes, re-select our old drive.
0902: E474     C3BDE0     	JMP	DSKSEL         
0903: E477                ;                   
0904: E477                ;**************************************************************
0905: E477                ;*                  
0906: E477                ;*           D I R E C T O R Y   C O M M A N D
0907: E477                ;*                  
0908: E477                ;**************************************************************
0909: E477                ;                   
0910: E477                DIRECT:             
0911: E477     CD5EE2     	CALL	CONVFST	;convert file name.
0912: E47A     CD54E4     	CALL	DSELECT	;select indicated drive.
0913: E47D     21CEE7     	LXI	H,FCB+1	;was any file indicated?
0914: E480     7E         	MOV	A,M            
0915: E481     FE20       	CPI	BLANK          
0916: E483     C28FE4     	JNZ	DIRECT2        
0917: E486     060B       	MVI	B,11	;no. Fill field with '?' - same as *.*.
0918: E488                DIRECT1:            
0919: E488     363F       	MVI	M,QMARK		; '?' 
0920: E48A     23         	INX	H              
0921: E48B     05         	DCR	B              
0922: E48C     C288E4     	JNZ	DIRECT1        
0923: E48F                DIRECT2:            
0924: E48F     1E00       	MVI	E,0	;set initial cursor position.
0925: E491     D5         	PUSH	D             
0926: E492     CDE9E0     	CALL	SRCHFCB	;get first file name.
0927: E495     CCEAE3     	CZ	NONE	;none found at all?
0928: E498                DIRECT3:            
0929: E498     CA1BE5     	JZ	DIRECT9	;terminate if no more names.
0930: E49B     3AEEE7     	LDA	RTNCODE	;get file's position in segment (0-3).
0931: E49E     0F         	RRC                
0932: E49F     0F         	RRC                
0933: E4A0     0F         	RRC                
0934: E4A1     E660       	ANI	60H	;(A)=position*32
0935: E4A3     4F         	MOV	C,A            
0936: E4A4     3E0A       	MVI	A,10           
0937: E4A6     CD4BE4     	CALL	EXTRACT	;extract the tenth entry in fcb.
0938: E4A9     17         	RAL		;check system file status bit.
0939: E4AA     DA0FE5     	JC	DIRECT8	;we don't list them.
0940: E4AD     D1         	POP	D              
0941: E4AE     7B         	MOV	A,E	;bump name count.
0942: E4AF     1C         	INR	E              
0943: E4B0     D5         	PUSH	D             
0944: E4B1     E603       	ANI	03H	;at end of line?
0945: E4B3     F5         	PUSH	PSW           
0946: E4B4     C2CCE4     	JNZ	DIRECT4        
0947: E4B7     CD98E0     	CALL	CRLF	;yes, end this line and start another.
0948: E4BA     C5         	PUSH	B             
0949: E4BB     CDD0E1     	CALL	GETDSK	;start line with ('A:').
0950: E4BE     C1         	POP	B              
0951: E4BF     C641       	ADI	041H	; 'A'     
0952: E4C1     CD92E0     	CALL	PRINTB        
0953: E4C4     3E3A       	MVI	A, COLON		; ':'
0954: E4C6     CD92E0     	CALL	PRINTB        
0955: E4C9     C3D4E4     	JMP	DIRECT5        
0956: E4CC                DIRECT4:            
0957: E4CC     CDA2E0     	CALL	SPACE	;add seperator between file names.
0958: E4CF     3E3A       	MVI	A, COLON	;':'  
0959: E4D1     CD92E0     	CALL	PRINTB        
0960: E4D4                DIRECT5:            
0961: E4D4     CDA2E0     	CALL	SPACE         
0962: E4D7     0601       	MVI	B,1	;'extract' each file name character at a time.
0963: E4D9                DIRECT6:            
0964: E4D9     78         	MOV	A,B            
0965: E4DA     CD4BE4     	CALL	EXTRACT       
0966: E4DD     E67F       	ANI	7FH	;strip bit 7 (status bit).
0967: E4DF     FE20       	CPI	BLANK	;are we at the end of the name?
0968: E4E1     C2F9E4     	JNZ	DRECT65        
0969: E4E4     F1         	POP	PSW	;yes, don't print spaces at the end of a line.
0970: E4E5     F5         	PUSH	PSW           
0971: E4E6     FE03       	CPI	3              
0972: E4E8     C2F7E4     	JNZ	DRECT63        
0973: E4EB     3E09       	MVI	A,9	;first check for no extension.
0974: E4ED     CD4BE4     	CALL	EXTRACT       
0975: E4F0     E67F       	ANI	7FH            
0976: E4F2     FE20       	CPI	BLANK          
0977: E4F4     CA0EE5     	JZ	DIRECT7	;don't print spaces.
0978: E4F7                DRECT63:            
0979: E4F7     3E20       	MVI	A,BLANK	;else print them.
0980: E4F9                DRECT65:            
0981: E4F9     CD92E0     	CALL	PRINTB        
0982: E4FC     04         	INR	B	;bump to next character psoition.
0983: E4FD     78         	MOV	A,B            
0984: E4FE     FE0C       	CPI	12	;end of the name?
0985: E500     D20EE5     	JNC	DIRECT7        
0986: E503     FE09       	CPI	9	;nope, starting extension?
0987: E505     C2D9E4     	JNZ	DIRECT6        
0988: E508     CDA2E0     	CALL	SPACE	;yes, add seperating space.
0989: E50B     C3D9E4     	JMP	DIRECT6        
0990: E50E                DIRECT7:            
0991: E50E     F1         	POP	PSW	;get the next file name.
0992: E50F                DIRECT8:            
0993: E50F     CDC2E1     	CALL	CHKCON	;first check console, quit on anything.
0994: E512     C21BE5     	JNZ	DIRECT9        
0995: E515     CDE4E0     	CALL	SRCHNXT	;get next name.
0996: E518     C398E4     	JMP	DIRECT3	;and continue with our list.
0997: E51B                DIRECT9:            
0998: E51B     D1         	POP	D	;restore the stack and return to command level.
0999: E51C     C386E7     	JMP	GETBACK        
1000: E51F                ;                   
1001: E51F                ;**************************************************************
1002: E51F                ;*                  
1003: E51F                ;*                E R A S E   C O M M A N D
1004: E51F                ;*                  
1005: E51F                ;**************************************************************
1006: E51F                ;                   
1007: E51F                ERASE:              
1008: E51F     CD5EE2     	CALL	CONVFST	;convert file name.
1009: E522     FE0B       	CPI	11	;was '*.*' entered?
1010: E524     C242E5     	JNZ	ERASE1         
1011: E527     0152E5     	LXI	B,YESNO	;yes, ask for confirmation.
1012: E52A     CDA7E0     	CALL	PLINE         
1013: E52D     CD39E1     	CALL	GETINP        
1014: E530     2107E0     	LXI	H,INBUFF+1     
1015: E533     35         	DCR	M	;must be exactly 'y'.
1016: E534     C282E3     	JNZ	CMMND1         
1017: E537     23         	INX	H              
1018: E538     7E         	MOV	A,M            
1019: E539     FE59       	CPI	059H	; 'Y'     
1020: E53B     C282E3     	JNZ	CMMND1         
1021: E53E     23         	INX	H              
1022: E53F     2288E0     	SHLD	INPOINT	;save input line pointer.
1023: E542                ERASE1:             
1024: E542     CD54E4     	CALL	DSELECT	;select desired disk.
1025: E545     11CDE7     	LXI	D,FCB          
1026: E548     CDEFE0     	CALL	DELETE	;delete the file.
1027: E54B     3C         	INR	A              
1028: E54C     CCEAE3     	CZ	NONE	;not there?
1029: E54F     C386E7     	JMP	GETBACK	;return to command level now.
1030: E552                YESNO:              
1031: E552     414C4C2028592F4E293F00 	DB	'All (y/n)?',0  
1032: E55D                ;                   
1033: E55D                ;**************************************************************
1034: E55D                ;*                  
1035: E55D                ;*            T Y P E   C O M M A N D
1036: E55D                ;*                  
1037: E55D                ;**************************************************************
1038: E55D                ;                   
1039: E55D                TYPE:               
1040: E55D     CD5EE2     	CALL	CONVFST	;convert file name.
1041: E560     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1042: E563     CD54E4     	CALL	DSELECT	;select indicated drive.
1043: E566     CDD0E0     	CALL	OPENFCB	;open the file.
1044: E569     CAA7E5     	JZ	TYPE5	;not there?
1045: E56C     CD98E0     	CALL	CRLF	;ok, start a new line on the screen.
1046: E56F     21F1E7     	LXI	H,NBYTES;initialize byte counter.
1047: E572     36FF       	MVI	M,0FFH	;set to read first sector.
1048: E574                TYPE1:              
1049: E574     21F1E7     	LXI	H,NBYTES       
1050: E577                TYPE2:              
1051: E577     7E         	MOV	A,M	;have we written the entire sector?
1052: E578     FE80       	CPI	128            
1053: E57A     DA87E5     	JC	TYPE3           
1054: E57D     E5         	PUSH	H	;yes, read in the next one.
1055: E57E     CDFEE0     	CALL	READFCB       
1056: E581     E1         	POP	H              
1057: E582     C2A0E5     	JNZ	TYPE4	;end or error?
1058: E585     AF         	XRA	A	;ok, clear byte counter.
1059: E586     77         	MOV	M,A            
1060: E587                TYPE3:              
1061: E587     34         	INR	M	;count this byte.
1062: E588     218000     	LXI	H,Pg0Buffer	;and get the (A)th one from the buffer (Pg0Buffer).
1063: E58B     CD59E2     	CALL	ADDHL         
1064: E58E     7E         	MOV	A,M            
1065: E58F     FE1A       	CPI	CNTRLZ	;end of file mark?
1066: E591     CA86E7     	JZ	GETBACK         
1067: E594     CD8CE0     	CALL	PRINT	;no, print it.
1068: E597     CDC2E1     	CALL	CHKCON	;check console, quit if anything ready.
1069: E59A     C286E7     	JNZ	GETBACK        
1070: E59D     C374E5     	JMP	TYPE1          
1071: E5A0                ;                   
1072: E5A0                ;   Get here on an end of file or read error.
1073: E5A0                ;                   
1074: E5A0                TYPE4:              
1075: E5A0     3D         	DCR	A	;read error? 
1076: E5A1     CA86E7     	JZ	GETBACK         
1077: E5A4     CDD9E3     	CALL	RDERROR	;yes, print message.
1078: E5A7                TYPE5:              
1079: E5A7     CD66E4     	CALL	RESETDR	;and reset proper drive
1080: E5AA     C309E2     	JMP	SYNERR	;now print file name with problem.
1081: E5AD                ;                   
1082: E5AD                ;**************************************************************
1083: E5AD                ;*                  
1084: E5AD                ;*            S A V E   C O M M A N D
1085: E5AD                ;*                  
1086: E5AD                ;**************************************************************
1087: E5AD                ;                   
1088: E5AD                SAVE:               
1089: E5AD     CDF8E3     	CALL	DECODE	;get numeric number that follows SAVE.
1090: E5B0     F5         	PUSH	PSW	;save number of pages to write.
1091: E5B1     CD5EE2     	CALL	CONVFST	;convert file name.
1092: E5B4     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1093: E5B7     CD54E4     	CALL	DSELECT	;select specified drive.
1094: E5BA     11CDE7     	LXI	D,FCB	;now delete this file.
1095: E5BD     D5         	PUSH	D             
1096: E5BE     CDEFE0     	CALL	DELETE        
1097: E5C1     D1         	POP	D              
1098: E5C2     CD09E1     	CALL	CREATE	;and create it again.
1099: E5C5     CAFBE5     	JZ	SAVE3	;can't create?
1100: E5C8     AF         	XRA	A	;clear record number byte.
1101: E5C9     32EDE7     	STA	FCB+32         
1102: E5CC     F1         	POP	PSW	;convert pages to sectors.
1103: E5CD     6F         	MOV	L,A            
1104: E5CE     2600       	MVI	H,0            
1105: E5D0     29         	DAD	H	;(HL)=number of sectors to write.
1106: E5D1     110001     	LXI	D,TBASE	;and we start from here.
1107: E5D4                SAVE1:              
1108: E5D4     7C         	MOV	A,H	;done yet? 
1109: E5D5     B5         	ORA	L              
1110: E5D6     CAF1E5     	JZ	SAVE2           
1111: E5D9     2B         	DCX	H	;nope, count this and compute the start
1112: E5DA     E5         	PUSH	H	;of the next 128 byte sector.
1113: E5DB     218000     	LXI	H,128          
1114: E5DE     19         	DAD	D              
1115: E5DF     E5         	PUSH	H	;save it and set the transfer address.
1116: E5E0     CDD8E1     	CALL	DMASET        
1117: E5E3     11CDE7     	LXI	D,FCB	;write out this sector now.
1118: E5E6     CD04E1     	CALL	WRTREC        
1119: E5E9     D1         	POP	D	;reset (DE) to the start of the last sector.
1120: E5EA     E1         	POP	H	;restore sector count.
1121: E5EB     C2FBE5     	JNZ	SAVE3	;write error?
1122: E5EE     C3D4E5     	JMP	SAVE1          
1123: E5F1                ;                   
1124: E5F1                ;   Get here after writing all of the file.
1125: E5F1                ;                   
1126: E5F1                SAVE2:              
1127: E5F1     11CDE7     	LXI	D,FCB	;now close the file.
1128: E5F4     CDDAE0     	CALL	CLOSE         
1129: E5F7     3C         	INR	A	;did it close ok?
1130: E5F8     C201E6     	JNZ	SAVE4          
1131: E5FB                ;                   
1132: E5FB                ;   Print out error message (no space).
1133: E5FB                ;                   
1134: E5FB                SAVE3:              
1135: E5FB     0107E6     	LXI	B,NOSPACE      
1136: E5FE     CDA7E0     	CALL	PLINE         
1137: E601                SAVE4:              
1138: E601     CDD5E1     	CALL	STDDMA	;reset the standard dma address.
1139: E604     C386E7     	JMP	GETBACK        
1140: E607                NOSPACE:            
1141: E607     4E4F20535041434500 	DB	'No space',0    
1142: E610                ;                   
1143: E610                ;**************************************************************
1144: E610                ;*                  
1145: E610                ;*           R E N A M E   C O M M A N D
1146: E610                ;*                  
1147: E610                ;**************************************************************
1148: E610                ;                   
1149: E610                RENAME:             
1150: E610     CD5EE2     	CALL	CONVFST	;convert first file name.
1151: E613     C209E2     	JNZ	SYNERR	;wild cards not allowed.
1152: E616     3AF0E7     	LDA	CHGDRV	;remember any change in drives specified.
1153: E619     F5         	PUSH	PSW           
1154: E61A     CD54E4     	CALL	DSELECT	;and select this drive.
1155: E61D     CDE9E0     	CALL	SRCHFCB	;is this file present?
1156: E620     C279E6     	JNZ	RENAME6	;yes, print error message.
1157: E623     21CDE7     	LXI	H,FCB	;yes, move this name into second slot.
1158: E626     11DDE7     	LXI	D,FCB+16       
1159: E629     0610       	MVI	B,16           
1160: E62B     CD42E4     	CALL	HL2DE         
1161: E62E     2A88E0     	LHLD	INPOINT	;get input pointer.
1162: E631     EB         	XCHG               
1163: E632     CD4FE2     	CALL	NONBLANK;get next non blank character.
1164: E635     FE3D       	CPI	EQUALS		; '='	;only allow an '=' or '_' seperator.
1165: E637     CA3FE6     	JZ	RENAME1         
1166: E63A     FE5F       	CPI	USCORE		; '_'  
1167: E63C     C273E6     	JNZ	RENAME5        
1168: E63F                RENAME1:            
1169: E63F     EB         	XCHG               
1170: E640     23         	INX	H	;ok, skip seperator.
1171: E641     2288E0     	SHLD	INPOINT	;save input line pointer.
1172: E644     CD5EE2     	CALL	CONVFST	;convert this second file name now.
1173: E647     C273E6     	JNZ	RENAME5	;again, no wild cards.
1174: E64A     F1         	POP	PSW	;if a drive was specified, then it
1175: E64B     47         	MOV	B,A	;must be the same as before.
1176: E64C     21F0E7     	LXI	H,CHGDRV       
1177: E64F     7E         	MOV	A,M            
1178: E650     B7         	ORA	A              
1179: E651     CA59E6     	JZ	RENAME2         
1180: E654     B8         	CMP	B              
1181: E655     70         	MOV	M,B            
1182: E656     C273E6     	JNZ	RENAME5	;they were different, error.
1183: E659                RENAME2:            
1184: E659     70         	MOV	M,B;	reset as per the first file specification.
1185: E65A     AF         	XRA	A              
1186: E65B     32CDE7     	STA	FCB	;clear the drive byte of the fcb.
1187: E65E                RENAME3:            
1188: E65E     CDE9E0     	CALL	SRCHFCB	;and go look for second file.
1189: E661     CA6DE6     	JZ	RENAME4	;doesn't exist?
1190: E664     11CDE7     	LXI	D,FCB          
1191: E667     CD0EE1     	CALL	RENAM	;ok, rename the file.
1192: E66A     C386E7     	JMP	GETBACK        
1193: E66D                ;                   
1194: E66D                ;   Process rename errors here.
1195: E66D                ;                   
1196: E66D                RENAME4:            
1197: E66D     CDEAE3     	CALL	NONE	;file not there.
1198: E670     C386E7     	JMP	GETBACK        
1199: E673                RENAME5:            
1200: E673     CD66E4     	CALL	RESETDR	;bad command format.
1201: E676     C309E2     	JMP	SYNERR         
1202: E679                RENAME6:            
1203: E679     0182E6     	LXI	B,EXISTS;destination file already exists.
1204: E67C     CDA7E0     	CALL	PLINE         
1205: E67F     C386E7     	JMP	GETBACK        
1206: E682                EXISTS:             
1207: E682     46494C452045584953545300 	DB	'File exists',0 
1208: E68E                ;                   
1209: E68E                ;**************************************************************
1210: E68E                ;*                  
1211: E68E                ;*             U S E R   C O M M A N D
1212: E68E                ;*                  
1213: E68E                ;**************************************************************
1214: E68E                ;                   
1215: E68E                USER:               
1216: E68E     CDF8E3     	CALL	DECODE	;get numeric value following command.
1217: E691     FE10       	CPI	16	;legal user number?
1218: E693     D209E2     	JNC	SYNERR         
1219: E696     5F         	MOV	E,A	;yes but is there anything else?
1220: E697     3ACEE7     	LDA	FCB+1          
1221: E69A     FE20       	CPI	BLANK          
1222: E69C     CA09E2     	JZ	SYNERR	;yes, that is not allowed.
1223: E69F     CD15E1     	CALL	GETSETUC;ok, set user code.
1224: E6A2     C389E7     	JMP	GETBACK1       
1225: E6A5                ;                   
1226: E6A5                ;**************************************************************
1227: E6A5                ;*                  
1228: E6A5                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
1229: E6A5                ;*                  
1230: E6A5                ;**************************************************************
1231: E6A5                ;                   
1232: E6A5                UNKNOWN:            
1233: E6A5     CDF5E1     	CALL	VERIFY	;check for valid system (why?).
1234: E6A8     3ACEE7     	LDA	FCB+1	;anything to execute?
1235: E6AB     FE20       	CPI	BLANK          
1236: E6AD     C2C4E6     	JNZ	UNKWN1         
1237: E6B0     3AF0E7     	LDA	CHGDRV	;nope, only a drive change?
1238: E6B3     B7         	ORA	A              
1239: E6B4     CA89E7     	JZ	GETBACK1;neither???
1240: E6B7     3D         	DCR	A              
1241: E6B8     32EFE7     	STA	CDRIVE	;ok, store new drive.
1242: E6BB     CD29E1     	CALL	MOVECD	;set (TDRIVE) also.
1243: E6BE     CDBDE0     	CALL	DSKSEL	;and select this drive.
1244: E6C1     C389E7     	JMP	GETBACK1;then return.
1245: E6C4                ;                   
1246: E6C4                ;   Here a file name was typed. Prepare to execute it.
1247: E6C4                ;                   
1248: E6C4                UNKWN1:             
1249: E6C4     11D6E7     	LXI	D,FCB+9	;an extension specified?
1250: E6C7     1A         	LDAX	D             
1251: E6C8     FE20       	CPI	BLANK          
1252: E6CA     C209E2     	JNZ	SYNERR	;yes, not allowed.
1253: E6CD                UNKWN2:             
1254: E6CD     D5         	PUSH	D             
1255: E6CE     CD54E4     	CALL	DSELECT	;select specified drive.
1256: E6D1     D1         	POP	D              
1257: E6D2     2183E7     	LXI	H,COMFILE	;set the extension to 'COM'.
1258: E6D5     CD40E4     	CALL	MOVE3         
1259: E6D8     CDD0E0     	CALL	OPENFCB	;and open this file.
1260: E6DB     CA6BE7     	JZ	UNKWN9	;not present?
1261: E6DE                ;                   
1262: E6DE                ;   Load in the program.
1263: E6DE                ;                   
1264: E6DE     210001     	LXI	H,TBASE	;store the program starting here.
1265: E6E1                UNKWN3:             
1266: E6E1     E5         	PUSH	H             
1267: E6E2     EB         	XCHG               
1268: E6E3     CDD8E1     	CALL	DMASET	;set transfer address.
1269: E6E6     11CDE7     	LXI	D,FCB	;and read the next record.
1270: E6E9     CDF9E0     	CALL	RDREC         
1271: E6EC     C201E7     	JNZ	UNKWN4	;end of file or read error?
1272: E6EF     E1         	POP	H	;nope, bump pointer for next sector.
1273: E6F0     118000     	LXI	D,128          
1274: E6F3     19         	DAD	D              
1275: E6F4     1100E0     	LXI	D,CBASE	;enough room for the whole file?
1276: E6F7     7D         	MOV	A,L            
1277: E6F8     93         	SUB	E              
1278: E6F9     7C         	MOV	A,H            
1279: E6FA     9A         	SBB	D              
1280: E6FB     D271E7     	JNC	UNKWN0	;no, it can't fit.
1281: E6FE     C3E1E6     	JMP	UNKWN3         
1282: E701                ;                   
1283: E701                ;   Get here after finished reading.
1284: E701                ;                   
1285: E701                UNKWN4:             
1286: E701     E1         	POP	H              
1287: E702     3D         	DCR	A	;normal end of file?
1288: E703     C271E7     	JNZ	UNKWN0         
1289: E706     CD66E4     	CALL	RESETDR	;yes, reset previous drive.
1290: E709     CD5EE2     	CALL	CONVFST	;convert the first file name that follows
1291: E70C     21F0E7     	LXI	H,CHGDRV;command name.
1292: E70F     E5         	PUSH	H             
1293: E710     7E         	MOV	A,M	;set drive code in default fcb.
1294: E711     32CDE7     	STA	FCB            
1295: E714     3E10       	MVI	A,16	;put second name 16 bytes later.
1296: E716     CD60E2     	CALL	CONVERT	;convert second file name.
1297: E719     E1         	POP	H              
1298: E71A     7E         	MOV	A,M	;and set the drive for this second file.
1299: E71B     32DDE7     	STA	FCB+16         
1300: E71E     AF         	XRA	A	;clear record byte in fcb.
1301: E71F     32EDE7     	STA	FCB+32         
1302: E722     115C00     	LXI	D,TFCB	;move it into place at(005Ch).
1303: E725     21CDE7     	LXI	H,FCB          
1304: E728     0621       	MVI	B,33           
1305: E72A     CD42E4     	CALL	HL2DE         
1306: E72D     2108E0     	LXI	H,INBUFF+2;now move the remainder of the input
1307: E730                UNKWN5:             
1308: E730     7E         	MOV	A,M	;line down to (0080h). Look for a non blank.
1309: E731     B7         	ORA	A	;or a null.  
1310: E732     CA3EE7     	JZ	UNKWN6          
1311: E735     FE20       	CPI	BLANK          
1312: E737     CA3EE7     	JZ	UNKWN6          
1313: E73A     23         	INX	H              
1314: E73B     C330E7     	JMP	UNKWN5         
1315: E73E                ;                   
1316: E73E                ;   Do the line move now. It ends in a null byte.
1317: E73E                ;                   
1318: E73E                UNKWN6:             
1319: E73E     0600       	MVI	B,0	;keep a character count.
1320: E740     118100     	LXI	D,Pg0Buffer+1;data gets put here.
1321: E743                UNKWN7:             
1322: E743     7E         	MOV	A,M	;move it now.
1323: E744     12         	STAX	D             
1324: E745     B7         	ORA	A              
1325: E746     CA4FE7     	JZ	UNKWN8          
1326: E749     04         	INR	B              
1327: E74A     23         	INX	H              
1328: E74B     13         	INX	D              
1329: E74C     C343E7     	JMP	UNKWN7         
1330: E74F                UNKWN8:             
1331: E74F     78         	MOV	A,B	;now store the character count.
1332: E750     328000     	STA	Pg0Buffer      
1333: E753     CD98E0     	CALL	CRLF	;clean up the screen.
1334: E756     CDD5E1     	CALL	STDDMA	;set standard transfer address.
1335: E759     CD1AE1     	CALL	SETCDRV	;reset current drive.
1336: E75C     CD0001     	CALL	TBASE	;and execute the program.
1337: E75F                ;                   
1338: E75F                ;   Transiant programs return here (or reboot).
1339: E75F                ;                   
1340: E75F     31ABE7     	LXI	SP,BATCH	;set stack first off.
1341: E762     CD29E1     	CALL	MOVECD	;move current drive into place (TDRIVE).
1342: E765     CDBDE0     	CALL	DSKSEL	;and reselect it.
1343: E768     C382E3     	JMP	CMMND1	;back to comand mode.
1344: E76B                ;                   
1345: E76B                ;   Get here if some error occured.
1346: E76B                ;                   
1347: E76B                UNKWN9:             
1348: E76B     CD66E4     	CALL	RESETDR	;inproper format.
1349: E76E     C309E2     	JMP	SYNERR         
1350: E771                UNKWN0:             
1351: E771     017AE7     	LXI	B,BADLOAD;read error or won't fit.
1352: E774     CDA7E0     	CALL	PLINE         
1353: E777     C386E7     	JMP	GETBACK        
1354: E77A                BADLOAD:            
1355: E77A     424144204C4F414400 	DB	'Bad load',0    
1356: E783                COMFILE:            
1357: E783     434F4D     	DB	'COM'	;command file extension.
1358: E786                ;                   
1359: E786                ;   Get here to return to command level. We will reset the
1360: E786                ; previous active drive and then either return to command
1361: E786                ; level directly or print error message and then return.
1362: E786                ;                   
1363: E786                GETBACK:            
1364: E786     CD66E4     	CALL	RESETDR	;reset previous drive.
1365: E789                GETBACK1:           
1366: E789     CD5EE2     	CALL	CONVFST	;convert first name in (FCB).
1367: E78C     3ACEE7     	LDA	FCB+1	;if this was just a drive change request,
1368: E78F     D620       	SUI	BLANK	;make sure it was valid.
1369: E791     21F0E7     	LXI	H,CHGDRV       
1370: E794     B6         	ORA	M              
1371: E795     C209E2     	JNZ	SYNERR         
1372: E798     C382E3     	JMP	CMMND1	;ok, return to command level.
1373: E79B                ;                   
1374: E79B                ;   ccp stack area. 
1375: E79B                ;                   
1376: E79B     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1377: E7AB                CCPSTACK	EQU	$	;end of ccp stack area.
1378: E7AB                ;                   
1379: E7AB                ;   Batch (or SUBMIT) processing information storage.
1380: E7AB                ;                   
1381: E7AB                BATCH:              
1382: E7AB     00         	DB	0	;batch mode flag (0=not active).
1383: E7AC                BATCHFCB:           
1384: E7AC     002424242020202020535542000000000000000000000000000000000000000000 DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1385: E7CD                ;                   
1386: E7CD                ;   File control block setup by the CCP.
1387: E7CD                ;                   
1388: E7CD                FCB:                
1389: E7CD     002020202020202020202020000000000020202020202020202020200000000000 	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
1390: E7EE                RTNCODE:            
1391: E7EE     00         	DB	0	;status returned from bdos call.
1392: E7EF                CDRIVE:             
1393: E7EF     00         	DB	0	;currently active drive.
1394: E7F0                CHGDRV:             
1395: E7F0     00         	DB	0	;change in drives flag (0=no change).
1396: E7F1                NBYTES:             
1397: E7F1     0000       	DW	0	;byte counter used by TYPE.
1398: E7F3                ;                   
1399: E7F3                ;   Room for expansion?
1400: E7F3                ;                   
1401: E7F3     00000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
1402: E800                ;                   
1403: E800                ;   Note that the following six bytes must match those at
1404: E800                ; (PATTRN1) or cp/m will HALT. Why?
1405: E800                ;                   
1406: E800                PATTRN2:            
1407: E800     001600000000 	DB	0,22,0,0,0,0;(* serial number bytes *).
1408: E806                ;                   
1409: E806                ;**************************************************************
1410: E806                ;*                  
1411: E806                ;*                    B D O S   E N T R Y
1412: E806                ;*                  
1413: E806                ;**************************************************************
1414: E806                ;                   
1415: E806                BDOSEntry:          
1416: E806     C311E8     	JMP	BDOSSetup      
1417: E809                ;                   
1418: E809                ;   Bdos error table.
1419: E809                ;                   
1420: E809     99E8       BADSCTR:	DW	ERROR1	;bad sector on read or write.
1421: E80B     A5E8       BADSLCT:	DW	ERROR2	;bad disk select.
1422: E80D     ABE8       RODISK:		DW	ERROR3	;disk is read only.
1423: E80F     B1E8       ROFILE:		DW	ERROR4	;file is read only.
1424: E811                ;                   
1425: E811                ;   Entry into bdos.
1426: E811                ;			Parameters: (DE) or (E) are the parameters passed. The
1427: E811                ;						(C) - function number
1428: E811                ;	The user's stack is saved (UserStack) 
1429: E811                ;	BDOS uses its own stack  (BDOSstack)
1430: E811                ;	The Function number is checked
1431: E811                ;	The corect routine is calcualted using the FunctionVector and (C)
1432: E811                ;                   
1433: E811                BDOSSetup:          
1434: E811     EB         	XCHG						;save the (DE) parameters.
1435: E812     2243EB     	SHLD	ParamsDE      
1436: E815     EB         	XCHG               
1437: E816     7B         	MOV		A,E					;and save register (E) in particular.
1438: E817     32D6F5     	STA		ParamE        
1439: E81A     210000     	LXI		H,0           
1440: E81D     2245EB     	SHLD	STATUS				;clear return status.
1441: E820     39         	DAD		SP            
1442: E821     220FEB     	SHLD	UserStack			;save users stack pointer.
1443: E824     3141EB     	LXI		SP,BDOSstack		;and set our own.
1444: E827     AF         	XRA		A					;clear auto select storage space.
1445: E828     32E0F5     	STA		AUTOFLAG      
1446: E82B     32DEF5     	STA		AUTO          
1447: E82E     2174F5     	LXI		H,BDOSExit			;set return address.
1448: E831     E5         	PUSH	H             
1449: E832     79         	MOV		A,C					;get function number.
1450: E833     FE29       	CPI		FunctionCount + 1	;valid function number?
1451: E835     D0         	RNC                
1452: E836     4B         	MOV		C,E					;keep single register function here.
1453: E837     2147E8     	LXI		H,FunctionVector	;now look thru the function table.
1454: E83A     5F         	MOV		E,A           
1455: E83B     1600       	MVI		D,0					;(DE)=function number.
1456: E83D     19         	DAD		D             
1457: E83E     19         	DAD		D					;(HL)=(start of table)+2*(function number).
1458: E83F     5E         	MOV		E,M           
1459: E840     23         	INX		H             
1460: E841     56         	MOV		D,M					;now (DE)=address for this function.
1461: E842     2A43EB     	LHLD	ParamsDE			;retrieve parameters.
1462: E845     EB         	XCHG						;now (DE) has the original parameters.
1463: E846     E9         	PCHL			;execute desired function.
1464: E847                ;                   
1465: E847                ;   BDOS function jump table.
1466: E847                ;                   
1467: E847                ;NFUNCTS	EQU	41	;number of functions in followin table.
1468: E847                ;                   
1469: E847                FunctionVector:     
1470: E847     03F6       	DW	WBOOT	;0		Overall system and BDOS reset
1471: E849     C8EA       	DW	GETCON	;1		Read a byte from the console keyboard
1472: E84B     90E9       	DW	OUTCON	;2		Write a byte to the console screen
1473: E84D     CEEA       	DW	GETRDR	;3		Read a byte from the logical reader device
1474: E84F     12F6       	DW	PUNCH	;4		Write a byte to the logical punch device
1475: E851     0FF6       	DW	LIST	;5		Write a byte to the logical list device
1476: E853     D4EA       	DW	DIRCIO	;6		Direct console I/O (no CCP-style editing)
1477: E855     EDEA       	DW	GETIOB	;7		Read the current setting of the IOBYTE
1478: E857     F3EA       	DW	SETIOB	;8		Set a new value of the IOBYTE
1479: E859     F8EA       	DW	PRTSTR	;9		Send a "$"-terminated string to the console
1480: E85B     E1E9       	DW	RDBUFF	;10		Read a string from the console into a buffer
1481: E85D     FEEA       	DW	GETCSTS	;11		Check if a console key is waiting to be read
1482: E85F     7EF4       	DW	GETVER	;12		Return the CP/M version number
1483: E861                	                   
1484: E861     83F4       	DW	RSTDSK		;13		Reset disk system
1485: E863     45F4       	DW	SETDSK		;14		Select specified logical disk drive
1486: E865     9CF4       	DW	OPENFIL		;15		Open specified file for reading/writing
1487: E867     A5F4       	DW	CLOSEFIL	;16		Close specified file after reading/writing
1488: E869     ABF4       	DW	GETFST		;17		Search file directory for first match with filename
1489: E86B     C8F4       	DW	GETNXT		;18		Search file directory for next match with filename
1490: E86D     D7F4       	DW	DELFILE		;19		Delete (erase) file
1491: E86F     E0F4       	DW	READSEQ		;20		Read the next "record" sequentially
1492: E871     E6F4       	DW	WRTSEQ		;21		Write the next "record" sequentially
1493: E873     ECF4       	DW	FCREATE		;22		Create a new file with the specified name
1494: E875     F5F4       	DW	RENFILE		;23		Rename a file to a new name
1495: E877     FEF4       	DW	GETLOG		;24		Indicate which logical disks are active
1496: E879     04F5       	DW	GETCRNT		;25		Return the current default disk drive number
1497: E87B     0AF5       	DW	PUTDMA		;26		Set the DMA address (read/write address)
1498: E87D     11F5       	DW	GETALOC		;27		Return the address of an allocation vector
1499: E87F     2CED       	DW	WRTPRTD		;28		Return the address of an allocation vector
1500: E881     17F5       	DW	GETROV		;29		Indicate which disks are currently Read-Only status
1501: E883     1DF5       	DW	SETATTR		;30		Set specified file to System or Read-Only status
1502: E885     26F5       	DW	GETPARM		;31		Return address of disk parameter block (DPB)
1503: E887     2DF5       	DW	GETUSER		;32		Set/Get the current user number
1504: E889     41F5       	DW	RDRANDOM	;33		Set/Get the current user number
1505: E88B     47F5       	DW	WTRANDOM	;34		Write a "record" randomly
1506: E88D     4DF5       	DW	FILESIZE	;35		Return logical file size (even for random files)
1507: E88F     0EF4       	DW	SETRAN		;36		Set record number for the next random read/write
1508: E891     53F5       	DW	LOGOFF		;37     
1509: E893     04EB       	DW	Return			;38		Simple Return
1510: E895     04EB       	DW	Return			;39		Simple Return
1511: E897     9BF5       	DW	WTSPECL		;40		Write a "record" randomly with zero fill
1512: E899                	                   
1513: E899                FunctionCount	EQU	 ($ -FunctionVector)/2
1514: E899                ;                   
1515: E899                ;   Bdos error message section.
1516: E899                ;                   
1517: E899                ERROR1:             
1518: E899     21CAE8     	LXI	H,BADSEC	;bad sector message.
1519: E89C     CDE5E8     	CALL	PRTERR	;print it and get a 1 char responce.
1520: E89F     FE03       	CPI	CNTRLC	;re-boot request (control-c)?
1521: E8A1     CA0000     	JZ	0	;yes.         
1522: E8A4     C9         	RET		;no, return to retry i/o function.
1523: E8A5                ;                   
1524: E8A5                ERROR2:             
1525: E8A5     21D5E8     	LXI	H,BADSEL	;bad drive selected.
1526: E8A8     C3B4E8     	JMP	ERROR5         
1527: E8AB                ;                   
1528: E8AB                ERROR3:             
1529: E8AB     21E1E8     	LXI	H,DISKRO	;disk is read only.
1530: E8AE     C3B4E8     	JMP	ERROR5         
1531: E8B1                ;                   
1532: E8B1                ERROR4:             
1533: E8B1     21DCE8     	LXI	H,FILERO	;file is read only.
1534: E8B4                ;                   
1535: E8B4                ERROR5:             
1536: E8B4     CDE5E8     	CALL	PRTERR        
1537: E8B7     C30000     	JMP	0	;always reboot on these errors.
1538: E8BA                ;                   
1539: E8BA     42444F5320455252204F4E20 BDOSERR:	DB	'Bdos Err On '
1540: E8C6     203A2024   BDOSDRV:	DB	' : $'  
1541: E8CA     42414420534543544F5224 BADSEC:		DB	'Bad Sector$'
1542: E8D5     53454C45435424 BADSEL:		DB	'Select$'
1543: E8DC     46494C4520 FILERO:		DB	'File ' 
1544: E8E1     522F4F24   DISKRO:		DB	'R/O$'  
1545: E8E5                ;                   
1546: E8E5                ;   Print bdos error message.
1547: E8E5                ;                   
1548: E8E5                PRTERR:             
1549: E8E5     E5         	PUSH	H	;save second message pointer.
1550: E8E6     CDC9E9     	CALL	OUTCRLF	;send (cr)(lf).
1551: E8E9     3A42EB     	LDA	CurrentDrive	;get Current Drive drive.
1552: E8EC     C641       	ADI	041H	; 'A'	;make ascii.
1553: E8EE     32C6E8     	STA	BDOSDRV	;and put in message.
1554: E8F1     01BAE8     	LXI	B,BDOSERR;and print it.
1555: E8F4     CDD3E9     	CALL	PRTMESG       
1556: E8F7     C1         	POP	B	;print second message line now.
1557: E8F8     CDD3E9     	CALL	PRTMESG       
1558: E8FB                ;                   
1559: E8FB                ;   Get an input character. We will check our 1 character
1560: E8FB                ; buffer first. This may be set by the console status routine.
1561: E8FB                ;                   
1562: E8FB                GETCHAR:            
1563: E8FB     210EEB     	LXI	H,CHARBUF;check character buffer.
1564: E8FE     7E         	MOV	A,M	;anything present already?
1565: E8FF     3600       	MVI	M,0	;...either case clear it.
1566: E901     B7         	ORA	A              
1567: E902     C0         	RNZ		;yes, use it. 
1568: E903     C309F6     	JMP	CONIN	;nope, go get a character responce.
1569: E906                ;                   
1570: E906                ;   Input and echo a character.
1571: E906                ;                   
1572: E906                GETECHO:            
1573: E906     CDFBE8     	CALL	GETCHAR	;input a character.
1574: E909     CD14E9     	CALL	CHKCHAR	;carriage control?
1575: E90C     D8         	RC		;no, a regular control char so don't echo.
1576: E90D     F5         	PUSH	PSW	;ok, save character now.
1577: E90E     4F         	MOV	C,A            
1578: E90F     CD90E9     	CALL	OUTCON	;and echo it.
1579: E912     F1         	POP	PSW	;get character and return.
1580: E913     C9         	RET                
1581: E914                ;                   
1582: E914                ;   Check character in (A). Set the zero flag on a carriage
1583: E914                ; control character and the carry flag on any other control
1584: E914                ; character.        
1585: E914                ;                   
1586: E914                CHKCHAR:            
1587: E914     FE0D       	CPI	CR	;check for carriage return, line feed, backspace,
1588: E916     C8         	RZ		;or a tab.     
1589: E917     FE0A       	CPI	LF             
1590: E919     C8         	RZ                 
1591: E91A     FE09       	CPI	TAB            
1592: E91C     C8         	RZ                 
1593: E91D     FE08       	CPI	BS             
1594: E91F     C8         	RZ                 
1595: E920     FE20       	CPI	BLANK	;other control char? Set carry flag.
1596: E922     C9         	RET                
1597: E923                ;                   
1598: E923                ;   Check the console during output. Halt on a control-s, then
1599: E923                ; reboot on a control-c. If anything else is ready, clear the
1600: E923                ; zero flag and return (the calling routine may want to do
1601: E923                ; something).       
1602: E923                ;                   
1603: E923                CKCONSOL:           
1604: E923     3A0EEB     	LDA	CHARBUF	;check buffer.
1605: E926     B7         	ORA	A	;if anything, just return without checking.
1606: E927     C245E9     	JNZ	CKCON2         
1607: E92A     CD06F6     	CALL	CONST	;nothing in buffer. Check console.
1608: E92D     E601       	ANI	01H	;look at bit 0.
1609: E92F     C8         	RZ		;return if nothing.
1610: E930     CD09F6     	CALL	CONIN	;ok, get it.
1611: E933     FE13       	CPI	CNTRLS	;if not control-s, return with zero cleared.
1612: E935     C242E9     	JNZ	CKCON1         
1613: E938     CD09F6     	CALL	CONIN	;halt processing until another char
1614: E93B     FE03       	CPI	CNTRLC	;is typed. Control-c?
1615: E93D     CA0000     	JZ	0	;yes, reboot now.
1616: E940     AF         	XRA	A	;no, just pretend nothing was ever ready.
1617: E941     C9         	RET                
1618: E942                CKCON1:             
1619: E942     320EEB     	STA	CHARBUF	;save character in buffer for later processing.
1620: E945                CKCON2:             
1621: E945     3E01       	MVI	A,1	;set (A) to non zero to mean something is ready.
1622: E947     C9         	RET                
1623: E948                ;                   
1624: E948                ;   Output (C) to the screen. If the printer flip-flop flag
1625: E948                ; is set, we will send character to printer also. The console
1626: E948                ; will be checked in the process.
1627: E948                ;                   
1628: E948                OUTCHAR:            
1629: E948     3A0AEB     	LDA	OUTFLAG	;check output flag.
1630: E94B     B7         	ORA	A	;anything and we won't generate output.
1631: E94C     C262E9     	JNZ	OUTCHR1        
1632: E94F     C5         	PUSH	B             
1633: E950     CD23E9     	CALL	CKCONSOL;check console (we don't care whats there).
1634: E953     C1         	POP	B              
1635: E954     C5         	PUSH	B             
1636: E955     CD0CF6     	CALL	CONOUT	;output (C) to the screen.
1637: E958     C1         	POP	B              
1638: E959     C5         	PUSH	B             
1639: E95A     3A0DEB     	LDA	PRTFLAG	;check printer flip-flop flag.
1640: E95D     B7         	ORA	A              
1641: E95E     C40FF6     	CNZ	LIST	;print it also if non-zero.
1642: E961     C1         	POP	B              
1643: E962                OUTCHR1:            
1644: E962     79         	MOV	A,C	;update cursors position.
1645: E963     210CEB     	LXI	H,CURPOS       
1646: E966     FE7F       	CPI	DEL	;rubouts don't do anything here.
1647: E968     C8         	RZ                 
1648: E969     34         	INR	M	;bump line pointer.
1649: E96A     FE20       	CPI	BLANK	;and return if a normal character.
1650: E96C     D0         	RNC                
1651: E96D     35         	DCR	M	;restore and check for the start of the line.
1652: E96E     7E         	MOV	A,M            
1653: E96F     B7         	ORA	A              
1654: E970     C8         	RZ		;ingnore control characters at the start of the line.
1655: E971     79         	MOV	A,C            
1656: E972     FE08       	CPI	BS	;is it a backspace?
1657: E974     C279E9     	JNZ	OUTCHR2        
1658: E977     35         	DCR	M	;yes, backup pointer.
1659: E978     C9         	RET                
1660: E979                OUTCHR2:            
1661: E979     FE0A       	CPI	LF	;is it a line feed?
1662: E97B     C0         	RNZ		;ignore anything else.
1663: E97C     3600       	MVI	M,0	;reset pointer to start of line.
1664: E97E     C9         	RET                
1665: E97F                ;                   
1666: E97F                ;   Output (A) to the screen. If it is a control character
1667: E97F                ; (other than carriage control), use ^x format.
1668: E97F                ;                   
1669: E97F                SHOWIT:             
1670: E97F     79         	MOV	A,C            
1671: E980     CD14E9     	CALL	CHKCHAR	;check character.
1672: E983     D290E9     	JNC	OUTCON	;not a control, use normal output.
1673: E986     F5         	PUSH	PSW           
1674: E987     0E5E       	MVI	C, CARET	; '^'	;for a control character, preceed it with '^'.
1675: E989     CD48E9     	CALL	OUTCHAR       
1676: E98C     F1         	POP	PSW            
1677: E98D     F640       	ORI	ATSIGN		; '@'	;and then use the letter equivelant.
1678: E98F     4F         	MOV	C,A            
1679: E990                ;                   
1680: E990                ;   Function to output (C) to the console device and expand tabs
1681: E990                ; if necessary.     
1682: E990                ;                   
1683: E990                OUTCON:             
1684: E990     79         	MOV	A,C            
1685: E991     FE09       	CPI	TAB	;is it a tab?
1686: E993     C248E9     	JNZ	OUTCHAR	;use regular output.
1687: E996                OUTCON1:            
1688: E996     0E20       	MVI	C,BLANK	;yes it is, use spaces instead.
1689: E998     CD48E9     	CALL	OUTCHAR       
1690: E99B     3A0CEB     	LDA	CURPOS	;go until the cursor is at a multiple of 8
1691: E99E                                    
1692: E99E     E607       	ANI	07H	;position. 
1693: E9A0     C296E9     	JNZ	OUTCON1        
1694: E9A3     C9         	RET                
1695: E9A4                ;                   
1696: E9A4                ;   Echo a backspace character. Erase the prevoius character
1697: E9A4                ; on the screen.    
1698: E9A4                ;                   
1699: E9A4                BACKUP:             
1700: E9A4     CDACE9     	CALL	BACKUP1	;backup the screen 1 place.
1701: E9A7     0E20       	MVI	C,BLANK	;then blank that character.
1702: E9A9     CD0CF6     	CALL	CONOUT        
1703: E9AC                BACKUP1:            
1704: E9AC     0E08       	MVI	C,BS	;then back space once more.
1705: E9AE     C30CF6     	JMP	CONOUT         
1706: E9B1                ;                   
1707: E9B1                ;   Signal a deleted line. Print a '#' at the end and start
1708: E9B1                ; over.             
1709: E9B1                ;                   
1710: E9B1                NEWLINE:            
1711: E9B1     0E23       	MVI	C, POUNDSN		; '#'
1712: E9B3     CD48E9     	CALL	OUTCHAR	;print this.
1713: E9B6     CDC9E9     	CALL	OUTCRLF	;start new line.
1714: E9B9                NEWLN1:             
1715: E9B9     3A0CEB     	LDA	CURPOS	;move the cursor to the starting position.
1716: E9BC     210BEB     	LXI	H,STARTING     
1717: E9BF     BE         	CMP	M              
1718: E9C0     D0         	RNC		;there yet?   
1719: E9C1     0E20       	MVI	C,BLANK        
1720: E9C3     CD48E9     	CALL	OUTCHAR	;nope, keep going.
1721: E9C6     C3B9E9     	JMP	NEWLN1         
1722: E9C9                ;                   
1723: E9C9                ;   Output a (cr) (lf) to the console device (screen).
1724: E9C9                ;                   
1725: E9C9                OUTCRLF:            
1726: E9C9     0E0D       	MVI	C,CR           
1727: E9CB     CD48E9     	CALL	OUTCHAR       
1728: E9CE     0E0A       	MVI	C,LF           
1729: E9D0     C348E9     	JMP	OUTCHAR        
1730: E9D3                ;                   
1731: E9D3                ;   Print message pointed to by (BC). It will end with a '$'.
1732: E9D3                ;                   
1733: E9D3                PRTMESG:            
1734: E9D3     0A         	LDAX	B	;check for terminating character.
1735: E9D4     FE24       	CPI	DOLLAR		; '$'  
1736: E9D6     C8         	RZ                 
1737: E9D7     03         	INX	B              
1738: E9D8     C5         	PUSH	B	;otherwise, bump pointer and print it.
1739: E9D9     4F         	MOV	C,A            
1740: E9DA     CD90E9     	CALL	OUTCON        
1741: E9DD     C1         	POP	B              
1742: E9DE     C3D3E9     	JMP	PRTMESG        
1743: E9E1                ;                   
1744: E9E1                ;   Function to execute a buffered read.
1745: E9E1                ;                   
1746: E9E1                RDBUFF:             
1747: E9E1     3A0CEB     	LDA	CURPOS	;use present location as starting one.
1748: E9E4     320BEB     	STA	STARTING       
1749: E9E7     2A43EB     	LHLD	ParamsDE	;get the maximum buffer space.
1750: E9EA     4E         	MOV	C,M            
1751: E9EB     23         	INX	H	;point to first available space.
1752: E9EC     E5         	PUSH	H	;and save.  
1753: E9ED     0600       	MVI	B,0	;keep a character count.
1754: E9EF                RDBUF1:             
1755: E9EF     C5         	PUSH	B             
1756: E9F0     E5         	PUSH	H             
1757: E9F1                RDBUF2:             
1758: E9F1     CDFBE8     	CALL	GETCHAR	;get the next input character.
1759: E9F4     E67F       	ANI	7FH	;strip bit 7.
1760: E9F6     E1         	POP	H	;reset registers.
1761: E9F7     C1         	POP	B              
1762: E9F8     FE0D       	CPI	CR	;en of the line?
1763: E9FA     CAC1EA     	JZ	RDBUF17         
1764: E9FD     FE0A       	CPI	LF             
1765: E9FF     CAC1EA     	JZ	RDBUF17         
1766: EA02     FE08       	CPI	BS	;how about a backspace?
1767: EA04     C216EA     	JNZ	RDBUF3         
1768: EA07     78         	MOV	A,B	;yes, but ignore at the beginning of the line.
1769: EA08     B7         	ORA	A              
1770: EA09     CAEFE9     	JZ	RDBUF1          
1771: EA0C     05         	DCR	B	;ok, update counter.
1772: EA0D     3A0CEB     	LDA	CURPOS	;if we backspace to the start of the line,
1773: EA10     320AEB     	STA	OUTFLAG	;treat as a cancel (control-x).
1774: EA13     C370EA     	JMP	RDBUF10        
1775: EA16                RDBUF3:             
1776: EA16     FE7F       	CPI	DEL	;user typed a rubout?
1777: EA18     C226EA     	JNZ	RDBUF4         
1778: EA1B     78         	MOV	A,B	;ignore at the start of the line.
1779: EA1C     B7         	ORA	A              
1780: EA1D     CAEFE9     	JZ	RDBUF1          
1781: EA20     7E         	MOV	A,M	;ok, echo the prevoius character.
1782: EA21     05         	DCR	B	;and reset pointers (counters).
1783: EA22     2B         	DCX	H              
1784: EA23     C3A9EA     	JMP	RDBUF15        
1785: EA26                RDBUF4:             
1786: EA26     FE05       	CPI	CNTRLE	;physical end of line?
1787: EA28     C237EA     	JNZ	RDBUF5         
1788: EA2B     C5         	PUSH	B	;yes, do it.
1789: EA2C     E5         	PUSH	H             
1790: EA2D     CDC9E9     	CALL	OUTCRLF       
1791: EA30     AF         	XRA	A	;and update starting position.
1792: EA31     320BEB     	STA	STARTING       
1793: EA34     C3F1E9     	JMP	RDBUF2         
1794: EA37                RDBUF5:             
1795: EA37     FE10       	CPI	CNTRLP	;control-p?
1796: EA39     C248EA     	JNZ	RDBUF6         
1797: EA3C     E5         	PUSH	H	;yes, flip the print flag filp-flop byte.
1798: EA3D     210DEB     	LXI	H,PRTFLAG      
1799: EA40     3E01       	MVI	A,1	;PRTFLAG=1-PRTFLAG
1800: EA42     96         	SUB	M              
1801: EA43     77         	MOV	M,A            
1802: EA44     E1         	POP	H              
1803: EA45     C3EFE9     	JMP	RDBUF1         
1804: EA48                RDBUF6:             
1805: EA48     FE18       	CPI	CNTRLX	;control-x (cancel)?
1806: EA4A     C25FEA     	JNZ	RDBUF8         
1807: EA4D     E1         	POP	H              
1808: EA4E                RDBUF7:             
1809: EA4E     3A0BEB     	LDA	STARTING;yes, backup the cursor to here.
1810: EA51     210CEB     	LXI	H,CURPOS       
1811: EA54     BE         	CMP	M              
1812: EA55     D2E1E9     	JNC	RDBUFF	;done yet?
1813: EA58     35         	DCR	M	;no, decrement pointer and output back up one space.
1814: EA59     CDA4E9     	CALL	BACKUP        
1815: EA5C     C34EEA     	JMP	RDBUF7         
1816: EA5F                RDBUF8:             
1817: EA5F     FE15       	CPI	CNTRLU	;cntrol-u (cancel line)?
1818: EA61     C26BEA     	JNZ	RDBUF9         
1819: EA64     CDB1E9     	CALL	NEWLINE	;start a new line.
1820: EA67     E1         	POP	H              
1821: EA68     C3E1E9     	JMP	RDBUFF         
1822: EA6B                RDBUF9:             
1823: EA6B     FE12       	CPI	CNTRLR	;control-r?
1824: EA6D     C2A6EA     	JNZ	RDBUF14        
1825: EA70                RDBUF10:            
1826: EA70     C5         	PUSH	B	;yes, start a new line and retype the old one.
1827: EA71     CDB1E9     	CALL	NEWLINE       
1828: EA74     C1         	POP	B              
1829: EA75     E1         	POP	H              
1830: EA76     E5         	PUSH	H             
1831: EA77     C5         	PUSH	B             
1832: EA78                RDBUF11:            
1833: EA78     78         	MOV	A,B	;done whole line yet?
1834: EA79     B7         	ORA	A              
1835: EA7A     CA8AEA     	JZ	RDBUF12         
1836: EA7D     23         	INX	H	;nope, get next character.
1837: EA7E     4E         	MOV	C,M            
1838: EA7F     05         	DCR	B	;count it.   
1839: EA80     C5         	PUSH	B             
1840: EA81     E5         	PUSH	H             
1841: EA82     CD7FE9     	CALL	SHOWIT	;and display it.
1842: EA85     E1         	POP	H              
1843: EA86     C1         	POP	B              
1844: EA87     C378EA     	JMP	RDBUF11        
1845: EA8A                RDBUF12:            
1846: EA8A     E5         	PUSH	H	;done with line. If we were displaying
1847: EA8B     3A0AEB     	LDA	OUTFLAG	;then update cursor position.
1848: EA8E     B7         	ORA	A              
1849: EA8F     CAF1E9     	JZ	RDBUF2          
1850: EA92     210CEB     	LXI	H,CURPOS;because this line is shorter, we must
1851: EA95     96         	SUB	M	;back up the cursor (not the screen however)
1852: EA96     320AEB     	STA	OUTFLAG	;some number of positions.
1853: EA99                RDBUF13:            
1854: EA99     CDA4E9     	CALL	BACKUP	;note that as long as (OUTFLAG) is non
1855: EA9C     210AEB     	LXI	H,OUTFLAG;zero, the screen will not be changed.
1856: EA9F     35         	DCR	M              
1857: EAA0     C299EA     	JNZ	RDBUF13        
1858: EAA3     C3F1E9     	JMP	RDBUF2	;now just get the next character.
1859: EAA6                ;                   
1860: EAA6                ;   Just a normal character, put this in our buffer and echo.
1861: EAA6                ;                   
1862: EAA6                RDBUF14:            
1863: EAA6     23         	INX	H              
1864: EAA7     77         	MOV	M,A	;store character.
1865: EAA8     04         	INR	B	;and count it.
1866: EAA9                RDBUF15:            
1867: EAA9     C5         	PUSH	B             
1868: EAAA     E5         	PUSH	H             
1869: EAAB     4F         	MOV	C,A	;echo it now.
1870: EAAC     CD7FE9     	CALL	SHOWIT        
1871: EAAF     E1         	POP	H              
1872: EAB0     C1         	POP	B              
1873: EAB1     7E         	MOV	A,M	;was it an abort request?
1874: EAB2     FE03       	CPI	CNTRLC	;control-c abort?
1875: EAB4     78         	MOV	A,B            
1876: EAB5     C2BDEA     	JNZ	RDBUF16        
1877: EAB8     FE01       	CPI	1	;only if at start of line.
1878: EABA     CA0000     	JZ	0               
1879: EABD                RDBUF16:            
1880: EABD     B9         	CMP	C	;nope, have we filled the buffer?
1881: EABE     DAEFE9     	JC	RDBUF1          
1882: EAC1                RDBUF17:            
1883: EAC1     E1         	POP	H	;yes end the line and return.
1884: EAC2     70         	MOV	M,B            
1885: EAC3     0E0D       	MVI	C,CR           
1886: EAC5     C348E9     	JMP	OUTCHAR	;output (cr) and return.
1887: EAC8                ;                   
1888: EAC8                ;   Function to get a character from the console device.
1889: EAC8                ;                   
1890: EAC8                GETCON:             
1891: EAC8     CD06E9     	CALL	GETECHO	;get and echo.
1892: EACB     C301EB     	JMP	SETSTAT	;save status and return.
1893: EACE                ;                   
1894: EACE                ;   Function to get a character from the tape reader device.
1895: EACE                ;                   
1896: EACE                GETRDR:             
1897: EACE     CD15F6     	CALL	READER	;get a character from reader, set status and return.
1898: EAD1     C301EB     	JMP	SETSTAT        
1899: EAD4                ;                   
1900: EAD4                ;  Function to perform direct console i/o. If (C) contains (FF)
1901: EAD4                ; then this is an input request. If (C) contains (FE) then
1902: EAD4                ; this is a status request. Otherwise we are to output (C).
1903: EAD4                ;                   
1904: EAD4                DIRCIO:             
1905: EAD4     79         	MOV	A,C	;test for (FF).
1906: EAD5     3C         	INR	A              
1907: EAD6     CAE0EA     	JZ	DIRC1           
1908: EAD9     3C         	INR	A	;test for (FE).
1909: EADA     CA06F6     	JZ	CONST           
1910: EADD     C30CF6     	JMP	CONOUT	;just output (C).
1911: EAE0                DIRC1:              
1912: EAE0     CD06F6     	CALL	CONST	;this is an input request.
1913: EAE3     B7         	ORA	A              
1914: EAE4     CA91F5     	JZ	BDOSExit1	;not ready? Just return (directly).
1915: EAE7     CD09F6     	CALL	CONIN	;yes, get character.
1916: EAEA     C301EB     	JMP	SETSTAT	;set status and return.
1917: EAED                ;                   
1918: EAED                ;   Function to return the i/o byte.
1919: EAED                ;                   
1920: EAED                GETIOB:             
1921: EAED     3A0300     	LDA	IOBYTE         
1922: EAF0     C301EB     	JMP	SETSTAT        
1923: EAF3                ;                   
1924: EAF3                ;   Function to set the i/o byte.
1925: EAF3                ;                   
1926: EAF3                SETIOB:             
1927: EAF3     210300     	LXI	H,IOBYTE       
1928: EAF6     71         	MOV	M,C            
1929: EAF7     C9         	RET                
1930: EAF8                ;                   
1931: EAF8                ;   Function to print the character string pointed to by (DE)
1932: EAF8                ; on the console device. The string ends with a '$'.
1933: EAF8                ;                   
1934: EAF8                PRTSTR:             
1935: EAF8     EB         	XCHG               
1936: EAF9     4D         	MOV	C,L            
1937: EAFA     44         	MOV	B,H	;now (BC) points to it.
1938: EAFB     C3D3E9     	JMP	PRTMESG        
1939: EAFE                ;                   
1940: EAFE                ;   Function to interigate the console device.
1941: EAFE                ;                   
1942: EAFE                GETCSTS:            
1943: EAFE     CD23E9     	CALL	CKCONSOL      
1944: EB01                ;                   
1945: EB01                ;   Get here to set the status and return to the cleanup
1946: EB01                ; section. Then back to the user.
1947: EB01                ;                   
1948: EB01                SETSTAT:            
1949: EB01     3245EB     	STA	STATUS         
1950: EB04                Return:             
1951: EB04     C9         	RET                
1952: EB05                ;                   
1953: EB05                ;   Set the status to 1 (read or write error code).
1954: EB05                ;                   
1955: EB05                IOERR1:             
1956: EB05     3E01       	MVI	A,1            
1957: EB07     C301EB     	JMP	SETSTAT        
1958: EB0A                ;                   
1959: EB0A     00         OUTFLAG:	DB	0	;output flag (non zero means no output).
1960: EB0B     02         STARTING:	DB	2	;starting position for cursor.
1961: EB0C     00         CURPOS:		DB	0	;cursor position (0=start of line).
1962: EB0D     00         PRTFLAG:	DB	0	;printer flag (control-p toggle). List if non zero.
1963: EB0E     00         CHARBUF:	DB	0	;single input character buffer.
1964: EB0F                ;                   
1965: EB0F                ;   Stack area for BDOS calls.
1966: EB0F                ;                   
1967: EB0F                UserStack:          
1968: EB0F     0000       	DW	0	;save users stack pointer here.
1969: EB11                ;                   
1970: EB11     000000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1971: EB29     000000000000000000000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
1972: EB41                BDOSstack	EQU	$	;end of stack area.
1973: EB41                ;                   
1974: EB41     00         USERNO:	DB	0	;current user number.
1975: EB42     00         CurrentDrive:	DB	0	;currently active drive.
1976: EB43     0000       ParamsDE:	DW	0	;save (DE) parameters here on entry.
1977: EB45     0000       STATUS:	DW	0	;status returned from bdos function.
1978: EB47                ;                   
1979: EB47                ;   Select error occured, jump to error routine.
1980: EB47                ;                   
1981: EB47                SLCTERR:            
1982: EB47     210BE8     	LXI	H,BADSLCT      
1983: EB4A                ;                   
1984: EB4A                ;   Jump to (HL) indirectly.
1985: EB4A                ;                   
1986: EB4A                JUMPHL:             
1987: EB4A     5E         	MOV	E,M            
1988: EB4B     23         	INX	H              
1989: EB4C     56         	MOV	D,M	;now (DE) contain the desired address.
1990: EB4D     EB         	XCHG               
1991: EB4E     E9         	PCHL               
1992: EB4F                ;                   
1993: EB4F                ;   Block move. (DE) to (HL), (C) bytes total.
1994: EB4F                ;                   
1995: EB4F                DE2HL:              
1996: EB4F     0C         	INR	C	;is count down to zero?
1997: EB50                DE2HL1:             
1998: EB50     0D         	DCR	C              
1999: EB51     C8         	RZ		;yes, we are done.
2000: EB52     1A         	LDAX	D	;no, move one more byte.
2001: EB53     77         	MOV	M,A            
2002: EB54     13         	INX	D              
2003: EB55     23         	INX	H              
2004: EB56     C350EB     	JMP	DE2HL1	;and repeat.
2005: EB59                ;                   
2006: EB59                ;   Select the desired drive.
2007: EB59                ;                   
2008: EB59                SelectDisk:         
2009: EB59     3A42EB     	LDA	CurrentDrive	;get active disk.
2010: EB5C     4F         	MOV	C,A            
2011: EB5D     CD1BF6     	CALL	SELDSK	; (BIOS CALL )select it.
2012: EB60     7C         	MOV	A,H	;valid drive?
2013: EB61     B5         	ORA	L	;valid drive?
2014: EB62     C8         	RZ		;return if not.
2015: EB63                ;                   
2016: EB63                ;   Here, the BIOS returned the address of the parameter block
2017: EB63                ; in (HL). We will extract the necessary pointers and save them.
2018: EB63                ;                   
2019: EB63     5E         	MOV	E,M	;yes, get address of translation table into (DE).
2020: EB64     23         	INX	H              
2021: EB65     56         	MOV	D,M            
2022: EB66     23         	INX	H              
2023: EB67     22B3F5     	SHLD	SCRATCH1	;save pointers to scratch areas.
2024: EB6A     23         	INX	H              
2025: EB6B     23         	INX	H              
2026: EB6C     22B5F5     	SHLD	SCRATCH2	;ditto.
2027: EB6F     23         	INX	H              
2028: EB70     23         	INX	H              
2029: EB71     22B7F5     	SHLD	SCRATCH3	;ditto.
2030: EB74     23         	INX	H              
2031: EB75     23         	INX	H              
2032: EB76     EB         	XCHG		;now save the translation table address.
2033: EB77     22D0F5     	SHLD	XLATE         
2034: EB7A     21B9F5     	LXI	H,DIRBUF	;put the next 8 bytes here.
2035: EB7D     0E08       	MVI	C,8	;they consist of the directory buffer
2036: EB7F     CD4FEB     	CALL	DE2HL	;pointer, parameter block pointer,
2037: EB82     2ABBF5     	LHLD	DISKPB	;check and allocation vectors.
2038: EB85     EB         	XCHG               
2039: EB86     21C1F5     	LXI	H,SECTORS	;move parameter block into our ram.
2040: EB89     0E0F       	MVI	C,15	;it is 15 bytes long.
2041: EB8B     CD4FEB     	CALL	DE2HL         
2042: EB8E     2AC6F5     	LHLD	DSKSIZE	;check disk size.
2043: EB91     7C         	MOV	A,H	;more than 256 blocks on this?
2044: EB92     21DDF5     	LXI	H,BIGDISK      
2045: EB95     36FF       	MVI	M,0FFH	;set to samll.
2046: EB97     B7         	ORA	A              
2047: EB98     CA9DEB     	JZ	SelectDisk1     
2048: EB9B     3600       	MVI	M,0	;wrong, set to large.
2049: EB9D                SelectDisk1:        
2050: EB9D     3EFF       	MVI	A,0FFH	;clear the zero flag.
2051: EB9F     B7         	ORA	A              
2052: EBA0     C9         	RET                
2053: EBA1                ;                   
2054: EBA1                ;   Routine to home the disk track head and clear pointers.
2055: EBA1                ;                   
2056: EBA1                HOMEDRV:            
2057: EBA1     CD18F6     	CALL	HOME	;home the head.
2058: EBA4     AF         	XRA	A              
2059: EBA5     2AB5F5     	LHLD	SCRATCH2;set our track pointer also.
2060: EBA8     77         	MOV	M,A            
2061: EBA9     23         	INX	H              
2062: EBAA     77         	MOV	M,A            
2063: EBAB     2AB7F5     	LHLD	SCRATCH3;and our sector pointer.
2064: EBAE     77         	MOV	M,A            
2065: EBAF     23         	INX	H              
2066: EBB0     77         	MOV	M,A            
2067: EBB1     C9         	RET                
2068: EBB2                ;                   
2069: EBB2                ;   Do the actual disk read and check the error return status.
2070: EBB2                ;                   
2071: EBB2                DOREAD:             
2072: EBB2     CD27F6     	CALL	READ          
2073: EBB5     C3BBEB     	JMP	IORET          
2074: EBB8                ;                   
2075: EBB8                ;   Do the actual disk write and handle any bios error.
2076: EBB8                ;                   
2077: EBB8                DOWRITE:            
2078: EBB8     CD2AF6     	CALL	WRITE         
2079: EBBB                IORET:              
2080: EBBB     B7         	ORA	A              
2081: EBBC     C8         	RZ		;return unless an error occured.
2082: EBBD     2109E8     	LXI	H,BADSCTR;bad read/write on this sector.
2083: EBC0     C34AEB     	JMP	JUMPHL         
2084: EBC3                ;                   
2085: EBC3                ;   Routine to select the track and sector that the desired
2086: EBC3                ; block number falls in.
2087: EBC3                ;                   
2088: EBC3                TRKSEC:             
2089: EBC3     2AEAF5     	LHLD	FILEPOS	;get position of last accessed file
2090: EBC6     0E02       	MVI	C,2	;in directory and compute sector #.
2091: EBC8     CDEAEC     	CALL	SHIFTR	;sector #=file-position/4.
2092: EBCB     22E5F5     	SHLD	BLKNMBR	;save this as the block number of interest.
2093: EBCE     22ECF5     	SHLD	CKSUMTBL;what's it doing here too?
2094: EBD1                ;                   
2095: EBD1                ;   if the sector number has already been set (BLKNMBR), enter
2096: EBD1                ; at this point.    
2097: EBD1                ;                   
2098: EBD1                TRKSEC1:            
2099: EBD1     21E5F5     	LXI	H,BLKNMBR      
2100: EBD4     4E         	MOV	C,M	;move sector number into (BC).
2101: EBD5     23         	INX	H              
2102: EBD6     46         	MOV	B,M            
2103: EBD7     2AB7F5     	LHLD	SCRATCH3;get current sector number and
2104: EBDA     5E         	MOV	E,M	;move this into (DE).
2105: EBDB     23         	INX	H              
2106: EBDC     56         	MOV	D,M            
2107: EBDD     2AB5F5     	LHLD	SCRATCH2;get current track number.
2108: EBE0     7E         	MOV	A,M	;and this into (HL).
2109: EBE1     23         	INX	H              
2110: EBE2     66         	MOV	H,M            
2111: EBE3     6F         	MOV	L,A            
2112: EBE4                TRKSEC2:            
2113: EBE4     79         	MOV	A,C	;is desired sector before current one?
2114: EBE5     93         	SUB	E              
2115: EBE6     78         	MOV	A,B            
2116: EBE7     9A         	SBB	D              
2117: EBE8     D2FAEB     	JNC	TRKSEC3        
2118: EBEB     E5         	PUSH	H	;yes, decrement sectors by one track.
2119: EBEC     2AC1F5     	LHLD	SECTORS	;get sectors per track.
2120: EBEF     7B         	MOV	A,E            
2121: EBF0     95         	SUB	L              
2122: EBF1     5F         	MOV	E,A            
2123: EBF2     7A         	MOV	A,D            
2124: EBF3     9C         	SBB	H              
2125: EBF4     57         	MOV	D,A	;now we have backed up one full track.
2126: EBF5     E1         	POP	H              
2127: EBF6     2B         	DCX	H	;adjust track counter.
2128: EBF7     C3E4EB     	JMP	TRKSEC2        
2129: EBFA                TRKSEC3:            
2130: EBFA     E5         	PUSH	H	;desired sector is after current one.
2131: EBFB     2AC1F5     	LHLD	SECTORS	;get sectors per track.
2132: EBFE     19         	DAD	D	;bump sector pointer to next track.
2133: EBFF     DA0FEC     	JC	TRKSEC4         
2134: EC02     79         	MOV	A,C	;is desired sector now before current one?
2135: EC03     95         	SUB	L              
2136: EC04     78         	MOV	A,B            
2137: EC05     9C         	SBB	H              
2138: EC06     DA0FEC     	JC	TRKSEC4         
2139: EC09     EB         	XCHG		;not yes, increment track counter
2140: EC0A     E1         	POP	H	;and continue until it is.
2141: EC0B     23         	INX	H              
2142: EC0C     C3FAEB     	JMP	TRKSEC3        
2143: EC0F                ;                   
2144: EC0F                ;   here we have determined the track number that contains the
2145: EC0F                ; desired sector.   
2146: EC0F                ;                   
2147: EC0F                TRKSEC4:            
2148: EC0F     E1         	POP	H	;get track number (HL).
2149: EC10     C5         	PUSH	B             
2150: EC11     D5         	PUSH	D             
2151: EC12     E5         	PUSH	H             
2152: EC13     EB         	XCHG               
2153: EC14     2ACEF5     	LHLD	OFFSET	;adjust for first track offset.
2154: EC17     19         	DAD	D              
2155: EC18     44         	MOV	B,H            
2156: EC19     4D         	MOV	C,L            
2157: EC1A     CD1EF6     	CALL	SETTRK	;select this track.
2158: EC1D     D1         	POP	D	;reset current track pointer.
2159: EC1E     2AB5F5     	LHLD	SCRATCH2      
2160: EC21     73         	MOV	M,E            
2161: EC22     23         	INX	H              
2162: EC23     72         	MOV	M,D            
2163: EC24     D1         	POP	D              
2164: EC25     2AB7F5     	LHLD	SCRATCH3;reset the first sector on this track.
2165: EC28     73         	MOV	M,E            
2166: EC29     23         	INX	H              
2167: EC2A     72         	MOV	M,D            
2168: EC2B     C1         	POP	B              
2169: EC2C     79         	MOV	A,C	;now subtract the desired one.
2170: EC2D     93         	SUB	E	;to make it relative (1-# sectors/track).
2171: EC2E     4F         	MOV	C,A            
2172: EC2F     78         	MOV	A,B            
2173: EC30     9A         	SBB	D              
2174: EC31     47         	MOV	B,A            
2175: EC32     2AD0F5     	LHLD	XLATE	;translate this sector according to this table.
2176: EC35     EB         	XCHG               
2177: EC36     CD30F6     	CALL	SECTRN	;let the bios translate it.
2178: EC39     4D         	MOV	C,L            
2179: EC3A     44         	MOV	B,H            
2180: EC3B     C321F6     	JMP	SETSEC	;and select it.
2181: EC3E                ;                   
2182: EC3E                ;   Compute block number from record number (SAVNREC) and
2183: EC3E                ; extent number (SAVEXT).
2184: EC3E                ;                   
2185: EC3E                GETBLOCK:           
2186: EC3E     21C3F5     	LXI	H,BLKSHFT;get logical to physical conversion.
2187: EC41     4E         	MOV	C,M	;note that this is base 2 log of ratio.
2188: EC42     3AE3F5     	LDA	SAVNREC	;get record number.
2189: EC45                GETBLK1:            
2190: EC45     B7         	ORA	A	;compute (A)=(A)/2^BLKSHFT.
2191: EC46     1F         	RAR                
2192: EC47     0D         	DCR	C              
2193: EC48     C245EC     	JNZ	GETBLK1        
2194: EC4B     47         	MOV	B,A	;save result in (B).
2195: EC4C     3E08       	MVI	A,8            
2196: EC4E     96         	SUB	M              
2197: EC4F     4F         	MOV	C,A	;compute (C)=8-BLKSHFT.
2198: EC50     3AE2F5     	LDA	SAVEXT         
2199: EC53                GETBLK2:            
2200: EC53     0D         	DCR	C	;compute (A)=SAVEXT*2^(8-BLKSHFT).
2201: EC54     CA5CEC     	JZ	GETBLK3         
2202: EC57     B7         	ORA	A              
2203: EC58     17         	RAL                
2204: EC59     C353EC     	JMP	GETBLK2        
2205: EC5C                GETBLK3:            
2206: EC5C     80         	ADD	B              
2207: EC5D     C9         	RET                
2208: EC5E                ;                   
2209: EC5E                ;   Routine to extract the (BC) block byte from the fcb pointed
2210: EC5E                ; to by (ParamsDE). If this is a big-disk, then these are 16 bit
2211: EC5E                ; block numbers, else they are 8 bit numbers.
2212: EC5E                ; Number is returned in (HL).
2213: EC5E                ;                   
2214: EC5E                EXTBLK:             
2215: EC5E     2A43EB     	LHLD	ParamsDE	;get fcb address.
2216: EC61     111000     	LXI	D,16	;block numbers start 16 bytes into fcb.
2217: EC64     19         	DAD	D              
2218: EC65     09         	DAD	B              
2219: EC66     3ADDF5     	LDA	BIGDISK	;are we using a big-disk?
2220: EC69     B7         	ORA	A              
2221: EC6A     CA71EC     	JZ	EXTBLK1         
2222: EC6D     6E         	MOV	L,M	;no, extract an 8 bit number from the fcb.
2223: EC6E     2600       	MVI	H,0            
2224: EC70     C9         	RET                
2225: EC71                EXTBLK1:            
2226: EC71     09         	DAD	B	;yes, extract a 16 bit number.
2227: EC72     5E         	MOV	E,M            
2228: EC73     23         	INX	H              
2229: EC74     56         	MOV	D,M            
2230: EC75     EB         	XCHG		;return in (HL).
2231: EC76     C9         	RET                
2232: EC77                ;                   
2233: EC77                ;   Compute block number.
2234: EC77                ;                   
2235: EC77                COMBLK:             
2236: EC77     CD3EEC     	CALL	GETBLOCK      
2237: EC7A     4F         	MOV	C,A            
2238: EC7B     0600       	MVI	B,0            
2239: EC7D     CD5EEC     	CALL	EXTBLK        
2240: EC80     22E5F5     	SHLD	BLKNMBR       
2241: EC83     C9         	RET                
2242: EC84                ;                   
2243: EC84                ;   Check for a zero block number (unused).
2244: EC84                ;                   
2245: EC84                CHKBLK:             
2246: EC84     2AE5F5     	LHLD	BLKNMBR       
2247: EC87     7D         	MOV	A,L	;is it zero?
2248: EC88     B4         	ORA	H              
2249: EC89     C9         	RET                
2250: EC8A                ;                   
2251: EC8A                ;   Adjust physical block (BLKNMBR) and convert to logical
2252: EC8A                ; sector (LOGSECT). This is the starting sector of this block.
2253: EC8A                ; The actual sector of interest is then added to this and the
2254: EC8A                ; resulting sector number is stored back in (BLKNMBR). This
2255: EC8A                ; will still have to be adjusted for the track number.
2256: EC8A                ;                   
2257: EC8A                LOGICAL:            
2258: EC8A     3AC3F5     	LDA	BLKSHFT	;get log2(physical/logical sectors).
2259: EC8D     2AE5F5     	LHLD	BLKNMBR	;get physical sector desired.
2260: EC90                LOGICL1:            
2261: EC90     29         	DAD	H	;compute logical sector number.
2262: EC91     3D         	DCR	A	;note logical sectors are 128 bytes long.
2263: EC92     C290EC     	JNZ	LOGICL1        
2264: EC95     22E7F5     	SHLD	LOGSECT	;save logical sector.
2265: EC98     3AC4F5     	LDA	BLKMASK	;get block mask.
2266: EC9B     4F         	MOV	C,A            
2267: EC9C     3AE3F5     	LDA	SAVNREC	;get next sector to access.
2268: EC9F     A1         	ANA	C	;extract the relative position within physical block.
2269: ECA0     B5         	ORA	L	;and add it too logical sector.
2270: ECA1     6F         	MOV	L,A            
2271: ECA2     22E5F5     	SHLD	BLKNMBR	;and store.
2272: ECA5     C9         	RET                
2273: ECA6                ;                   
2274: ECA6                ;   Set (HL) to point to extent byte in fcb.
2275: ECA6                ;                   
2276: ECA6                SETEXT:             
2277: ECA6     2A43EB     	LHLD	ParamsDE      
2278: ECA9     110C00     	LXI	D,12	;it is the twelth byte.
2279: ECAC     19         	DAD	D              
2280: ECAD     C9         	RET                
2281: ECAE                ;                   
2282: ECAE                ;   Set (HL) to point to record count byte in fcb and (DE) to
2283: ECAE                ; next record number byte.
2284: ECAE                ;                   
2285: ECAE                SETHLDE:            
2286: ECAE     2A43EB     	LHLD	ParamsDE      
2287: ECB1     110F00     	LXI	D,15	;record count byte (#15).
2288: ECB4     19         	DAD	D              
2289: ECB5     EB         	XCHG               
2290: ECB6     211100     	LXI	H,17	;next record number (#32).
2291: ECB9     19         	DAD	D              
2292: ECBA     C9         	RET                
2293: ECBB                ;                   
2294: ECBB                ;   Save current file data from fcb.
2295: ECBB                ;                   
2296: ECBB                STRDATA:            
2297: ECBB     CDAEEC     	CALL	SETHLDE       
2298: ECBE     7E         	MOV	A,M	;get and store record count byte.
2299: ECBF     32E3F5     	STA	SAVNREC        
2300: ECC2     EB         	XCHG               
2301: ECC3     7E         	MOV	A,M	;get and store next record number byte.
2302: ECC4     32E1F5     	STA	SAVNXT         
2303: ECC7     CDA6EC     	CALL	SETEXT	;point to extent byte.
2304: ECCA     3AC5F5     	LDA	EXTMASK	;get extent mask.
2305: ECCD     A6         	ANA	M              
2306: ECCE     32E2F5     	STA	SAVEXT	;and save extent here.
2307: ECD1     C9         	RET                
2308: ECD2                ;                   
2309: ECD2                ;   Set the next record to access. If (MODE) is set to 2, then
2310: ECD2                ; the last record byte (SAVNREC) has the correct number to access.
2311: ECD2                ; For sequential access, (MODE) will be equal to 1.
2312: ECD2                ;                   
2313: ECD2                SETNREC:            
2314: ECD2     CDAEEC     	CALL	SETHLDE       
2315: ECD5     3AD5F5     	LDA	MODE	;get sequential flag (=1).
2316: ECD8     FE02       	CPI	2	;a 2 indicates that no adder is needed.
2317: ECDA     C2DEEC     	JNZ	STNREC1        
2318: ECDD     AF         	XRA	A	;clear adder (random access?).
2319: ECDE                STNREC1:            
2320: ECDE     4F         	MOV	C,A            
2321: ECDF     3AE3F5     	LDA	SAVNREC	;get last record number.
2322: ECE2     81         	ADD	C	;increment record count.
2323: ECE3     77         	MOV	M,A	;and set fcb's next record byte.
2324: ECE4     EB         	XCHG               
2325: ECE5     3AE1F5     	LDA	SAVNXT	;get next record byte from storage.
2326: ECE8     77         	MOV	M,A	;and put this into fcb as number of records used.
2327: ECE9     C9         	RET                
2328: ECEA                ;                   
2329: ECEA                ;   Shift HL right (C) bits.
2330: ECEA                ;                   
2331: ECEA                SHIFTR:             
2332: ECEA     0C         	INR		C			; minor adjustment
2333: ECEB                SHIFTR1:            
2334: ECEB     0D         	DCR		C			; count down
2335: ECEC     C8         	RZ					; exit if done
2336: ECED     7C         	MOV		A,H			; get the hi byte
2337: ECEE     B7         	ORA		A			; reset carry bit
2338: ECEF     1F         	RAR					; rotate right thru carry
2339: ECF0     67         	MOV		H,A			; return new hi byte
2340: ECF1     7D         	MOV		A,L			; get lo byte
2341: ECF2     1F         	RAR					; rotate right thru carry
2342: ECF3     6F         	MOV		L,A			; return new lo byte
2343: ECF4     C3EBEC     	JMP		SHIFTR1		; keep doing it
2344: ECF7                ;                   
2345: ECF7                ;   Compute the check-sum for the directory buffer. Return
2346: ECF7                ; integer sum in (A).
2347: ECF7                ;                   
2348: ECF7                CHECKSUM:           
2349: ECF7     0E80       	MVI	C,128	;length of buffer.
2350: ECF9     2AB9F5     	LHLD	DIRBUF	;get its location.
2351: ECFC     AF         	XRA	A	;clear summation byte.
2352: ECFD                CHKSUM1:            
2353: ECFD     86         	ADD	M	;and compute sum ignoring carries.
2354: ECFE     23         	INX	H              
2355: ECFF     0D         	DCR	C              
2356: ED00     C2FDEC     	JNZ	CHKSUM1        
2357: ED03     C9         	RET                
2358: ED04                ;                   
2359: ED04                ;   Shift (HL) left (C) bits.
2360: ED04                ;                   
2361: ED04                SHIFTL:             
2362: ED04     0C         	INR	C              
2363: ED05                SHIFTL1:            
2364: ED05     0D         	DCR	C              
2365: ED06     C8         	RZ                 
2366: ED07     29         	DAD	H	;shift left 1 bit.
2367: ED08     C305ED     	JMP	SHIFTL1        
2368: ED0B                ;                   
2369: ED0B                ;   Routine to set a bit in a 16 bit value contained in (BC).
2370: ED0B                ; The bit set depends on the current drive selection.
2371: ED0B                ;                   
2372: ED0B                SETBIT:             
2373: ED0B     C5         	PUSH	B	;save 16 bit word.
2374: ED0C     3A42EB     	LDA	CurrentDrive	;get active drive.
2375: ED0F     4F         	MOV	C,A            
2376: ED10     210100     	LXI	H,1            
2377: ED13     CD04ED     	CALL	SHIFTL	;shift bit 0 into place.
2378: ED16     C1         	POP	B	;now 'or' this with the original word.
2379: ED17     79         	MOV	A,C            
2380: ED18     B5         	ORA	L              
2381: ED19     6F         	MOV	L,A	;low byte done, do high byte.
2382: ED1A     78         	MOV	A,B            
2383: ED1B     B4         	ORA	H              
2384: ED1C     67         	MOV	H,A            
2385: ED1D     C9         	RET                
2386: ED1E                ;                   
2387: ED1E                ;   Extract the write protect status bit for the current drive.
2388: ED1E                ; The result is returned in (A), bit 0.
2389: ED1E                ;                   
2390: ED1E                GETWPRT:            
2391: ED1E     2AADF5     	LHLD	ROBitMap	;get Read Only Bit Map
2392: ED21     3A42EB     	LDA	CurrentDrive	;which drive is current?
2393: ED24     4F         	MOV	C,A            
2394: ED25     CDEAEC     	CALL	SHIFTR	;shift status such that bit 0 is the
2395: ED28     7D         	MOV	A,L	;one of interest for this drive.
2396: ED29     E601       	ANI	01H	;and isolate it.
2397: ED2B     C9         	RET                
2398: ED2C                ;                   
2399: ED2C                ;   Function to write protect the current disk.
2400: ED2C                ;                   
2401: ED2C                WRTPRTD:            
2402: ED2C     21ADF5     	LXI	H,ROBitMap	;point to Read Only Bit Map
2403: ED2F     4E         	MOV	C,M	;set (BC) equal to the status.
2404: ED30     23         	INX	H              
2405: ED31     46         	MOV	B,M            
2406: ED32     CD0BED     	CALL	SETBIT	;and set this bit according to current drive.
2407: ED35     22ADF5     	SHLD	ROBitMap	;then save.
2408: ED38     2AC8F5     	LHLD	DIRSIZE	;now save directory size limit.
2409: ED3B     23         	INX	H	;remember the last one.
2410: ED3C     EB         	XCHG               
2411: ED3D     2AB3F5     	LHLD	SCRATCH1;and store it here.
2412: ED40     73         	MOV	M,E	;put low byte.
2413: ED41     23         	INX	H              
2414: ED42     72         	MOV	M,D	;then high byte.
2415: ED43     C9         	RET                
2416: ED44                ;                   
2417: ED44                ;   Check for a read only file.
2418: ED44                ;                   
2419: ED44                CHKROFL:            
2420: ED44     CD5EED     	CALL	FCB2HL	;set (HL) to file entry in directory buffer.
2421: ED47                CKROF1:             
2422: ED47     110900     	LXI	D,9	;look at bit 7 of the ninth byte.
2423: ED4A     19         	DAD	D              
2424: ED4B     7E         	MOV	A,M            
2425: ED4C     17         	RAL                
2426: ED4D     D0         	RNC		;return if ok.
2427: ED4E     210FE8     	LXI	H,ROFILE;else, print error message and terminate.
2428: ED51     C34AEB     	JMP	JUMPHL         
2429: ED54                ;                   
2430: ED54                ;   Check the write protect status of the active disk.
2431: ED54                ;                   
2432: ED54                CHKWPRT:            
2433: ED54     CD1EED     	CALL	GETWPRT       
2434: ED57     C8         	RZ		;return if ok. 
2435: ED58     210DE8     	LXI	H,RODISK;else print message and terminate.
2436: ED5B     C34AEB     	JMP	JUMPHL         
2437: ED5E                ;                   
2438: ED5E                ;   Routine to set (HL) pointing to the proper entry in the
2439: ED5E                ; directory buffer. 
2440: ED5E                ;                   
2441: ED5E                FCB2HL:             
2442: ED5E     2AB9F5     	LHLD	DIRBUF	;get address of buffer.
2443: ED61     3AE9F5     	LDA	FCBPOS	;relative position of file.
2444: ED64                ;                   
2445: ED64                ;   Routine to add (A) to (HL).
2446: ED64                ;                   
2447: ED64                ADDA2HL:            
2448: ED64     85         	ADD	L              
2449: ED65     6F         	MOV	L,A            
2450: ED66     D0         	RNC                
2451: ED67     24         	INR	H	;take care of any carry.
2452: ED68     C9         	RET                
2453: ED69                ;                   
2454: ED69                ;   Routine to get the 's2' byte from the fcb supplied in
2455: ED69                ; the initial parameter specification.
2456: ED69                ;                   
2457: ED69                GETS2:              
2458: ED69     2A43EB     	LHLD	ParamsDE	;get address of fcb.
2459: ED6C     110E00     	LXI	D,14	;relative position of 's2'.
2460: ED6F     19         	DAD	D              
2461: ED70     7E         	MOV	A,M	;extract this byte.
2462: ED71     C9         	RET                
2463: ED72                ;                   
2464: ED72                ;   Clear the 's2' byte in the fcb.
2465: ED72                ;                   
2466: ED72                CLEARS2:            
2467: ED72     CD69ED     	CALL	GETS2	;this sets (HL) pointing to it.
2468: ED75     3600       	MVI	M,0	;now clear it.
2469: ED77     C9         	RET                
2470: ED78                ;                   
2471: ED78                ;   Set bit 7 in the 's2' byte of the fcb.
2472: ED78                ;                   
2473: ED78                SETS2B7:            
2474: ED78     CD69ED     	CALL	GETS2	;get the byte.
2475: ED7B     F680       	ORI	80H	;and set bit 7.
2476: ED7D     77         	MOV	M,A	;then store.
2477: ED7E     C9         	RET                
2478: ED7F                ;                   
2479: ED7F                ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
2480: ED7F                ; the difference. This checks to see if there are more file
2481: ED7F                ; names in the directory. We are at (FILEPOS) and there are
2482: ED7F                ; (SCRATCH1) of them to check.
2483: ED7F                ;                   
2484: ED7F                MOREFLS:            
2485: ED7F     2AEAF5     	LHLD	FILEPOS	;we are here.
2486: ED82     EB         	XCHG               
2487: ED83     2AB3F5     	LHLD	SCRATCH1;and don't go past here.
2488: ED86     7B         	MOV	A,E	;compute difference but don't keep.
2489: ED87     96         	SUB	M              
2490: ED88     23         	INX	H              
2491: ED89     7A         	MOV	A,D            
2492: ED8A     9E         	SBB	M	;set carry if no more names.
2493: ED8B     C9         	RET                
2494: ED8C                ;                   
2495: ED8C                ;   Call this routine to prevent (SCRATCH1) from being greater
2496: ED8C                ; than (FILEPOS).   
2497: ED8C                ;                   
2498: ED8C                CHKNMBR:            
2499: ED8C     CD7FED     	CALL	MOREFLS	;SCRATCH1 too big?
2500: ED8F     D8         	RC                 
2501: ED90     13         	INX	D	;yes, reset it to (FILEPOS).
2502: ED91     72         	MOV	M,D            
2503: ED92     2B         	DCX	H              
2504: ED93     73         	MOV	M,E            
2505: ED94     C9         	RET                
2506: ED95                ;                   
2507: ED95                ;   Compute (HL)=(DE)-(HL)
2508: ED95                ;                   
2509: ED95                SUBHL:              
2510: ED95     7B         	MOV	A,E	;compute difference.
2511: ED96     95         	SUB	L              
2512: ED97     6F         	MOV	L,A	;store low byte.
2513: ED98     7A         	MOV	A,D            
2514: ED99     9C         	SBB	H              
2515: ED9A     67         	MOV	H,A	;and then high byte.
2516: ED9B     C9         	RET                
2517: ED9C                ;                   
2518: ED9C                ;   Set the directory checksum byte.
2519: ED9C                ;                   
2520: ED9C                SETDIR:             
2521: ED9C     0EFF       	MVI	C,0FFH         
2522: ED9E                ;                   
2523: ED9E                ;   Routine to set or compare the directory checksum byte. If
2524: ED9E                ; (C)=0ffh, then this will set the checksum byte. Else the byte
2525: ED9E                ; will be checked. If the check fails (the disk has been changed),
2526: ED9E                ; then this disk will be write protected.
2527: ED9E                ;                   
2528: ED9E                CHECKDIR:           
2529: ED9E     2AECF5     	LHLD	CKSUMTBL      
2530: EDA1     EB         	XCHG               
2531: EDA2     2ACCF5     	LHLD	ALLOC1        
2532: EDA5     CD95ED     	CALL	SUBHL         
2533: EDA8     D0         	RNC		;ok if (CKSUMTBL) > (ALLOC1), so return.
2534: EDA9     C5         	PUSH	B             
2535: EDAA     CDF7EC     	CALL	CHECKSUM;else compute checksum.
2536: EDAD     2ABDF5     	LHLD	CHKVECT	;get address of checksum table.
2537: EDB0     EB         	XCHG               
2538: EDB1     2AECF5     	LHLD	CKSUMTBL      
2539: EDB4     19         	DAD	D	;set (HL) to point to byte for this drive.
2540: EDB5     C1         	POP	B              
2541: EDB6     0C         	INR	C	;set or check ?
2542: EDB7     CAC4ED     	JZ	CHKDIR1         
2543: EDBA     BE         	CMP	M	;check them. 
2544: EDBB     C8         	RZ		;return if they are the same.
2545: EDBC     CD7FED     	CALL	MOREFLS	;not the same, do we care?
2546: EDBF     D0         	RNC                
2547: EDC0     CD2CED     	CALL	WRTPRTD	;yes, mark this as write protected.
2548: EDC3     C9         	RET                
2549: EDC4                CHKDIR1:            
2550: EDC4     77         	MOV	M,A	;just set the byte.
2551: EDC5     C9         	RET                
2552: EDC6                ;                   
2553: EDC6                ;   Do a write to the directory of the current disk.
2554: EDC6                ;                   
2555: EDC6                DIRWRITE:           
2556: EDC6     CD9CED     	CALL	SETDIR			;set checksum byte.
2557: EDC9     CDE0ED     	CALL	SetDirDMA		;set directory dma address.
2558: EDCC     0E01       	MVI		C,1				;tell the bios to actually write.
2559: EDCE     CDB8EB     	CALL	DOWRITE			;then do the write.
2560: EDD1     C3DAED     	JMP		Set2UsersDMA  
2561: EDD4                ;                   
2562: EDD4                ;   Read from the directory.
2563: EDD4                ;                   
2564: EDD4                DIRREAD:            
2565: EDD4     CDE0ED     	CALL	SetDirDMA	;set the directory dma address.
2566: EDD7     CDB2EB     	CALL	DOREAD	;and read it.
2567: EDDA                ;                   
2568: EDDA                ;   Routine to set the dma address to the users choice.
2569: EDDA                ;                   
2570: EDDA                Set2UsersDMA:       
2571: EDDA     21B1F5     	LXI		H,UsersDMA		;reset the default dma address and return.
2572: EDDD     C3E3ED     	JMP		SetDMA0       
2573: EDE0                ;                   
2574: EDE0                ;   Routine to set the dma address for directory work.
2575: EDE0                ;                   
2576: EDE0                SetDirDMA:          
2577: EDE0     21B9F5     	LXI		H,DIRBUF      
2578: EDE3                ;                   
2579: EDE3                ;   Set the dma address. On entry, (HL) points to
2580: EDE3                ; word containing the desired dma address.
2581: EDE3                ;                   
2582: EDE3                SetDMA0:            
2583: EDE3     4E         	MOV		C,M           
2584: EDE4     23         	INX		H             
2585: EDE5     46         	MOV		B,M			;setup (BC) and go to the bios to set it.
2586: EDE6     C324F6     	JMP		SETDMA        
2587: EDE9                ;                   
2588: EDE9                ;   Move the directory buffer into user's dma space.
2589: EDE9                ;                   
2590: EDE9                MOVEDIR:            
2591: EDE9     2AB9F5     	LHLD	DIRBUF	;buffer is located here, and
2592: EDEC     EB         	XCHG               
2593: EDED     2AB1F5     	LHLD	UsersDMA; put it here.
2594: EDF0     0E80       	MVI	C,128	;this is its length.
2595: EDF2     C34FEB     	JMP	DE2HL	;move it now and return.
2596: EDF5                ;                   
2597: EDF5                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
2598: EDF5                ;                   
2599: EDF5                CKFILPOS:           
2600: EDF5     21EAF5     	LXI	H,FILEPOS      
2601: EDF8     7E         	MOV	A,M            
2602: EDF9     23         	INX	H              
2603: EDFA     BE         	CMP	M	;are both bytes the same?
2604: EDFB     C0         	RNZ                
2605: EDFC     3C         	INR	A	;yes, but are they each 0ffh?
2606: EDFD     C9         	RET                
2607: EDFE                ;                   
2608: EDFE                ;   Set location (FILEPOS) to 0ffffh.
2609: EDFE                ;                   
2610: EDFE                STFILPOS:           
2611: EDFE     210000     	LXI	H,0FFFFH       
2612: EE01     22EAF5     	SHLD	FILEPOS       
2613: EE04     C9         	RET                
2614: EE05                ;                   
2615: EE05                ;   Move on to the next file position within the current
2616: EE05                ; directory buffer. If no more exist, set pointer to 0ffffh
2617: EE05                ; and the calling routine will check for this. Enter with (C)
2618: EE05                ; equal to 0ffh to cause the checksum byte to be set, else we
2619: EE05                ; will check this disk and set write protect if checksums are
2620: EE05                ; not the same (applies only if another directory sector must
2621: EE05                ; be read).         
2622: EE05                ;                   
2623: EE05                NXENTRY:            
2624: EE05     2AC8F5     	LHLD	DIRSIZE	;get directory entry size limit.
2625: EE08     EB         	XCHG               
2626: EE09     2AEAF5     	LHLD	FILEPOS	;get current count.
2627: EE0C     23         	INX	H	;go on to the next one.
2628: EE0D     22EAF5     	SHLD	FILEPOS       
2629: EE10     CD95ED     	CALL	SUBHL	;(HL)=(DIRSIZE)-(FILEPOS)
2630: EE13     D219EE     	JNC	NXENT1	;is there more room left?
2631: EE16     C3FEED     	JMP	STFILPOS;no. Set this flag and return.
2632: EE19                NXENT1:             
2633: EE19     3AEAF5     	LDA	FILEPOS	;get file position within directory.
2634: EE1C     E603       	ANI	03H	;only look within this sector (only 4 entries fit).
2635: EE1E     0605       	MVI	B,5	;convert to relative position (32 bytes each).
2636: EE20                NXENT2:             
2637: EE20     87         	ADD	A	;note that this is not efficient code.
2638: EE21     05         	DCR	B	;5 'ADD A's would be better.
2639: EE22     C220EE     	JNZ	NXENT2         
2640: EE25     32E9F5     	STA	FCBPOS	;save it as position of fcb.
2641: EE28     B7         	ORA	A              
2642: EE29     C0         	RNZ		;return if we are within buffer.
2643: EE2A     C5         	PUSH	B             
2644: EE2B     CDC3EB     	CALL	TRKSEC	;we need the next directory sector.
2645: EE2E     CDD4ED     	CALL	DIRREAD       
2646: EE31     C1         	POP	B              
2647: EE32     C39EED     	JMP	CHECKDIR       
2648: EE35                ;                   
2649: EE35                ;   Routine to to get a bit from the disk space allocation
2650: EE35                ; map. It is returned in (A), bit position 0. On entry to here,
2651: EE35                ; set (BC) to the block number on the disk to check.
2652: EE35                ; On return, (D) will contain the original bit position for
2653: EE35                ; this block number and (HL) will point to the address for it.
2654: EE35                ;                   
2655: EE35                CKBITMAP:           
2656: EE35     79         	MOV	A,C	;determine bit number of interest.
2657: EE36     E607       	ANI	07H	;compute (D)=(E)=(C and 7)+1.
2658: EE38     3C         	INR	A              
2659: EE39     5F         	MOV	E,A	;save particular bit number.
2660: EE3A     57         	MOV	D,A            
2661: EE3B                ;                   
2662: EE3B                ;   compute (BC)=(BC)/8.
2663: EE3B                ;                   
2664: EE3B     79         	MOV	A,C            
2665: EE3C     0F         	RRC		;now shift right 3 bits.
2666: EE3D     0F         	RRC                
2667: EE3E     0F         	RRC                
2668: EE3F     E61F       	ANI	1FH	;and clear bits 7,6,5.
2669: EE41     4F         	MOV	C,A            
2670: EE42     78         	MOV	A,B            
2671: EE43     87         	ADD	A	;now shift (B) into bits 7,6,5.
2672: EE44     87         	ADD	A              
2673: EE45     87         	ADD	A              
2674: EE46     87         	ADD	A              
2675: EE47     87         	ADD	A              
2676: EE48     B1         	ORA	C	;and add in (C).
2677: EE49     4F         	MOV	C,A	;ok, (C) ha been completed.
2678: EE4A     78         	MOV	A,B	;is there a better way of doing this?
2679: EE4B     0F         	RRC                
2680: EE4C     0F         	RRC                
2681: EE4D     0F         	RRC                
2682: EE4E     E61F       	ANI	1FH            
2683: EE50     47         	MOV	B,A	;and now (B) is completed.
2684: EE51                ;                   
2685: EE51                ;   use this as an offset into the disk space allocation
2686: EE51                ; table.            
2687: EE51                ;                   
2688: EE51     2ABFF5     	LHLD	ALOCVECT      
2689: EE54     09         	DAD	B              
2690: EE55     7E         	MOV	A,M	;now get correct byte.
2691: EE56                CKBMAP1:            
2692: EE56     07         	RLC		;get correct bit into position 0.
2693: EE57     1D         	DCR	E              
2694: EE58     C256EE     	JNZ	CKBMAP1        
2695: EE5B     C9         	RET                
2696: EE5C                ;                   
2697: EE5C                ;   Set or clear the bit map such that block number (BC) will be marked
2698: EE5C                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
2699: EE5C                ; 1 then it will be set (don't use anyother values).
2700: EE5C                ;                   
2701: EE5C                STBITMAP:           
2702: EE5C     D5         	PUSH	D             
2703: EE5D     CD35EE     	CALL	CKBITMAP;get the byte of interest.
2704: EE60     E6FE       	ANI	0FEH	;clear the affected bit.
2705: EE62     C1         	POP	B              
2706: EE63     B1         	ORA	C	;and now set it acording to (C).
2707: EE64                ;                   
2708: EE64                ;  entry to restore the original bit position and then store
2709: EE64                ; in table. (A) contains the value, (D) contains the bit
2710: EE64                ; position (1-8), and (HL) points to the address within the
2711: EE64                ; space allocation table for this byte.
2712: EE64                ;                   
2713: EE64                STBMAP1:            
2714: EE64     0F         	RRC		;restore original bit position.
2715: EE65     15         	DCR	D              
2716: EE66     C264EE     	JNZ	STBMAP1        
2717: EE69     77         	MOV	M,A	;and stor byte in table.
2718: EE6A     C9         	RET                
2719: EE6B                ;                   
2720: EE6B                ;   Set/clear space used bits in allocation map for this file.
2721: EE6B                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
2722: EE6B                ;                   
2723: EE6B                SETFILE:            
2724: EE6B     CD5EED     	CALL	FCB2HL	;get address of fcb
2725: EE6E     111000     	LXI	D,16           
2726: EE71     19         	DAD	D	;get to block number bytes.
2727: EE72     C5         	PUSH	B             
2728: EE73     0E11       	MVI	C,17	;check all 17 bytes (max) of table.
2729: EE75                SETFL1:             
2730: EE75     D1         	POP	D              
2731: EE76     0D         	DCR	C	;done all bytes yet?
2732: EE77     C8         	RZ                 
2733: EE78     D5         	PUSH	D             
2734: EE79     3ADDF5     	LDA	BIGDISK	;check disk size for 16 bit block numbers.
2735: EE7C     B7         	ORA	A              
2736: EE7D     CA88EE     	JZ	SETFL2          
2737: EE80     C5         	PUSH	B	;only 8 bit numbers. set (BC) to this one.
2738: EE81     E5         	PUSH	H             
2739: EE82     4E         	MOV	C,M	;get low byte from table, always
2740: EE83     0600       	MVI	B,0	;set high byte to zero.
2741: EE85     C38EEE     	JMP	SETFL3         
2742: EE88                SETFL2:             
2743: EE88     0D         	DCR	C	;for 16 bit block numbers, adjust counter.
2744: EE89     C5         	PUSH	B             
2745: EE8A     4E         	MOV	C,M	;now get both the low and high bytes.
2746: EE8B     23         	INX	H              
2747: EE8C     46         	MOV	B,M            
2748: EE8D     E5         	PUSH	H             
2749: EE8E                SETFL3:             
2750: EE8E     79         	MOV	A,C	;block used?
2751: EE8F     B0         	ORA	B              
2752: EE90     CA9DEE     	JZ	SETFL4          
2753: EE93     2AC6F5     	LHLD	DSKSIZE	;is this block number within the
2754: EE96     7D         	MOV	A,L	;space on the disk?
2755: EE97     91         	SUB	C              
2756: EE98     7C         	MOV	A,H            
2757: EE99     98         	SBB	B              
2758: EE9A     D45CEE     	CNC	STBITMAP;yes, set the proper bit.
2759: EE9D                SETFL4:             
2760: EE9D     E1         	POP	H	;point to next block number in fcb.
2761: EE9E     23         	INX	H              
2762: EE9F     C1         	POP	B              
2763: EEA0     C375EE     	JMP	SETFL1         
2764: EEA3                ;                   
2765: EEA3                ;   Construct the space used allocation bit map for the active
2766: EEA3                ; drive. If a file name starts with '$' and it is under the
2767: EEA3                ; current user number, then (STATUS) is set to minus 1. Otherwise
2768: EEA3                ; it is not set at all.
2769: EEA3                ;                   
2770: EEA3                BITMAP:             
2771: EEA3     2AC6F5     	LHLD	DSKSIZE	;compute size of allocation table.
2772: EEA6     0E03       	MVI	C,3            
2773: EEA8     CDEAEC     	CALL	SHIFTR	;(HL)=(HL)/8.
2774: EEAB     23         	INX	H	;at lease 1 byte.
2775: EEAC     44         	MOV	B,H            
2776: EEAD     4D         	MOV	C,L	;set (BC) to the allocation table length.
2777: EEAE                ;                   
2778: EEAE                ;   Initialize the bitmap for this drive. Right now, the first
2779: EEAE                ; two bytes are specified by the disk parameter block. However
2780: EEAE                ; a patch could be entered here if it were necessary to setup
2781: EEAE                ; this table in a special mannor. For example, the bios could
2782: EEAE                ; determine locations of 'bad blocks' and set them as already
2783: EEAE                ; 'used' in the map.
2784: EEAE                ;                   
2785: EEAE     2ABFF5     	LHLD	ALOCVECT;now zero out the table now.
2786: EEB1                BITMAP1:            
2787: EEB1     3600       	MVI	M,0            
2788: EEB3     23         	INX	H              
2789: EEB4     0B         	DCX	B              
2790: EEB5     78         	MOV	A,B            
2791: EEB6     B1         	ORA	C              
2792: EEB7     C2B1EE     	JNZ	BITMAP1        
2793: EEBA     2ACAF5     	LHLD	ALLOC0	;get initial space used by directory.
2794: EEBD     EB         	XCHG               
2795: EEBE     2ABFF5     	LHLD	ALOCVECT;and put this into map.
2796: EEC1     73         	MOV	M,E            
2797: EEC2     23         	INX	H              
2798: EEC3     72         	MOV	M,D            
2799: EEC4                ;                   
2800: EEC4                ;   End of initialization portion.
2801: EEC4                ;                   
2802: EEC4     CDA1EB     	CALL	HOMEDRV	;now home the drive.
2803: EEC7     2AB3F5     	LHLD	SCRATCH1      
2804: EECA     3603       	MVI	M,3	;force next directory request to read
2805: EECC     23         	INX	H	;in a sector.
2806: EECD     3600       	MVI	M,0            
2807: EECF     CDFEED     	CALL	STFILPOS;clear initial file position also.
2808: EED2                BITMAP2:            
2809: EED2     0EFF       	MVI	C,0FFH	;read next file name in directory
2810: EED4     CD05EE     	CALL	NXENTRY	;and set checksum byte.
2811: EED7     CDF5ED     	CALL	CKFILPOS;is there another file?
2812: EEDA     C8         	RZ                 
2813: EEDB     CD5EED     	CALL	FCB2HL	;yes, get its address.
2814: EEDE     3EE5       	MVI	A,0E5H         
2815: EEE0     BE         	CMP	M	;empty file entry?
2816: EEE1     CAD2EE     	JZ	BITMAP2         
2817: EEE4     3A41EB     	LDA	USERNO	;no, correct user number?
2818: EEE7     BE         	CMP	M              
2819: EEE8     C2F6EE     	JNZ	BITMAP3        
2820: EEEB     23         	INX	H              
2821: EEEC     7E         	MOV	A,M	;yes, does name start with a '$'?
2822: EEED     D624       	SUI	DOLLAR		; '$'  
2823: EEEF     C2F6EE     	JNZ	BITMAP3        
2824: EEF2     3D         	DCR	A	;yes, set atatus to minus one.
2825: EEF3     3245EB     	STA	STATUS         
2826: EEF6                BITMAP3:            
2827: EEF6     0E01       	MVI	C,1	;now set this file's space as used in bit map.
2828: EEF8     CD6BEE     	CALL	SETFILE       
2829: EEFB     CD8CED     	CALL	CHKNMBR	;keep (SCRATCH1) in bounds.
2830: EEFE     C3D2EE     	JMP	BITMAP2        
2831: EF01                ;                   
2832: EF01                ;   Set the status (STATUS) and return.
2833: EF01                ;                   
2834: EF01                STSTATUS:           
2835: EF01     3AD4F5     	LDA	FNDSTAT        
2836: EF04     C301EB     	JMP	SETSTAT        
2837: EF07                ;                   
2838: EF07                ;   Check extents in (A) and (C). Set the zero flag if they
2839: EF07                ; are the same. The number of 16k chunks of disk space that
2840: EF07                ; the directory extent covers is expressad is (EXTMASK+1).
2841: EF07                ; No registers are modified.
2842: EF07                ;                   
2843: EF07                SAMEXT:             
2844: EF07     C5         	PUSH	B             
2845: EF08     F5         	PUSH	PSW           
2846: EF09     3AC5F5     	LDA	EXTMASK	;get extent mask and use it to
2847: EF0C     2F         	CMA		;to compare both extent numbers.
2848: EF0D     47         	MOV	B,A	;save resulting mask here.
2849: EF0E     79         	MOV	A,C	;mask first extent and save in (C).
2850: EF0F     A0         	ANA	B              
2851: EF10     4F         	MOV	C,A            
2852: EF11     F1         	POP	PSW	;now mask second extent and compare
2853: EF12     A0         	ANA	B	;with the first one.
2854: EF13     91         	SUB	C              
2855: EF14     E61F       	ANI	1FH	;(* only check buts 0-4 *)
2856: EF16     C1         	POP	B	;the zero flag is set if they are the same.
2857: EF17     C9         	RET		;restore (BC) and return.
2858: EF18                ;                   
2859: EF18                ;   Search for the first occurence of a file name. On entry,
2860: EF18                ; register (C) should contain the number of bytes of the fcb
2861: EF18                ; that must match.  
2862: EF18                ;                   
2863: EF18                FINDFST:            
2864: EF18     3EFF       	MVI	A,0FFH         
2865: EF1A     32D4F5     	STA	FNDSTAT        
2866: EF1D     21D8F5     	LXI	H,COUNTER;save character count.
2867: EF20     71         	MOV	M,C            
2868: EF21     2A43EB     	LHLD	ParamsDE	;get filename to match.
2869: EF24     22D9F5     	SHLD	SAVEFCB	;and save.
2870: EF27     CDFEED     	CALL	STFILPOS;clear initial file position (set to 0ffffh).
2871: EF2A     CDA1EB     	CALL	HOMEDRV	;home the drive.
2872: EF2D                ;                   
2873: EF2D                ;   Entry to locate the next occurence of a filename within the
2874: EF2D                ; directory. The disk is not expected to have been changed. If
2875: EF2D                ; it was, then it will be write protected.
2876: EF2D                ;                   
2877: EF2D                FINDNXT:            
2878: EF2D     0E00       	MVI	C,0	;write protect the disk if changed.
2879: EF2F     CD05EE     	CALL	NXENTRY	;get next filename entry in directory.
2880: EF32     CDF5ED     	CALL	CKFILPOS;is file position = 0ffffh?
2881: EF35     CA94EF     	JZ	FNDNXT6	;yes, exit now then.
2882: EF38     2AD9F5     	LHLD	SAVEFCB	;set (DE) pointing to filename to match.
2883: EF3B     EB         	XCHG               
2884: EF3C     1A         	LDAX	D             
2885: EF3D     FEE5       	CPI	0E5H	;empty directory entry?
2886: EF3F     CA4AEF     	JZ	FNDNXT1	;(* are we trying to reserect erased entries? *)
2887: EF42     D5         	PUSH	D             
2888: EF43     CD7FED     	CALL	MOREFLS	;more files in directory?
2889: EF46     D1         	POP	D              
2890: EF47     D294EF     	JNC	FNDNXT6	;no more. Exit now.
2891: EF4A                FNDNXT1:            
2892: EF4A     CD5EED     	CALL	FCB2HL	;get address of this fcb in directory.
2893: EF4D     3AD8F5     	LDA	COUNTER	;get number of bytes (characters) to check.
2894: EF50     4F         	MOV	C,A            
2895: EF51     0600       	MVI	B,0	;initialize byte position counter.
2896: EF53                FNDNXT2:            
2897: EF53     79         	MOV	A,C	;are we done with the compare?
2898: EF54     B7         	ORA	A              
2899: EF55     CA83EF     	JZ	FNDNXT5         
2900: EF58     1A         	LDAX	D	;no, check next byte.
2901: EF59     FE3F       	CPI	QMARK		; '?'	;don't care about this character?
2902: EF5B     CA7CEF     	JZ	FNDNXT4         
2903: EF5E     78         	MOV	A,B	;get bytes position in fcb.
2904: EF5F     FE0D       	CPI	13	;don't care about the thirteenth byte either.
2905: EF61     CA7CEF     	JZ	FNDNXT4         
2906: EF64     FE0C       	CPI	12	;extent byte?
2907: EF66     1A         	LDAX	D             
2908: EF67     CA73EF     	JZ	FNDNXT3         
2909: EF6A     96         	SUB	M	;otherwise compare characters.
2910: EF6B     E67F       	ANI	7FH            
2911: EF6D     C22DEF     	JNZ	FINDNXT	;not the same, check next entry.
2912: EF70     C37CEF     	JMP	FNDNXT4	;so far so good, keep checking.
2913: EF73                FNDNXT3:            
2914: EF73     C5         	PUSH	B	;check the extent byte here.
2915: EF74     4E         	MOV	C,M            
2916: EF75     CD07EF     	CALL	SAMEXT        
2917: EF78     C1         	POP	B              
2918: EF79     C22DEF     	JNZ	FINDNXT	;not the same, look some more.
2919: EF7C                ;                   
2920: EF7C                ;   So far the names compare. Bump pointers to the next byte
2921: EF7C                ; and continue until all (C) characters have been checked.
2922: EF7C                ;                   
2923: EF7C                FNDNXT4:            
2924: EF7C     13         	INX	D	;bump pointers.
2925: EF7D     23         	INX	H              
2926: EF7E     04         	INR	B              
2927: EF7F     0D         	DCR	C	;adjust character counter.
2928: EF80     C353EF     	JMP	FNDNXT2        
2929: EF83                FNDNXT5:            
2930: EF83     3AEAF5     	LDA	FILEPOS	;return the position of this entry.
2931: EF86     E603       	ANI	03H            
2932: EF88     3245EB     	STA	STATUS         
2933: EF8B     21D4F5     	LXI	H,FNDSTAT      
2934: EF8E     7E         	MOV	A,M            
2935: EF8F     17         	RAL                
2936: EF90     D0         	RNC                
2937: EF91     AF         	XRA	A              
2938: EF92     77         	MOV	M,A            
2939: EF93     C9         	RET                
2940: EF94                ;                   
2941: EF94                ;   Filename was not found. Set appropriate status.
2942: EF94                ;                   
2943: EF94                FNDNXT6:            
2944: EF94     CDFEED     	CALL	STFILPOS;set (FILEPOS) to 0ffffh.
2945: EF97     3EFF       	MVI	A,0FFH	;say not located.
2946: EF99     C301EB     	JMP	SETSTAT        
2947: EF9C                ;                   
2948: EF9C                ;   Erase files from the directory. Only the first byte of the
2949: EF9C                ; fcb will be affected. It is set to (E5).
2950: EF9C                ;                   
2951: EF9C                ERAFILE:            
2952: EF9C     CD54ED     	CALL	CHKWPRT	;is disk write protected?
2953: EF9F     0E0C       	MVI	C,12	;only compare file names.
2954: EFA1     CD18EF     	CALL	FINDFST	;get first file name.
2955: EFA4                ERAFIL1:            
2956: EFA4     CDF5ED     	CALL	CKFILPOS;any found?
2957: EFA7     C8         	RZ		;nope, we must be done.
2958: EFA8     CD44ED     	CALL	CHKROFL	;is file read only?
2959: EFAB     CD5EED     	CALL	FCB2HL	;nope, get address of fcb and
2960: EFAE     36E5       	MVI	M,0E5H	;set first byte to 'empty'.
2961: EFB0     0E00       	MVI	C,0	;clear the space from the bit map.
2962: EFB2     CD6BEE     	CALL	SETFILE       
2963: EFB5     CDC6ED     	CALL	DIRWRITE;now write the directory sector back out.
2964: EFB8     CD2DEF     	CALL	FINDNXT	;find the next file name.
2965: EFBB     C3A4EF     	JMP	ERAFIL1	;and repeat process.
2966: EFBE                ;                   
2967: EFBE                ;   Look through the space allocation map (bit map) for the
2968: EFBE                ; next available block. Start searching at block number (BC-1).
2969: EFBE                ; The search procedure is to look for an empty block that is
2970: EFBE                ; before the starting block. If not empty, look at a later
2971: EFBE                ; block number. In this way, we return the closest empty block
2972: EFBE                ; on either side of the 'target' block number. This will speed
2973: EFBE                ; access on random devices. For serial devices, this should be
2974: EFBE                ; changed to look in the forward direction first and then start
2975: EFBE                ; at the front and search some more.
2976: EFBE                ;                   
2977: EFBE                ;   On return, (DE)= block number that is empty and (HL) =0
2978: EFBE                ; if no empry block was found.
2979: EFBE                ;                   
2980: EFBE                FNDSPACE:           
2981: EFBE     50         	MOV	D,B	;set (DE) as the block that is checked.
2982: EFBF     59         	MOV	E,C            
2983: EFC0                ;                   
2984: EFC0                ;   Look before target block. Registers (BC) are used as the lower
2985: EFC0                ; pointer and (DE) as the upper pointer.
2986: EFC0                ;                   
2987: EFC0                FNDSPA1:            
2988: EFC0     79         	MOV	A,C	;is block 0 specified?
2989: EFC1     B0         	ORA	B              
2990: EFC2     CAD1EF     	JZ	FNDSPA2         
2991: EFC5     0B         	DCX	B	;nope, check previous block.
2992: EFC6     D5         	PUSH	D             
2993: EFC7     C5         	PUSH	B             
2994: EFC8     CD35EE     	CALL	CKBITMAP      
2995: EFCB     1F         	RAR		;is this block empty?
2996: EFCC     D2ECEF     	JNC	FNDSPA3	;yes. use this.
2997: EFCF                ;                   
2998: EFCF                ;   Note that the above logic gets the first block that it finds
2999: EFCF                ; that is empty. Thus a file could be written 'backward' making
3000: EFCF                ; it very slow to access. This could be changed to look for the
3001: EFCF                ; first empty block and then continue until the start of this
3002: EFCF                ; empty space is located and then used that starting block.
3003: EFCF                ; This should help speed up access to some files especially on
3004: EFCF                ; a well used disk with lots of fairly small 'holes'.
3005: EFCF                ;                   
3006: EFCF     C1         	POP	B	;nope, check some more.
3007: EFD0     D1         	POP	D              
3008: EFD1                ;                   
3009: EFD1                ;   Now look after target block.
3010: EFD1                ;                   
3011: EFD1                FNDSPA2:            
3012: EFD1     2AC6F5     	LHLD	DSKSIZE	;is block (DE) within disk limits?
3013: EFD4     7B         	MOV	A,E            
3014: EFD5     95         	SUB	L              
3015: EFD6     7A         	MOV	A,D            
3016: EFD7     9C         	SBB	H              
3017: EFD8     D2F4EF     	JNC	FNDSPA4        
3018: EFDB     13         	INX	D	;yes, move on to next one.
3019: EFDC     C5         	PUSH	B             
3020: EFDD     D5         	PUSH	D             
3021: EFDE     42         	MOV	B,D            
3022: EFDF     4B         	MOV	C,E            
3023: EFE0     CD35EE     	CALL	CKBITMAP;check it.
3024: EFE3     1F         	RAR		;empty?       
3025: EFE4     D2ECEF     	JNC	FNDSPA3        
3026: EFE7     D1         	POP	D	;nope, continue searching.
3027: EFE8     C1         	POP	B              
3028: EFE9     C3C0EF     	JMP	FNDSPA1        
3029: EFEC                ;                   
3030: EFEC                ;   Empty block found. Set it as used and return with (HL)
3031: EFEC                ; pointing to it (true?).
3032: EFEC                ;                   
3033: EFEC                FNDSPA3:            
3034: EFEC     17         	RAL		;reset byte.  
3035: EFED     3C         	INR	A	;and set bit 0.
3036: EFEE     CD64EE     	CALL	STBMAP1	;update bit map.
3037: EFF1     E1         	POP	H	;set return registers.
3038: EFF2     D1         	POP	D              
3039: EFF3     C9         	RET                
3040: EFF4                ;                   
3041: EFF4                ;   Free block was not found. If (BC) is not zero, then we have
3042: EFF4                ; not checked all of the disk space.
3043: EFF4                ;                   
3044: EFF4                FNDSPA4:            
3045: EFF4     79         	MOV	A,C            
3046: EFF5     B0         	ORA	B              
3047: EFF6     C2C0EF     	JNZ	FNDSPA1        
3048: EFF9     210000     	LXI	H,0	;set 'not found' status.
3049: EFFC     C9         	RET                
3050: EFFD                ;                   
3051: EFFD                ;   Move a complete fcb entry into the directory and write it.
3052: EFFD                ;                   
3053: EFFD                FCBSET:             
3054: EFFD     0E00       	MVI	C,0            
3055: EFFF     1E20       	MVI	E,32	;length of each entry.
3056: F001                ;                   
3057: F001                ;   Move (E) bytes from the fcb pointed to by (ParamsDE) into
3058: F001                ; fcb in directory starting at relative byte (C). This updated
3059: F001                ; directory buffer is then written to the disk.
3060: F001                ;                   
3061: F001                UPDATE:             
3062: F001     D5         	PUSH	D             
3063: F002     0600       	MVI	B,0	;set (BC) to relative byte position.
3064: F004     2A43EB     	LHLD	ParamsDE	;get address of fcb.
3065: F007     09         	DAD	B	;compute starting byte.
3066: F008     EB         	XCHG               
3067: F009     CD5EED     	CALL	FCB2HL	;get address of fcb to update in directory.
3068: F00C     C1         	POP	B	;set (C) to number of bytes to change.
3069: F00D     CD4FEB     	CALL	DE2HL         
3070: F010                UPDATE1:            
3071: F010     CDC3EB     	CALL	TRKSEC	;determine the track and sector affected.
3072: F013     C3C6ED     	JMP	DIRWRITE	;then write this sector out.
3073: F016                ;                   
3074: F016                ;   Routine to change the name of all files on the disk with a
3075: F016                ; specified name. The fcb contains the current name as the
3076: F016                ; first 12 characters and the new name 16 bytes into the fcb.
3077: F016                ;                   
3078: F016                CHGNAMES:           
3079: F016     CD54ED     	CALL	CHKWPRT	;check for a write protected disk.
3080: F019     0E0C       	MVI	C,12	;match first 12 bytes of fcb only.
3081: F01B     CD18EF     	CALL	FINDFST	;get first name.
3082: F01E     2A43EB     	LHLD	ParamsDE	;get address of fcb.
3083: F021     7E         	MOV	A,M	;get user number.
3084: F022     111000     	LXI	D,16	;move over to desired name.
3085: F025     19         	DAD	D              
3086: F026     77         	MOV	M,A	;keep same user number.
3087: F027                CHGNAM1:            
3088: F027     CDF5ED     	CALL	CKFILPOS;any matching file found?
3089: F02A     C8         	RZ		;no, we must be done.
3090: F02B     CD44ED     	CALL	CHKROFL	;check for read only file.
3091: F02E     0E10       	MVI	C,16	;start 16 bytes into fcb.
3092: F030     1E0C       	MVI	E,12	;and update the first 12 bytes of directory.
3093: F032     CD01F0     	CALL	UPDATE        
3094: F035     CD2DEF     	CALL	FINDNXT	;get te next file name.
3095: F038     C327F0     	JMP	CHGNAM1	;and continue.
3096: F03B                ;                   
3097: F03B                ;   Update a files attributes. The procedure is to search for
3098: F03B                ; every file with the same name as shown in fcb (ignoring bit 7)
3099: F03B                ; and then to update it (which includes bit 7). No other changes
3100: F03B                ; are made.         
3101: F03B                ;                   
3102: F03B                SAVEATTR:           
3103: F03B     0E0C       	MVI	C,12	;match first 12 bytes.
3104: F03D     CD18EF     	CALL	FINDFST	;look for first filename.
3105: F040                SAVATR1:            
3106: F040     CDF5ED     	CALL	CKFILPOS;was one found?
3107: F043     C8         	RZ		;nope, we must be done.
3108: F044     0E00       	MVI	C,0	;yes, update the first 12 bytes now.
3109: F046     1E0C       	MVI	E,12           
3110: F048     CD01F0     	CALL	UPDATE	;update filename and write directory.
3111: F04B     CD2DEF     	CALL	FINDNXT	;and get the next file.
3112: F04E     C340F0     	JMP	SAVATR1	;then continue until done.
3113: F051                ;                   
3114: F051                ;  Open a file (name specified in fcb).
3115: F051                ;                   
3116: F051                OPENIT:             
3117: F051     0E0F       	MVI	C,15	;compare the first 15 bytes.
3118: F053     CD18EF     	CALL	FINDFST	;get the first one in directory.
3119: F056     CDF5ED     	CALL	CKFILPOS;any at all?
3120: F059     C8         	RZ                 
3121: F05A                OPENIT1:            
3122: F05A     CDA6EC     	CALL	SETEXT	;point to extent byte within users fcb.
3123: F05D     7E         	MOV	A,M	;and get it.
3124: F05E     F5         	PUSH	PSW	;save it and address.
3125: F05F     E5         	PUSH	H             
3126: F060     CD5EED     	CALL	FCB2HL	;point to fcb in directory.
3127: F063     EB         	XCHG               
3128: F064     2A43EB     	LHLD	ParamsDE	;this is the users copy.
3129: F067     0E20       	MVI	C,32	;move it into users space.
3130: F069     D5         	PUSH	D             
3131: F06A     CD4FEB     	CALL	DE2HL         
3132: F06D     CD78ED     	CALL	SETS2B7	;set bit 7 in 's2' byte (unmodified).
3133: F070     D1         	POP	D	;now get the extent byte from this fcb.
3134: F071     210C00     	LXI	H,12           
3135: F074     19         	DAD	D              
3136: F075     4E         	MOV	C,M	;into (C). 
3137: F076     210F00     	LXI	H,15	;now get the record count byte into (B).
3138: F079     19         	DAD	D              
3139: F07A     46         	MOV	B,M            
3140: F07B     E1         	POP	H	;keep the same extent as the user had originally.
3141: F07C     F1         	POP	PSW            
3142: F07D     77         	MOV	M,A            
3143: F07E     79         	MOV	A,C	;is it the same as in the directory fcb?
3144: F07F     BE         	CMP	M              
3145: F080     78         	MOV	A,B	;if yes, then use the same record count.
3146: F081     CA8BF0     	JZ	OPENIT2         
3147: F084     3E00       	MVI	A,0	;if the user specified an extent greater than
3148: F086     DA8BF0     	JC	OPENIT2	;the one in the directory, then set record count to 0.
3149: F089     3E80       	MVI	A,128	;otherwise set to maximum.
3150: F08B                OPENIT2:            
3151: F08B     2A43EB     	LHLD	ParamsDE	;set record count in users fcb to (A).
3152: F08E     110F00     	LXI	D,15           
3153: F091     19         	DAD	D	;compute relative position.
3154: F092     77         	MOV	M,A	;and set the record count.
3155: F093     C9         	RET                
3156: F094                ;                   
3157: F094                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
3158: F094                ; point to a zero value (16 bit).
3159: F094                ;   Return with zero flag set it (DE) was moved. Registers (DE)
3160: F094                ; and (HL) are not changed. However (A) is.
3161: F094                ;                   
3162: F094                MOVEWORD:           
3163: F094     7E         	MOV	A,M	;check for a zero word.
3164: F095     23         	INX	H              
3165: F096     B6         	ORA	M	;both bytes zero?
3166: F097     2B         	DCX	H              
3167: F098     C0         	RNZ		;nope, just return.
3168: F099     1A         	LDAX	D	;yes, move two bytes from (DE) into
3169: F09A     77         	MOV	M,A	;this zero space.
3170: F09B     13         	INX	D              
3171: F09C     23         	INX	H              
3172: F09D     1A         	LDAX	D             
3173: F09E     77         	MOV	M,A            
3174: F09F     1B         	DCX	D	;don't disturb these registers.
3175: F0A0     2B         	DCX	H              
3176: F0A1     C9         	RET                
3177: F0A2                ;                   
3178: F0A2                ;   Get here to close a file specified by (fcb).
3179: F0A2                ;                   
3180: F0A2                CLOSEIT:            
3181: F0A2     AF         	XRA	A	;clear status and file position bytes.
3182: F0A3     3245EB     	STA	STATUS         
3183: F0A6     32EAF5     	STA	FILEPOS        
3184: F0A9     32EBF5     	STA	FILEPOS+1      
3185: F0AC     CD1EED     	CALL	GETWPRT	;get write protect bit for this drive.
3186: F0AF     C0         	RNZ		;just return if it is set.
3187: F0B0     CD69ED     	CALL	GETS2	;else get the 's2' byte.
3188: F0B3     E680       	ANI	80H	;and look at bit 7 (file unmodified?).
3189: F0B5     C0         	RNZ		;just return if set.
3190: F0B6     0E0F       	MVI	C,15	;else look up this file in directory.
3191: F0B8     CD18EF     	CALL	FINDFST       
3192: F0BB     CDF5ED     	CALL	CKFILPOS;was it found?
3193: F0BE     C8         	RZ		;just return if not.
3194: F0BF     011000     	LXI	B,16	;set (HL) pointing to records used section.
3195: F0C2     CD5EED     	CALL	FCB2HL        
3196: F0C5     09         	DAD	B              
3197: F0C6     EB         	XCHG               
3198: F0C7     2A43EB     	LHLD	ParamsDE	;do the same for users specified fcb.
3199: F0CA     09         	DAD	B              
3200: F0CB     0E10       	MVI	C,16	;this many bytes are present in this extent.
3201: F0CD                CLOSEIT1:           
3202: F0CD     3ADDF5     	LDA	BIGDISK	;8 or 16 bit record numbers?
3203: F0D0     B7         	ORA	A              
3204: F0D1     CAE8F0     	JZ	CLOSEIT4        
3205: F0D4     7E         	MOV	A,M	;just 8 bit. Get one from users fcb.
3206: F0D5     B7         	ORA	A              
3207: F0D6     1A         	LDAX	D	;now get one from directory fcb.
3208: F0D7     C2DBF0     	JNZ	CLOSEIT2       
3209: F0DA     77         	MOV	M,A	;users byte was zero. Update from directory.
3210: F0DB                CLOSEIT2:           
3211: F0DB     B7         	ORA	A              
3212: F0DC     C2E1F0     	JNZ	CLOSEIT3       
3213: F0DF     7E         	MOV	A,M	;directories byte was zero, update from users fcb.
3214: F0E0     12         	STAX	D             
3215: F0E1                CLOSEIT3:           
3216: F0E1     BE         	CMP	M	;if neither one of these bytes were zero,
3217: F0E2     C21FF1     	JNZ	CLOSEIT7	;then close error if they are not the same.
3218: F0E5     C3FDF0     	JMP	CLOSEIT5	;ok so far, get to next byte in fcbs.
3219: F0E8                CLOSEIT4:           
3220: F0E8     CD94F0     	CALL	MOVEWORD;update users fcb if it is zero.
3221: F0EB     EB         	XCHG               
3222: F0EC     CD94F0     	CALL	MOVEWORD;update directories fcb if it is zero.
3223: F0EF     EB         	XCHG               
3224: F0F0     1A         	LDAX	D	;if these two values are no different,
3225: F0F1     BE         	CMP	M	;then a close error occured.
3226: F0F2     C21FF1     	JNZ	CLOSEIT7       
3227: F0F5     13         	INX	D	;check second byte.
3228: F0F6     23         	INX	H              
3229: F0F7     1A         	LDAX	D             
3230: F0F8     BE         	CMP	M              
3231: F0F9     C21FF1     	JNZ	CLOSEIT7       
3232: F0FC     0D         	DCR	C	;remember 16 bit values.
3233: F0FD                CLOSEIT5:           
3234: F0FD     13         	INX	D	;bump to next item in table.
3235: F0FE     23         	INX	H              
3236: F0FF     0D         	DCR	C	;there are 16 entries only.
3237: F100     C2CDF0     	JNZ	CLOSEIT1;continue if more to do.
3238: F103     01ECFF     	LXI	B,0FFECH;backup 20 places (extent byte).
3239: F106     09         	DAD	B              
3240: F107     EB         	XCHG               
3241: F108     09         	DAD	B              
3242: F109     1A         	LDAX	D             
3243: F10A     BE         	CMP	M	;directory's extent already greater than the
3244: F10B     DA17F1     	JC	CLOSEIT6	;users extent?
3245: F10E     77         	MOV	M,A	;no, update directory extent.
3246: F10F     010300     	LXI	B,3	;and update the record count byte in
3247: F112     09         	DAD	B	;directories fcb.
3248: F113     EB         	XCHG               
3249: F114     09         	DAD	B              
3250: F115     7E         	MOV	A,M	;get from user.
3251: F116     12         	STAX	D	;and put in directory.
3252: F117                CLOSEIT6:           
3253: F117     3EFF       	MVI	A,0FFH	;set 'was open and is now closed' byte.
3254: F119     32D2F5     	STA	CLOSEFLG       
3255: F11C     C310F0     	JMP	UPDATE1	;update the directory now.
3256: F11F                CLOSEIT7:           
3257: F11F     2145EB     	LXI	H,STATUS;set return status and then return.
3258: F122     35         	DCR	M              
3259: F123     C9         	RET                
3260: F124                ;                   
3261: F124                ;   Routine to get the next empty space in the directory. It
3262: F124                ; will then be cleared for use.
3263: F124                ;                   
3264: F124                GETEMPTY:           
3265: F124     CD54ED     	CALL	CHKWPRT	;make sure disk is not write protected.
3266: F127     2A43EB     	LHLD	ParamsDE	;save current parameters (fcb).
3267: F12A     E5         	PUSH	H             
3268: F12B     21ACF5     	LXI	H,EMPTYFCB;use special one for empty space.
3269: F12E     2243EB     	SHLD	ParamsDE      
3270: F131     0E01       	MVI	C,1	;search for first empty spot in directory.
3271: F133     CD18EF     	CALL	FINDFST	;(* only check first byte *)
3272: F136     CDF5ED     	CALL	CKFILPOS;none?
3273: F139     E1         	POP	H              
3274: F13A     2243EB     	SHLD	ParamsDE	;restore original fcb address.
3275: F13D     C8         	RZ		;return if no more space.
3276: F13E     EB         	XCHG               
3277: F13F     210F00     	LXI	H,15	;point to number of records for this file.
3278: F142     19         	DAD	D              
3279: F143     0E11       	MVI	C,17	;and clear all of this space.
3280: F145     AF         	XRA	A              
3281: F146                GETMT1:             
3282: F146     77         	MOV	M,A            
3283: F147     23         	INX	H              
3284: F148     0D         	DCR	C              
3285: F149     C246F1     	JNZ	GETMT1         
3286: F14C     210D00     	LXI	H,13	;clear the 's1' byte also.
3287: F14F     19         	DAD	D              
3288: F150     77         	MOV	M,A            
3289: F151     CD8CED     	CALL	CHKNMBR	;keep (SCRATCH1) within bounds.
3290: F154     CDFDEF     	CALL	FCBSET	;write out this fcb entry to directory.
3291: F157     C378ED     	JMP	SETS2B7	;set 's2' byte bit 7 (unmodified at present).
3292: F15A                ;                   
3293: F15A                ;   Routine to close the current extent and open the next one
3294: F15A                ; for reading.      
3295: F15A                ;                   
3296: F15A                GETNEXT:            
3297: F15A     AF         	XRA	A              
3298: F15B     32D2F5     	STA	CLOSEFLG;clear close flag.
3299: F15E     CDA2F0     	CALL	CLOSEIT	;close this extent.
3300: F161     CDF5ED     	CALL	CKFILPOS      
3301: F164     C8         	RZ		;not there???  
3302: F165     2A43EB     	LHLD	ParamsDE	;get extent byte.
3303: F168     010C00     	LXI	B,12           
3304: F16B     09         	DAD	B              
3305: F16C     7E         	MOV	A,M	;and increment it.
3306: F16D     3C         	INR	A              
3307: F16E     E61F       	ANI	1FH	;keep within range 0-31.
3308: F170     77         	MOV	M,A            
3309: F171     CA83F1     	JZ	GTNEXT1	;overflow?
3310: F174     47         	MOV	B,A	;mask extent byte.
3311: F175     3AC5F5     	LDA	EXTMASK        
3312: F178     A0         	ANA	B              
3313: F179     21D2F5     	LXI	H,CLOSEFLG;check close flag (0ffh is ok).
3314: F17C     A6         	ANA	M              
3315: F17D     CA8EF1     	JZ	GTNEXT2	;if zero, we must read in next extent.
3316: F180     C3ACF1     	JMP	GTNEXT3	;else, it is already in memory.
3317: F183                GTNEXT1:            
3318: F183     010200     	LXI	B,2	;Point to the 's2' byte.
3319: F186     09         	DAD	B              
3320: F187     34         	INR	M	;and bump it.
3321: F188     7E         	MOV	A,M	;too many extents?
3322: F189     E60F       	ANI	0FH            
3323: F18B     CAB6F1     	JZ	GTNEXT5	;yes, set error code.
3324: F18E                ;                   
3325: F18E                ;   Get here to open the next extent.
3326: F18E                ;                   
3327: F18E                GTNEXT2:            
3328: F18E     0E0F       	MVI	C,15	;set to check first 15 bytes of fcb.
3329: F190     CD18EF     	CALL	FINDFST	;find the first one.
3330: F193     CDF5ED     	CALL	CKFILPOS;none available?
3331: F196     C2ACF1     	JNZ	GTNEXT3        
3332: F199     3AD3F5     	LDA	RDWRTFLG;no extent present. Can we open an empty one?
3333: F19C     3C         	INR	A	;0ffh means reading (so not possible).
3334: F19D     CAB6F1     	JZ	GTNEXT5	;or an error.
3335: F1A0     CD24F1     	CALL	GETEMPTY;we are writing, get an empty entry.
3336: F1A3     CDF5ED     	CALL	CKFILPOS;none?
3337: F1A6     CAB6F1     	JZ	GTNEXT5	;error if true.
3338: F1A9     C3AFF1     	JMP	GTNEXT4	;else we are almost done.
3339: F1AC                GTNEXT3:            
3340: F1AC     CD5AF0     	CALL	OPENIT1	;open this extent.
3341: F1AF                GTNEXT4:            
3342: F1AF     CDBBEC     	CALL	STRDATA	;move in updated data (rec #, extent #, etc.)
3343: F1B2     AF         	XRA	A	;clear status and return.
3344: F1B3     C301EB     	JMP	SETSTAT        
3345: F1B6                ;                   
3346: F1B6                ;   Error in extending the file. Too many extents were needed
3347: F1B6                ; or not enough space on the disk.
3348: F1B6                ;                   
3349: F1B6                GTNEXT5:            
3350: F1B6     CD05EB     	CALL	IOERR1	;set error code, clear bit 7 of 's2'
3351: F1B9     C378ED     	JMP	SETS2B7	;so this is not written on a close.
3352: F1BC                ;                   
3353: F1BC                ;   Read a sequential file.
3354: F1BC                ;                   
3355: F1BC                RDSEQ:              
3356: F1BC     3E01       	MVI	A,1	;set sequential access mode.
3357: F1BE     32D5F5     	STA	MODE           
3358: F1C1                RDSEQ1:             
3359: F1C1     3EFF       	MVI	A,0FFH	;don't allow reading unwritten space.
3360: F1C3     32D3F5     	STA	RDWRTFLG       
3361: F1C6     CDBBEC     	CALL	STRDATA	;put rec# and ext# into fcb.
3362: F1C9     3AE3F5     	LDA	SAVNREC	;get next record to read.
3363: F1CC     21E1F5     	LXI	H,SAVNXT;get number of records in extent.
3364: F1CF     BE         	CMP	M	;within this extent?
3365: F1D0     DAE6F1     	JC	RDSEQ2          
3366: F1D3     FE80       	CPI	128	;no. Is this extent fully used?
3367: F1D5     C2FBF1     	JNZ	RDSEQ3	;no. End-of-file.
3368: F1D8     CD5AF1     	CALL	GETNEXT	;yes, open the next one.
3369: F1DB     AF         	XRA	A	;reset next record to read.
3370: F1DC     32E3F5     	STA	SAVNREC        
3371: F1DF     3A45EB     	LDA	STATUS	;check on open, successful?
3372: F1E2     B7         	ORA	A              
3373: F1E3     C2FBF1     	JNZ	RDSEQ3	;no, error.
3374: F1E6                RDSEQ2:             
3375: F1E6     CD77EC     	CALL	COMBLK	;ok. compute block number to read.
3376: F1E9     CD84EC     	CALL	CHKBLK	;check it. Within bounds?
3377: F1EC     CAFBF1     	JZ	RDSEQ3	;no, error.
3378: F1EF     CD8AEC     	CALL	LOGICAL	;convert (BLKNMBR) to logical sector (128 byte).
3379: F1F2     CDD1EB     	CALL	TRKSEC1	;set the track and sector for this block #.
3380: F1F5     CDB2EB     	CALL	DOREAD	;and read it.
3381: F1F8     C3D2EC     	JMP	SETNREC	;and set the next record to be accessed.
3382: F1FB                ;                   
3383: F1FB                ;   Read error occured. Set status and return.
3384: F1FB                ;                   
3385: F1FB                RDSEQ3:             
3386: F1FB     C305EB     	JMP	IOERR1         
3387: F1FE                ;                   
3388: F1FE                ;   Write the next sequential record.
3389: F1FE                ;                   
3390: F1FE                WTSEQ:              
3391: F1FE     3E01       	MVI	A,1	;set sequential access mode.
3392: F200     32D5F5     	STA	MODE           
3393: F203                WTSEQ1:             
3394: F203     3E00       	MVI	A,0	;allow an addition empty extent to be opened.
3395: F205     32D3F5     	STA	RDWRTFLG       
3396: F208     CD54ED     	CALL	CHKWPRT	;check write protect status.
3397: F20B     2A43EB     	LHLD	ParamsDE      
3398: F20E     CD47ED     	CALL	CKROF1	;check for read only file, (HL) already set to fcb.
3399: F211     CDBBEC     	CALL	STRDATA	;put updated data into fcb.
3400: F214     3AE3F5     	LDA	SAVNREC	;get record number to write.
3401: F217     FE80       	CPI	128	;within range?
3402: F219     D205EB     	JNC	IOERR1	;no, error(?).
3403: F21C     CD77EC     	CALL	COMBLK	;compute block number.
3404: F21F     CD84EC     	CALL	CHKBLK	;check number.
3405: F222     0E00       	MVI	C,0	;is there one to write to?
3406: F224     C26EF2     	JNZ	WTSEQ6	;yes, go do it.
3407: F227     CD3EEC     	CALL	GETBLOCK;get next block number within fcb to use.
3408: F22A     32D7F5     	STA	RELBLOCK;and save.
3409: F22D     010000     	LXI	B,0	;start looking for space from the start
3410: F230     B7         	ORA	A	;if none allocated as yet.
3411: F231     CA3BF2     	JZ	WTSEQ2          
3412: F234     4F         	MOV	C,A	;extract previous block number from fcb
3413: F235     0B         	DCX	B	;so we can be closest to it.
3414: F236     CD5EEC     	CALL	EXTBLK        
3415: F239     44         	MOV	B,H            
3416: F23A     4D         	MOV	C,L            
3417: F23B                WTSEQ2:             
3418: F23B     CDBEEF     	CALL	FNDSPACE;find the next empty block nearest number (BC).
3419: F23E     7D         	MOV	A,L	;check for a zero number.
3420: F23F     B4         	ORA	H              
3421: F240     C248F2     	JNZ	WTSEQ3         
3422: F243     3E02       	MVI	A,2	;no more space?
3423: F245     C301EB     	JMP	SETSTAT        
3424: F248                WTSEQ3:             
3425: F248     22E5F5     	SHLD	BLKNMBR	;save block number to access.
3426: F24B     EB         	XCHG		;put block number into (DE).
3427: F24C     2A43EB     	LHLD	ParamsDE	;now we must update the fcb for this
3428: F24F     011000     	LXI	B,16	;newly allocated block.
3429: F252     09         	DAD	B              
3430: F253     3ADDF5     	LDA	BIGDISK	;8 or 16 bit block numbers?
3431: F256     B7         	ORA	A              
3432: F257     3AD7F5     	LDA	RELBLOCK	;(* update this entry *)
3433: F25A     CA64F2     	JZ	WTSEQ4	;zero means 16 bit ones.
3434: F25D     CD64ED     	CALL	ADDA2HL	;(HL)=(HL)+(A)
3435: F260     73         	MOV	M,E	;store new block number.
3436: F261     C36CF2     	JMP	WTSEQ5         
3437: F264                WTSEQ4:             
3438: F264     4F         	MOV	C,A	;compute spot in this 16 bit table.
3439: F265     0600       	MVI	B,0            
3440: F267     09         	DAD	B              
3441: F268     09         	DAD	B              
3442: F269     73         	MOV	M,E	;stuff block number (DE) there.
3443: F26A     23         	INX	H              
3444: F26B     72         	MOV	M,D            
3445: F26C                WTSEQ5:             
3446: F26C     0E02       	MVI	C,2	;set (C) to indicate writing to un-used disk space.
3447: F26E                WTSEQ6:             
3448: F26E     3A45EB     	LDA	STATUS	;are we ok so far?
3449: F271     B7         	ORA	A              
3450: F272     C0         	RNZ                
3451: F273     C5         	PUSH	B	;yes, save write flag for bios (register C).
3452: F274     CD8AEC     	CALL	LOGICAL	;convert (BLKNMBR) over to loical sectors.
3453: F277     3AD5F5     	LDA	MODE	;get access mode flag (1=sequential,
3454: F27A     3D         	DCR	A	;0=random, 2=special?).
3455: F27B     3D         	DCR	A              
3456: F27C     C2BBF2     	JNZ	WTSEQ9         
3457: F27F                ;                   
3458: F27F                ;   Special random i/o from function #40. Maybe for M/PM, but the
3459: F27F                ; current block, if it has not been written to, will be zeroed
3460: F27F                ; out and then written (reason?).
3461: F27F                ;                   
3462: F27F     C1         	POP	B              
3463: F280     C5         	PUSH	B             
3464: F281     79         	MOV	A,C	;get write status flag (2=writing unused space).
3465: F282     3D         	DCR	A              
3466: F283     3D         	DCR	A              
3467: F284     C2BBF2     	JNZ	WTSEQ9         
3468: F287     E5         	PUSH	H             
3469: F288     2AB9F5     	LHLD	DIRBUF	;zero out the directory buffer.
3470: F28B     57         	MOV	D,A	;note that (A) is zero here.
3471: F28C                WTSEQ7:             
3472: F28C     77         	MOV	M,A            
3473: F28D     23         	INX	H              
3474: F28E     14         	INR	D	;do 128 bytes.
3475: F28F     F28CF2     	JP	WTSEQ7          
3476: F292     CDE0ED     	CALL	SetDirDMA	;tell the bios the dma address for directory access.
3477: F295     2AE7F5     	LHLD	LOGSECT	;get sector that starts current block.
3478: F298     0E02       	MVI	C,2	;set 'writing to unused space' flag.
3479: F29A                WTSEQ8:             
3480: F29A     22E5F5     	SHLD	BLKNMBR	;save sector to write.
3481: F29D     C5         	PUSH	B             
3482: F29E     CDD1EB     	CALL	TRKSEC1	;determine its track and sector numbers.
3483: F2A1     C1         	POP	B              
3484: F2A2     CDB8EB     	CALL	DOWRITE	;now write out 128 bytes of zeros.
3485: F2A5     2AE5F5     	LHLD	BLKNMBR	;get sector number.
3486: F2A8     0E00       	MVI	C,0	;set normal write flag.
3487: F2AA     3AC4F5     	LDA	BLKMASK	;determine if we have written the entire
3488: F2AD     47         	MOV	B,A	;physical block.
3489: F2AE     A5         	ANA	L              
3490: F2AF     B8         	CMP	B              
3491: F2B0     23         	INX	H	;prepare for the next one.
3492: F2B1     C29AF2     	JNZ	WTSEQ8	;continue until (BLKMASK+1) sectors written.
3493: F2B4     E1         	POP	H	;reset next sector number.
3494: F2B5     22E5F5     	SHLD	BLKNMBR       
3495: F2B8     CDDAED     	CALL	Set2UsersDMA	;and reset dma address.
3496: F2BB                ;                   
3497: F2BB                ;   Normal disk write. Set the desired track and sector then
3498: F2BB                ; do the actual write.
3499: F2BB                ;                   
3500: F2BB                WTSEQ9:             
3501: F2BB     CDD1EB     	CALL	TRKSEC1	;determine track and sector for this write.
3502: F2BE     C1         	POP	B	;get write status flag.
3503: F2BF     C5         	PUSH	B             
3504: F2C0     CDB8EB     	CALL	DOWRITE	;and write this out.
3505: F2C3     C1         	POP	B              
3506: F2C4     3AE3F5     	LDA	SAVNREC	;get number of records in file.
3507: F2C7     21E1F5     	LXI	H,SAVNXT;get last record written.
3508: F2CA     BE         	CMP	M              
3509: F2CB     DAD2F2     	JC	WTSEQ10         
3510: F2CE     77         	MOV	M,A	;we have to update record count.
3511: F2CF     34         	INR	M              
3512: F2D0     0E02       	MVI	C,2            
3513: F2D2                ;                   
3514: F2D2                ;*   This area has been patched to correct disk update problem
3515: F2D2                ;* when using blocking and de-blocking in the BIOS.
3516: F2D2                ;                   
3517: F2D2                WTSEQ10:            
3518: F2D2     00         	NOP		;was 'dcr c'  
3519: F2D3     00         	NOP		;was 'dcr c'  
3520: F2D4     210000     	LXI	H,0	;was 'jnz wtseq99'
3521: F2D7                ;                   
3522: F2D7                ; *   End of patch. 
3523: F2D7                ;                   
3524: F2D7     F5         	PUSH	PSW           
3525: F2D8     CD69ED     	CALL	GETS2	;set 'extent written to' flag.
3526: F2DB     E67F       	ANI	7FH	;(* clear bit 7 *)
3527: F2DD     77         	MOV	M,A            
3528: F2DE     F1         	POP	PSW	;get record count for this extent.
3529: F2DF                WTSEQ99:            
3530: F2DF     FE7F       	CPI	127	;is it full?
3531: F2E1     C200F3     	JNZ	WTSEQ12        
3532: F2E4     3AD5F5     	LDA	MODE	;yes, are we in sequential mode?
3533: F2E7     FE01       	CPI	1              
3534: F2E9     C200F3     	JNZ	WTSEQ12        
3535: F2EC     CDD2EC     	CALL	SETNREC	;yes, set next record number.
3536: F2EF     CD5AF1     	CALL	GETNEXT	;and get next empty space in directory.
3537: F2F2     2145EB     	LXI	H,STATUS;ok?   
3538: F2F5     7E         	MOV	A,M            
3539: F2F6     B7         	ORA	A              
3540: F2F7     C2FEF2     	JNZ	WTSEQ11        
3541: F2FA     3D         	DCR	A	;yes, set record count to -1.
3542: F2FB     32E3F5     	STA	SAVNREC        
3543: F2FE                WTSEQ11:            
3544: F2FE     3600       	MVI	M,0	;clear status.
3545: F300                WTSEQ12:            
3546: F300     C3D2EC     	JMP	SETNREC	;set next record to access.
3547: F303                ;                   
3548: F303                ;   For random i/o, set the fcb for the desired record number
3549: F303                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
3550: F303                ; used as follows:  
3551: F303                ;                   
3552: F303                ;       fcb+35            fcb+34            fcb+33
3553: F303                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
3554: F303                ;  |7             0 | 7             0 | 7             0|
3555: F303                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
3556: F303                ;  |    overflow   | | extra |  extent   |   record #  |
3557: F303                ;  | ______________| |_extent|__number___|_____________|
3558: F303                ;                     also 's2'
3559: F303                ;                   
3560: F303                ;   On entry, register (C) contains 0ffh if this is a read
3561: F303                ; and thus we can not access unwritten disk space. Otherwise,
3562: F303                ; another extent will be opened (for writing) if required.
3563: F303                ;                   
3564: F303                POSITION:           
3565: F303     AF         	XRA	A	;set random i/o flag.
3566: F304     32D5F5     	STA	MODE           
3567: F307                ;                   
3568: F307                ;   Special entry (function #40). M/PM ?
3569: F307                ;                   
3570: F307                POSITN1:            
3571: F307     C5         	PUSH	B	;save read/write flag.
3572: F308     2A43EB     	LHLD	ParamsDE	;get address of fcb.
3573: F30B     EB         	XCHG               
3574: F30C     212100     	LXI	H,33	;now get byte 'r0'.
3575: F30F     19         	DAD	D              
3576: F310     7E         	MOV	A,M            
3577: F311     E67F       	ANI	7FH	;keep bits 0-6 for the record number to access.
3578: F313     F5         	PUSH	PSW           
3579: F314     7E         	MOV	A,M	;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
3580: F315     17         	RAL                
3581: F316     23         	INX	H              
3582: F317     7E         	MOV	A,M            
3583: F318     17         	RAL                
3584: F319     E61F       	ANI	1FH	;and save this in bits 0-4 of (C).
3585: F31B     4F         	MOV	C,A	;this is the extent byte.
3586: F31C     7E         	MOV	A,M	;now get the extra extent byte.
3587: F31D     1F         	RAR                
3588: F31E     1F         	RAR                
3589: F31F     1F         	RAR                
3590: F320     1F         	RAR                
3591: F321     E60F       	ANI	0FH            
3592: F323     47         	MOV	B,A	;and save it in (B).
3593: F324     F1         	POP	PSW	;get record number back to (A).
3594: F325     23         	INX	H	;check overflow byte 'r2'.
3595: F326     6E         	MOV	L,M            
3596: F327     2C         	INR	L              
3597: F328     2D         	DCR	L              
3598: F329     2E06       	MVI	L,6	;prepare for error.
3599: F32B     C28BF3     	JNZ	POSITN5	;out of disk space error.
3600: F32E     212000     	LXI	H,32	;store record number into fcb.
3601: F331     19         	DAD	D              
3602: F332     77         	MOV	M,A            
3603: F333     210C00     	LXI	H,12	;and now check the extent byte.
3604: F336     19         	DAD	D              
3605: F337     79         	MOV	A,C            
3606: F338     96         	SUB	M	;same extent as before?
3607: F339     C247F3     	JNZ	POSITN2        
3608: F33C     210E00     	LXI	H,14	;yes, check extra extent byte 's2' also.
3609: F33F     19         	DAD	D              
3610: F340     78         	MOV	A,B            
3611: F341     96         	SUB	M              
3612: F342     E67F       	ANI	7FH            
3613: F344     CA7FF3     	JZ	POSITN3;same, we are almost done then.
3614: F347                ;                   
3615: F347                ;  Get here when another extent is required.
3616: F347                ;                   
3617: F347                POSITN2:            
3618: F347     C5         	PUSH	B             
3619: F348     D5         	PUSH	D             
3620: F349     CDA2F0     	CALL	CLOSEIT	;close current extent.
3621: F34C     D1         	POP	D              
3622: F34D     C1         	POP	B              
3623: F34E     2E03       	MVI	L,3	;prepare for error.
3624: F350     3A45EB     	LDA	STATUS         
3625: F353     3C         	INR	A              
3626: F354     CA84F3     	JZ	POSITN4	;close error.
3627: F357     210C00     	LXI	H,12	;put desired extent into fcb now.
3628: F35A     19         	DAD	D              
3629: F35B     71         	MOV	M,C            
3630: F35C     210E00     	LXI	H,14	;and store extra extent byte 's2'.
3631: F35F     19         	DAD	D              
3632: F360     70         	MOV	M,B            
3633: F361     CD51F0     	CALL	OPENIT	;try and get this extent.
3634: F364     3A45EB     	LDA	STATUS	;was it there?
3635: F367     3C         	INR	A              
3636: F368     C27FF3     	JNZ	POSITN3        
3637: F36B     C1         	POP	B	;no. can we create a new one (writing?).
3638: F36C     C5         	PUSH	B             
3639: F36D     2E04       	MVI	L,4	;prepare for error.
3640: F36F     0C         	INR	C              
3641: F370     CA84F3     	JZ	POSITN4	;nope, reading unwritten space error.
3642: F373     CD24F1     	CALL	GETEMPTY;yes we can, try to find space.
3643: F376     2E05       	MVI	L,5	;prepare for error.
3644: F378     3A45EB     	LDA	STATUS         
3645: F37B     3C         	INR	A              
3646: F37C     CA84F3     	JZ	POSITN4	;out of space?
3647: F37F                ;                   
3648: F37F                ;   Normal return location. Clear error code and return.
3649: F37F                ;                   
3650: F37F                POSITN3:            
3651: F37F     C1         	POP	B	;restore stack.
3652: F380     AF         	XRA	A	;and clear error code byte.
3653: F381     C301EB     	JMP	SETSTAT        
3654: F384                ;                   
3655: F384                ;   Error. Set the 's2' byte to indicate this (why?).
3656: F384                ;                   
3657: F384                POSITN4:            
3658: F384     E5         	PUSH	H             
3659: F385     CD69ED     	CALL	GETS2         
3660: F388     36C0       	MVI	M,0C0H         
3661: F38A     E1         	POP	H              
3662: F38B                ;                   
3663: F38B                ;   Return with error code (presently in L).
3664: F38B                ;                   
3665: F38B                POSITN5:            
3666: F38B     C1         	POP	B              
3667: F38C     7D         	MOV	A,L	;get error code.
3668: F38D     3245EB     	STA	STATUS         
3669: F390     C378ED     	JMP	SETS2B7        
3670: F393                ;                   
3671: F393                ;   Read a random record.
3672: F393                ;                   
3673: F393                READRAN:            
3674: F393     0EFF       	MVI	C,0FFH	;set 'read' status.
3675: F395     CD03F3     	CALL	POSITION;position the file to proper record.
3676: F398     CCC1F1     	CZ	RDSEQ1	;and read it as usual (if no errors).
3677: F39B     C9         	RET                
3678: F39C                ;                   
3679: F39C                ;   Write to a random record.
3680: F39C                ;                   
3681: F39C                WRITERAN:           
3682: F39C     0E00       	MVI	C,0	;set 'writing' flag.
3683: F39E     CD03F3     	CALL	POSITION;position the file to proper record.
3684: F3A1     CC03F2     	CZ	WTSEQ1	;and write as usual (if no errors).
3685: F3A4     C9         	RET                
3686: F3A5                ;                   
3687: F3A5                ;   Compute the random record number. Enter with (HL) pointing
3688: F3A5                ; to a fcb an (DE) contains a relative location of a record
3689: F3A5                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
3690: F3A5                ; byte, and (A) the 'r2' byte.
3691: F3A5                ;                   
3692: F3A5                ;   On return, the zero flag is set if the record is within
3693: F3A5                ; bounds. Otherwise, an overflow occured.
3694: F3A5                ;                   
3695: F3A5                COMPRAND:           
3696: F3A5     EB         	XCHG		;save fcb pointer in (DE).
3697: F3A6     19         	DAD	D	;compute relative position of record #.
3698: F3A7     4E         	MOV	C,M	;get record number into (BC).
3699: F3A8     0600       	MVI	B,0            
3700: F3AA     210C00     	LXI	H,12	;now get extent.
3701: F3AD     19         	DAD	D              
3702: F3AE     7E         	MOV	A,M	;compute (BC)=(record #)+(extent)*128.
3703: F3AF     0F         	RRC		;move lower bit into bit 7.
3704: F3B0     E680       	ANI	80H	;and ignore all other bits.
3705: F3B2     81         	ADD	C	;add to our record number.
3706: F3B3     4F         	MOV	C,A            
3707: F3B4     3E00       	MVI	A,0	;take care of any carry.
3708: F3B6     88         	ADC	B              
3709: F3B7     47         	MOV	B,A            
3710: F3B8     7E         	MOV	A,M	;now get the upper bits of extent into
3711: F3B9     0F         	RRC		;bit positions 0-3.
3712: F3BA     E60F       	ANI	0FH	;and ignore all others.
3713: F3BC     80         	ADD	B	;add this in to 'r1' byte.
3714: F3BD     47         	MOV	B,A            
3715: F3BE     210E00     	LXI	H,14	;get the 's2' byte (extra extent).
3716: F3C1     19         	DAD	D              
3717: F3C2     7E         	MOV	A,M            
3718: F3C3     87         	ADD	A	;and shift it left 4 bits (bits 4-7).
3719: F3C4     87         	ADD	A              
3720: F3C5     87         	ADD	A              
3721: F3C6     87         	ADD	A              
3722: F3C7     F5         	PUSH	PSW	;save carry flag (bit 0 of flag byte).
3723: F3C8     80         	ADD	B	;now add extra extent into 'r1'.
3724: F3C9     47         	MOV	B,A            
3725: F3CA     F5         	PUSH	PSW	;and save carry (overflow byte 'r2').
3726: F3CB     E1         	POP	H	;bit 0 of (L) is the overflow indicator.
3727: F3CC     7D         	MOV	A,L            
3728: F3CD     E1         	POP	H	;and same for first carry flag.
3729: F3CE     B5         	ORA	L	;either one of these set?
3730: F3CF     E601       	ANI	01H	;only check the carry flags.
3731: F3D1     C9         	RET                
3732: F3D2                ;                   
3733: F3D2                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
3734: F3D2                ; reflect the last record used for a random (or other) file.
3735: F3D2                ; This reads the directory and looks at all extents computing
3736: F3D2                ; the largerst record number for each and keeping the maximum
3737: F3D2                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
3738: F3D2                ; maximum record number. This is used to compute the space used
3739: F3D2                ; by a random file. 
3740: F3D2                ;                   
3741: F3D2                RANSIZE:            
3742: F3D2     0E0C       	MVI	C,12	;look thru directory for first entry with
3743: F3D4     CD18EF     	CALL	FINDFST	;this name.
3744: F3D7     2A43EB     	LHLD	ParamsDE	;zero out the 'r0, r1, r2' bytes.
3745: F3DA     112100     	LXI	D,33           
3746: F3DD     19         	DAD	D              
3747: F3DE     E5         	PUSH	H             
3748: F3DF     72         	MOV	M,D	;note that (D)=0.
3749: F3E0     23         	INX	H              
3750: F3E1     72         	MOV	M,D            
3751: F3E2     23         	INX	H              
3752: F3E3     72         	MOV	M,D            
3753: F3E4                RANSIZ1:            
3754: F3E4     CDF5ED     	CALL	CKFILPOS;is there an extent to process?
3755: F3E7     CA0CF4     	JZ	RANSIZ3	;no, we are done.
3756: F3EA     CD5EED     	CALL	FCB2HL	;set (HL) pointing to proper fcb in dir.
3757: F3ED     110F00     	LXI	D,15	;point to last record in extent.
3758: F3F0     CDA5F3     	CALL	COMPRAND;and compute random parameters.
3759: F3F3     E1         	POP	H              
3760: F3F4     E5         	PUSH	H	;now check these values against those
3761: F3F5     5F         	MOV	E,A	;already in fcb.
3762: F3F6     79         	MOV	A,C	;the carry flag will be set if those
3763: F3F7     96         	SUB	M	;in the fcb represent a larger size than
3764: F3F8     23         	INX	H	;this extent does.
3765: F3F9     78         	MOV	A,B            
3766: F3FA     9E         	SBB	M              
3767: F3FB     23         	INX	H              
3768: F3FC     7B         	MOV	A,E            
3769: F3FD     9E         	SBB	M              
3770: F3FE     DA06F4     	JC	RANSIZ2         
3771: F401     73         	MOV	M,E	;we found a larger (in size) extent.
3772: F402     2B         	DCX	H	;stuff these values into fcb.
3773: F403     70         	MOV	M,B            
3774: F404     2B         	DCX	H              
3775: F405     71         	MOV	M,C            
3776: F406                RANSIZ2:            
3777: F406     CD2DEF     	CALL	FINDNXT	;now get the next extent.
3778: F409     C3E4F3     	JMP	RANSIZ1	;continue til all done.
3779: F40C                RANSIZ3:            
3780: F40C     E1         	POP	H	;we are done, restore the stack and
3781: F40D     C9         	RET		;return.      
3782: F40E                ;                   
3783: F40E                ;   Function to return the random record position of a given
3784: F40E                ; file which has been read in sequential mode up to now.
3785: F40E                ;                   
3786: F40E                SETRAN:             
3787: F40E     2A43EB     	LHLD	ParamsDE	;point to fcb.
3788: F411     112000     	LXI	D,32	;and to last used record.
3789: F414     CDA5F3     	CALL	COMPRAND;compute random position.
3790: F417     212100     	LXI	H,33	;now stuff these values into fcb.
3791: F41A     19         	DAD	D              
3792: F41B     71         	MOV	M,C	;move 'r0'.
3793: F41C     23         	INX	H              
3794: F41D     70         	MOV	M,B	;and 'r1'. 
3795: F41E     23         	INX	H              
3796: F41F     77         	MOV	M,A	;and lastly 'r2'.
3797: F420     C9         	RET                
3798: F421                ;                   
3799: F421                ;   This routine select the drive specified in (CurrentDrive) and
3800: F421                ; update the login vector and bitmap table if this drive was
3801: F421                ; not already active.
3802: F421                ;                   
3803: F421                LoginDrive:         
3804: F421     2AAFF5     	LHLD	LoggedBitMap	;get the logged Bitmap.
3805: F424     3A42EB     	LDA	CurrentDrive	;get the default drive.
3806: F427     4F         	MOV	C,A            
3807: F428     CDEAEC     	CALL	SHIFTR	;position active bit for this drive
3808: F42B     E5         	PUSH	H	;into bit 0.
3809: F42C     EB         	XCHG               
3810: F42D     CD59EB     	CALL	SelectDisk	;select this drive.
3811: F430     E1         	POP	H              
3812: F431     CC47EB     	CZ	SLCTERR	;valid drive?
3813: F434     7D         	MOV	A,L	;is this a newly activated drive?
3814: F435     1F         	RAR                
3815: F436     D8         	RC                 
3816: F437     2AAFF5     	LHLD	LoggedBitMap	;yes, update the logged Bitmap.
3817: F43A     4D         	MOV	C,L            
3818: F43B     44         	MOV	B,H            
3819: F43C     CD0BED     	CALL	SETBIT        
3820: F43F     22AFF5     	SHLD	LoggedBitMap	;and save.
3821: F442     C3A3EE     	JMP	BITMAP	;now update the bitmap.
3822: F445                ;                   
3823: F445                ;   Function to set the active disk number.
3824: F445                ;                   
3825: F445                SETDSK:             
3826: F445     3AD6F5     	LDA	ParamE	;get parameter passed and see if this
3827: F448     2142EB     	LXI	H,CurrentDrive;represents a change in drives.
3828: F44B     BE         	CMP	M              
3829: F44C     C8         	RZ                 
3830: F44D     77         	MOV	M,A	;yes it does, log it in.
3831: F44E     C321F4     	JMP	LoginDrive     
3832: F451                ;                   
3833: F451                ;   This is the 'auto disk select' routine. The firsst byte
3834: F451                ; of the fcb is examined for a drive specification. If non
3835: F451                ; zero then the drive will be selected and loged in.
3836: F451                ;                   
3837: F451                AUTOSEL:            
3838: F451     3EFF       	MVI	A,0FFH	;say 'auto-select activated'.
3839: F453     32DEF5     	STA	AUTO           
3840: F456     2A43EB     	LHLD	ParamsDE	;get drive specified.
3841: F459     7E         	MOV	A,M            
3842: F45A     E61F       	ANI	1FH	;look at lower 5 bits.
3843: F45C     3D         	DCR	A	;adjust for (1=A, 2=B) etc.
3844: F45D     32D6F5     	STA	ParamE	;and save for the select routine.
3845: F460     FE1E       	CPI	1EH	;check for 'no change' condition.
3846: F462     D275F4     	JNC	AUTOSL1	;yes, don't change.
3847: F465     3A42EB     	LDA	CurrentDrive	;we must change, save currently active
3848: F468     32DFF5     	STA	OLDDRV	;drive. 
3849: F46B     7E         	MOV	A,M	;and save first byte of fcb also.
3850: F46C     32E0F5     	STA	AUTOFLAG;this must be non-zero.
3851: F46F     E6E0       	ANI	0E0H	;whats this for (bits 6,7 are used for
3852: F471     77         	MOV	M,A	;something)?
3853: F472     CD45F4     	CALL	SETDSK	;select and log in this drive.
3854: F475                AUTOSL1:            
3855: F475     3A41EB     	LDA	USERNO	;move user number into fcb.
3856: F478     2A43EB     	LHLD	ParamsDE	;(* upper half of first byte *)
3857: F47B     B6         	ORA	M              
3858: F47C     77         	MOV	M,A            
3859: F47D     C9         	RET		;and return (all done).
3860: F47E                ;                   
3861: F47E                ;   Function to return the current cp/m version number.
3862: F47E                ;                   
3863: F47E                GETVER:             
3864: F47E     3E22       	MVI	A,022h	;version 2.2
3865: F480     C301EB     	JMP	SETSTAT        
3866: F483                ;                   
3867: F483                ;   Function to reset the disk system.
3868: F483                ;                   
3869: F483                RSTDSK:             
3870: F483     210000     	LXI		H,0				;clear write protect status and log
3871: F486     22ADF5     	SHLD	ROBitMap		;Clear All Read Only Bits
3872: F489     22AFF5     	SHLD	LoggedBitMap	; Clear all loggerd in drives
3873: F48C     AF         	XRA		A				;select drive 'A'.
3874: F48D     3242EB     	STA		CurrentDrive  
3875: F490     218000     	LXI		H,Pg0Buffer		;setup default dma address.
3876: F493     22B1F5     	SHLD	UsersDMA      
3877: F496     CDDAED     	CALL	Set2UsersDMA  
3878: F499     C321F4     	JMP		LoginDrive		;now log in drive 'A'.
3879: F49C                ;                   
3880: F49C                ;   Function to open a specified file.
3881: F49C                ;                   
3882: F49C                OPENFIL:            
3883: F49C     CD72ED     	CALL	CLEARS2	;clear 's2' byte.
3884: F49F     CD51F4     	CALL	AUTOSEL	;select proper disk.
3885: F4A2     C351F0     	JMP	OPENIT	;and open the file.
3886: F4A5                ;                   
3887: F4A5                ;   Function to close a specified file.
3888: F4A5                ;                   
3889: F4A5                CLOSEFIL:           
3890: F4A5     CD51F4     	CALL	AUTOSEL	;select proper disk.
3891: F4A8     C3A2F0     	JMP	CLOSEIT	;and close the file.
3892: F4AB                ;                   
3893: F4AB                ;   Function to return the first occurence of a specified file
3894: F4AB                ; name. If the first byte of the fcb is '?' then the name will
3895: F4AB                ; not be checked (get the first entry no matter what).
3896: F4AB                ;                   
3897: F4AB                GETFST:             
3898: F4AB     0E00       	MVI	C,0	;prepare for special search.
3899: F4AD     EB         	XCHG               
3900: F4AE     7E         	MOV	A,M	;is first byte a '?'?
3901: F4AF     FE3F       	CPI	QMARK		;'?'    
3902: F4B1     CAC2F4     	JZ	GETFST1	;yes, just get very first entry (zero length match).
3903: F4B4     CDA6EC     	CALL	SETEXT	;get the extension byte from fcb.
3904: F4B7     7E         	MOV	A,M	;is it '?'? if yes, then we want
3905: F4B8     FE3F       	CPI	QMARK		; '?'	;an entry with a specific 's2' byte.
3906: F4BA     C472ED     	CNZ	CLEARS2	;otherwise, look for a zero 's2' byte.
3907: F4BD     CD51F4     	CALL	AUTOSEL	;select proper drive.
3908: F4C0     0E0F       	MVI	C,15	;compare bytes 0-14 in fcb (12&13 excluded).
3909: F4C2                GETFST1:            
3910: F4C2     CD18EF     	CALL	FINDFST	;find an entry and then move it into
3911: F4C5     C3E9ED     	JMP	MOVEDIR	;the users dma space.
3912: F4C8                ;                   
3913: F4C8                ;   Function to return the next occurence of a file name.
3914: F4C8                ;                   
3915: F4C8                GETNXT:             
3916: F4C8     2AD9F5     	LHLD	SAVEFCB	;restore pointers. note that no
3917: F4CB     2243EB     	SHLD	ParamsDE	;other dbos calls are allowed.
3918: F4CE     CD51F4     	CALL	AUTOSEL	;no error will be returned, but the
3919: F4D1     CD2DEF     	CALL	FINDNXT	;results will be wrong.
3920: F4D4     C3E9ED     	JMP	MOVEDIR        
3921: F4D7                ;                   
3922: F4D7                ;   Function to delete a file by name.
3923: F4D7                ;                   
3924: F4D7                DELFILE:            
3925: F4D7     CD51F4     	CALL	AUTOSEL	;select proper drive.
3926: F4DA     CD9CEF     	CALL	ERAFILE	;erase the file.
3927: F4DD     C301EF     	JMP	STSTATUS;set status and return.
3928: F4E0                ;                   
3929: F4E0                ;   Function to execute a sequential read of the specified
3930: F4E0                ; record number.    
3931: F4E0                ;                   
3932: F4E0                READSEQ:            
3933: F4E0     CD51F4     	CALL	AUTOSEL	;select proper drive then read.
3934: F4E3     C3BCF1     	JMP	RDSEQ          
3935: F4E6                ;                   
3936: F4E6                ;   Function to write the net sequential record.
3937: F4E6                ;                   
3938: F4E6                WRTSEQ:             
3939: F4E6     CD51F4     	CALL	AUTOSEL	;select proper drive then write.
3940: F4E9     C3FEF1     	JMP	WTSEQ          
3941: F4EC                ;                   
3942: F4EC                ;   Create a file function.
3943: F4EC                ;                   
3944: F4EC                FCREATE:            
3945: F4EC     CD72ED     	CALL	CLEARS2	;clear the 's2' byte on all creates.
3946: F4EF     CD51F4     	CALL	AUTOSEL	;select proper drive and get the next
3947: F4F2     C324F1     	JMP	GETEMPTY;empty directory space.
3948: F4F5                ;                   
3949: F4F5                ;   Function to rename a file.
3950: F4F5                ;                   
3951: F4F5                RENFILE:            
3952: F4F5     CD51F4     	CALL	AUTOSEL	;select proper drive and then switch
3953: F4F8     CD16F0     	CALL	CHGNAMES;file names.
3954: F4FB     C301EF     	JMP	STSTATUS       
3955: F4FE                ;                   
3956: F4FE                ;   Function to return the logged in Bit map.
3957: F4FE                ;                   
3958: F4FE                GETLOG:             
3959: F4FE     2AAFF5     	LHLD	LoggedBitMap  
3960: F501     C329F5     	JMP	GETPRM1        
3961: F504                ;                   
3962: F504                ;   Function to return the current disk assignment.
3963: F504                ;                   
3964: F504                GETCRNT:            
3965: F504     3A42EB     	LDA	CurrentDrive   
3966: F507     C301EB     	JMP	SETSTAT        
3967: F50A                ;                   
3968: F50A                ;   Function to set the dma address.
3969: F50A                ;                   
3970: F50A                PUTDMA:             
3971: F50A     EB         	XCHG               
3972: F50B     22B1F5     	SHLD	UsersDMA	;save in our space and then get to
3973: F50E     C3DAED     	JMP	Set2UsersDMA	;the bios with this also.
3974: F511                ;                   
3975: F511                ;   Function to return the allocation vector.
3976: F511                ;                   
3977: F511                GETALOC:            
3978: F511     2ABFF5     	LHLD	ALOCVECT      
3979: F514     C329F5     	JMP	GETPRM1        
3980: F517                ;                   
3981: F517                ;   Function to return the read-only status vector.
3982: F517                ;                   
3983: F517                GETROV:             
3984: F517     2AADF5     	LHLD	ROBitMap      
3985: F51A     C329F5     	JMP	GETPRM1        
3986: F51D                ;                   
3987: F51D                ;   Function to set the file attributes (read-only, system).
3988: F51D                ;                   
3989: F51D                SETATTR:            
3990: F51D     CD51F4     	CALL	AUTOSEL	;select proper drive then save attributes.
3991: F520     CD3BF0     	CALL	SAVEATTR      
3992: F523     C301EF     	JMP	STSTATUS       
3993: F526                ;                   
3994: F526                ;   Function to return the address of the disk parameter block
3995: F526                ; for the current drive.
3996: F526                ;                   
3997: F526                GETPARM:            
3998: F526     2ABBF5     	LHLD	DISKPB        
3999: F529                GETPRM1:            
4000: F529     2245EB     	SHLD	STATUS        
4001: F52C     C9         	RET                
4002: F52D                ;                   
4003: F52D                ;   Function to get or set the user number. If (E) was (FF)
4004: F52D                ; then this is a request to return the current user number.
4005: F52D                ; Else set the user number from (E).
4006: F52D                ;                   
4007: F52D                GETUSER:            
4008: F52D     3AD6F5     	LDA	ParamE	;get parameter.
4009: F530     FEFF       	CPI	0FFH	;get user number?
4010: F532     C23BF5     	JNZ	SETUSER        
4011: F535     3A41EB     	LDA	USERNO	;yes, just do it.
4012: F538     C301EB     	JMP	SETSTAT        
4013: F53B                SETUSER:            
4014: F53B     E61F       	ANI	1FH	;no, we should set it instead. keep low
4015: F53D     3241EB     	STA	USERNO	;bits (0-4) only.
4016: F540     C9         	RET                
4017: F541                ;                   
4018: F541                ;   Function to read a random record from a file.
4019: F541                ;                   
4020: F541                RDRANDOM:           
4021: F541     CD51F4     	CALL	AUTOSEL	;select proper drive and read.
4022: F544     C393F3     	JMP	READRAN        
4023: F547                ;                   
4024: F547                ;   Function to compute the file size for random files.
4025: F547                ;                   
4026: F547                WTRANDOM:           
4027: F547     CD51F4     	CALL	AUTOSEL	;select proper drive and write.
4028: F54A     C39CF3     	JMP	WRITERAN       
4029: F54D                ;                   
4030: F54D                ;   Function to compute the size of a random file.
4031: F54D                ;                   
4032: F54D                FILESIZE:           
4033: F54D     CD51F4     	CALL	AUTOSEL	;select proper drive and check file length
4034: F550     C3D2F3     	JMP	RANSIZE        
4035: F553                ;                   
4036: F553                ;   Function #37. This allows a program to log off any drives.
4037: F553                ; On entry, set (DE) to contain a word with bits set for those
4038: F553                ; drives that are to be logged off. The log-in vector and the
4039: F553                ; write protect vector will be updated. This must be a M/PM
4040: F553                ; special function. 
4041: F553                ;                   
4042: F553                LOGOFF:             
4043: F553     2A43EB     	LHLD	ParamsDE	;get drives to log off.
4044: F556     7D         	MOV	A,L	;for each bit that is set, we want
4045: F557     2F         	CMA		;to clear that bit in (LoggedBitMap)
4046: F558     5F         	MOV	E,A	;and (ROBitMap).
4047: F559     7C         	MOV	A,H            
4048: F55A     2F         	CMA                
4049: F55B     2AAFF5     	LHLD	LoggedBitMap	;reset the login Bit map.
4050: F55E     A4         	ANA	H              
4051: F55F     57         	MOV	D,A            
4052: F560     7D         	MOV	A,L            
4053: F561     A3         	ANA	E              
4054: F562     5F         	MOV	E,A            
4055: F563     2AADF5     	LHLD	ROBitMap      
4056: F566     EB         	XCHG               
4057: F567     22AFF5     	SHLD	LoggedBitMap	;and save.
4058: F56A     7D         	MOV	A,L	;now do the write protect vector.
4059: F56B     A3         	ANA	E              
4060: F56C     6F         	MOV	L,A            
4061: F56D     7C         	MOV	A,H            
4062: F56E     A2         	ANA	D              
4063: F56F     67         	MOV	H,A            
4064: F570     22ADF5     	SHLD	ROBitMap	;and save. all done.
4065: F573     C9         	RET                
4066: F574                ;                   
4067: F574                ;   Get here to return to the user.
4068: F574                ;                   
4069: F574                BDOSExit:           
4070: F574     3ADEF5     	LDA	AUTO	;was auto select activated?
4071: F577     B7         	ORA	A              
4072: F578     CA91F5     	JZ	BDOSExit1       
4073: F57B     2A43EB     	LHLD	ParamsDE	;yes, but was a change made?
4074: F57E     3600       	MVI	M,0	;(* reset first byte of fcb *)
4075: F580     3AE0F5     	LDA	AUTOFLAG       
4076: F583     B7         	ORA	A              
4077: F584     CA91F5     	JZ	BDOSExit1       
4078: F587     77         	MOV	M,A	;yes, reset first byte properly.
4079: F588     3ADFF5     	LDA	OLDDRV	;and get the old drive and select it.
4080: F58B     32D6F5     	STA	ParamE         
4081: F58E     CD45F4     	CALL	SETDSK        
4082: F591                BDOSExit1:          
4083: F591     2A0FEB     	LHLD	UserStack;reset the users stack pointer.
4084: F594     F9         	SPHL               
4085: F595     2A45EB     	LHLD	STATUS	;get return status.
4086: F598     7D         	MOV	A,L	;force version 1.4 compatability.
4087: F599     44         	MOV	B,H            
4088: F59A     C9         	RET		;and go back to user.
4089: F59B                ;                   
4090: F59B                ;   Function #40. This is a special entry to do random i/o.
4091: F59B                ; For the case where we are writing to unused disk space, this
4092: F59B                ; space will be zeroed out first. This must be a M/PM special
4093: F59B                ; purpose function, because why would any normal program even
4094: F59B                ; care about the previous contents of a sector about to be
4095: F59B                ; written over.     
4096: F59B                ;                   
4097: F59B                WTSPECL:            
4098: F59B     CD51F4     	CALL	AUTOSEL	;select proper drive.
4099: F59E     3E02       	MVI	A,2	;use special write mode.
4100: F5A0     32D5F5     	STA	MODE           
4101: F5A3     0E00       	MVI	C,0	;set write indicator.
4102: F5A5     CD07F3     	CALL	POSITN1	;position the file.
4103: F5A8     CC03F2     	CZ	WTSEQ1	;and write (if no errors).
4104: F5AB     C9         	RET                
4105: F5AC                ;                   
4106: F5AC                ;**************************************************************
4107: F5AC                ;*                  
4108: F5AC                ;*     BDOS data storage pool.
4109: F5AC                ;*                  
4110: F5AC                ;**************************************************************
4111: F5AC                ;                   
4112: F5AC     E5         EMPTYFCB:	DB	0E5H	;empty directory segment indicator.
4113: F5AD     0000       ROBitMap:		DW	0	;write protect status for all 16 drives.
4114: F5AF     0000       LoggedBitMap:		DW	0	;drive active word (1 bit per drive).
4115: F5B1     8000       UsersDMA:	DW	080H	;user's dma address (defaults to 80h).
4116: F5B3                ;                   
4117: F5B3                ;   Scratch areas from parameter block.
4118: F5B3                ;                   
4119: F5B3     0000       SCRATCH1:	DW	0	;relative position within dir segment for file (0-3).
4120: F5B5     0000       SCRATCH2:	DW	0	;last selected track number.
4121: F5B7     0000       SCRATCH3:	DW	0	;last selected sector number.
4122: F5B9                ;                   
4123: F5B9                ;   Disk storage areas from parameter block.
4124: F5B9                ;                   
4125: F5B9     0000       DIRBUF:		DW	0	;address of directory buffer to use.
4126: F5BB     0000       DISKPB:		DW	0	;contains address of disk parameter block.
4127: F5BD     0000       CHKVECT:	DW	0	;address of check vector.
4128: F5BF     0000       ALOCVECT:	DW	0	;address of allocation vector (bit map).
4129: F5C1                ;                   
4130: F5C1                ;   Parameter block returned from the bios.
4131: F5C1                ;                   
4132: F5C1     0000       SECTORS:	DW	0	;sectors per track from bios.
4133: F5C3     00         BLKSHFT:	DB	0	;block shift.
4134: F5C4     00         BLKMASK:	DB	0	;block mask.
4135: F5C5     00         EXTMASK:	DB	0	;extent mask.
4136: F5C6     0000       DSKSIZE:	DW	0	;disk size from bios (number of blocks-1).
4137: F5C8     0000       DIRSIZE:	DW	0	;directory size.
4138: F5CA     0000       ALLOC0:		DW	0	;storage for first bytes of bit map (dir space used).
4139: F5CC     0000       ALLOC1:		DW	0       
4140: F5CE     0000       OFFSET:		DW	0	;first usable track number.
4141: F5D0     0000       XLATE:		DW	0	;sector translation table address.
4142: F5D2                ;                   
4143: F5D2                ;                   
4144: F5D2     00         CLOSEFLG:	DB	0	;close flag (=0ffh is extent written ok).
4145: F5D3     00         RDWRTFLG:	DB	0	;read/write flag (0ffh=read, 0=write).
4146: F5D4     00         FNDSTAT:	DB	0	;filename found status (0=found first entry).
4147: F5D5     00         MODE:		DB	0	;I/o mode select (0=random, 1=sequential, 2=special random).
4148: F5D6     00         ParamE:		DB	0	;storage for register (E) on entry to bdos.
4149: F5D7     00         RELBLOCK:	DB	0	;relative position within fcb of block number written.
4150: F5D8     00         COUNTER:	DB	0	;byte counter for directory name searches.
4151: F5D9     00000000   SAVEFCB:	DW	0,0	;save space for address of fcb (for directory searches).
4152: F5DD     00         BIGDISK:	DB	0	;if =0 then disk is > 256 blocks long.
4153: F5DE     00         AUTO:		DB	0	;if non-zero, then auto select activated.
4154: F5DF     00         OLDDRV:		DB	0	;on auto select, storage for previous drive.
4155: F5E0     00         AUTOFLAG:	DB	0	;if non-zero, then auto select changed drives.
4156: F5E1     00         SAVNXT:		DB	0	;storage for next record number to access.
4157: F5E2     00         SAVEXT:		DB	0	;storage for extent number of file.
4158: F5E3     0000       SAVNREC:	DW	0	;storage for number of records in file.
4159: F5E5     0000       BLKNMBR:	DW	0	;block number (physical sector) used within a file or logical sector.
4160: F5E7     0000       LOGSECT:	DW	0	;starting logical (128 byte) sector of block (physical sector).
4161: F5E9     00         FCBPOS:		DB	0	;relative position within buffer for fcb of file of interest.
4162: F5EA     0000       FILEPOS:	DW	0	;files position within directory (0 to max entries -1).
4163: F5EC                ;                   
4164: F5EC                ;   Disk directory buffer checksum bytes. One for each of the
4165: F5EC                ; 16 possible drives.
4166: F5EC                ;                   
4167: F5EC                CKSUMTBL:           
4168: F5EC     00000000000000000000000000000000 	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
4169: F5FC                ;                   
4170: F5FC                ;   Extra space ?   
4171: F5FC                ;                   
4172: F5FC     00000000   	DB	0,0,0,0         
4173: F600                ;                   
4174: F600                ;**************************************************************
4175: F600                ;*                  
4176: F600                ;*        B I O S   J U M P   T A B L E
4177: F600                ;*                  
4178: F600                ;**************************************************************
4179: F600                ;                   
4180: F600                BIOSEntry	Equ	0F600H		; start of bios
4181: F600                                    
4182: F600     C300F6     BOOT:	JMP	BIOSEntry + 000H	
4183: F603     C303F6     WBOOT:	JMP	BIOSEntry + 003H
4184: F606     C306F6     CONST:	JMP	BIOSEntry + 006H
4185: F609     C309F6     CONIN:	JMP	BIOSEntry + 009H
4186: F60C     C30CF6     CONOUT:	JMP	BIOSEntry + 00CH
4187: F60F     C30FF6     LIST:	JMP	BIOSEntry + 00FH
4188: F612     C312F6     PUNCH:	JMP	BIOSEntry + 012H
4189: F615     C315F6     READER:	JMP	BIOSEntry + 015H
4190: F618     C318F6     HOME:	JMP	BIOSEntry + 018H
4191: F61B     C31BF6     SELDSK:	JMP	BIOSEntry + 01BH
4192: F61E     C31EF6     SETTRK:	JMP	BIOSEntry + 01EH
4193: F621     C321F6     SETSEC:	JMP	BIOSEntry + 021H
4194: F624     C324F6     SETDMA:	JMP	BIOSEntry + 024H
4195: F627     C327F6     READ:	JMP	BIOSEntry + 027H
4196: F62A     C32AF6     WRITE:	JMP	BIOSEntry + 02AH
4197: F62D     C32DF6     PRSTAT:	JMP	BIOSEntry + 02DH
4198: F630     C330F6     SECTRN:	JMP	BIOSEntry + 030H
4199: F633                ;                   
4200: F633                ;*                  
4201: F633                ;******************   E N D   O F   C P / M   *****************
4202: F633                ;*                  
4203: F633                CodeEnd:            
4204: F633                		END               




                                    Xref


0000	0000	$                             		  1513,

2447	ED64	ADDA2HL                       		  3434,
0499	E259	ADDHL                         		  0517,  0870,  1063,
4138	F5CA	ALLOC0                        		  2793,
4139	F5CC	ALLOC1                        		  2531,
4128	F5BF	ALOCVECT                      		  2688,  2785,  2795,  3978,
0052	002A	ASTRK                         		  0557,  0589,
0054	0040	ATSIGN                        		  1677,
4153	F5DE	AUTO                          		  1446,  3839,  4070,
4155	F5E0	AUTOFLAG                      		  1445,  3850,  4075,
3837	F451	AUTOSEL                       		  3884,  3890,  3907,  3918,  3925,  3933,  3939,  3946,  3952,  3990,  4021,  4027,  4033,  4098,
3854	F475	AUTOSL1                       		  3846,

1699	E9A4	BACKUP                        		  1814,  1854,
1703	E9AC	BACKUP1                       		  1700,
1354	E77A	BADLOAD                       		  1351,
1420	E809	BADSCTR                       		  2082,
1541	E8CA	BADSEC                        		  1518,
1542	E8D5	BADSEL                        		  1525,
1421	E80B	BADSLCT                       		  1982,
1381	E7AB	BATCH                         		  0290,  0408,  0716,  1340,
1383	E7AC	BATCHFCB                      		  0302,  0305,  0307,  0308,  0318,  0322,  0415,
1540	E8C6	BDOSDRV                       		  1553,
1415	E806	BDOSENTRY                     		
1539	E8BA	BDOSERR                       		  1554,
4069	F574	BDOSEXIT                      		  1447,
4082	F591	BDOSEXIT1                     		  1914,  4072,  4077,
1433	E811	BDOSSETUP                     		  1416,
1972	EB41	BDOSSTACK                     		  1443,
4152	F5DD	BIGDISK                       		  2044,  2219,  2734,  3202,  3430,
4180	F600	BIOSENTRY                     		  4182,  4183,  4184,  4185,  4186,  4187,  4188,  4189,  4190,  4191,  4192,  4193,  4194,  4195,  4196,  4197,  4198,
2770	EEA3	BITMAP                        		  3821,
2786	EEB1	BITMAP1                       		  2792,
2808	EED2	BITMAP2                       		  2816,  2830,
2826	EEF6	BITMAP3                       		  2819,  2823,
0041	0020	BLANK                         		  0114,  0444,  0467,  0492,  0574,  0606,  0678,  0812,  0839,  0915,  0967,  0976,  0979,  1221,  1235,  1251,  1311,  1368,  1595,  1649,  1688,  1701,  1719,
4134	F5C4	BLKMASK                       		  2265,  3487,
4159	F5E5	BLKNMBR                       		  2092,  2099,  2240,  2246,  2259,  2271,  3425,  3480,  3485,  3494,
4133	F5C3	BLKSHFT                       		  2186,  2258,
4182	F600	BOOT                          		
0042	007B	BRACKETLEFT                   		  0280,
0043	007D	BRACKETRIGHT                  		
0028	0008	BS                            		  1593,  1656,  1704,  1766,

0053	005E	CARET                         		  1674,
0064	E000	CBASE                         		  0777,  0778,  1275,
1377	E7AB	CCPSTACK                      		  0705,  0729,
1392	E7EF	CDRIVE                        		  0262,  0270,  0298,  0325,  0417,  0540,  0720,  0744,  0885,  0898,  0901,  1241,
1963	EB0E	CHARBUF                       		  1563,  1604,  1619,
0463	E230	CHECK                         		  0554,  0568,  0586,  0600,
2528	ED9E	CHECKDIR                      		  2647,
2348	ECF7	CHECKSUM                      		  2535,
1394	E7F0	CHGDRV                        		  0521,  0545,  0747,  0805,  0881,  0894,  1152,  1176,  1237,  1291,  1369,
3087	F027	CHGNAM1                       		  3095,
3078	F016	CHGNAMES                      		  3953,
2245	EC84	CHKBLK                        		  3376,  3404,
1586	E914	CHKCHAR                       		  1574,  1671,
0378	E1C2	CHKCON                        		  0333,  0993,  1068,
2549	EDC4	CHKDIR1                       		  2542,
2498	ED8C	CHKNMBR                       		  2829,  3289,
2419	ED44	CHKROFL                       		  2958,  3090,
2352	ECFD	CHKSUM1                       		  2356,
4127	F5BD	CHKVECT                       		  2536,
2432	ED54	CHKWPRT                       		  2952,  3079,  3265,  3396,
2655	EE35	CKBITMAP                      		  2703,  2994,  3023,
2691	EE56	CKBMAP1                       		  2694,
1618	E942	CKCON1                        		  1612,
1620	E945	CKCON2                        		  1606,
1603	E923	CKCONSOL                      		  1633,  1943,
2599	EDF5	CKFILPOS                      		  2811,  2880,  2956,  3088,  3106,  3119,  3192,  3272,  3300,  3330,  3336,  3754,
2421	ED47	CKROF1                        		  3398,
4167	F5EC	CKSUMTBL                      		  2093,  2529,  2538,
0693	E358	CLEARBUF                      		  0066,
2466	ED72	CLEARS2                       		  3883,  3906,  3945,
0172	E0DA	CLOSE                         		  0323,  1128,
3889	F4A5	CLOSEFIL                      		  1487,
4144	F5D2	CLOSEFLG                      		  3254,  3298,  3313,
3180	F0A2	CLOSEIT                       		  3299,  3620,  3891,
3201	F0CD	CLOSEIT1                      		  3237,
3210	F0DB	CLOSEIT2                      		  3208,
3215	F0E1	CLOSEIT3                      		  3212,
3219	F0E8	CLOSEIT4                      		  3204,
3233	F0FD	CLOSEIT5                      		  3218,
3252	F117	CLOSEIT6                      		  3244,
3256	F11F	CLOSEIT7                      		  3217,  3226,  3231,
0769	E3C1	CMDADR                        		  0756,
0640	E310	CMDTBL                        		  0661,
0728	E382	CMMND1                        		  0341,  0458,  1016,  1020,  1343,  1372,
0740	E398	CMMND2                        		  0724,
0026	0003	CNTRLC                        		  1520,  1614,  1874,
0027	0005	CNTRLE                        		  1786,
0033	0010	CNTRLP                        		  1795,
0034	0012	CNTRLR                        		  1823,
0035	0013	CNTRLS                        		  1611,
0036	0015	CNTRLU                        		  1817,
0037	0018	CNTRLX                        		  1805,
0038	001A	CNTRLZ                        		  1065,
4203	F633	CODEEND                       		
0062	E000	CODESTART                     		
0048	003A	COLON                         		  0476,  0536,  0953,  0958,
2235	EC77	COMBLK                        		  3375,  3403,
1356	E783	COMFILE                       		  1257,
0704	E35C	COMMAND                       		  0065,
3695	F3A5	COMPRAND                      		  3758,  3789,
4185	F609	CONIN                         		  1568,  1610,  1613,  1915,
4186	F60C	CONOUT                        		  1636,  1702,  1705,  1910,
4184	F606	CONST                         		  1607,  1909,  1912,
0515	E260	CONVERT                       		  1296,
0508	E25E	CONVFST                       		  0745,  0804,  0911,  1008,  1040,  1091,  1150,  1172,  1290,  1366,
0539	E289	CONVRT1                       		  0531,
0543	E290	CONVRT2                       		  0537,
0551	E296	CONVRT3                       		  0542,
0553	E298	CONVRT4                       		  0566,
0561	E2A9	CONVRT5                       		  0558,
0564	E2AB	CONVRT6                       		  0560,
0567	E2AF	CONVRT7                       		  0571,
0572	E2B9	CONVRT8                       		  0555,  0576,
4150	F5D8	COUNTER                       		  2866,  2893,
0032	000D	CR                            		  0106,  1587,  1726,  1762,  1885,
0231	E109	CREATE                        		  1098,
0105	E098	CRLF                          		  0122,  0440,  0456,  0730,  0947,  1045,  1333,
1961	EB0C	CURPOS                        		  1645,  1690,  1715,  1747,  1772,  1810,  1850,
1975	EB42	CURRENTDRIVE                  		  1551,  2009,  2374,  2392,  3805,  3827,  3847,  3874,  3965,

1995	EB4F	DE2HL                         		  2036,  2041,  2595,  3069,  3131,
1997	EB50	DE2HL1                        		  2004,
0803	E3F8	DECODE                        		  1089,  1216,
0810	E408	DECODE1                       		  0835,
0831	E42A	DECODE2                       		
0837	E433	DECODE3                       		  0813,  0844,
0842	E43A	DECODE4                       		
0039	007F	DEL                           		  1646,  1776,
0407	E1DD	DELBATCH                      		  0340,  0347,  0457,
0197	E0EF	DELETE                        		  0416,  1026,  1096,
3924	F4D7	DELFILE                       		  1490,
4125	F5B9	DIRBUF                        		  2034,  2350,  2442,  2577,  2591,  3469,
1911	EAE0	DIRC1                         		  1907,
1904	EAD4	DIRCIO                        		  1476,
0910	E477	DIRECT                        		  0770,
0918	E488	DIRECT1                       		  0922,
0923	E48F	DIRECT2                       		  0916,
0928	E498	DIRECT3                       		  0996,
0956	E4CC	DIRECT4                       		  0946,
0960	E4D4	DIRECT5                       		  0955,
0963	E4D9	DIRECT6                       		  0987,  0989,
0990	E50E	DIRECT7                       		  0977,  0985,
0992	E50F	DIRECT8                       		  0939,
0997	E51B	DIRECT9                       		  0929,  0994,
2564	EDD4	DIRREAD                       		  2645,
4137	F5C8	DIRSIZE                       		  2408,  2624,
2555	EDC6	DIRWRITE                      		  2963,  3072,
4126	F5BB	DISKPB                        		  2037,  3998,
1544	E8E1	DISKRO                        		  1529,
0401	E1D8	DMASET                        		  0742,  1116,  1268,
0056	0024	DOLLAR                        		  1735,  2822,
2071	EBB2	DOREAD                        		  2566,  3380,
2077	EBB8	DOWRITE                       		  2559,  3484,  3504,
0978	E4F7	DRECT63                       		  0972,
0980	E4F9	DRECT65                       		  0968,
0878	E454	DSELECT                       		  0912,  1024,  1042,  1093,  1154,  1255,
0142	E0BD	DSKSEL                        		  0301,  0327,  0414,  0418,  0721,  0888,  0902,  1243,  1342,
4136	F5C6	DSKSIZE                       		  2042,  2753,  2771,  3012,

4112	F5AC	EMPTYFCB                      		  3268,
0019	0005	ENTRY                         		  0092,  0138,  0145,  0151,  0199,  0205,  0240,  0252,  0351,  0380,  0384,  0392,  0403,
0150	E0C3	ENTRY1                        		  0160,  0174,  0181,  0187,  0233,
0204	E0F4	ENTRY2                        		  0214,  0227,
0045	003D	EQUALS                        		  0470,  1164,
2955	EFA4	ERAFIL1                       		  2965,
2951	EF9C	ERAFILE                       		  3926,
1007	E51F	ERASE                         		  0770,
1023	E542	ERASE1                        		  1010,
1517	E899	ERROR1                        		  1420,
1524	E8A5	ERROR2                        		  1421,
1528	E8AB	ERROR3                        		  1422,
1532	E8B1	ERROR4                        		  1423,
1535	E8B4	ERROR5                        		  1526,  1530,
1206	E682	EXISTS                        		  1203,
2214	EC5E	EXTBLK                        		  2239,  3414,
2225	EC71	EXTBLK1                       		  2221,
4135	F5C5	EXTMASK                       		  2304,  2846,  3311,
0867	E44B	EXTRACT                       		  0937,  0965,  0974,

1388	E7CD	FCB                           		  0166,  0167,  0192,  0219,  0516,  0667,  0808,  0880,  0913,  1025,  1094,  1101,  1117,  1127,  1157,  1158,  1186,  1190,  1220,  1234,  1249,  1269,  1294,  1299,  1301,  1303,  1367,
2441	ED5E	FCB2HL                        		  2420,  2724,  2813,  2892,  2959,  3067,  3126,  3195,  3756,
4161	F5E9	FCBPOS                        		  2443,  2640,
3053	EFFD	FCBSET                        		  3290,
3944	F4EC	FCREATE                       		  1493,
0031	000C	FF                            		
4162	F5EA	FILEPOS                       		  2089,  2485,  2600,  2612,  2626,  2628,  2633,  2930,  3183,  3184,
1543	E8DC	FILERO                        		  1533,
4032	F54D	FILESIZE                      		  1506,
2863	EF18	FINDFST                       		  2954,  3081,  3104,  3118,  3191,  3271,  3329,  3743,  3910,
2877	EF2D	FINDNXT                       		  2911,  2918,  2964,  3094,  3111,  3777,  3919,
2891	EF4A	FNDNXT1                       		  2886,
2896	EF53	FNDNXT2                       		  2928,
2913	EF73	FNDNXT3                       		  2908,
2923	EF7C	FNDNXT4                       		  2902,  2905,  2912,
2929	EF83	FNDNXT5                       		  2899,
2943	EF94	FNDNXT6                       		  2881,  2890,
2987	EFC0	FNDSPA1                       		  3028,  3047,
3011	EFD1	FNDSPA2                       		  2990,
3033	EFEC	FNDSPA3                       		  2996,  3025,
3044	EFF4	FNDSPA4                       		  3017,
2980	EFBE	FNDSPACE                      		  3418,
4146	F5D4	FNDSTAT                       		  2835,  2865,  2933,
1513	0028	FUNCTIONCOUNT                 		  1450,
1469	E847	FUNCTIONVECTOR                		  1513,  1453,

3977	F511	GETALOC                       		  1498,
1363	E786	GETBACK                       		  0999,  1029,  1066,  1069,  1076,  1139,  1192,  1198,  1205,  1353,
1365	E789	GETBACK1                      		  1224,  1239,  1244,
2189	EC45	GETBLK1                       		  2193,
2199	EC53	GETBLK2                       		  2204,
2205	EC5C	GETBLK3                       		  2201,
2185	EC3E	GETBLOCK                      		  2236,  3407,
1562	E8FB	GETCHAR                       		  1573,  1758,
1890	EAC8	GETCON                        		  1471,
3964	F504	GETCRNT                       		  1496,
1942	EAFE	GETCSTS                       		  1481,
0390	E1D0	GETDSK                        		  0731,  0743,  0949,
1572	E906	GETECHO                       		  1891,
3264	F124	GETEMPTY                      		  3335,  3642,  3947,
0580	E2C0	GETEXT                        		  0569,
0585	E2C8	GETEXT1                       		  0598,
0593	E2D9	GETEXT2                       		  0590,
0596	E2DB	GETEXT3                       		  0592,
0599	E2DF	GETEXT4                       		  0603,
0604	E2E9	GETEXT5                       		  0583,  0587,  0608,
0609	E2F0	GETEXT6                       		  0601,
0611	E2F2	GETEXT7                       		  0615,
0624	E301	GETEXT8                       		  0632,
0630	E309	GETEXT9                       		  0628,
3897	F4AB	GETFST                        		  1488,
3909	F4C2	GETFST1                       		  3902,
0289	E139	GETINP                        		  0736,  1013,
0346	E196	GETINP1                       		  0292,  0304,  0310,  0324,
0356	E1A7	GETINP2                       		  0334,
0359	E1AB	GETINP3                       		  0368,
0369	E1BA	GETINP4                       		  0363,
1920	EAED	GETIOB                        		  1477,
3958	F4FE	GETLOG                        		  1495,
3281	F146	GETMT1                        		  3285,
3296	F15A	GETNEXT                       		  3368,  3536,
3915	F4C8	GETNXT                        		  1489,
3997	F526	GETPARM                       		  1502,
3999	F529	GETPRM1                       		  3960,  3979,  3985,
1896	EACE	GETRDR                        		  1473,
3983	F517	GETROV                        		  1500,
2457	ED69	GETS2                         		  2467,  2474,  3187,  3525,  3659,
0250	E115	GETSETUC                      		  0714,  1223,
4007	F52D	GETUSER                       		  1503,
0244	E113	GETUSR                        		  0257,
3863	F47E	GETVER                        		  1482,
2390	ED1E	GETWPRT                       		  2433,  3185,
0051	003E	GRTTHAN                       		  0482,  0734,
3317	F183	GTNEXT1                       		  3309,
3327	F18E	GTNEXT2                       		  3315,
3339	F1AC	GTNEXT3                       		  3316,  3331,
3341	F1AF	GTNEXT4                       		  3338,
3349	F1B6	GTNEXT5                       		  3323,  3334,  3337,

0775	E3CF	HALT                          		  0430,
0856	E442	HL2DE                         		  0317,  0862,  1160,  1305,
4190	F618	HOME                          		  2057,
2056	EBA1	HOMEDRV                       		  2802,  2871,

0072	E006	INBUFF                        		  0082,  0314,  0331,  0350,  0357,  0371,  0695,  0722,  1014,  1306,
0081	E088	INPOINT                       		  0372,  0522,  0617,  1022,  1161,  1171,
0017	0003	IOBYTE                        		  1921,  1927,
1955	EB05	IOERR1                        		  3350,  3386,  3402,
2079	EBBB	IORET                         		  2073,

1986	EB4A	JUMPHL                        		  2083,  2428,  2436,

0050	003C	LESSTH                        		  0480,
0030	000A	LF                            		  0108,  1589,  1661,  1728,  1764,
4187	F60F	LIST                          		  1475,  1641,
4114	F5AF	LOGGEDBITMAP                  		  3804,  3816,  3820,  3872,  3959,  4049,  4057,
2257	EC8A	LOGICAL                       		  3378,  3452,
2260	EC90	LOGICL1                       		  2263,
3803	F421	LOGINDRIVE                    		  3831,  3878,
4042	F553	LOGOFF                        		  1508,
4160	F5E7	LOGSECT                       		  2264,  3477,

0015	0040	MEM                           		  0061,
4147	F5D5	MODE                          		  2315,  3357,  3392,  3453,  3532,  3566,  4100,
2484	ED7F	MOREFLS                       		  2499,  2545,  2888,
0851	E440	MOVE3                         		  1258,
0269	E129	MOVECD                        		  0352,  1242,  1341,
2590	EDE9	MOVEDIR                       		  3911,  3920,
3162	F094	MOVEWORD                      		  3220,  3222,

0083	E08A	NAMEPNT                       		  0441,  0526,
1396	E7F1	NBYTES                        		  1046,  1049,
1710	E9B1	NEWLINE                       		  1819,  1827,
1714	E9B9	NEWLN1                        		  1721,
0795	E3F0	NOFILE                        		  0793,
0488	E24F	NONBLANK                      		  0495,  0524,  1163,
0792	E3EA	NONE                          		  0927,  1028,  1197,
1140	E607	NOSPACE                       		  1135,
0639	0006	NUMCMDS                       		  0665,
2632	EE19	NXENT1                        		  2630,
2636	EE20	NXENT2                        		  2639,
2623	EE05	NXENTRY                       		  2810,  2879,

4140	F5CE	OFFSET                        		  2153,
4154	F5DF	OLDDRV                        		  3848,  4079,
0158	E0CB	OPEN                          		  0168,  0303,
0164	E0D0	OPENFCB                       		  1043,  1259,
3882	F49C	OPENFIL                       		  1486,
3116	F051	OPENIT                        		  3633,  3885,
3121	F05A	OPENIT1                       		  3340,
3150	F08B	OPENIT2                       		  3146,  3148,
1628	E948	OUTCHAR                       		  1675,  1686,  1689,  1712,  1720,  1727,  1729,  1886,
1643	E962	OUTCHR1                       		  1631,
1660	E979	OUTCHR2                       		  1657,
1683	E990	OUTCON                        		  1472,  1578,  1672,  1740,
1687	E996	OUTCON1                       		  1693,
1725	E9C9	OUTCRLF                       		  1550,  1713,  1790,
1959	EB0A	OUTFLAG                       		  1629,  1773,  1847,  1852,  1855,

4148	F5D6	PARAME                        		  1438,  3826,  3844,  4008,  4080,
1976	EB43	PARAMSDE                      		  1435,  1461,  1749,  2215,  2277,  2286,  2458,  2868,  3064,  3082,  3128,  3151,  3198,  3266,  3269,  3274,  3302,  3397,  3427,  3572,  3744,  3787,  3840,  3856,  3917,  4043,  4073,
0651	E328	PATTRN1                       		  0424,
1406	E800	PATTRN2                       		  0425,
0047	002E	PERIOD                        		  0474,  0582,
0021	0080	PG0BUFFER                     		  0315,  0397,  0741,  0868,  1062,  1320,  1332,  3875,
0120	E0A7	PLINE                         		  0785,  0794,  1012,  1136,  1204,  1352,
0124	E0AC	PLINE2                        		  0132,  0332,
3564	F303	POSITION                      		  3675,  3683,
3570	F307	POSITN1                       		  4102,
3617	F347	POSITN2                       		  3607,
3650	F37F	POSITN3                       		  3613,  3636,
3657	F384	POSITN4                       		  3626,  3641,  3646,
3665	F38B	POSITN5                       		  3599,
0055	0023	POUNDSN                       		  1711,
0089	E08C	PRINT                         		  0098,  0130,  0449,  0455,  0733,  0735,  1067,
0096	E092	PRINTB                        		  0107,  0109,  0115,  0952,  0954,  0959,  0981,
4197	F62D	PRSTAT                        		
1548	E8E5	PRTERR                        		  1519,  1536,
1962	EB0D	PRTFLAG                       		  1639,  1798,
1733	E9D3	PRTMESG                       		  1555,  1557,  1742,  1938,
1934	EAF8	PRTSTR                        		  1479,
4188	F612	PUNCH                         		  1474,
3970	F50A	PUTDMA                        		  1497,

0044	003F	QMARK                         		  0454,  0559,  0591,  0627,  0919,  2901,  3901,  3905,

3753	F3E4	RANSIZ1                       		  3778,
3776	F406	RANSIZ2                       		  3770,
3779	F40C	RANSIZ3                       		  3755,
3741	F3D2	RANSIZE                       		  4034,
1754	E9EF	RDBUF1                        		  1770,  1780,  1803,  1881,
1825	EA70	RDBUF10                       		  1774,
1832	EA78	RDBUF11                       		  1844,
1845	EA8A	RDBUF12                       		  1835,
1853	EA99	RDBUF13                       		  1857,
1862	EAA6	RDBUF14                       		  1824,
1866	EAA9	RDBUF15                       		  1784,
1879	EABD	RDBUF16                       		  1876,
1882	EAC1	RDBUF17                       		  1763,  1765,
1757	E9F1	RDBUF2                        		  1793,  1849,  1858,
1775	EA16	RDBUF3                        		  1767,
1785	EA26	RDBUF4                        		  1777,
1794	EA37	RDBUF5                        		  1787,
1804	EA48	RDBUF6                        		  1796,
1808	EA4E	RDBUF7                        		  1815,
1816	EA5F	RDBUF8                        		  1806,
1822	EA6B	RDBUF9                        		  1818,
1746	E9E1	RDBUFF                        		  1480,  1812,  1821,
0786	E3DF	RDERR                         		  0784,
0783	E3D9	RDERROR                       		  1077,
4020	F541	RDRANDOM                      		  1504,
0212	E0F9	RDREC                         		  0220,  0309,  1270,
3355	F1BC	RDSEQ                         		  3934,
3358	F1C1	RDSEQ1                        		  3676,
3374	F1E6	RDSEQ2                        		  3365,
3385	F1FB	RDSEQ3                        		  3367,  3373,  3377,
4145	F5D3	RDWRTFLG                      		  3332,  3360,  3395,
4195	F627	READ                          		  2072,
4189	F615	READER                        		  1897,
0218	E0FE	READFCB                       		  1055,
3673	F393	READRAN                       		  4022,
3932	F4E0	READSEQ                       		  1491,
4149	F5D7	RELBLOCK                      		  3408,  3432,
0238	E10E	RENAM                         		  1191,
1149	E610	RENAME                        		  0771,
1168	E63F	RENAME1                       		  1165,
1183	E659	RENAME2                       		  1179,
1187	E65E	RENAME3                       		
1196	E66D	RENAME4                       		  1189,
1199	E673	RENAME5                       		  1167,  1173,  1182,
1202	E679	RENAME6                       		  1156,
3951	F4F5	RENFILE                       		  1494,
0136	E0B8	RESDSK                        		  0715,
0893	E466	RESETDR                       		  1079,  1200,  1289,  1348,  1364,
1950	EB04	RETURN                        		  1509,  1510,
4113	F5AD	ROBITMAP                      		  2391,  2402,  2407,  3871,  3984,  4055,  4064,
1422	E80D	RODISK                        		  2435,
1423	E80F	ROFILE                        		  2427,
3869	F483	RSTDSK                        		  1484,
1390	E7EE	RTNCODE                       		  0152,  0930,

2843	EF07	SAMEXT                        		  2916,
3105	F040	SAVATR1                       		  3112,
1088	E5AD	SAVE                          		  0770,
1107	E5D4	SAVE1                         		  1122,
1126	E5F1	SAVE2                         		  1110,
1134	E5FB	SAVE3                         		  1099,  1121,
1137	E601	SAVE4                         		  1130,
3102	F03B	SAVEATTR                      		  3991,
4151	F5D9	SAVEFCB                       		  2869,  2882,  3916,
4157	F5E2	SAVEXT                        		  2198,  2306,
4158	F5E3	SAVNREC                       		  2188,  2267,  2299,  2321,  3362,  3370,  3400,  3506,  3542,
4156	F5E1	SAVNXT                        		  2302,  2325,  3363,  3507,
4119	F5B3	SCRATCH1                      		  2023,  2411,  2487,  2803,
4120	F5B5	SCRATCH2                      		  2026,  2059,  2107,  2159,
4121	F5B7	SCRATCH3                      		  2029,  2063,  2103,  2164,
0660	E32E	SEARCH                        		  0750,
0663	E333	SEARCH1                       		  0688,
0669	E33C	SEARCH2                       		  0676,
0682	E34F	SEARCH3                       		  0672,  0685,
0686	E354	SEARCH4                       		  0679,
4132	F5C1	SECTORS                       		  2039,  2119,  2131,
4198	F630	SECTRN                        		  2177,
4191	F61B	SELDSK                        		  2011,
2008	EB59	SELECTDISK                    		  3810,
2049	EB9D	SELECTDISK1                   		  2047,
0049	003B	SEMIC                         		  0478,
2570	EDDA	SET2USERSDMA                  		  2560,  3495,  3877,  3973,
3989	F51D	SETATTR                       		  1501,
2372	ED0B	SETBIT                        		  2406,  3819,
0256	E11A	SETCDRV                       		  0348,  1335,
2520	ED9C	SETDIR                        		  2556,
2576	EDE0	SETDIRDMA                     		  2557,  2565,  3476,
4194	F624	SETDMA                        		  2586,
2582	EDE3	SETDMA0                       		  2572,
3825	F445	SETDSK                        		  1485,  3853,  4081,
2276	ECA6	SETEXT                        		  2303,  3122,  3903,
2723	EE6B	SETFILE                       		  2828,  2962,
2729	EE75	SETFL1                        		  2763,
2742	EE88	SETFL2                        		  2736,
2749	EE8E	SETFL3                        		  2741,
2759	EE9D	SETFL4                        		  2752,
2285	ECAE	SETHLDE                       		  2297,  2314,
1926	EAF3	SETIOB                        		  1478,
2313	ECD2	SETNREC                       		  3381,  3535,  3546,
3786	F40E	SETRAN                        		  1507,
2473	ED78	SETS2B7                       		  3132,  3291,  3351,  3669,
4193	F621	SETSEC                        		  2180,
1948	EB01	SETSTAT                       		  1892,  1898,  1916,  1922,  1957,  2836,  2946,  3344,  3423,  3653,  3865,  3966,  4012,
4192	F61E	SETTRK                        		  2157,
4013	F53B	SETUSER                       		  4010,
2361	ED04	SHIFTL                        		  2377,
2363	ED05	SHIFTL1                       		  2367,
2331	ECEA	SHIFTR                        		  2091,  2394,  2773,  3807,
2333	ECEB	SHIFTR1                       		  2343,
1669	E97F	SHOWIT                        		  1841,  1870,
1981	EB47	SLCTERR                       		  3812,
0113	E0A2	SPACE                         		  0957,  0961,  0988,
0191	E0E9	SRCHFCB                       		  0926,  1155,  1188,
0179	E0DF	SRCHFST                       		  0193,
0185	E0E4	SRCHNXT                       		  0995,
1960	EB0B	STARTING                      		  1716,  1748,  1792,  1809,
1977	EB45	STATUS                        		  1440,  1949,  2825,  2932,  3182,  3257,  3371,  3448,  3537,  3624,  3634,  3644,  3668,  4000,  4085,
2701	EE5C	STBITMAP                      		  2758,
2713	EE64	STBMAP1                       		  2716,  3036,
0396	E1D5	STDDMA                        		  1138,  1334,
2610	EDFE	STFILPOS                      		  2631,  2807,  2870,  2944,
2319	ECDE	STNREC1                       		  2317,
2296	ECBB	STRDATA                       		  3342,  3361,  3399,
2834	EF01	STSTATUS                      		  3927,  3954,  3992,
2509	ED95	SUBHL                         		  2532,  2629,
0439	E209	SYNERR                        		  0468,  0746,  0807,  0817,  0821,  0827,  0829,  0832,  0840,  1041,  1080,  1092,  1151,  1201,  1218,  1222,  1252,  1349,  1371,
0442	E20F	SYNERR1                       		  0452,
0453	E222	SYNERR2                       		  0445,  0447,

0029	0009	TAB                           		  1591,  1685,
0022	0100	TBASE                         		  1106,  1264,  1336,
0018	0004	TDRIVE                        		  0264,  0271,
0020	005C	TFCB                          		  1302,
2088	EBC3	TRKSEC                        		  2644,  3071,
2098	EBD1	TRKSEC1                       		  3379,  3482,  3501,
2112	EBE4	TRKSEC2                       		  2128,
2129	EBFA	TRKSEC3                       		  2117,  2142,
2147	EC0F	TRKSEC4                       		  2133,  2138,
1039	E55D	TYPE                          		  0770,
1048	E574	TYPE1                         		  1070,
1050	E577	TYPE2                         		
1060	E587	TYPE3                         		  1053,
1074	E5A0	TYPE4                         		  1057,
1078	E5A7	TYPE5                         		  1044,

1232	E6A5	UNKNOWN                       		  0749,  0771,
1350	E771	UNKWN0                        		  1280,  1288,
1248	E6C4	UNKWN1                        		  1236,
1253	E6CD	UNKWN2                        		
1265	E6E1	UNKWN3                        		  1281,
1285	E701	UNKWN4                        		  1271,
1307	E730	UNKWN5                        		  1314,
1318	E73E	UNKWN6                        		  1310,  1312,
1321	E743	UNKWN7                        		  1329,
1330	E74F	UNKWN8                        		  1325,
1347	E76B	UNKWN9                        		  1260,
3061	F001	UPDATE                        		  3093,  3110,
3070	F010	UPDATE1                       		  3255,
0277	E130	UPPER                         		  0365,
0046	005F	USCORE                        		  0472,  1166,
1215	E68E	USER                          		  0771,
1974	EB41	USERNO                        		  2817,  3855,  4011,  4015,
4115	F5B1	USERSDMA                      		  2571,  2593,  3876,  3972,
1967	EB0F	USERSTACK                     		  1442,  4083,

0423	E1F5	VERIFY                        		  1233,
0427	E1FD	VERIFY1                       		  0434,

4183	F603	WBOOT                         		  1470,
4196	F62A	WRITE                         		  2078,
3681	F39C	WRITERAN                      		  4028,
2401	ED2C	WRTPRTD                       		  1499,  2547,
0225	E104	WRTREC                        		  1118,
3938	F4E6	WRTSEQ                        		  1492,
4026	F547	WTRANDOM                      		  1505,
3390	F1FE	WTSEQ                         		  3940,
3393	F203	WTSEQ1                        		  3684,  4103,
3517	F2D2	WTSEQ10                       		  3509,
3543	F2FE	WTSEQ11                       		  3540,
3545	F300	WTSEQ12                       		  3531,  3534,
3417	F23B	WTSEQ2                        		  3411,
3424	F248	WTSEQ3                        		  3421,
3437	F264	WTSEQ4                        		  3433,
3445	F26C	WTSEQ5                        		  3436,
3447	F26E	WTSEQ6                        		  3406,
3471	F28C	WTSEQ7                        		  3475,
3479	F29A	WTSEQ8                        		  3492,
3500	F2BB	WTSEQ9                        		  3456,  3467,
3529	F2DF	WTSEQ99                       		
4097	F59B	WTSPECL                       		  1511,

4141	F5D0	XLATE                         		  2033,  2175,

1030	E552	YESNO                         		  1011,
