0001: 0000 		 ;	Pages 165/493 &  204/493  Programmers CPM Handbook by Andy Johnston-Laird
0002: 0000 		 					
0003: 0000 		 
0004: 0000 		 INopCode	EQU		0DBH
0005: 0000 		 OUTopCode	EQU		0D3H
0006: 0000 		 ; programmers CPM Handbook by Andy Johnson
0007: 0000 		 
0008: 0000 		 VERSION		EQU		03130H		;Equates for the sign-on Screen
0009: 0000 		 MONTH		EQU		03830H		; '08'
0010: 0000 		 DAY			EQU		03930H		; '09'
0011: 0000 		 Year		EQU		03531H		; '15'
0012: 0000 		 
0013: 0000 		 MemorySize	EQU 64
0014: 0000 		 
0015: 0000 		 BIOSLength	EQU 0900H
0016: 0000 		 
0017: 0000 		 CCPLength	EQU 0800H	; Constant
0018: 0000 		 BDOSLength	EQU 0E00H	; Constant
0019: 0000 		 
0020: 0000 		 LengthInK	EQU ((CCPLength + BDOSLength + BIOSLength) /1024) + 1
0021: 0000 		 LengthInBytes	EQU (CCPLength + BDOSLength + BIOSLength)
0022: 0000 		 
0023: 0000 		 CCPEntry	EQU	((MemorySize - LengthInK) * (0 + 1024))
0024: 0000 		 BDOSEntry	EQU	CCPEntry + CCPLength + 6
0025: 0000 		 BIOSEntry	EQU	CCPENtry + CCPLength + BDOSLength
0026: 0000 		 
0027: 0000 		 PageZero:	ORG 0000H		; Start of page Zero
0028: 0000 	C303F6	 	JMP		WarmBootEntry	; warm start
0029: 0003 		 IOBYTE:
0030: 0003 	01	 	DB		01H				; IOBYTE- Console is assigned the CRT device
0031: 0004 	00	 	DB		00H				; Current default drive (A)
0032: 0005 	C306E8	 	JMP		BDOSEntry		; jump to BDOS entry
0033: 0008 		 	DS		028H			; interrupt locations 1-5 not used
0034: 0030 		 	DS		008H			; interrupt location 6 is reserved
0035: 0038 	C30000	 	JMP		0000H			; rst 7 used only by DDT & SID programs
0036: 003B 		 	DS		005H			; not currently used
0037: 0040 		 	DS		010H			; reserved for scratch by CBIOS- not used by CP/M
0038: 0050 		 	DS		00CH			; not currently used
0039: 005C 		 FCB:
0040: 005C 		 	DS		021H			; Default FCB for transient programs
0041: 007D 		 RandomRecordPosition:
0042: 007D 		 	DS		003H			; optional random record position
0043: 0080 		 DefaultDiskBuffer:
0044: 0080 		 	DS		080H			; default 128- byte disk buffer,
0045: 0100 		 							; also filled with the command line from CCP
0046: 0100 		 	
0047: 0100 		 
0048: 0100 		 
0049: 0100 		 	ORG		BIOSEntry		; Assemble code at BIOS address
0050: F600 		 		
0051: F600 		 		; BIOS jum Vector
0052: F600 		 		
0053: F600 	C3F9F6	 	JMP	BOOT			; NOT YET CODED
0054: F603 		 WarmBootEntry:
0055: F603 	C329FE	 	JMP	WBOOT			; NOT YET CODED
0056: F606 	C362F8	 	JMP	CONST			; CODED
0057: F609 	C378F8	 	JMP	CONIN			; CODED
0058: F60C 	C386F8	 	JMP	CONOUT			; CODED		     495   F95B: OutputStatusPort:
0059: F60F 	C3ACF8	 	JMP	LIST			; CODED
0060: F612 	C3BCF8	 	JMP	PUNCH			; CODED
0061: F615 	C3CDF8	 	JMP	READER			; CODED
0062: F618 	C3D3FB	 	JMP	HOME			; CODED			302		FBD3
0063: F61B 	C32BFB	 	JMP	SELDSK			; CODED			168		FB2B
0064: F61E 	C358FB	 	JMP	SETTRK			; CODED			211		FB58
0065: F621 	C35EFB	 	JMP	SETSEC			; CODED			221		FB5E
0066: F624 	C365FB	 	JMP	SETDMA			; CODED			230		FB65
0067: F627 	C3FBFB	 	JMP	READ			; CODED			398		FBFB
0068: F62A 	C315FC	 	JMP	WRITE			; CODED			426		FC15
0069: F62D 	C394F8	 	JMP	LISTST			; CODED
0070: F630 	C3CDFB	 	JMP	SECTRAN			; CODED
0071: F633 		 	
0072: F633 		 PhysicalSectorSize	EQU	512			; for the 5.25" disk the 8" size is 128, 
0073: F633 		 DiskBuffer:
0074: F633 		 	DS	PhysicalSectorSize	
0075: F833 		 AfterDiskBuffer		EQU	$
0076: F833 		 
0077: F833 		 		ORG		DiskBuffer		; wind the location counter back
0078: F633 		 
0079: F633 		 InitializeStream:		; used by the initialization subroutine. Layout:
0080: F633 		 						;	DB	Port number to be initialized
0081: F633 		 						;	DB	Number of bytes to be output
0082: F633 		 						;	DB	xx.xx.xx.xx.xx.xx data to be output
0083: F633 		 						;	:
0084: F633 		 						;	:
0085: F633 		 						;	DB	Port numbe of 00H terminator
0086: F633 		 						;	Console does not need to be initalized. it was done in the PROM
0087: F633 		 
0088: F633 	ED	 		DB	CommunicationStatusPort	; intel 8251 ?
0089: F634 	06	 		DB	06H		; number of bytes
0090: F635 	00	 		DB	0		; get chip ready by sending data out to it
0091: F636 	00	 		DB	0
0092: F637 	00	 		DB	0
0093: F638 	42	 		DB	042H;	; Reset and raise data terminal ready
0094: F639 	6E	 		DB	06Eh	; 1 stop bit, no parity, 8bits/char baud rate / 16
0095: F63A 	25	 		DB	025H	;Raise request to send, and enable transmit and receive
0096: F63B 		 		
0097: F63B 	DF	 		DB	CommunicationBaudMode;	Intel 8253 time
0098: F63C 	01	 		DB	01H		; number of bytes
0099: F63D 	B6	 		DB	0B6H	; select counter2, load LS Byte
0100: F63E 		 		
0101: F63E 	DE	 		DB	CommunicationBaudRate
0102: F63F 	02	 		DB	02H		; number of bytes
0103: F640 	3800	 		DW	0038H	; 1200 baud rate
0104: F642 		 		
0105: F642 	00	 		DB	0		; port number of 0 terminates
0106: F643 		 		
0107: F643 		 ;  Equates for the sign in message
0108: F643 		 
0109: F643 		 CR		EQU	0DH		; Carriage Return
0110: F643 		 LF		EQU	0AH		; Line Feed
0111: F643 		 
0112: F643 		 SignOnMessage:		; Main sign on message
0113: F643 	43502F4D20	 		DB	43H,50H,2FH,4DH,20H		; CP/M 2.2.
0114: F648 	322E322E	 		DB	32H,2EH,32H,2EH			;(2.2.)
0115: F64C 	3031	 		DW	VERSION
0116: F64E 		 ;		DB	30H,30H		; VERSION
0117: F64E 	20	 		DB	20H
0118: F64F 	3038	 		DW	MONTH
0119: F651 		 ;		DB	30H,37H		; MONTH
0120: F651 	2F	 		DB	2FH			; /
0121: F652 	3039	 		DW	DAY
0122: F654 		 ;		DB	31H,35H		; DAY
0123: F654 	2F	 		DB	2FH			; /
0124: F655 	3135	 		DW	YEAR
0125: F657 		 ;		DB	38H,32H		; YEAR
0126: F657 	0D0A0A	 		DB	CR,LF,LF
0127: F65A 		 		
0128: F65A 	53696D706C	 		DB	53H,69H,6DH,70H,6CH		;Simple BIOS
0129: F65F 	652042494F53	 		DB	65H,20H,42H,49H,4fH,53H
0130: F665 	0D0A0A	 		DB	CR,LF,LF
0131: F668 		 		
0132: F668 	4469736B20	 		DB	44H,69H,73H,6BH,20H		; Disk configuration :
0133: F66D 	636F6E6669	 		DB 	63H,6FH,6EH,66H,69H
0134: F672 	6775726174	 		DB	67H,75H,72H,61H,74H
0135: F677 	696F6E203A	 		DB	69H,6FH,6EH,20H,3Ah
0136: F67C 	0D0A0A	 		DB	CR,LF,LF
0137: F67F 		 		
0138: F67F 	2020202020	 		DB	20H,20H,20H,20H,20H		; A: 0.35 Mbyte 5" Floppy' 
0139: F684 	413A20302E3335	 		DB	41H,3AH,20H,30H,2EH,33H,35H
0140: F68B 	204D62797465	 		DB	20H,4DH,62H,79H,74H,65H
0141: F691 	20352220	 		DB	20H,35H,22H,20H
0142: F695 	466C6F707079	 		DB	46H,6CH,6FH,70H,70H,79H
0143: F69B 	0D0A	 		DB	CR,LF
0144: F69D 		 		
0145: F69D 	2020202020	 		DB	20H,20H,20H,20H,20H		; B: 0.35 Mbyte 5" Floppy'
0146: F6A2 	423A20302E3335	 		DB	42H,3AH,20H,30H,2EH,33H,35H
0147: F6A9 	204D62797465	 		DB	20H,4DH,62H,79H,74H,65H
0148: F6AF 	20352220	 		DB	20H,35H,22H,20H
0149: F6B3 	466C6F707079	 		DB	46H,6CH,6FH,70H,70H,79H
0150: F6B9 	0D0A0A	 		DB	CR,LF,LF
0151: F6BC 		 		
0152: F6BC 	2020202020	 		DB	20H,20H,20H,20H,20H		; C: 0.24 Mbyte 8" Floppy
0153: F6C1 	433A20302E3234	 		DB	43H,3AH,20H,30H,2EH,32H,34H
0154: F6C8 	204D62797465	 		DB	20H,4DH,62H,79H,74H,65H
0155: F6CE 	20352220	 		DB	20H,35H,22H,20H
0156: F6D2 	466C6F707079	 		DB	46H,6CH,6FH,70H,70H,79H
0157: F6D8 	0D0A	 		DB	CR,LF
0158: F6DA 		 		
0159: F6DA 	2020202020	 		DB	20H,20H,20H,20H,20H		; D: 0.24 Mbyte 8" Floppy
0160: F6DF 	443A20302E3234	 		DB	44H,3AH,20H,30H,2EH,32H,34H
0161: F6E6 	204D62797465	 		DB	20H,4DH,62H,79H,74H,65H
0162: F6EC 	20352220	 		DB	20H,35H,22H,20H
0163: F6F0 	466C6F707079	 		DB	46H,6CH,6FH,70H,70H,79H
0164: F6F6 	0D0A	 		DB	CR,LF
0165: F6F8 		 		
0166: F6F8 		 ;		DB	20H,20H,20H,20H,20H
0167: F6F8 		 ;		DB	20H,20H,20H,20H,20H
0168: F6F8 		 ;		DB	20H,20H,20H,20H,20H
0169: F6F8 		 ;		DB	20H,20H,20H,20H,20H
0170: F6F8 		 		
0171: F6F8 		 ;		DS	84H		; 132  sign on message goes here
0172: F6F8 		 		
0173: F6F8 	00	 		DB	00
0174: F6F9 		 		
0175: F6F9 		 	DefaultDisk	EQU	0004H
0176: F6F9 		 	
0177: F6F9 		 ;219--------------------BOOT-----------------------------	
0178: F6F9 		 	
0179: F6F9 		 	BOOT:		; entered directly from the BIOS JMP vector
0180: F6F9 		 				; Control transfered by the CP/M bootstrap loader
0181: F6F9 		 				; initial state will be determined by the PROM
0182: F6F9 		 				
0183: F6F9 		 				; setting up 8251 & 8253 --
0184: F6F9 	F3	 	DI
0185: F6FA 	2133F6	 	LXI	H,InitializeStream		;HL-> Data stream
0186: F6FD 		 ;
0187: F6FD 		 InitializeLoop:
0188: F6FD 	7E	 	MOV	A,M		; get port #
0189: F6FE 	B7	 	ORA A		; if 00H then done
0190: F6FF 	CA13F7	 	JZ	InitializeComplete
0191: F702 		 	
0192: F702 	320AF7	 	STA	InitializePort	; set up OUT instruction
0193: F705 	23	 	INX	H		; HL -> count # of bytes to output
0194: F706 	4E	 	MOV	C,M		; get byte count
0195: F707 		 	
0196: F707 		 InitializeNextByte:
0197: F707 	23	 	INX	H	
0198: F708 	7E	 	MOV	A,M		; get next byte
0199: F709 	D3	 	DB OUTopCode		; OUT instruction output to correct port
0200: F70A 		 	
0201: F70A 		 InitializePort:
0202: F70A 	00	 	DB	0		; set by above code (self modifying code!!!!!)
0203: F70B 	0D	 	DCR	C		; Count down
0204: F70C 	C207F7	 	JNZ	InitializeNextByte
0205: F70F 	23	 	INX	H		; HL-> next port number
0206: F710 	C3FDF6	 	JMP InitializeLoop	; go back for more
0207: F713 		 	
0208: F713 		 InitializeComplete:
0209: F713 	3E01	 	MVI	A,01H	; set up for terminal to be console
0210: F715 	320300	 	STA	IOBYTE
0211: F718 		 	
0212: F718 	2143F6	 	LXI	H,SignonMessage
0213: F71B 	CD33F8	 	CALL	DisplayMessage
0214: F71E 		 	
0215: F71E 	AF	 	XRA	A		; Set default disk to A:
0216: F71F 	320400	 	STA	DefaultDisk
0217: F722 	FB	 	EI			; enable the interrupts
0218: F723 		 	
0219: F723 	C340F8	 	JMP	EnterCPM	; Complete initialization and enter CP/M
0220: F726 		 					; by going to the Console Command Processor
0221: F726 		 ;
0222: F726 		 ;271---------------End of Cold Boot Initialization Code--------------
0223: F726 		 
0224: F726 		 		ORG AfterDiskBuffer		; reset Location Counter
0225: F833 		 DisplayMessage:
0226: F833 	7E	 	MOV		A,M		; get next message byte
0227: F834 	B7	 	ORA		A		; check if terminator
0228: F835 	C8	 	RZ			; Yes, thes return to caller
0229: F836 		 	
0230: F836 	4F	 	MOV		C,A		; prepare for output
0231: F837 	E5	 	PUSH	HL		; save message pointer
0232: F838 	CD86F8	 	CALL	CONOUT	; go to main console output routine	*********************************************
0233: F83B 	E1	 	POP		H
0234: F83C 	23	 	INX		H 		; point at next character
0235: F83D 	C333F8	 	JMP		DisplayMessage	; loop till done
0236: F840 		 	
0237: F840 		 EnterCPM:
0238: F840 	3EC3	 	MVI		A,0C3H		; JMP op code
0239: F842 	320000	 	STA		0000H		; set up the jump in location 0000H
0240: F845 	320500	 	STA		0005H		; and at location 0005H
0241: F848 		 	
0242: F848 	2103F6	 	LXI		H,WarmBootEntry	; get BIOS vector address
0243: F84B 	220100	 	SHLD	0001H		; put address in location 1
0244: F84E 		 	
0245: F84E 	2106E8	 	LXI		H,BDOSEntry	; Get BDOS entry point address
0246: F851 	220600	 	SHLD	0006H		; put address at location 5
0247: F854 		 	
0248: F854 	018000	 	LXI		B,80H		; set disk I/O address to default
0249: F857 	CD65FB	 	CALL	SETDMA		; use normal BIOS routine		****************************************************************
0250: F85A 		 	
0251: F85A 	FB	 	EI
0252: F85B 	3A0400	 	LDA		DefaultDisk		; Transfer current default disk to
0253: F85E 	4F	 	MOV		C,A			; Console Command Processor
0254: F85F 	C300E0	 	JMP		CCPEntry	; transfer to CCP
0255: F862 		 		
0256: F862 		 		
0257: F862 		 		
0258: F862 		 ;IOBYTE	EQU		0003H		;I/O redirection byte
0259: F862 		 
0260: F862 		 ;333--------------------CONST----------------------------
0261: F862 		 	; Entered directly from BIOS JMP vector
0262: F862 		 	; returns Register A
0263: F862 		 	; 00H -> No data
0264: F862 		 	; 0FFH -> there is data
0265: F862 		 CONST:
0266: F862 	CD6AF8	 	CALL	GetConsoleStatus	; return A= zero or not zero
0267: F865 	B7	 	ORA		A
0268: F866 	C8	 	RZ					; if 0 no returning data
0269: F867 	3EFF	 	MVI		A,0FFH		; else indicate there is data
0270: F869 	C9	 	RET
0271: F86A 		 	
0272: F86A 		 GetConsoleStatus:
0273: F86A 	3A0300	 	LDA		IOBYTE		; Get IO redirection byte
0274: F86D 	CDDCF8	 	CALL	SelectRoutine	; these routines return to the caller of GetConsoleStatus
0275: F870 	F6F8	 	DW		TTYInStatus				; 00  <- IOBYTE bits 1,0
0276: F872 	FCF8	 	DW		TerminalInStatus		; 01
0277: F874 	02F9	 	DW		CommunicationInStatus	; 10
0278: F876 	08F9	 	DW		DummyInStatus			; 11
0279: F878 		 	
0280: F878 		 CONIN:
0281: F878 		 						; get console Input character
0282: F878 		 						; entered directly from the BIOS jmp Vector
0283: F878 		 						; return the character from the console in the A register.
0284: F878 		 						; most significant bit will be 0. except when "reader" (communication)
0285: F878 		 						; port has input , all 8 bits are reurned
0286: F878 		 						;
0287: F878 		 						; normally this follows a call to CONST. it indicates a char is ready.
0288: F878 		 						; this is a blocking call
0289: F878 	3A0300	 	LDA		IOBYTE			; get i/o redirection byte
0290: F87B 	CDDCF8	 	CALL 	SelectRoutine
0291: F87E 	20F9	 	DW		TTYInput			; 00 <- IOBYTE bits 1,0
0292: F880 	26F9	 	DW		TerminalInput		; 01
0293: F882 	2FF9	 	DW		CommunicationInput	; 10
0294: F884 	35F9	 	DW		DummyInput			; 11
0295: F886 		 	
0296: F886 		 CONOUT:
0297: F886 		 						; Console output
0298: F886 		 						; entered directly from BIOS JMP Vector
0299: F886 		 						; outputs the data character in the C register
0300: F886 		 						; to the appropriate device according to bits 1,0 of IOBYTE
0301: F886 	3A0300	 	LDA		IOBYTE			; get i/o redirection byte
0302: F889 	CDDCF8	 	CALL 	SelectRoutine
0303: F88C 	38F9	 	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0304: F88E 	3EF9	 	DW		TerminalOutput		; 01
0305: F890 	44F9	 	DW		CommunicationOutput	; 10
0306: F892 	4AF9	 	DW		DummyOutput			; 11
0307: F894 		 	
0308: F894 		 LISTST:					; List Device (output) status
0309: F894 		 						; entered directly from the BIOS JMP Vector
0310: F894 		 						; returns in A the list device status that indicates
0311: F894 		 						; if the device will accept another character
0312: F894 		 						; the IOBYTE's bits 7,6 determin the physical device
0313: F894 		 						;
0314: F894 		 						; A = 00H (zero flag set): cannot accpet data
0315: F894 		 						; A = 0FFH ( zero flag cleared): can accept data
0316: F894 	CD9CF8	 	CALL	GetListStatus	; return  A = 0 or non-zero
0317: F897 		 	
0318: F897 	B7	 	ORA		A				; set flags
0319: F898 	C8	 	RZ						; exit if not ready
0320: F899 	3EFF	 	MVI		a,0FFH			; else set retuen value for ok
0321: F89B 	C9	 	RET	
0322: F89C 		 	; exit
0323: F89C 		 GetListStatus:
0324: F89C 	3A0300	 	LDA		IOBYTE
0325: F89F 	07	 	RLC						; move bits 7,6
0326: F8A0 	07	 	RLC						; to 1,0
0327: F8A1 	CDDCF8	 	CALL	SelectRoutine
0328: F8A4 	0BF9	 	DW		TTYOutStatus			; 00 <- IOBYTE bits 1,0
0329: F8A6 	11F9	 	DW		TerminalOutStatus		; 01
0330: F8A8 	17F9	 	DW		CommunicationOutStatus	; 10
0331: F8AA 	1DF9	 	DW		DummyOutStatus			; 11
0332: F8AC 		 	
0333: F8AC 		 LIST:					; List output
0334: F8AC 		 						; entered directly from the BIOS JMP Vector
0335: F8AC 		 						; outputs the data in Register C
0336: F8AC 	3A0300	 	LDA		IOBYTE
0337: F8AF 	07	 	RLC						; move bits 7,6
0338: F8B0 	07	 	RLC						; to 1,0
0339: F8B1 	CDDCF8	 	CALL	SelectRoutine
0340: F8B4 	38F9	 	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0341: F8B6 	3EF9	 	DW		TerminalOutput		; 01
0342: F8B8 	44F9	 	DW		CommunicationOutput	; 10
0343: F8BA 	4AF9	 	DW		DummyOutput			; 11
0344: F8BC 		 	
0345: F8BC 		 PUNCH:					; Punch output
0346: F8BC 		 						; entered directly from the BIOS JMP Vector
0347: F8BC 		 						; outputs the data in Register C
0348: F8BC 	3A0300	 	LDA		IOBYTE
0349: F8BF 	07	 	RLC						; move bits 5,4
0350: F8C0 	07	 	RLC
0351: F8C1 	07	 	RLC						; to 1,0
0352: F8C2 	CDDCF8	 	CALL	SelectRoutine
0353: F8C5 	38F9	 	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0354: F8C7 	4AF9	 	DW		DummyOutput			; 01
0355: F8C9 	44F9	 	DW		CommunicationOutput	; 10
0356: F8CB 	3EF9	 	DW		TerminalOutput		; 11
0357: F8CD 		 	
0358: F8CD 		 READER:					; Reader Input
0359: F8CD 		 						; entered directly from the BIOS JMP Vector
0360: F8CD 		 						; inputs data into the A register
0361: F8CD 	3A0300	 	LDA		IOBYTE
0362: F8D0 	07	 	RLC						; move bits 3,2  to 1,0
0363: F8D1 	CDDCF8	 	CALL	SelectRoutine
0364: F8D4 	38F9	 	DW		TTYOutput			; 00 <- IOBYTE bits 1,0
0365: F8D6 	4AF9	 	DW		DummyOutput			; 01
0366: F8D8 	44F9	 	DW		CommunicationOutput	; 10
0367: F8DA 	3EF9	 	DW		TerminalOutput		; 11
0368: F8DC 		 	
0369: F8DC 		 	
0370: F8DC 		 		; SelectRoutine
0371: F8DC 		 		; Transfer control to a specified address following its calling address
0372: F8DC 		 		; according to the values in bits 1, 0 in A.
0373: F8DC 		 		
0374: F8DC 		 SelectRoutine:
0375: F8DC 	07	 	RLC				; Shift select values into bits 2,1 in order to do word arithmetic
0376: F8DD 		 SelectRoutine21:	; entry point if bits already in 2,1
0377: F8DD 	E606	 	ANI		06H		; isolate bits 2 and 1
0378: F8DF 	E3	 	XTHL			; HL-> first word of address after CALL instruction
0379: F8E0 	5F	 	MOV		E,A		; Add on selection value to address table base
0380: F8E1 	1600	 	MVI		D,00H
0381: F8E3 	19	 	DAD		D		; HL-> now has the selected routine
0382: F8E4 	7E	 	MOV		A,M		; LS Byte
0383: F8E5 	23	 	INX		H		; HL-> MS byte
0384: F8E6 	66	 	MOV		H,M		; MS byte
0385: F8E7 	6F	 	MOV		L,A		; HL->routine
0386: F8E8 	E3	 	XTHL			; top of stack -> routine
0387: F8E9 	C9	 	RET				; transfer to selected routine
0388: F8EA 		 
0389: F8EA 		 	
0390: F8EA 		 ;------------------------- Input/Output Equates---------------------------------------
0391: F8EA 		 
0392: F8EA 		 TTYStatusPort				EQU	0EDH
0393: F8EA 		 TTYDataPort					EQU	0ECH
0394: F8EA 		 TTYOutputReady				EQU	01H		; Status Mask
0395: F8EA 		 TTYInputReady				EQU	02H		; Status Mask
0396: F8EA 		 
0397: F8EA 		 TerminalStatusPort			EQU	02H
0398: F8EA 		 TerminalDataPort			EQU	01H
0399: F8EA 		 TerminalOutputReady			EQU	80H		; Status Mask - ready for output
0400: F8EA 		 TerminalInputReady			EQU	07FH	; Status Mask - bytes yet to have been read
0401: F8EA 		 
0402: F8EA 		 CommunicationStatusPort		EQU	0EDH
0403: F8EA 		 CommunicationDataPort		EQU	0ECH
0404: F8EA 		 CommunicationOutputReady	EQU	01H		; Status Mask
0405: F8EA 		 CommunicationInputReady		EQU	02H		; Status Mask
0406: F8EA 		 
0407: F8EA 		 CommunicationBaudMode		EQU	0DFH
0408: F8EA 		 CommunicationBaudRate		EQU	0DEH
0409: F8EA 		 
0410: F8EA 		 TTYTable:
0411: F8EA 	ED	 		DB		TTYStatusPort
0412: F8EB 	EC	 		DB		TTYDataPort
0413: F8EC 	01	 		DB		TTYOutputReady
0414: F8ED 	02	 		DB		TTYInputReady
0415: F8EE 		 TerminalTable:
0416: F8EE 	02	 		DB		TerminalStatusPort
0417: F8EF 	01	 		DB		TerminalDataPort
0418: F8F0 	80	 		DB		TerminalOutputReady
0419: F8F1 	7F	 		DB		TerminalInputReady
0420: F8F2 		 CommunicationTable:
0421: F8F2 	ED	 		DB		CommunicationStatusPort
0422: F8F3 	EC	 		DB		CommunicationDataPort
0423: F8F4 	01	 		DB		CommunicationOutputReady
0424: F8F5 	02	 		DB		CommunicationInputReady
0425: F8F6 		 ;------------------------- Input/Output Equates---------------------------------------
0426: F8F6 		 
0427: F8F6 		 
0428: F8F6 		 ;590----------------------routines called by SelectRoutine----------------------------
0429: F8F6 		 TTYInStatus:
0430: F8F6 	21EAF8	 		LXI		H,TTYTable		;HL-> control table
0431: F8F9 	C34BF9	 		JMP		InputStatus		; use of JMP, InputStatus will execute thr RETurn
0432: F8FC 		 TerminalInStatus:
0433: F8FC 	21EEF8	 		LXI		H,TerminalTable	;HL-> control table
0434: F8FF 	C34BF9	 		JMP		InputStatus		; use of JMP, InputStatus will execute thr RETurn
0435: F902 		 CommunicationInStatus:
0436: F902 	21F2F8	 		LXI		H,CommunicationTable	;HL-> control table
0437: F905 	C34BF9	 		JMP		InputStatus		; use of JMP, InputStatus will execute thr RETurn
0438: F908 		 DummyInStatus:
0439: F908 	3EFF	 		MVI		A,0FFH			; Dummy always indicates data ready
0440: F90A 	C9	 		RET
0441: F90B 		 		
0442: F90B 		 TTYOutStatus:
0443: F90B 	21EAF8	 		LXI		H,TTYTable		;HL-> control table
0444: F90E 	C356F9	 		JMP		OutputStatus		; use of JMP, OutputStatus will execute thr RETurn
0445: F911 		 TerminalOutStatus:
0446: F911 	21EEF8	 		LXI		H,TerminalTable	;HL-> control table
0447: F914 	C356F9	 		JMP		OutputStatus		; use of JMP, OutputStatus will execute thr RETurn
0448: F917 		 CommunicationOutStatus:
0449: F917 	21F2F8	 		LXI		H,CommunicationTable	;HL-> control table
0450: F91A 	C356F9	 		JMP		OutputStatus		; use of JMP, OutputStatus will execute thr RETurn
0451: F91D 		 DummyOutStatus:
0452: F91D 	3EFF	 		MVI		A,0FFH			; Dummy always indicates ready to output data
0453: F91F 	C9	 		RET
0454: F920 		 
0455: F920 		 TTYInput:
0456: F920 	21EAF8	 		LXI		H,TTYTable		;HL-> control table
0457: F923 	C360F9	 		JMP		InputData		; use of JMP, InputStatus will execute thr RETurn
0458: F926 		 TerminalInput:
0459: F926 	21EEF8	 		LXI		H,TerminalTable	;HL-> control table
0460: F929 	CD60F9	 		CALL	InputData		;** special **
0461: F92C 	E67F	 		ANI		07FH			; Strip off high order bit
0462: F92E 	C9	 		RET	
0463: F92F 		 CommunicationInput:
0464: F92F 	21F2F8	 		LXI		H,CommunicationTable	;HL-> control table
0465: F932 	C360F9	 		JMP		InputData		; use of JMP, InputStatus will execute thr RETurn
0466: F935 		 DummyInput:
0467: F935 	3E1A	 		MVI		A,01AH			; Dummy always returns EOF
0468: F937 	C9	 		RET
0469: F938 		 		
0470: F938 		 TTYOutput:
0471: F938 	21EAF8	 		LXI		H,TTYTable		;HL-> control table
0472: F93B 	C370F9	 		JMP		OutputData		; use of JMP, InputStatus will execute thr RETurn
0473: F93E 		 TerminalOutput:
0474: F93E 	21EEF8	 		LXI		H,TerminalTable	;HL-> control table
0475: F941 	C370F9	 		JMP		OutputData		; use of JMP, InputStatus will execute thr RETurn
0476: F944 		 CommunicationOutput:
0477: F944 	21F2F8	 		LXI		H,CommunicationTable	;HL-> control table
0478: F947 	C370F9	 		JMP		OutputData		; use of JMP, InputStatus will execute thr RETurn
0479: F94A 		 DummyOutput:
0480: F94A 	C9	 		RET						; Dummy always discards the data
0481: F94B 		 
0482: F94B 		 ;680---------------------General purpose low-level drivers-------------------
0483: F94B 		 
0484: F94B 		 ; On entry, HL points to appropriate control table, for output Register C contains the data to output
0485: F94B 		 
0486: F94B 		 InputStatus:				; return- A = 00H no incoming data
0487: F94B 	7E	 		MOV		A,M			; get status port
0488: F94C 	3250F9	 		STA		InputStatusPort	;** self modifying code
0489: F94F 	DB	 		DB		INopCode		; IN opcode
0490: F950 		 InputStatusPort:
0491: F950 	00	 		DB		00H			; <- set from above
0492: F951 	23	 		INX		H			; move HL to point to input data mask
0493: F952 	23	 		INX		H
0494: F953 	23	 		INX		H
0495: F954 	A6	 		ANA		M			; mask with input status
0496: F955 	C9	 		RET
0497: F956 		 		
0498: F956 		 OutputStatus:				; return - A = 00H not ready
0499: F956 	7E	 		MOV		A,M
0500: F957 	325BF9	 		STA		OutputStatusPort
0501: F95A 	DB	 		DB		INopCode		; IN opcode
0502: F95B 		 OutputStatusPort:
0503: F95B 	00	 		DB		00H			; <- set from above
0504: F95C 	23	 		INX		H			;HL , Output status mask
0505: F95D 	23	 		INX		H
0506: F95E 	A6	 		ANA		M			; mask with output status
0507: F95F 	C9	 		RET
0508: F960 		 		
0509: F960 		 InputData:					; return with next character
0510: F960 	E5	 		PUSH	H			; save control table pointer
0511: F961 	CD4BF9	 		CALL	InputStatus
0512: F964 	E1	 		POP		H
0513: F965 	CA60F9	 		JZ		InputData	; wait until incoming data
0514: F968 	23	 		INX		H			; HL <- data port
0515: F969 	7E	 		MOV		A,M			; get data port
0516: F96A 	326EF9	 		STA		InputDataPort
0517: F96D 	DB	 		DB		INopCode
0518: F96E 		 InputDataPort:
0519: F96E 	00	 		DB		00H			; <- set from above
0520: F96F 	C9	 		RET
0521: F970 		 		
0522: F970 		 OutputData:					; data in Register C is output
0523: F970 	E5	 		PUSH	H			; save control table pointer
0524: F971 	CD56F9	 		CALL	OutputStatus
0525: F974 	E1	 		POP		H
0526: F975 	CA70F9	 		JZ		OutputData	; wait until incoming data
0527: F978 	23	 		INX		H			; HL <- data port
0528: F979 	7E	 		MOV		A,M			; get data port
0529: F97A 	327FF9	 		STA		OutputDataPort
0530: F97D 	79	 		MOV		A,C			; get the data to output
0531: F97E 	D3	 		DB		OUTopCode
0532: F97F 		 OutputDataPort:
0533: F97F 	00	 		DB		00H			; <- set from above
0534: F980 	C9	 		RET
0535: F981 		 		
0536: F981 		 ;746,795
0537: F981 		 ;  page 175 -----------------High Level Diskette drivers--------------------	
0538: F981 		 
0539: F981 		 
0540: F981 		 
0541: F981 		 					; listing starts on page 175/493 FIgure 6-4
0542: F981 		 					; in Programmers CPM Handbook by
0543: F981 		 					; Andy Johnston-Laird
0544: F981 		 
0545: F981 		 ;	ORG	0F981H	; Continue from bios.asm
0546: F981 		 ; PhysicalSectorSize	EQU	512			; for the 5.25" disk the 8" size is 128,
0547: F981 		 	
0548: F981 		 ; 					High level diskette drivers
0549: F981 		 ;
0550: F981 		 ;
0551: F981 		 ; These drivers perform the following functions:
0552: F981 		 ;
0553: F981 		 ; SELDSK		Select a specific disk and return the address of
0554: F981 		 ;				the appropriate disk parameter header
0555: F981 		 ; SETTRK		Set the track number for the next read or write
0556: F981 		 ; SETSEC		Set the sector number for the next read or write
0557: F981 		 ; SETDMA		Set the DMA (read/write) address for the next read or write
0558: F981 		 ; SECTRAN	Translate a logical sector number into a physical
0559: F981 		 ; HOME		Set the track to 0 so that the next read or write will
0560: F981 		 ;				be on Track 0
0561: F981 		 ;
0562: F981 		 ; In addition, the high-level drivers are responsible for making
0563: F981 		 ; the 5 1/4"" floppy diskettes that use a 512-byte sector appear
0564: F981 		 ; to CP/M as though they use a 128-byte sector. They do this
0565: F981 		 ; by using what is called blocking/de-blocking code,
0566: F981 		 ; described in more detail later in this listing.
0567: F981 		 ;
0568: F981 		 ;
0569: F981 		 ; 					Disk Parameter Tables
0570: F981 		 ;
0571: F981 		 ; As discussed in Chapter 3, these describe the physical
0572: F981 		 ; characteristics of the disk drives. In this example BIOS,
0573: F981 		 ; there are two types of disk drives: standard single-sided,
0574: F981 		 ; single-density 8", and double-sided, double-density 5 1/4"
0575: F981 		 ; diskettes.
0576: F981 		 ;
0577: F981 		 ; The standard 8" diskettes do not need the blocking/de-blocking
0578: F981 		 ; code, but the 5 1/4" drives do. Therefore an additional
0579: F981 		 ; byte has been prefixed to the disk parameter block to
0580: F981 		 ; tell the disk drivers each logical disk's physical
0581: F981 		 ; diskette type, and whether or not it needs de-blocking.
0582: F981 		 ;
0583: F981 		 ;
0584: F981 		 ; 					Disk Definition Tables
0585: F981 		 ;
0586: F981 		 ; These consists of disk parameter headers, with one entry
0587: F981 		 ; per logical disk driver, and disk parameter blocks, with
0588: F981 		 ; either one parameter block per logical disk or the same
0589: F981 		 ; parameter block for several logical disks.
0590: F981 		 ;
0591: F981 		 DiskParameterHeaders:		; described in chapter 3
0592: F981 		 
0593: F981 		 		; Logical Disk A: (5 1/4" Diskette)
0594: F981 	6BFB	 	DW	Floppy5SkewTable	; 5 1/4" skew table
0595: F983 	0000000081F9	 	DW	0,0,0F981H			; reserved for CP/M
0596: F989 	C1F9	 	DW	DirectoryBuffer
0597: F98B 	42FA	 	DW	Floppy5ParameterBlock
0598: F98D 	61FA	 	DW	DiskAWorkArea
0599: F98F 	C1FA	 	DW	DiskAAllocationVector
0600: F991 		 	
0601: F991 		 		; Logical Disk B: (5 1/4" Diskette)
0602: F991 	6BFB	 	DW	Floppy5SkewTable	; shares the same skew table as A:
0603: F993 	0000000081F9	 	DW	0,0,0F981H			; reserved for CP/M
0604: F999 	C1F9	 	DW	DirectoryBuffer		; all disks use this buffer
0605: F99B 	42FA	 	DW	Floppy5ParameterBlock
0606: F99D 	81FA	 	DW	DiskBWorkArea
0607: F99F 	D7FA	 	DW	DiskBAllocationVector
0608: F9A1 		 	
0609: F9A1 		 		; Logical Disk C: (8" Floppy)
0610: F9A1 	B3FB	 	DW	Floppy8SkewTable	; 8" skew table
0611: F9A3 	0000000081F9	 	DW	0,0,0F981H			; reserved for CP/M
0612: F9A9 	C1F9	 	DW	DirectoryBuffer		; all disks use this buffer
0613: F9AB 	52FA	 	DW	Floppy8ParameterBlock
0614: F9AD 	A1FA	 	DW	DiskCWorkArea
0615: F9AF 	EDFA	 	DW	DiskCAllocationVector
0616: F9B1 		 	
0617: F9B1 		 		; Logical Disk D: (8" Floppy)
0618: F9B1 	6BFB	 	DW	Floppy5SkewTable	; shares the same skew table as A:
0619: F9B3 	0000000081F9	 	DW	0,0,0F981H			; reserved for CP/M
0620: F9B9 	C1F9	 	DW	DirectoryBuffer		; all disks use this buffer
0621: F9BB 	52FA	 	DW	Floppy8ParameterBlock
0622: F9BD 	B1FA	 	DW	DiskDWorkArea
0623: F9BF 	0CFB	 	DW	DiskDAllocationVector
0624: F9C1 		 	
0625: F9C1 		 DirectoryBuffer:	DS	128
0626: FA41 		 
0627: FA41 		 	; Disk Types
0628: FA41 		 Floppy5		EQU		1 		; 5 1/4" mini floppy
0629: FA41 		 Floppy8 	EQU		2 		; 8"  floppy (SS SD)
0630: FA41 		 
0631: FA41 		 	; blocking/de-blocking indicator
0632: FA41 		 NeedDeblocking	EQU 	080H	; Sector size > 128 bytes
0633: FA41 		 
0634: FA41 		 
0635: FA41 		 	; Disk Parameter Blocks
0636: FA41 		 	
0637: FA41 		 	; 5 1/4" mini floppy
0638: FA41 		 							; extra byte prefixed to indicate 
0639: FA41 		 							; disk type and blocking required
0640: FA41 	81	 	DB	Floppy5 + NeedDeblocking
0641: FA42 		 	
0642: FA42 		 Floppy5ParameterBlock:
0643: FA42 	4800	 	DW	048H				; 128-byte sectors per track
0644: FA44 	31	 	DB	49					; Block shift
0645: FA45 	0F	 	DB	15 					; Block mask
0646: FA46 	01	 	DB	01 					; Extent mask
0647: FA47 	AE00	 	DW	174 				; Maximum allocation block number
0648: FA49 	7F00	 	DW	127 				; Number of directory entries - 1
0649: FA4B 	C0	 	DB	0C0H				; Bit map for reserving 1 alloc. block
0650: FA4C 	00	 	DB	00					;  for file directory
0651: FA4D 	2000	 	DW	020H				;Disk change work area size
0652: FA4F 	0100	 	DW	01					; Number of tracks before directory
0653: FA51 		 	
0654: FA51 		 	; Standard 8" floppy
0655: FA51 		 							; extra byte prefixed to DPB for 
0656: FA51 		 							;  this version of the BIOS
0657: FA51 	02	 	DB	Floppy8				; Indicates disk type and the fact
0658: FA52 		 							;   that no de-blocking is required
0659: FA52 		 	
0660: FA52 		 Floppy8ParameterBlock:
0661: FA52 	1A00	 	DW	01AH				; sectors per track
0662: FA54 	03	 	DB	03					; Block shift
0663: FA55 	07	 	DB	07					; Block mask
0664: FA56 	00	 	DB	00 					; Extent mask
0665: FA57 	F200	 	DW	242 				; Maximum allocation block number
0666: FA59 	3F00	 	DW	63	 				; Number of directory entries - 1
0667: FA5B 	C0	 	DB	0C0H				; Bit map for reserving 2 alloc. block
0668: FA5C 	00	 	DB	00					;  for file directory
0669: FA5D 	1000	 	DW	010H				;Disk change work area size
0670: FA5F 	0200	 	DW	02					; Number of tracks before directory
0671: FA61 		 	
0672: FA61 		 			; Disk work area
0673: FA61 		 	
0674: FA61 		 	; These are used by the BDOS to detect any unexpected
0675: FA61 		 	; change of diskette. The BDOS will automatically set
0676: FA61 		 	; such a changed diskette to read-only status.
0677: FA61 		 	
0678: FA61 		 DiskAWorkArea:	DS	020H		; A:
0679: FA81 		 DiskBWorkArea:	DS	020H		; B:
0680: FAA1 		 DiskCWorkArea:	DS	010H		; C:
0681: FAB1 		 DiskDWorkArea:	DS	010H		; D:
0682: FAC1 		 
0683: FAC1 		 	
0684: FAC1 		 			; Disk allocation vectors
0685: FAC1 		 			
0686: FAC1 		 		; These are used by the BDOS to maintain a bit map of
0687: FAC1 		 		; which allocation blocks are used and which are free.
0688: FAC1 		 		; One byte is used for eight allocation blocks, hence the
0689: FAC1 		 		; expression of the form (allocation blocks/8)+1
0690: FAC1 		 
0691: FAC1 		 DiskAAllocationVector:	DS		(174/8)+1 	; A:
0692: FAD7 		 DiskBAllocationVector:	DS		(174/8)+1 	; B:
0693: FAED 		 	
0694: FAED 		 DiskCAllocationVector:	DS		(242/8)+1 	; C:
0695: FB0C 		 DiskDAllocationVector:	DS		(242/8)+1 	; A:
0696: FB2B 		 	
0697: FB2B 		 NumberOfLogicalDisks:	EQU 4
0698: FB2B 		 
0699: FB2B 		 
0700: FB2B 		 		;  Disk routines
0701: FB2B 		 		
0702: FB2B 		 ;**********************
0703: FB2B 		 ;SELDSK - Select disk in C. C=0 for A: 1 for B: etc.
0704: FB2B 		 ;  Return the address of the appropriate disk parameter header
0705: FB2B 		 ;  in HL, or 0000H if selected disk does not exist		
0706: FB2B 		 ;**********************	
0707: FB2B 		 SELDSK:
0708: FB2B 	210000	 	LXI		H,00H		; Assume an error
0709: FB2E 	79	 	MOV		A,C 		; Check if  requested disk is valid
0710: FB2F 	FEFB2B	 	CPI		NumberOfLogicalDisks
0711: FB31 	D0	 	RNC					; return if > max number of Disks
0712: FB32 		 	
0713: FB32 	32EAFB	 	STA		SelectedDisk	; save disk number
0714: FB35 	6F	 	MOV		L,A			; make disk into word number
0715: FB36 	2600	 	MVI		H,0
0716: FB38 		 						; Compute offset down disk parameter
0717: FB38 		 						; table by multiplying by parameter
0718: FB38 		 						; header length (16 bytes)
0719: FB38 	29	 	DAD		H
0720: FB39 	29	 	DAD		H
0721: FB3A 	29	 	DAD		H
0722: FB3B 	29	 	DAD		H			; pointing at right one
0723: FB3C 	1181F9	 	LXI		D,DiskParameterHeaders		; get base address
0724: FB3F 	19	 	DAD		D			; DE -> appropriate DPH
0725: FB40 	E5	 	PUSH	H			; save DPH address
0726: FB41 		 						; access disk parameter block to
0727: FB41 		 						; extract special prefix byte that
0728: FB41 		 						; identifies disk type and whether
0729: FB41 		 						; de-blocking is required
0730: FB41 	110A00	 	LXI		D,10		; Get DPB pointer offset in DPH
0731: FB44 	19	 	DAD		D			; DE -> DPB address
0732: FB45 	5E	 	MOV		E,M			; Get DPB address in DE
0733: FB46 	23	 	INX		H
0734: FB47 	56	 	MOV		D,M	
0735: FB48 	EB	 	XCHG				; DE ->DPB
0736: FB49 	2B	 	DCX		H			; DE -> prefix byte
0737: FB4A 	7E	 	MOV		A,M			; get prefix byte
0738: FB4B 	E60F	 	ANI		0FH			; isolate disk type
0739: FB4D 	32FAFB	 	STA		DiskType	; save for use in low level driver
0740: FB50 	7E	 	MOV		A,M			; get another copy
0741: FB51 	E680	 	ANI		NeedDeblocking
0742: FB53 	32F9FB	 	STA		DeblockingRequired	; save for low level driver
0743: FB56 	E1	 	POP		H			; recover DPH pointer
0744: FB57 	C9	 	RET
0745: FB58 		 
0746: FB58 		 ;**********************	
0747: FB58 		 ;SETTRK - Set logical track for next read or write
0748: FB58 		 ;		Track is in BC
0749: FB58 		 ;**********************	
0750: FB58 		 SETTRK:
0751: FB58 	60	 	MOV		H,B					; select track in BC on entry
0752: FB59 	69	 	MOV		L,C
0753: FB5A 	22EBFB	 	SHLD	SelectedTrack		; save for low level driver	
0754: FB5D 	C9	 	RET
0755: FB5E 		 	
0756: FB5E 		 ;**********************	
0757: FB5E 		 ;SETSEC - Set logical sector for next read or write
0758: FB5E 		 ;		Sector is in C
0759: FB5E 		 ;**********************
0760: FB5E 		 SETSEC:
0761: FB5E 	79	 	MOV		A,C
0762: FB5F 	32EDFB	 	STA		SelectedSector		; save for low level driver	
0763: FB62 	C9	 	RET
0764: FB63 		 	
0765: FB63 		 ;**********************
0766: FB63 		 ;SetDMA - Set DMA (input/output) address for next read or write
0767: FB63 		 ;       Address in BC
0768: FB63 		 ;**********************
0769: FB63 	0000	 DMAAddress:	DW	0		; DMA address
0770: FB65 		 SETDMA:
0771: FB65 	69	 	MOV		L,C					; select address in BC on entry
0772: FB66 	60	 	MOV		H,B
0773: FB67 	2263FB	 	SHLD	DMAAddress		; save for low level driver	
0774: FB6A 	C9	 	RET
0775: FB6B 		 	
0776: FB6B 		 			; Translate logical sector number to physical
0777: FB6B 		 			
0778: FB6B 		 			; Sector translation tables
0779: FB6B 		 			; These tables are indexed using the logical sector number
0780: FB6B 		 			; and contain the corresponding physical sector number
0781: FB6B 		 
0782: FB6B 		 
0783: FB6B 		 ;**********************
0784: FB6B 		 ;	Skew tables
0785: FB6B 		 ;**********************
0786: FB6B 		 
0787: FB6B 		 Floppy5SkewTable:			; each physical sector contains four
0788: FB6B 		 							;  128-byte sectors
0789: FB6B 		 							
0790: FB6B 		 ;	,		Physical 128b 	Logical 128b	Physical 512-byte
0791: FB6B 	00010203	 	DB		00,01,02,03		;00,01,02,03				0	)
0792: FB6F 	10111213	 	DB		16,17,18,19		;04,05,06,07				4	)
0793: FB73 	20212223	 	DB		32,33,34,35		;08,09,10,11				8	)
0794: FB77 	0C0D0E0F	 	DB		12,13,14,15		;12,13,14,15				3	)Head
0795: FB7B 	1C1D1E1F	 	DB		28,29,30,31		;16,17,18,19				7	) 0
0796: FB7F 	08090A0B	 	DB		08,09,10,11		;20,21,22,23				2	)
0797: FB83 	18191A1B	 	DB		24,25,26,27		;24,25,26,27				6	)
0798: FB87 	04050607	 	DB		04,05,06,07		;28,29,30,31				1	)
0799: FB8B 	14151617	 	DB		20,21,22,23		;32,33,34,35				5	)
0800: FB8F 		 	
0801: FB8F 	24252627	 	DB		36,37,38,39		;36,37,38,39				0	]
0802: FB93 	34353637	 	DB		52,53,54,55		;40,41,42,43				4	]
0803: FB97 	44454647	 	DB		68,69,70,71		;44,45,46,47				8	]
0804: FB9B 	30313233	 	DB		48,49,50,51		;48,49,50,51				3	]Head
0805: FB9F 	40414243	 	DB		64,65,66,67		;52,53,54,55				7	] 0
0806: FBA3 	2C2D2E2F	 	DB		44,45,46,47		;56,57,58,59				2	]
0807: FBA7 	3C3D3E3F	 	DB		60,61,62,63		;60,61,62,63				6	]
0808: FBAB 	28292A2B	 	DB		40,41,42,43		;63,65,66,67				1	]
0809: FBAF 	38393A3B	 	DB		56,57,58,59		;68,69,70,71				5	]
0810: FBB3 		 	
0811: FBB3 		 Floppy8SkewTable:			; Standard 8" Driver
0812: FBB3 		 	;		01,02,03,04,05,06,07,08,09,10		; Logical Sectors
0813: FBB3 	01070D1319050B111703	 	DB		01,07,13,19,25,05,11,17,23,03		; Physical Sectors
0814: FBBD 		 	
0815: FBBD 		 	;		11,12,13,14,15,16,17,18,19,20		; Logical Sectors	
0816: FBBD 	090F1502080E141A060C	 	DB		09,15,21,02,08,14,20,26,06,12		; Physical Sectors
0817: FBC7 		 	
0818: FBC7 		 	;		21,22,23,24,25,26					; Logical Sectors	
0819: FBC7 	1218040A1016	 	DB		18,24,04,10,16,22					; Physical Sectors
0820: FBCD 		 	
0821: FBCD 		 ;**********************
0822: FBCD 		 ;SECTRAN - Translate logical sector to physical
0823: FBCD 		 ;	on Entry:	BC= logical sector number
0824: FBCD 		 ;				DE-> appropriate skew table
0825: FBCD 		 ;	on Exit:	HL = physical sector number
0826: FBCD 		 ;**********************
0827: FBCD 		 SECTRAN:
0828: FBCD 	EB	 	XCHG			;HL -> skew table base
0829: FBCE 	09	 	DAD		B		; Add on logical sector number
0830: FBCF 	6E	 	MOV		L,M		; Get physical sector number
0831: FBD0 	2600	 	MVI		H,00H	; make into a word
0832: FBD2 	C9	 	RET
0833: FBD3 		 	
0834: FBD3 		 ;**********************
0835: FBD3 		 ;HOME - Home the selected logical disk to track 0.
0836: FBD3 		 ;	Before doing this, a check must be made to see if the
0837: FBD3 		 ;	physical disk buffer has information that must be
0838: FBD3 		 ;	written out. This is indicated by a flag, MustWriteBuffer,
0839: FBD3 		 ;	set in the de-blocking code
0840: FBD3 		 ;**********************	
0841: FBD3 		 HOME:
0842: FBD3 	3AE9FB	 	LDA		MustWriteBuffer		; check flag
0843: FBD6 	B7	 	ORA		A
0844: FBD7 	C2DDFB	 	JNZ		HomeNoWrite
0845: FBDA 	32E8FB	 	STA		DataInDiskBuffer	; no, so indicate empty buffer
0846: FBDD 		 HomeNoWrite:
0847: FBDD 	0E00	 	MVI		C,00H				; Set to track 0
0848: FBDF 	CD58FB	 	CALL	SETTRK				; no, physical, only logical
0849: FBE2 	C9	 	RET
0850: FBE3 		 
0851: FBE3 		 ;*******************************************************************************
0852: FBE3 		 ;					 More tables
0853: FBE3 		 ; Data written to or read from the mini-floppy drive is transferred via a
0854: FBE3 		 ; physical buffer that is actually 512 bytes long (it was declared at the front
0855: FBE3 		 ; of the BIOS and holds the "one-time" initialization code used for the
0856: FBE3 		 ; cold boot procedure.)
0857: FBE3 		 ;
0858: FBE3 		 ; The blocking/de-blocking code attempts to minimize the amount of actual
0859: FBE3 		 ; disk I/O by storing the disk,track, and physical sector currently residing
0860: FBE3 		 ; in the Physical Buffer. If a read request is for a 128 byte CP/M "sector"
0861: FBE3 		 ; that is already in the physical buffer, then no disk access occurs
0862: FBE3 		 ;*******************************************************************************
0863: FBE3 		 AllocationBlockSize		EQU		0800H		; 2048
0864: FBE3 		 PhysicalSecPerTrack		EQU		012H		; 18
0865: FBE3 		 CPMSecPerPhysical		EQU		PhysicalSectorSize/128
0866: FBE3 		 CPMSecPerTrack			EQU		CPMSecPerPhysical * PhysicalSecPerTrack
0867: FBE3 		 SectorMask				EQU		CPMSecPerPhysical - 1
0868: FBE3 		 SectorBitShift			EQU		02H			; LOG2(CPMSecPerPhysical)
0869: FBE3 		 
0870: FBE3 		 ;*******************************************************************************
0871: FBE3 		 ; These are the values handed over by the BDOS when it calls the Writer operation
0872: FBE3 		 ; The allocated.unallocated indicates whether the BDOS is set to write to an
0873: FBE3 		 ; unallocated allocation block (it only indicates this for the first 128 byte
0874: FBE3 		 ; sector write) or to an allocation block that has already been allocated to a
0875: FBE3 		 ; file. The BDOS also indicates if it is set to write to the file directory
0876: FBE3 		 ;*******************************************************************************
0877: FBE3 		 WriteAllocated			EQU		00H
0878: FBE3 		 WriteDirectory			EQU		01H
0879: FBE3 		 WriteUnallocated		EQU		02H
0880: FBE3 		 
0881: FBE3 	00	 WriteType:				DB		00H		; The type of write indicated by BDOS
0882: FBE4 		 
0883: FBE4 		 	;       variables for physical sector
0884: FBE4 		 	; These are moved and compared as a group, DO NOT ALTER
0885: FBE4 		 InBufferDkTrkSec:
0886: FBE4 	00	 InBufferDisk:			DB		00H
0887: FBE5 	0000	 InBufferTrack:			DW		00H
0888: FBE7 	00	 InBufferSector:			DB		00H
0889: FBE8 		 
0890: FBE8 	00	 DataInDiskBuffer:		DB		00H		; when non-zero, the disk buffer has data from disk
0891: FBE9 		 
0892: FBE9 	00	 MustWriteBuffer:		DB		00H		; Non-zero when data has been written into DiskBuffer,
0893: FBEA 		 										;	but not yet written out to the disk
0894: FBEA 		 										
0895: FBEA 		 	;     variables for selected disk, track and sector
0896: FBEA 		 	; These are moved and compared as a group, DO NOT ALTER
0897: FBEA 		 SelectedDkTrkSec:
0898: FBEA 	00	 SelectedDisk:			DB		00H
0899: FBEB 	0000	 SelectedTrack:			DW		00H
0900: FBED 	00	 SelectedSector:			DB		00H
0901: FBEE 		 
0902: FBEE 		 	;Selected physical sector derived from selected (CP/M) sector by shifting it
0903: FBEE 		 	;	right the number of of bits specified by SectorBitShift
0904: FBEE 	00	 SelectedPhysicalSector:	DB		00H
0905: FBEF 		 
0906: FBEF 	00	 SelectedDiskType:		DB		00H		; Set by SELDSK to indicate either , 8" or 5 1/4" floppy 
0907: FBF0 	00	 SelectedDiskDeblock:	DB		00H		; Set by SELDSK to indicate whether de-blocking is required
0908: FBF1 		 
0909: FBF1 		 	; Parameters for writing to a previously unallocated allocation block
0910: FBF1 		 	; These are moved and compared as a group, DO NOT ALTER
0911: FBF1 		 UnallocatedDkTrkSec:
0912: FBF1 	00	 UnallocatedDisk:		DB		00H
0913: FBF2 	0000	 UnallocatedTrack:		DW		00H
0914: FBF4 	00	 UnallocatedSector:		DB		00H
0915: FBF5 	00	 UnalocatedlRecordCount:	DB		00H		; Number of unallocated "records"in current previously unallocated allocation block.
0916: FBF6 		 
0917: FBF6 	00	 DiskErrorFlag:			DB		00H		; Non-Zero - unrecoverable error output "Bad Sector" message
0918: FBF7 		 
0919: FBF7 		 	; Flags used inside the de-blocking code
0920: FBF7 	00	 MustPrereadSector:		DB		00H		; non-zero if physical sector must be read into the disk buffer
0921: FBF8 		 										; either before a write to a allocated block can occur, or
0922: FBF8 		 										; for a normal CP/M 128 byte sector read
0923: FBF8 	00	 ReadOperation:			DB		00H		; Non-zero when a CP/M 128 byte sector is to be read
0924: FBF9 	00	 DeblockingRequired:		DB		00H		; Non-zero when the selected disk needs de-blocking (set in SELDSK)
0925: FBFA 	00	 DiskType:				DB		00H		; Indicate 8" or 5 1/4" selected  (set in SELDSK)
0926: FBFB 		 
0927: FBFB 		 ; 180/493
0928: FBFB 		 
0929: FBFB 		 ;************************************************************************************************
0930: FBFB 		 ;        READ
0931: FBFB 		 ; Read in the 128-byte CP/M sector specified by previous calls to select disk and to set track  and 
0932: FBFB 		 ; sector. The sector will be read into the address specified in the previous call to set DMA address
0933: FBFB 		 ;
0934: FBFB 		 ; If reading from a disk drive using sectors larger than 128 bytes, de-blocking code will be used
0935: FBFB 		 ; to unpack a 128-byte sector from  the physical sector. 
0936: FBFB 		 ;************************************************************************************************
0937: FBFB 		 READ:
0938: FBFB 	3AF9FB	 		LDA		DeblockingRequired
0939: FBFE 	B7	 		ORA		A
0940: FBFF 	CA52FD	 		JZ		ReadNoDeblock			; if 0 use normal non-blocked read
0941: FC02 		 ; The de-blocking algorithm used is such that a read operation can be viewed UP until the actual
0942: FC02 		 ; data transfer as though it was the first write to an unallocated allocation block. 
0943: FC02 	AF	 		XRA		A					; set record count to 0
0944: FC03 	32F5FB	 		STA		UnalocatedlRecordCount
0945: FC06 	3C	 		INR		A
0946: FC07 	32F8FB	 		STA		ReadOperation			; Indicate that this is a read
0947: FC0A 	32F7FB	 		STA		MustPreReadSector		; force pre-read
0948: FC0D 	3E02	 		MVI		A,WriteUnallocated		; fake de-blocking code into responding as if this
0949: FC0F 	32E3FB	 		STA		WriteType				;  is the first write to an unallocated allocation block
0950: FC12 	C36EFC	 		JMP		PerformReadWrite		; use common code to execute read
0951: FC15 		 		
0952: FC15 		 ;************************************************************************************************
0953: FC15 		 ;		WRITE
0954: FC15 		 ;Write a 128-byte sector from the current DMA address to the previously $elected disk, track, and sector.
0955: FC15 		 ;
0956: FC15 		 ; On arrival here, the BOOS will have set register C to indicate whether this write operation is to
0957: FC15 		 ; an already allocated allocation block (which means a pre-read of the sector may be needed),
0958: FC15 		 ; to the directory (in which case the data will be written to the disk immediately),
0959: FC15 		 ; or to the first 128-byte sector of a previously unallocated allocation block (In which case no pre-read is required).
0960: FC15 		 
0961: FC15 		 ; Only writes to the directory take place immediately. In all other cases, the data will be moved
0962: FC15 		 ; from the DMA address into the disk buffer, and only written out when circumstance, force the transfer.
0963: FC15 		 ; The number of physical disk operations can therefore be reduced considerably.
0964: FC15 		 ;************************************************************************************************
0965: FC15 		 WRITE:
0966: FC15 	3AF9FB	 		LDA		DeblockingRequired
0967: FC18 	B7	 		ORA		A
0968: FC19 	CA4DFD	 		JZ		WriteNoDeblock			; if 0 use normal non-blocked write
0969: FC1C 		 
0970: FC1C 	AF	 		XRA		A
0971: FC1D 	32F8FB	 		STA		ReadOperation			; its a write (Not a read)
0972: FC20 	79	 		MOV		A,C
0973: FC21 	32E3FB	 		STA		WriteType				; save the BDOS write type
0974: FC24 	FE02	 		CPI		WriteUnallocated		; first write to an unallocated allocation block ?
0975: FC26 	C237FC	 		JNZ		CheckUnallocatedBlock	; No, - in the middle of writing to an unallocated block ?
0976: FC29 		 										; Yes, first write to unallocated allocation block. Initialize
0977: FC29 		 										; variables associated with unallocated writes
0978: FC29 	3E10	 		MVI		A,AllocationBlockSize/ 128	; Number of 128 byte sectors
0979: FC2B 	32F5FB	 		STA		UnalocatedlRecordCount
0980: FC2E 	21EAFB	 		LXI		H,SelectedDkTrkSec		; copy disk, track & sector into unallocated variables
0981: FC31 	11F1FB	 		LXI		D,UnallocatedDkTrkSec
0982: FC34 	CD35FD	 		CALL 	MoveDkTrkSec
0983: FC37 		 		
0984: FC37 		 	; Check if this is not the first write to an unallocated allocation block -- if it is,
0985: FC37 		 	; the unallocated record count has just been set to the number of 128-byte sectors in the allocation block
0986: FC37 		 CheckUnallocatedBlock:
0987: FC37 	3AF5FB	 		LDA		UnalocatedlRecordCount
0988: FC3A 	B7	 		ORA		A
0989: FC3B 	CA66FC	 		JZ		RequestPreread			; No - write to an unallocated block
0990: FC3E 	3D	 		DCR		A						; decrement 128 byte sectors left
0991: FC3F 	32F5FB	 		STA		UnalocatedlRecordCount
0992: FC42 		 		
0993: FC42 	21EAFB	 		LXI		H,SelectedDkTrkSec		; same Disk, Track & sector as for those in an unallocated block
0994: FC45 	11F1FB	 		LXI		D,UnallocatedDkTrkSec
0995: FC48 	CD29FD	 		CALL	CompareDkTrkSec			; are they the same
0996: FC4B 	C266FC	 		JNZ		RequestPreread			; NO - do a pre-read
0997: FC4E 		 										;Compare$DkSTrkSec  returns with  DE -> Unallocated$Sector , HL -> UnallocatedSSector 
0998: FC4E 	EB	 		XCHG
0999: FC4F 	34	 		INR	M
1000: FC50 	7E	 		MOV		A,M
1001: FC51 	FE48	 		CPI		CPMSecPerTrack			; Sector > maximum on track ?
1002: FC53 	DA5FFC	 		JC		NoTrackChange			; No ( A < M)
1003: FC56 	3600	 		MVI		M,00H					; Yes
1004: FC58 	2AF2FB	 		LHLD	UnallocatedTrack
1005: FC5B 	23	 		INX		H						; increment track 
1006: FC5C 	22F2FB	 		SHLD	UnallocatedTrack
1007: FC5F 		 NoTrackChange:
1008: FC5F 	AF	 		XRA		A
1009: FC60 	32F7FB	 		STA		MustPrereadSector		; clear flag
1010: FC63 	C36EFC	 		JMP		PerformReadWrite
1011: FC66 		 RequestPreread:
1012: FC66 	AF	 		XRA		A
1013: FC67 	32F5FB	 		STA		UnalocatedlRecordCount	; not a write into an unallocated block
1014: FC6A 	3C	 		INR		A
1015: FC6B 	32F7FB	 		STA		MustPrereadSector		; set flag
1016: FC6E 		 ;*******************************************************
1017: FC6E 		 ; Common code to execute both reads and writes of 128-byte sectors	
1018: FC6E 		 ;*******************************************************	
1019: FC6E 		 PerformReadWrite:
1020: FC6E 	AF	 		XRA		A				; Assume no disk error will occur
1021: FC6F 	32F6FB	 		STA		DiskErrorFlag
1022: FC72 	3AEDFB	 		LDA		SelectedSector
1023: FC75 	1F	 		RAR						; Convert selected 128-byte sector
1024: FC76 	1F	 		RAR						; into physical sector by dividing by 4
1025: FC77 	E63F	 		ANI		03FH			; remove unwanted bits
1026: FC79 	32EEFB	 		STA		SelectedPhysicalSector
1027: FC7C 	21E8FB	 		LXI		H,DataInDiskBuffer	; see if there is any data here ?
1028: FC7F 	7E	 		MOV		A,M
1029: FC80 	3601	 		MVI		M,001H				; force there is data
1030: FC82 	B7	 		ORA		A					; any data here ?
1031: FC83 	CAA3FC	 		JZ		ReadSectorIntoBuffer	; NO - go read into buffer
1032: FC86 		 ;
1033: FC86 		 ;The buffer does have a physical sector in it.
1034: FC86 		 ; Note: The disk. track. and PHYSICAL sector in the buffer need to be checked,
1035: FC86 		 ; hence the use of the CompareDkTrk subroutine
1036: FC86 		 ;
1037: FC86 	11E4FB	 		LXI		D,InBufferDkTrkSec
1038: FC89 	21EAFB	 		LXI		H,SelectedDkTrkSec	; is it the same 
1039: FC8C 	CD24FD	 		CALL	CompareDkTrk		;    Disk and Track as selected ?
1040: FC8F 	C29CFC	 		JNZ		SectorNotInBuffer	; NO, it must be read
1041: FC92 		 ; it is in the buffer
1042: FC92 	3AE7FB	 		LDA		InBufferSector		; get the sector
1043: FC95 	21EEFB	 		LXI		H,SelectedPhysicalSector
1044: FC98 	BE	 		CMP		M					; Check if correct physical sector
1045: FC99 	CAB1FC	 		JZ		SectorInBuffer		; Yes - it is already in memory
1046: FC9C 		 		
1047: FC9C 		 ; No, it will have to be read in over current contents of buffer
1048: FC9C 		 SectorNotInBuffer:
1049: FC9C 	3AE9FB	 		LDA		MustWriteBuffer
1050: FC9F 	B7	 		ORA		A					; do we need to write ?
1051: FCA0 	C495FD	 		CNZ		WritePhysical		; Yes - write it out
1052: FCA3 		 
1053: FCA3 		 ReadSectorIntoBuffer:
1054: FCA3 	CD11FD	 		CALL	SetInBufferDkTrkSector
1055: FCA6 	3AF7FB	 		LDA		MustPrereadSector	; do we need to pre-read
1056: FCA9 	B7	 		ORA		A
1057: FCAA 	C49AFD	 		CNZ		ReadPhysical		; yes - pre-read the sector
1058: FCAD 	AF	 		XRA		A					; reset the flag
1059: FCAE 	32E9FB	 		STA		MustWriteBuffer
1060: FCB1 		 		
1061: FCB1 		 ; Selected sector on correct track and  disk is already 1n the buffer.
1062: FCB1 		 ; Convert the selected CP/M(128-byte sector into relative address down the buffer. 
1063: FCB1 		 SectorInBuffer:
1064: FCB1 	3AEDFB	 		LDA		SelectedSector
1065: FCB4 	E603	 		ANI		SectorMask			; only want the least bits
1066: FCB6 	6F	 		MOV		L,A
1067: FCB7 	2600	 		MVI		H,00H				; Multiply by 128
1068: FCB9 	29	 		DAD		H					; *2
1069: FCBA 	29	 		DAD		H					; *4
1070: FCBB 	29	 		DAD		H					; *8
1071: FCBC 	29	 		DAD		H					; *16
1072: FCBD 	29	 		DAD		H					; *32
1073: FCBE 	29	 		DAD		H					; *64
1074: FCBF 	29	 		DAD		H					; *128
1075: FCC0 	1133F6	 		LXI		D,DiskBuffer
1076: FCC3 	19	 		DAD		D					; HL -> 128-byte sector number start address
1077: FCC4 	EB	 		XCHG						; DE -> sector in the disk buffer
1078: FCC5 	2A63FB	 		LHLD	DMAAddress			; Get DMA address (set in SETDMA)
1079: FCC8 	EB	 		XCHG						; assume a read so :
1080: FCC9 		 									; DE -> DMA Address & HL -> sector in disk buffer
1081: FCC9 	0E10	 		MVI		C,128/8				; 8 bytes per move (loop count)
1082: FCCB 		 ;
1083: FCCB 		 ;  At this point -
1084: FCCB 		 ;	C	->	loop count
1085: FCCB 		 ;	DE	->	DMA address
1086: FCCB 		 ;	HL	->	sector in disk buffer
1087: FCCB 		 ;
1088: FCCB 	3AF8FB	 		LDA		ReadOperation		; Move into or out of buffer /
1089: FCCE 	B7	 		ORA		A
1090: FCCF 	C2D7FC	 		JNZ		BufferMove			; Move out of buffer
1091: FCD2 		 		
1092: FCD2 	3C	 		INR		A					; going to force a write
1093: FCD3 	32E9FB	 		STA		MustWriteBuffer
1094: FCD6 	EB	 		XCHG						; DE <--> HL
1095: FCD7 		 		
1096: FCD7 		 ;The following move loop moves eight bytes at a time from (HL> to (DE), C contains the loop count
1097: FCD7 		 BufferMove:
1098: FCD7 	7E	 		MOV		A,M					; Get byte from source
1099: FCD8 	12	 		STAX	D					; Put into destination
1100: FCD9 	13	 		INX		D					; update pointers
1101: FCDA 	23	 		INX		H
1102: FCDB 		 		
1103: FCDB 	7E	 		MOV		A,M					; Get byte from source
1104: FCDC 	12	 		STAX	D					; Put into destination
1105: FCDD 	13	 		INX		D					; update pointers
1106: FCDE 	23	 		INX		H
1107: FCDF 		 		
1108: FCDF 	7E	 		MOV		A,M					; Get byte from source
1109: FCE0 	12	 		STAX	D					; Put into destination
1110: FCE1 	13	 		INX		D					; update pointers
1111: FCE2 	23	 		INX		H
1112: FCE3 		 		
1113: FCE3 	7E	 		MOV		A,M					; Get byte from source
1114: FCE4 	12	 		STAX	D					; Put into destination
1115: FCE5 	13	 		INX		D					; update pointers
1116: FCE6 	23	 		INX		H
1117: FCE7 		 		
1118: FCE7 	7E	 		MOV		A,M					; Get byte from source
1119: FCE8 	12	 		STAX	D					; Put into destination
1120: FCE9 	13	 		INX		D					; update pointers
1121: FCEA 	23	 		INX		H
1122: FCEB 		 		
1123: FCEB 	7E	 		MOV		A,M					; Get byte from source
1124: FCEC 	12	 		STAX	D					; Put into destination
1125: FCED 	13	 		INX		D					; update pointers
1126: FCEE 	23	 		INX		H
1127: FCEF 		 		
1128: FCEF 	7E	 		MOV		A,M					; Get byte from source
1129: FCF0 	12	 		STAX	D					; Put into destination
1130: FCF1 	13	 		INX		D					; update pointers
1131: FCF2 	23	 		INX		H
1132: FCF3 		 		
1133: FCF3 	7E	 		MOV		A,M					; Get byte from source
1134: FCF4 	12	 		STAX	D					; Put into destination
1135: FCF5 	13	 		INX		D					; update pointers
1136: FCF6 	23	 		INX		H
1137: FCF7 		 		
1138: FCF7 	0D	 		DCR		C					; count down on loop counter
1139: FCF8 	C2D7FC	 		JNZ		BufferMove			; repeat till done (CP/M sector moved)
1140: FCFB 		 ; end of loop		
1141: FCFB 	3AE3FB	 		LDA		WriteType			; write to directory ?
1142: FCFE 	FE01	 		CPI		WriteDirectory
1143: FD00 	3AF6FB	 		LDA		DiskErrorFlag		; get flag in case of a delayed read or write
1144: FD03 	C0	 		RNZ							; return if delayed read or write
1145: FD04 		 		
1146: FD04 	B7	 		ORA		A					; Any disk errors ?
1147: FD05 	C0	 		RNZ							; yes - abandon attempt to write to directory
1148: FD06 		 		
1149: FD06 	AF	 		XRA		A
1150: FD07 	32E9FB	 		STA		MustWriteBuffer		; clear flag
1151: FD0A 	CD95FD	 		CALL	WritePhysical
1152: FD0D 	3AF6FB	 		LDA		DiskErrorFlag		; return error flag to caller
1153: FD10 	C9	 		RET
1154: FD11 		 ;********************************************************************
1155: FD11 		 
1156: FD11 		 		
1157: FD11 		 ; indicates  selected disk, track, and sector now residing in buffer
1158: FD11 		 SetInBufferDkTrkSector:
1159: FD11 	3AEAFB	 		LDA		SelectedDisk
1160: FD14 	32E4FB	 		STA		InBufferDisk
1161: FD17 	2AEBFB	 		LHLD	SelectedTrack
1162: FD1A 	22E5FB	 		SHLD	InBufferTrack
1163: FD1D 	3AEEFB	 		LDA		SelectedPhysicalSector
1164: FD20 	32E7FB	 		STA		InBufferSector
1165: FD23 	C9	 		Ret
1166: FD24 		 		
1167: FD24 		 CompareDkTrk:					;Compares just the disk and track   pointed to by DE and HL 
1168: FD24 	0E03	 		MVI		C,03H			; Disk(1), Track(2)
1169: FD26 	C32BFD	 		JMP		CompareDkTrkSecLoop
1170: FD29 		 CompareDkTrkSec:				;Compares just the disk and track   pointed to by DE and HL 
1171: FD29 	0E04	 		MVI		C,04H			; Disk(1), Track(2), Sector(1)
1172: FD2B 		 CompareDkTrkSecLoop:
1173: FD2B 	1A	 		LDAX	D
1174: FD2C 	BE	 		CMP		M
1175: FD2D 	C0	 		RNZ						; Not equal
1176: FD2E 	13	 		INX	D
1177: FD2F 	23	 		INX	H
1178: FD30 	0D	 		DCR		C
1179: FD31 	C8	 		RZ						; return they match (zero flag set)
1180: FD32 	C32BFD	 		JMP		CompareDkTrkSecLoop	; keep going
1181: FD35 		 
1182: FD35 		 ;********************************************************************
1183: FD35 		 
1184: FD35 		 ;Moves the disk, track, and sector variables pointed at by HL to those pointed at by DE 
1185: FD35 		 MoveDkTrkSec:
1186: FD35 	0E04	 		MVI		C,04H			; Disk(1), Track(2), Sector(1)
1187: FD37 		 MoveDkTrkSecLoop:
1188: FD37 	7E	 		MOV		A,M
1189: FD38 	12	 		STAX	D
1190: FD39 	13	 		INX		D
1191: FD3A 	23	 		INX		H
1192: FD3B 	0D	 		DCR		C
1193: FD3C 	C8	 		RZ					; exit loop done
1194: FD3D 	C337FD	 		JMP		MoveDkTrkSecLoop
1195: FD40 		 		
1196: FD40 		 ;**************************************************************************************************
1197: FD40 		 ;  There are two "smart" disk controllers on this system, one for the 8" floppy diskette drives,
1198: FD40 		 ; and one for the 5 1/4" mini-diskette drives
1199: FD40 		 ;
1200: FD40 		 ;  The controllers are "hard-wired" to monitor certain locations in memory to detect when they are to
1201: FD40 		 ; perform some disk operation. The 8" controller monitors location 0040H, and the 5 1/4 controller
1202: FD40 		 ; monitors location 0045H. These are called their disk control bytes.
1203: FD40 		 ; If the most significant bit of  disk control byte is set, the controller will look at the word
1204: FD40 		 ; following the respective control bytes. This word must contain the address of  valid disk control
1205: FD40 		 ; table that specifies the exact disk operation to be performed.
1206: FD40 		 ;
1207: FD40 		 ;  Once the operation has been completed. the controller resets its disk control byte to OOH.
1208: FD40 		 ; This indicates completion to the disk driver code.
1209: FD40 		 ;
1210: FD40 		 ;  The controller also sets a return code in a disk status block -both controllers use the SAME location
1211: FD40 		 ; for this, 0043H. If the first byte of this status block is less than 80H. then a disk error
1212: FD40 		 ; has occurred. For this simple BIOS. no further details of the status settings are relevant.
1213: FD40 		 ; Note that the disk controller has built-in retry logic -- reads and writes are attempted
1214: FD40 		 ; ten times before the controller returns an error
1215: FD40 		 ;
1216: FD40 		 ;  The disk control table layout is shown below. Note that the controllers have the capability
1217: FD40 		 ; for control tables to be chained together so that a sequence of disk operations can be initiated.
1218: FD40 		 ; In this BIOS this feature is not used. However. the controller requires that the chain pointers
1219: FD40 		 ; in the disk control tables be pointed back to the main control bytes in order to indicate
1220: FD40 		 ; the end of the chain
1221: FD40 		 ;**************************************************************************************************
1222: FD40 		 
1223: FD40 		 DiskControl8	EQU	040H	; 8" control byte
1224: FD40 		 CommandBlock8	EQU	041H	; Control Table Pointer
1225: FD40 		 
1226: FD40 		 DiskStatusBlock	EQU	043H	; 8" and 5 1/4" status block
1227: FD40 		 
1228: FD40 		 DiskControl5	EQU	045H	; 8" control byte
1229: FD40 		 CommandBlock5	EQU	046H	; Control Table Pointer
1230: FD40 		 
1231: FD40 		 ;***************************************************************************
1232: FD40 		 ;					Floppy Disk Control tables
1233: FD40 		 ;***************************************************************************
1234: FD40 	00	 FloppyCommand:	DB	00H		; Command
1235: FD41 		 FloppyReadCode	EQU	01H
1236: FD41 		 FloppyWriteCode	EQU	02H
1237: FD41 	00	 FloppyUnit:		DB	00H		; unit (drive) number = 0 or 1
1238: FD42 	00	 FloppyHead:		DB	00H		; head number = 0 or 1
1239: FD43 	00	 FloppyTrack:	DB	00H		; track number
1240: FD44 	00	 FloppySector:	DB	00H		; sector number
1241: FD45 	0000	 FloppyByteCount:	DW	0000H	; number of bytes to read/write
1242: FD47 	0000	 FloppyDMAAddress:	DW	0000H	; transfer address
1243: FD49 	0000	 FloppyNextStatusBlock:	DW	0000H	; pointer to next status block
1244: FD4B 	0000	 FloppyNextControlLocation:	DW	0000H	; pointer to next control byte
1245: FD4D 		 
1246: FD4D 		 ; Write contents of disk buffer to correct sector
1247: FD4D 		 WriteNoDeblock:
1248: FD4D 	3E02	 	MVI		A,FloppyWriteCode	; get write function code
1249: FD4F 	C354FD	 	JMP		CommonNoDeblock
1250: FD52 		 ;Read previously selected sector into disk buffer
1251: FD52 		 ReadNoDeblock:
1252: FD52 	3E01	 	MVI		A,FloppyReadCode	; get read function code
1253: FD54 		 CommonNoDeblock:
1254: FD54 	3240FD	 	STA		FloppyCommand		; set the correct command code
1255: FD57 	218000	 	LXI		H,128				; bytes per sector
1256: FD5A 	2245FD	 	SHLD	FloppyByteCount
1257: FD5D 	AF	 	XRA		A					; 8" has only head 0
1258: FD5E 	3242FD	 	STA		FloppyHead
1259: FD61 		 	
1260: FD61 	3AEAFB	 	LDA		SelectedDisk		; insure only disk 0 or 1
1261: FD64 	E601	 	ANI		01H
1262: FD66 	3241FD	 	STA		FloppyUnit			; set the unit number
1263: FD69 		 	
1264: FD69 	3AEBFB	 	LDA		SelectedTrack
1265: FD6C 	3243FD	 	STA		FloppyTrack			; set track number
1266: FD6F 		 	
1267: FD6F 	3AEDFB	 	LDA		SelectedSector
1268: FD72 	3244FD	 	STA		FloppySector		; set sector
1269: FD75 		 	
1270: FD75 	2A63FB	 	LHLD	DMAAddress
1271: FD78 	2247FD	 	SHLD	FloppyDMAAddress	; set transfer address
1272: FD7B 		 	
1273: FD7B 		 ;  The disk controller can accept chained disk control tables, but in this case
1274: FD7B 		 ; they are not used. so the "Next" pointers must be pointed back at the initial
1275: FD7B 		 ; control bytes in the base page. 
1276: FD7B 	214300	 	LXI		H,DiskStatusBlock
1277: FD7E 	2249FD	 	SHLD	FloppyNextStatusBlock	; set pointer back to start
1278: FD81 	214000	 	LXI		H,DiskControl8
1279: FD84 	224BFD	 	SHLD	FloppyNextControlLocation	; set pointer back to start
1280: FD87 	2140FD	 	LXI		H,FloppyCommand
1281: FD8A 	224100	 	SHLD	CommandBlock8
1282: FD8D 		 	
1283: FD8D 	214000	 	LXI		H,DiskControl8
1284: FD90 	3680	 	MVI		M,080H				; activate the controller to perform operation
1285: FD92 	C3F7FD	 	JMP		WaitForDiskComplete
1286: FD95 		 	
1287: FD95 		 ;Write contents of disk buffer to correct sector
1288: FD95 		 WritePhysical:
1289: FD95 	3E02	 	MVI		A,FloppyWriteCode	; get write function
1290: FD97 	C39CFD	 	JMP		CommonPhysical
1291: FD9A 		 ReadPhysical:
1292: FD9A 	3E01	 	MVI		A,FloppyReadCode	; get read function
1293: FD9C 		 CommonPhysical:
1294: FD9C 	3240FD	 	STA		FloppyCommand		; set the command
1295: FD9F 		 	
1296: FD9F 	3AFAFB	 	LDA		DiskType
1297: FDA2 	FE01	 	CPI		Floppy5				; is it 5 1/4 ?
1298: FDA4 	CAADFD	 	JZ		CorrectDisktype		; yes
1299: FDA7 	3E01	 	MVI		A,1
1300: FDA9 	3209FE	 	STA		DiskError			; no set error and exit
1301: FDAC 	C9	 	RET
1302: FDAD 		 CorrectDisktype:
1303: FDAD 	3AE4FB	 	LDA		InBufferDisk
1304: FDB0 	E601	 	ANI		01H					; only units 0 or 1
1305: FDB2 	3241FD	 	STA		FloppyUnit			; set disk
1306: FDB5 	2AE5FB	 	LHLD	InBufferTrack
1307: FDB8 	7D	 	MOV		A,L					; for this controller it is a byte value
1308: FDB9 	3243FD	 	STA		FloppyTrack			; set track
1309: FDBC 		 ;  The sector must be converted into a head number and sector number.
1310: FDBC 		 ; Sectors 0 - 8 are head 0, 9 - 17 , are head 1 
1311: FDBC 	0600	 	MVI		B,0					; assume head 0
1312: FDBE 	3AE7FB	 	LDA		InBufferSector
1313: FDC1 	4F	 	MOV		C,A					; save copy
1314: FDC2 	FE09	 	CPI		09H
1315: FDC4 	DACBFD	 	JC		Head0
1316: FDC7 	D609	 	SUI		09H					; Modulo sector
1317: FDC9 	4F	 	MOV		C,A
1318: FDCA 	04	 	INR		B					; set head to 1
1319: FDCB 		 Head0:
1320: FDCB 	78	 	MOV		A,B
1321: FDCC 	3242FD	 	STA		FloppyHead			; set head number
1322: FDCF 	79	 	MOV		A,C
1323: FDD0 	3C	 	INR		A					; physical sectors start at 1
1324: FDD1 	3244FD	 	STA		FloppySector		; set sector
1325: FDD4 	210002	 	LXI		H,PhysicalSectorSize
1326: FDD7 	2245FD	 	SHLD	FloppyByteCount		; set byte count
1327: FDDA 	2133F6	 	LXI		H,DiskBuffer
1328: FDDD 	2247FD	 	SHLD	FloppyDMAAddress	; set transfer address
1329: FDE0 		 ;	As only one control table is in use, close the status and busy chain pointers
1330: FDE0 		 ;  back to the main control bytes
1331: FDE0 	214300	 	LXI		H,DiskStatusBlock
1332: FDE3 	2249FD	 	SHLD	FloppyNextStatusBlock
1333: FDE6 	214500	 	LXI		H,DiskControl5
1334: FDE9 	224BFD	 	SHLD	FloppyNextControlLocation
1335: FDEC 	2140FD	 	LXI		H,FloppyCommand
1336: FDEF 	224600	 	SHLD	CommandBlock5
1337: FDF2 		 	
1338: FDF2 	214500	 	LXI		H,DiskControl5		; activate 5 1/4" disk controller
1339: FDF5 	3680	 	MVI		M,080H
1340: FDF7 		 
1341: FDF7 		 ;Wait until Disk Status Block indicates , operation complete, then check 
1342: FDF7 		 ; if any errors occurred. ,On entry HL -> disk control byte	
1343: FDF7 		 WaitForDiskComplete:
1344: FDF7 	7E	 	MOV		A,M				; get control bytes
1345: FDF8 	B7	 	ORA		A
1346: FDF9 	C2F7FD	 	JNZ		WaitForDiskComplete	; operation not done
1347: FDFC 		 	
1348: FDFC 	3A4300	 	LDA		DiskStatusBlock		; done , so now check status
1349: FDFF 	FE80	 	CPI		080H
1350: FE01 	DA09FE	 	JC		DiskError
1351: FE04 	AF	 	XRA		A
1352: FE05 	32F6FB	 	STA		DiskErrorFlag		; clear the flag
1353: FE08 	C9	 	RET
1354: FE09 		 	
1355: FE09 		 DiskError:
1356: FE09 	3E01	 	MVI		A,1
1357: FE0B 	32F6FB	 	STA		DiskErrorFlag		; set the error flag
1358: FE0E 	C9	 	RET
1359: FE0F 		 	
1360: FE0F 		 ;**********************************************************************************
1361: FE0F 		 ;		Disk Control table image for warm boot
1362: FE0F 		 ;**********************************************************************************
1363: FE0F 		 BootControlPart1:
1364: FE0F 	01	 	DB	01H				; Read function
1365: FE10 	00	 	DB	00H				; unit number
1366: FE11 	00	 	DB	00H				; head number
1367: FE12 	00	 	DB	00H				; track number
1368: FE13 	02	 	DB	02H				; Starting sector number
1369: FE14 	0010	 	DW	8 * 512			; Number of bytes to read
1370: FE16 	00E0	 	DW	CCPEntry		; read into this address
1371: FE18 	4300	 	DW	DiskStatusBlock	; pointer to next block
1372: FE1A 	4500	 	DW	DiskControl5	; pointer to next table
1373: FE1C 		 BootControlPart2:
1374: FE1C 	01	 	DB	01H				; Read function
1375: FE1D 	00	 	DB	00H				; unit number
1376: FE1E 	01	 	DB	01H				; head number
1377: FE1F 	00	 	DB	00H				; track number
1378: FE20 	01	 	DB	01H				; Starting sector number
1379: FE21 	0006	 	DW	3 * 512			; Number of bytes to read
1380: FE23 	00F0	 	DW	CCPEntry + ( 8 * 512)		; read into this address
1381: FE25 	4300	 	DW	DiskStatusBlock	; pointer to next block
1382: FE27 	4500	 	DW	DiskControl5	; pointer to next table
1383: FE29 		 
1384: FE29 		 ;**********************************************************************************	
1385: FE29 		 ;						Warm Boot
1386: FE29 		 ;  On warm boot. the CCP and BDOS must be reloaded into memory.
1387: FE29 		 ; In this BIOS. only the 5 1/4" diskettes will be used.
1388: FE29 		 ; Therefore this code is hardware specific to the controller.
1389: FE29 		 ; Two prefabricated control tables are used.
1390: FE29 		 ;**********************************************************************************	
1391: FE29 		 WBOOT:
1392: FE29 	318000	 	LXI		SP,080H
1393: FE2C 	110FFE	 	LXI		D,BootControlPart1
1394: FE2F 	CD3BFE	 	CALL	WarmBootRead
1395: FE32 		 	
1396: FE32 	111CFE	 	LXi		D,BootControlPart2
1397: FE35 	CD3BFE	 	CALL	WarmBootRead
1398: FE38 	C340F8	 	JMP		EnterCPM
1399: FE3B 		 	
1400: FE3B 		 WarmBootRead:
1401: FE3B 	2140FD	 	LXI		H,FloppyCommand
1402: FE3E 	224600	 	SHLD	CommandBlock5
1403: FE41 	0E0D	 	MVI		C,13				; set byte count
1404: FE43 		 WarmByteMove:
1405: FE43 	1A	 	LDAX	D
1406: FE44 	77	 	MOV		M,A
1407: FE45 	23	 	INX		H
1408: FE46 	13	 	INX		D
1409: FE47 	0D	 	DCR		C
1410: FE48 	C243FE	 	JNZ		WarmByteMove
1411: FE4B 		 	
1412: FE4B 	214500	 	LXI		H,DiskControl5
1413: FE4E 	3680	 	MVI		M,080H			; activate the controller
1414: FE50 		 	
1415: FE50 		 WaitForBootComplete:
1416: FE50 	7E	 	MOV		A,M
1417: FE51 	B7	 	ORA		A
1418: FE52 	C250FE	 	JNZ		WaitForBootComplete
1419: FE55 		 	
1420: FE55 	3A4300	 	LDA		DiskStatusBlock
1421: FE58 	FE80	 	CPI		080H		; any errors ?
1422: FE5A 	DA5EFE	 	JC		WarmBootError	; Yup
1423: FE5D 	C9	 	RET
1424: FE5E 		 
1425: FE5E 		 WarmBootError:
1426: FE5E 	2167FE	 	LXI		H,WarmBootErroMessage
1427: FE61 	CD33F8	 	CALL	DisplayMessage
1428: FE64 	C329FE	 	JMP		WBOOT
1429: FE67 		 	
1430: FE67 		 WarmBootErroMessage:
1431: FE67 	0D0A	 	DB		0DH,0AH
1432: FE69 	5761726D20	 	DB		057H,061H,072H,06DH,020H				; Warm
1433: FE6E 	426F6F7420	 	DB		042H,06FH,06FH,074H,020H				; Boot
1434: FE73 	7265744879696E67	 	DB		072H,065H,074H,072,079H,069H,06EH,067H	;retrying
1435: FE7B 	2E2E2E0D0A	 	DB		02EH,02EH,02EH,0DH,0AH
1436: FE80 	00	 	DB		00H
1437: FE81 		 End:
1438: FE81 		 
1439: FE81 		 
1440: FE81 		 	
1441: FE81 		 
1442: FE81 		 
1443: FE81 		 	




                                    Xref


0000	0000	$                             		

0075	F833	AFTERDISKBUFFER               		  0224,
0863	0800	ALLOCATIONBLOCKSIZE           		  0978,

0024	E806	BDOSENTRY                     		  0032,  0245,
0018	0E00	BDOSLENGTH                    		  0020,  0021,  0025,
0025	F600	BIOSENTRY                     		  0049,
0015	0900	BIOSLENGTH                    		  0020,  0021,
0179	F6F9	BOOT                          		  0053,
1363	FE0F	BOOTCONTROLPART1              		  1393,
1373	FE1C	BOOTCONTROLPART2              		  1396,
1097	FCD7	BUFFERMOVE                    		  1090,  1139,

0023	E000	CCPENTRY                      		  0024,  0025,  0254,  1370,  1380,
0017	0800	CCPLENGTH                     		  0020,  0021,  0024,  0025,
0986	FC37	CHECKUNALLOCATEDBLOCK         		  0975,
1229	0046	COMMANDBLOCK5                 		  1336,  1402,
1224	0041	COMMANDBLOCK8                 		  1281,
1253	FD54	COMMONNODEBLOCK               		  1249,
1293	FD9C	COMMONPHYSICAL                		  1290,
0407	00DF	COMMUNICATIONBAUDMODE         		  0097,
0408	00DE	COMMUNICATIONBAUDRATE         		  0101,
0403	00EC	COMMUNICATIONDATAPORT         		  0422,
0463	F92F	COMMUNICATIONINPUT            		  0293,
0405	0002	COMMUNICATIONINPUTREADY       		  0424,
0435	F902	COMMUNICATIONINSTATUS         		  0277,
0476	F944	COMMUNICATIONOUTPUT           		  0305,  0342,  0355,  0366,
0404	0001	COMMUNICATIONOUTPUTREADY      		  0423,
0448	F917	COMMUNICATIONOUTSTATUS        		  0330,
0402	00ED	COMMUNICATIONSTATUSPORT       		  0088,  0421,
0420	F8F2	COMMUNICATIONTABLE            		  0436,  0449,  0464,  0477,
1167	FD24	COMPAREDKTRK                  		  1039,
1170	FD29	COMPAREDKTRKSEC               		  0995,
1172	FD2B	COMPAREDKTRKSECLOOP           		  1169,  1180,
0280	F878	CONIN                         		  0057,
0296	F886	CONOUT                        		  0058,  0232,
0265	F862	CONST                         		  0056,
1302	FDAD	CORRECTDISKTYPE               		  1298,
0865	0004	CPMSECPERPHYSICAL             		  0866,  0867,
0866	0048	CPMSECPERTRACK                		  1001,
0109	000D	CR                            		  0126,  0130,  0136,  0143,  0150,  0157,  0164,

0890	FBE8	DATAINDISKBUFFER              		  0845,  1027,
0010	3930	DAY                           		  0121,
0924	FBF9	DEBLOCKINGREQUIRED            		  0742,  0938,  0966,
0175	0004	DEFAULTDISK                   		  0216,  0252,
0043	0080	DEFAULTDISKBUFFER             		
0625	F9C1	DIRECTORYBUFFER               		  0596,  0604,  0612,  0620,
0691	FAC1	DISKAALLOCATIONVECTOR         		  0599,
0678	FA61	DISKAWORKAREA                 		  0598,
0692	FAD7	DISKBALLOCATIONVECTOR         		  0607,
0073	F633	DISKBUFFER                    		  0077,  1075,  1327,
0679	FA81	DISKBWORKAREA                 		  0606,
0694	FAED	DISKCALLOCATIONVECTOR         		  0615,
1228	0045	DISKCONTROL5                  		  1333,  1338,  1372,  1382,  1412,
1223	0040	DISKCONTROL8                  		  1278,  1283,
0680	FAA1	DISKCWORKAREA                 		  0614,
0695	FB0C	DISKDALLOCATIONVECTOR         		  0623,
0681	FAB1	DISKDWORKAREA                 		  0622,
1355	FE09	DISKERROR                     		  1300,  1350,
0917	FBF6	DISKERRORFLAG                 		  1021,  1143,  1152,  1352,  1357,
0591	F981	DISKPARAMETERHEADERS          		  0723,
1226	0043	DISKSTATUSBLOCK               		  1276,  1331,  1348,  1371,  1381,  1420,
0925	FBFA	DISKTYPE                      		  0739,  1296,
0225	F833	DISPLAYMESSAGE                		  0213,  0235,  1427,
0769	FB63	DMAADDRESS                    		  0773,  1078,  1270,
0466	F935	DUMMYINPUT                    		  0294,
0438	F908	DUMMYINSTATUS                 		  0278,
0479	F94A	DUMMYOUTPUT                   		  0306,  0343,  0354,  0365,
0451	F91D	DUMMYOUTSTATUS                		  0331,

1437	FE81	END                           		
0237	F840	ENTERCPM                      		  0219,  1398,

0039	005C	FCB                           		
0628	0001	FLOPPY5                       		  0640,  1297,
0642	FA42	FLOPPY5PARAMETERBLOCK         		  0597,  0605,
0787	FB6B	FLOPPY5SKEWTABLE              		  0594,  0602,  0618,
0629	0002	FLOPPY8                       		  0657,
0660	FA52	FLOPPY8PARAMETERBLOCK         		  0613,  0621,
0811	FBB3	FLOPPY8SKEWTABLE              		  0610,
1241	FD45	FLOPPYBYTECOUNT               		  1256,  1326,
1234	FD40	FLOPPYCOMMAND                 		  1254,  1280,  1294,  1335,  1401,
1242	FD47	FLOPPYDMAADDRESS              		  1271,  1328,
1238	FD42	FLOPPYHEAD                    		  1258,  1321,
1244	FD4B	FLOPPYNEXTCONTROLLOCATION     		  1279,  1334,
1243	FD49	FLOPPYNEXTSTATUSBLOCK         		  1277,  1332,
1235	0001	FLOPPYREADCODE                		  1252,  1292,
1240	FD44	FLOPPYSECTOR                  		  1268,  1324,
1239	FD43	FLOPPYTRACK                   		  1265,  1308,
1237	FD41	FLOPPYUNIT                    		  1262,  1305,
1236	0002	FLOPPYWRITECODE               		  1248,  1289,

0272	F86A	GETCONSOLESTATUS              		  0266,
0323	F89C	GETLISTSTATUS                 		  0316,

1319	FDCB	HEAD0                         		  1315,
0841	FBD3	HOME                          		  0062,
0846	FBDD	HOMENOWRITE                   		  0844,

0886	FBE4	INBUFFERDISK                  		  1160,  1303,
0885	FBE4	INBUFFERDKTRKSEC              		  1037,
0888	FBE7	INBUFFERSECTOR                		  1042,  1164,  1312,
0887	FBE5	INBUFFERTRACK                 		  1162,  1306,
0208	F713	INITIALIZECOMPLETE            		  0190,
0187	F6FD	INITIALIZELOOP                		  0206,
0196	F707	INITIALIZENEXTBYTE            		  0204,
0201	F70A	INITIALIZEPORT                		  0192,
0079	F633	INITIALIZESTREAM              		  0185,
0004	00DB	INOPCODE                      		  0489,  0501,  0517,
0509	F960	INPUTDATA                     		  0457,  0460,  0465,  0513,
0518	F96E	INPUTDATAPORT                 		  0516,
0486	F94B	INPUTSTATUS                   		  0431,  0434,  0437,  0511,
0490	F950	INPUTSTATUSPORT               		  0488,
0029	0003	IOBYTE                        		  0210,  0273,  0289,  0301,  0324,  0336,  0348,  0361,

0021	1F00	LENGTHINBYTES                 		
0020	0008	LENGTHINK                     		  0023,
0110	000A	LF                            		  0126,  0130,  0136,  0143,  0150,  0157,  0164,
0333	F8AC	LIST                          		  0059,
0308	F894	LISTST                        		  0069,

0013	0040	MEMORYSIZE                    		  0023,
0009	3830	MONTH                         		  0118,
1185	FD35	MOVEDKTRKSEC                  		  0982,
1187	FD37	MOVEDKTRKSECLOOP              		  1194,
0920	FBF7	MUSTPREREADSECTOR             		  0947,  1009,  1015,  1055,
0892	FBE9	MUSTWRITEBUFFER               		  0842,  1049,  1059,  1093,  1150,

0632	0080	NEEDDEBLOCKING                		  0640,  0741,
1007	FC5F	NOTRACKCHANGE                 		  1002,
0697	FB2B	NUMBEROFLOGICALDISKS          		  0710,

0005	00D3	OUTOPCODE                     		  0199,  0531,
0522	F970	OUTPUTDATA                    		  0472,  0475,  0478,  0526,
0532	F97F	OUTPUTDATAPORT                		  0529,
0498	F956	OUTPUTSTATUS                  		  0444,  0447,  0450,  0524,
0502	F95B	OUTPUTSTATUSPORT              		  0500,

0027	0000	PAGEZERO                      		
1019	FC6E	PERFORMREADWRITE              		  0950,  1010,
0864	0012	PHYSICALSECPERTRACK           		  0866,
0072	0200	PHYSICALSECTORSIZE            		  0074,  0865,  1325,
0345	F8BC	PUNCH                         		  0060,

0041	007D	RANDOMRECORDPOSITION          		
0937	FBFB	READ                          		  0067,
0358	F8CD	READER                        		  0061,
1251	FD52	READNODEBLOCK                 		  0940,
0923	FBF8	READOPERATION                 		  0946,  0971,  1088,
1291	FD9A	READPHYSICAL                  		  1057,
1053	FCA3	READSECTORINTOBUFFER          		  1031,
1011	FC66	REQUESTPREREAD                		  0989,  0996,

0868	0002	SECTORBITSHIFT                		
1063	FCB1	SECTORINBUFFER                		  1045,
0867	0003	SECTORMASK                    		  1065,
1048	FC9C	SECTORNOTINBUFFER             		  1040,
0827	FBCD	SECTRAN                       		  0070,
0707	FB2B	SELDSK                        		  0063,
0898	FBEA	SELECTEDDISK                  		  0713,  1159,  1260,
0907	FBF0	SELECTEDDISKDEBLOCK           		
0906	FBEF	SELECTEDDISKTYPE              		
0897	FBEA	SELECTEDDKTRKSEC              		  0980,  0993,  1038,
0904	FBEE	SELECTEDPHYSICALSECTOR        		  1026,  1043,  1163,
0900	FBED	SELECTEDSECTOR                		  0762,  1022,  1064,  1267,
0899	FBEB	SELECTEDTRACK                 		  0753,  1161,  1264,
0374	F8DC	SELECTROUTINE                 		  0274,  0290,  0302,  0327,  0339,  0352,  0363,
0376	F8DD	SELECTROUTINE21               		
0770	FB65	SETDMA                        		  0066,  0249,
1158	FD11	SETINBUFFERDKTRKSECTOR        		  1054,
0760	FB5E	SETSEC                        		  0065,
0750	FB58	SETTRK                        		  0064,  0848,
0112	F643	SIGNONMESSAGE                 		  0212,

0398	0001	TERMINALDATAPORT              		  0417,
0458	F926	TERMINALINPUT                 		  0292,
0400	007F	TERMINALINPUTREADY            		  0419,
0432	F8FC	TERMINALINSTATUS              		  0276,
0473	F93E	TERMINALOUTPUT                		  0304,  0341,  0356,  0367,
0399	0080	TERMINALOUTPUTREADY           		  0418,
0445	F911	TERMINALOUTSTATUS             		  0329,
0397	0002	TERMINALSTATUSPORT            		  0416,
0415	F8EE	TERMINALTABLE                 		  0433,  0446,  0459,  0474,
0393	00EC	TTYDATAPORT                   		  0412,
0455	F920	TTYINPUT                      		  0291,
0395	0002	TTYINPUTREADY                 		  0414,
0429	F8F6	TTYINSTATUS                   		  0275,
0470	F938	TTYOUTPUT                     		  0303,  0340,  0353,  0364,
0394	0001	TTYOUTPUTREADY                		  0413,
0442	F90B	TTYOUTSTATUS                  		  0328,
0392	00ED	TTYSTATUSPORT                 		  0411,
0410	F8EA	TTYTABLE                      		  0430,  0443,  0456,  0471,

0912	FBF1	UNALLOCATEDDISK               		
0911	FBF1	UNALLOCATEDDKTRKSEC           		  0981,  0994,
0914	FBF4	UNALLOCATEDSECTOR             		
0913	FBF2	UNALLOCATEDTRACK              		  1004,  1006,
0915	FBF5	UNALOCATEDLRECORDCOUNT        		  0944,  0979,  0987,  0991,  1013,

0008	3130	VERSION                       		  0115,

1415	FE50	WAITFORBOOTCOMPLETE           		  1418,
1343	FDF7	WAITFORDISKCOMPLETE           		  1285,  1346,
0054	F603	WARMBOOTENTRY                 		  0028,  0242,
1430	FE67	WARMBOOTERROMESSAGE           		  1426,
1425	FE5E	WARMBOOTERROR                 		  1422,
1400	FE3B	WARMBOOTREAD                  		  1394,  1397,
1404	FE43	WARMBYTEMOVE                  		  1410,
1391	FE29	WBOOT                         		  0055,  1428,
0965	FC15	WRITE                         		  0068,
0877	0000	WRITEALLOCATED                		
0878	0001	WRITEDIRECTORY                		  1142,
1247	FD4D	WRITENODEBLOCK                		  0968,
1288	FD95	WRITEPHYSICAL                 		  1051,  1151,
0881	FBE3	WRITETYPE                     		  0949,  0973,  1141,
0879	0002	WRITEUNALLOCATED              		  0948,  0974,

0011	3531	YEAR                          		  0124,
