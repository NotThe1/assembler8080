;Source File name - binaryCopyOfUnarcca.com-8080
;Generated by - ManualDisassembler V A.0 on Tue Dec 29 11:01:53 EST 2015

ASCII_MASK		EQU		7FH			; Ascii mask 7 bits

NULL			EQU		00H			; Null
SOH				EQU		01H			; Start of Heading
CTRL_C			EQU		03H			; ETX
BELL			EQU		07H			; Bell
LF				EQU		0AH			; Line Feed
CTRL_K			EQU		0BH			; VT - Vertical tab
CR				EQU		0DH			; Carriage Return
CTRL_S			EQU		13H			; X-OFF
SPACE			EQU		20H			; Space
EXCLAIM_POINT	EQU		21H			; Exclamtion Point
DOLLAR			EQU		24H			; Dollar Sign
PERCENT			EQU		25H			; Percent Sign
PERIOD			EQU		2EH			; Period
EQUAL_SIGN		EQU		3DH			; equal Sign
QMARK			EQU		3FH			; Question Mark
ASCII_A			EQU		'A'	
ASCII_C			EQU		'C'	
ASCII_R			EQU		'R'	
ASCII_K			EQU		'K'
ASCII_LO_A		EQU		'a'
ASCII_LO_K		EQU		'K'
LEFT_CURLY		EQU		'{'			; Left curly Bracket	
DEL				EQU		7FH			; Delete Key	

FullNameSize	EQU		11			; name (8) + Ext (3) = 11

;command line flags
flagNoPause		EQU		'P'			; no screen pause
flagPrint		EQU		'N'			; print flag
flagCheckValidity	EQU	'C'			; check file validity
ARC_SOE			EQU		01AH		; Start of File

vGetConInput	EQU		01H			; A <- ASCII char
vConsoleOutput	EQU		02H			; E has Char to output, no return value
vListOutput		EQU		05H			; E has Char to output, no return value
vPrintString	EQU		09H			; DE buffer address, $ terminated, no return value
vGetConStat		EQU		0BH			; A<- 00/non zero
vGetVersion		EQU		0CH			; HL< - Version Number
vSelectDisk		EQU		0EH			; E has Disk number
vOpenfile		EQU		0FH			; DE - FCB | A<- FF if not found
vCloseFile		EQU		10H			; DE - FCB | A<- FF if not found
vSearchForFirst	EQU		11H			; DE - FCB | A<- directory code
vDeleteFile		EQU		13H			; DE - FCB | A<- nothing
vReadSeq		EQU		14H			; DE - FCB | A<-error code
vWriteSeq		EQU		15H			; DE - FCB | A<-error code
vMakeFile		EQU		16H			; DE - FCB | A<- FF if no DIR Space
vGetCurDisk		EQU		19H			; A <- current disk
vSetDMA			EQU		1AH			; DE - DMA address, no return value
vGetDPB			EQU	 	1FH			; HL <- Disk Parameter Block address
vReadRandom		EQU		21H			; DE - FCB | A<- nothing error codes in BA & HL
vSetRandRec		EQu		24H			; DE - FCB | r0,r1,r2

CODE_LXI		EQU		031H		; byte value of LXI command
CODE_CPI		EQU		0FEH		; byte value of CPI command
CODE_MVI		EQU		00EH		; byte value of MVI command

;-------------------------------------------------------------------------------------
; BasePageCPM.asm
;
RAM			EQU		0		; Start of RAM (and the base page)
			ORG		RAM		; Set location counter to RAM base
WarmBoot:	DS		3		; Contains a JMP to warm boot entry in BIOS jump vector table
BiosPage	EQU		RAM + 2	; BIOS jump vector page
IOBYTE:		DS		1		; Input/output redirection byte
CurUser:	DS		1		; Current User ( bits 7-4) hi-nibble
CurDisk		EQU		CurUser	; Default logical disk ( bits 3-0) lo-nibble
							;    0 =A, 1 = B ...
BDOSE:		DS		3		; Contains a JMP to BDOS entry
TopRam		EQU		BDOSE+2	; Top palle of usable RAM
			ORG		RAM + 05CH
FCB1:		DS		16		; F11e control block #1. Note, if you use this FCB here
							;   you will overwrite FCB2 below.
FCB2:		DS		16		; File control block #2. You must move this to another
							;   place before using it
			ORG		RAM + 080H
ComTail:					; Complete command tail
ComTailCount:	DS	1		; Count of the number of chars in command tail (CR not incl.)
ComtailChars:	DS	127		; Characters in command tail converted to uppercase and
							;   without trailing carriage ret.
			ORG		RAM + 080H	; redefine command tail area
DMAbuffer:	DS		128		; Default "DMA" address used as a 128-byte record buffer
			ORG		RAM + 0100H
TPA:						; ,Start of transient program area where programs are loaded.
;-------------------------------------------------------------------------------------


;				  ORG  00100H


;     <New code fragment-----from 0100 to 0102 ( 102 :  258)>
;              ORG  00100H
CodeStart:
				JMP		BEGIN ;004B6H

;     <New constant fragment-----from 0103 to 010E ( 10E :  270)>
;              ORG  00103H
pageOverhead:	DB		008H		; read Only - checked to see if there is enough memory to do this
L0104:			DB		000H		; read Only
maxDrive:		DB		010H		; read Only - L0105
L0106:			DB		010H		; read Only
L0107:			DB		0FFH		; read Only
L0108:			DB		000H		; read Only
L0109:			DB		000H		; read Only
L010A:			DW		L0106		; read Only

pauseLimit:		DB		23			; read Only - L010C
L010D:			DB		000H		; read & write  ****
L010E:			DB		0FFH		; read Only


;     <New literal fragment-----from 010F to 013B ( 13B :  315)>
;              ORG  0010FH
				DB		'COMCM'
				DB		0C4H
				DB		'EXEOBJOV'
				DB		DOLLAR
				DB		'REL'
				DB		DOLLAR
				DB		'RLINTSYSBADLBRARCARK'
				DB		DOLLAR
				DB		'Q'
				DB		DOLLAR
				DB		DOLLAR
				DB		'Z'
				DB		DOLLAR

;     <New constant fragment-----from 013C to 014B ( 14B :  331)>
;              ORG  0013CH
				DB		000H
				DB		000H,000H,000H,000H,000H
				DB		000H,000H,000H,000H,000H
				DB		000H,000H,000H,000H,000H

;     <New literal fragment-----from 014C to 0499 ( 499 : 1177)>
;              ORG  0014CH
				DB		'UNARC  1.6  27 Mar 87'
				DB		CR
				DB		LF
				DB		'CP/M Archive File Extractor (8080 Version)'
				DB		CR
				DB		LF
				DB		LF
				DB		'Usage:  '
				DB		SOH
				DB		'[d:]arcfile[.typ] [d:][afn] [N|P|C]'
				DB		CR
				DB		LF
				DB		LF
				DB		'Examples:'
				DB		CR
				DB		LF
				DB		'B>'
				DB		SOH
				DB		'A:SAVE.ARK *.*  # List all files in CP/M archive SAVE on drive A'
				DB		CR
				DB		LF
				DB		'B>'
				DB		SOH
				DB		'A:SAVE.ARC *.*  # List all files in MS-DOS archive SAVE on drive A'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE            # Same as either of above'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.* N      # Same as above (no screen pauses)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.DOC      # List just .DOC files'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE READ.ME    # Typeout the file READ.ME'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE READ.ME N  # Typeout the file READ.ME (no screen pauses)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE A:         # Extract all files to drive A'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE B:*.DOC    # Extract .DOC files to drive B'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE C:READ.ME  # Extract file READ.ME to drive C'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE PRN.DAT P  # Print the file PRN.DAT (no formatting)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.* C      # Check validity of all files in archive'
				DB		CR
				DB		LF
				DB		LF
				DB		'Copyright (C) 1986  1987 by Robert A. Freed'

;     <New unknown fragment-----from 049A to 04B2 ( 4B2 : 1202)>
;              ORG  0049AH
				DS		00019H

;     <New code fragment-----from 04B3 to 0D99 ( D99 : 3481)>
;              ORG  004B3H
				JMP		00000H
BEGIN:
				SUB		A
				MVI		C,vPrintString
				LXI		D,messZ80
				CPO		BDOSE						; never makes the call, because we are  8080 
				LXI		H,00000H					;  standard procedure
				DAD		SP							;      for orderly return
				SHLD	ccpStackSave				;         to CCP
				CALL	checkENV					; checks - CP/M ver, Memory Space
				LXI		SP,appStack					;  Set applications stack - 0172EH
				LXI		H,buffer1					; 0172EH
				LXI		B,01200H					; Fill 00 for 12H bytes
				CALL	fillMemWithC
				CALL	parseComTail				; 005AAH
				CALL	00833H						; came back with QMARKS is Subject file name;
				LXI		H,00003H					; load b with a limit count
				MOV		B,L
findEntryStart:
				CALL getNextRawValue				; returns with first byte in Acc
				CPI  ARC_SOE						; is this the start of an Entry ?
				JZ   entryFound						; jump if it is.
				DCR  B								;  else count down
				JNZ  findEntryStart					;  and try again if not done
L04EB:
				CALL getNextRawValue					; 00738H
				CPI  ARC_SOE						; is this the start of an Entry ?						
				JNZ  0053FH							; skip if not
; end of the physical File ?
entryFound:
				CALL getNextRawValue				; is the return byte 00 - End of ARK file
				ORA  A								; Zero ?
				JZ   endOfArkFile					; jump if it is
	; this must be the start of a file ie 1A 08
processEntry:
				CALL loadBuffHeader					;  else move 1C/18 bytes of data  into bufferHeader
				CALL setSubFileName					; move file name to 1750 
				JNZ  pointAtNextEntry				; skip if header file name not matching target file name
				CALL 00EC4H				; display file info????
				CALL 0090CH
				CALL 00900H
				JNZ  cleanUp			; 00531H
				
pointAtNextEntry:
				LXI		H,fileStored				; get number of bytes to the next entry
				CALL	dblWord2Regs				; HL+0 =>E, HL+1 =>D, HL+2 =>C, HL+3=>B
				CALL 0076BH
				LXI  H,00000H
				JMP  004EBH
				
endOfArkFile:
				LHLD buffer1						; 0172EH
				MOV  A,H
				ORA  A
				JNZ  0052EH
				ORA  L
				LXI  D,messNoMatchingFile			; 01411H
				JZ   sendErrorMess				; 0059BH
				DCR  A
L052E:
				CNZ  00F1DH
cleanUp:										; L0531
				CALL closeFiles					; 006D2H
				LDA  00103H
				ORA  A
				JZ   00000H						; do a warm boot or
												;    return to CCP

				; modified code *****
				DB		CODE_LXI				; LXI
ccpStackSave:	DW		0000H

				RET
				
L053F:
				CALL 00764H
				CALL getNextRawValue					; 00738H
L0545:
				CPI  01AH
				JNZ  0053FH
				CALL getNextRawValue					; 00738H
				PUSH PSW
				DCR  A
				CPI  009H
				JNC  0056AH
				XCHG
				LXI  H,0140BH
				LXI  B,00000H
				CALL hexToAsciiDisplay2
				MVI  M,000H
				LXI  D,messBadArchHeader			; 013D8H
				CALL sendStringNL00NL				; 00F7FH
				POP  PSW
				JMP  processEntry
L056A:
				CALL 00764H
				POP  PSW
				JMP  00545H
;
; Make sure the OS is up to date ie Ver 2.0 or later.
; Make sure there is enough memory > 1700H
;				
checkENV:
				XRA		A    			; clear Acc
				STA		openSource			; 006D6H
				STA		openSpecFile			; 006DEH
				STA		pauseFlag		; clear the pause Flag (no-Pause);
				MVI		C,vGetVersion
				CALL	BDOSE 			; HL has Version Number and  Acc?
				CPI		020H      		; is it at least Ver 2.0 ?
				LXI		D,messVer		; 01353H
				JC		sendErrorMess0	; no , jump - 0059AH 
				LDA		TopRam  		; get page number of start of DBOS
				LXI		H,pageOverhead	; point at stored value (08) - 00103H 		
				SUB		M  				; subtract fom BDOS page start
				STA		workingMemory	;  result = 0xE0H, put it away
				MVI		A,017H			; minimum number of pages needed to run
L0594:
; modified code *****
				DB		CODE_CPI		; CPI
workingMemory:	DB		00H				;  check against need memory

				RC             			; return if there is enough Memory
				
				LXI  D,messNEMemory		; Else send not enough memory message 01375H
sendErrorMess0:							; L059A:
				POP  H
sendErrorMess:
				CALL sendStringNL00
sendAbortMess:
				LXI  D,messAborted
sendStringNL00NL:
				CALL sendStringNL00	
				CALL sendNL
				JMP  cleanUp			; cleanup and exit
;
; See if there are any command line flags - N|P|C
;
				
parseComTail:
				LXI  H,ComTailCount
				MOV  E,M       			; get number of bytes in the buffer
				MVI  D,000H 			; set hibyte to zero
				DAD  D 					; point at the end of the buffer
				DCX  H 					; is the next
				MOV  A,M       			;   to last character
				CPI  SPACE 				;    a Space ?
				JNZ  parseComTail2		; skip if no	
				INX  H 					; else look at last char, its a flag
				MOV  A,M       			; get the flag
				CPI  flagNoPause		; is there a No-Pause flag ?
				JZ   parseComTail3		; skip if yes
				CPI  flagPrint			; else - is there a Print flag
				JNZ  parseComTail1		; skip if no		
				STA  printFlag			; else store P in the print flag
parseComTail1:
				CPI  flagCheckValidity	; Is it a Check Valitity flag ?
				JNZ  parseComTail2		; skip if no - 005CFH
				STA  checkValidFlag		; else store if checkValidFlag 
parseComTail2:
				LDA  pauseLimit			; get the number of lines to show before pausing
				STA  pauseFlag			; set flag non zero (pauseLimit) else empty for no-pause option
				STA  pauseCount			; set up count down to pause 
; past the cmd line flags [N|P|C]
parseComTail3:
				MVI  A,SPACE
				LXI  H,FCB2				; cmd arg 2 expanded FCB 
				LXI  D,targetDrive	
				PUSH PSW
				MOV  A,M				; a<- (M)
				STAX D 					; in targetDrive NULL means no writing of extracted files
				INX  H
				INX  D
				DCX  B  				; ????????
				POP  PSW       			; get the space back into Acc	
				LXI  D,subjectFiles
				LXI  B,FullNameSize		; filename and ext length 8 + 3 = 11 - 0000BH
				CMP  M 					; does FCB2 contain a SPACE ?
				JNZ  parseComTail4		; skip if not -  005F7H 				
				MOV  H,D 				; place memory pointer
				MOV  L,E       			;    into from DE to HL
				MVI  M,QMARK			; put QMARK into memory - (1744)
				INX  D  				; set up fill Target files with QMARKS
				DCX  B 
; put in ext if its not there				
parseComTail4:
				CALL moveHLtoDE			; put the target file FCB into Target Files
				LXI  H,FCB1 + 9			; point at ext for FCB1
				CMP  M					; if SPACE for ARK extension
				JNZ  parseComTail5		; skip , else force to ARK
				MVI  M,ASCII_A
				INX  H
				MVI  M,ASCII_R
				INX  H
				MVI  M,ASCII_K
				STA  flagOS				; 0173DH
parseComTail5:							; L060C:
				LXI  H,FCB1 +1
				CMP  M 					; file name start with a SPACE ?
				JZ   noComTail 			; skip if Yes - display usage and go back to CCP
				PUSH H 					; save fcb1 pointer
				CALL anyQMarks			; Does FCB1 have any QMARKS? (Zero flag set if yes)
				LXI  D,messAmbigFile	; we dont want any. Only one Archive file!
parseComTail6:	
				JZ   sendErrorMess		;  get outta here if FCB1 is Ambiguous
				POP  D         			; put the Arc file's into DE - FCB1 
				LXI  H,messArcFileName	; put Archive file's FCB into HL for cleanup
				MVI  C,SPACE			; remove spaces and insert Period
				CALL trimFullName		;    and put into location pointed at by HL
				XRA  A					; set Acc = 0
				MOV  M,A				;   terminate the string -messArcFileName- with NULL
				DCR  A
				STA  bufferPointer		; Store -1  as flag to read 
				LXI  H,FCB1				; points at the disk (0= current, 1 = A, 2= B)
				LDA  maxDrive			; 00105H - L0105
				CMP  M					; is it a good drive number ?
				LXI  D,messBadArchFileDrive		; load message if not
				JC   sendErrorMess		; Jump to send error message if drive not valid
				XCHG					; load DE with FCB1, the archive file
				MVI  C,vOpenfile
				CALL sysCall			; open it
				JNZ  haveArcFile		; returns 0 (FF inc 1), if failed. jump if sucsessful open - 00656H				
				LXI  H,flagOS			;   else not valid open
				ORA  M					; 	is it an MS-DOS File ?
				LXI  D,messMissingArchiveFile
				JZ   parseComTail6		; if Yes do a clean exit out.
				MVI  M,000H				;    else force osFlag to MS-DOS
				LXI  H,FCB1 + 11		; point at last char of ext - 00067H
				MVI  M,ASCII_C			; force type to be ARC
				JMP  parseComTail5		; retry with file ext of ARC
				
haveArcFile:							; L0656:
				STA  openSource			; save the return code for late testing - 006D6H
				LXI  D,messArchFileEqual
				CALL sendStringNL00NL	; Display - Archive File = .....
				LDA  00104H				; this is the only reference to 104
				ORA  A					; if 104 is Zero then
				CZ   in106Not
				JNZ  setBlockSize		; SKIP if 106 was zero  and set blockSizeInK to 1
calcBlockSize:							; L0669
				LDA  0010DH				; else, check if 10D is Zero
				ORA  A
				JNZ  setBlockSize		; set blockSizeInK to (10D) if it is not empty
				MVI  C,vGetDPB			; else get BLM from Disk Parameter Block and Calc
				CALL BDOSE				; HL points to the Disk Parameter BlocK
				INX  H
				INX  H					; at BSH (Block Shift)
				INX  H					; at Block Mask
				MOV  A,M				; get the Block Mask
				INR  A
				RRC
				RRC
				RRC
setBlockSize:								; L067D
				STA  blockSizeInK
				RET
;
;   if no comm tail then display usage and go back to CCP
;				
noComTail:									; L0681:
				CALL in106Not
				PUSH PSW
				DCR  A
				JZ   noComTail1				; if 104 = 0, skip
				LDA  00106H					; else load contents of 106 ie 10
				ORA  A
noComTail1:
				LXI  H,001ABH
				LXI  B,00480H
				CZ   fillMemWithC
				LXI  H,00357H
				MVI  B,09DH
				CZ   fillMemWithC
				POP  PSW
				JZ   noComTail2
				LXI  H,001B7H
				MVI  B,004H
				CALL fillMemWithC
				LXI  H,003F4H
				MVI  B,07AH
				CALL fillMemWithC
				LDA  00107H
				ORA  A
				LXI  H,002E6H
				MVI  B,071H
				CZ   fillMemWithC
noComTail2:
				LXI  D,0014CH
				JMP  sendStringNL00NL		;005A1H
				
;
;			Check the value found by indirectly addrssing 10A, ie at location 106
;			If it is zero make Acc = 1 reset Zero flag & return.
;			if it is not Zero make Acc = 0, set Zero flag & return
in106Not:								; L06C4:
				PUSH H
				LHLD 0010AH
				MOV  A,M
				POP  H
				ORA  A
				JNZ  in106Not1			; if its not 0, jump, zero out and return
				INR  A					; set Acc to 1, reset zero flag
				RET
in106Not1:
				XRA  A					; clear register and set Zero flag
				RET
				
				
closeFiles:								; L06D2:
				LXI  D,FCB1		; point at the Archive file itself
				
; modified code *****
				DB	CODE_MVI			; MVI
openSource:		DB	00H					; return from OpenFile +1 : 0= file not open , we have a 4?

				CALL closeOneFile		; 006DFH
closeSubjectFile:						; L06DA
				LXI  D,targetDrive		; 0174FH
				
; modified code *****
				DB	CODE_MVI			; MVI
openSpecFile:	DB	00H					; 0= file is not open

closeOneFile:							; L06DF:
				ORA  A					; is the file currently open ?
				MVI  C,vCloseFile
				CNZ  BDOSE				; if yes, then close it
				INR  A					; set Acc to 1
				RET						; and exit
				
sysCall0:									; L06E7
				LXI  D,targetDrive		; 0174FH
sysCall:									; L06EA
				CALL BDOSE
				INR  A
				RET
;		SetDMA - called with DE pointing to the Address
setDMA:										;L06EF:
				MVI  C,vSetDMA
				CALL BDOSE					; set dma to default 80
checkConsoleIn:								; L06F4
				MVI  C,vGetConStat
				CALL BDOSE
				ORA  A
				RZ							; return if no character pending from Console
				MVI  C,vGetConInput
				CALL BDOSE
				ANI  ASCII_MASK
				CPI  CTRL_S					; X-OFF 013H
				MVI  C,vGetConInput
				CZ   BDOSE
				ANI  ASCII_MASK
				CPI  CTRL_C					; ETX 003H
				JZ   00713H					; abort if CTRL_C sent
				CPI  CTRL_K					; VT	00BH
				RNZ
L0713:
				JMP  sendAbortMess			; 0059EH
				
				
L0716:
				CALL swapAllRegisters
L0719:
				PUSH B
				PUSH D
				PUSH H
				LXI  H,fileStored
				MVI  B,004H
L0721:
				MOV  A,M
				DCR  M
				ORA  A
				JNZ  getNextRawValue1
				INX  H
				DCR  B
				JNZ  00721H
				MVI  B,004H
L072E:
				DCX  H
				MOV  M,A
				DCR  B
				JNZ  0072EH
				STC
				JMP  restoreRegsBCDEHL
;
; Return the next byte from the read buffer in the Acc.
;  read the next sector if necessary.
;
getNextRawValue:								; L0738:
				PUSH B
				PUSH D
				PUSH H
getNextRawValue1:						; L073B
				LHLD bufferPointer		; L1740
				INR  L
				CZ   readSeq			; call read seq if 1740 was -1 (initialized -1)
				SHLD bufferPointer		; save buffer pointer in 01740H
				MOV  A,M				; get the first byte from buffer
restoreRegsBCDEHL:						; L0746:
				POP  H
				POP  D
				POP  B
				RET
readSeq:								; L074A
				MVI  C,vReadSeq			; 014H
readFile:								; L074C
				LXI  D,00080H			; point at default FCB
				PUSH D
				PUSH B
				CALL setDMA				; 006EFH
				LXI  D,FCB1
				POP  B					; get the kind of read
				CALL BDOSE				; do the read
				POP  H
				ORA  A
				RZ
badArcFileFmt:
				LXI  D,messInvalidArcFileFmt			;013BCH
				JMP  sendErrorMess		; 0059BH
L0764:
				INX  H
				MOV  A,H
				ORA  L
				RNZ
				JMP  badArcFileFmt			; exit
				
L076B:
				MOV  A,B
				ORA  A
				JNZ  badArcFileFmt			; exit B must be zero
				MOV  A,E					; get least byte
				MOV  L,D					; get mid byte
				MOV  H,C					; get hi byte
				ADD  A						; double least byte
				PUSH PSW					; save above
				MOV  A,L					; get mid byte
				ADC  L						; double it
				MOV  L,A					; put back in L
				MOV  A,H					; get hi byte
				ADC  H						; double it
				MOV  H,A					; put back
				JNZ  00780H
				INR  L
				DCR  L
L0780:
				XTHL
				MOV  A,H
				POP  H
				JC   badArcFileFmt			; exit
				RAR
				XCHG
				LXI  H,bufferPointer		; L1740
				ADD  M
				MOV  M,A
				INR  A
				JP   00798H
; Label ??
				MOV  A,D
				ORA  E
				RZ
				DCX  D
				JMP  0079BH
L0798:
				ADI  07FH
				MOV  M,A
L079B:
				PUSH D
				LXI  D,0005CH
				MVI  C,vSetRandRec
				CALL BDOSE
				LHLD 0007DH
				POP  D
				DAD  D
				JC   badArcFileFmt			; exit
				SHLD 0007DH
				MVI  C,vReadRandom				; 021H
				CALL readFile					; 0074CH
				LXI  H,0007CH
				INR  M
				RET
;		get data from buffer and put into bufferHeader.
;       move 18H bytes if Acc= 1, else make it 1CH bytes
loadBuffHeader:									; L07B9
				LXI  D,bufferHeader
				MVI  B,01CH						; put a counter in B ??
				CPI  001H						; does Acc = 01?
				PUSH PSW						; save the second byte 1A
				JNZ  loadBuffHeader2						; skip if != 01
				MVI  B,018H						; put a diferent counter in B ??
				JMP  loadBuffHeader2
loadBuffHeader1:
				CALL getNextRawValue					; 00738H
loadBuffHeader2:								; L07CC
				STAX D
				INX  D
				DCR  B
				JNZ  loadBuffHeader1			; loop if not done
				POP  PSW
				RNZ
				LXI  H,fileStored
				MVI  C,004H
				CALL moveHLtoDE		; 012FFH
				RET
;		move file name to 1750 
; return with Zero flag set if file in header matches target file name
setSubFileName:									; L07DD:
				LXI  D,buffSubjectFileName		; point at 1771 data moved from rawBuffer
				LXI  H,wFileName				; load for later 1750
				PUSH H
				LXI  H,subjectFiles				; get address of target file name
				SHLD ptrSubjectFile				; save it for later
				POP  H
				MVI  B,00BH
;			Most likely we have a file name here
setSubFileName1:
				LDAX D
				ANI  ASCII_MASK
				JZ   setSubFileName4			; skip if its a NULL or 80H
				INX  D	
				CPI  EXCLAIM_POINT				; is it a printable character?
				JC   setSubFileName2			; skip if not
				CPI  DEL						; is it the Delete Key ?
				JNZ  setSubFileName3			; skip if not
setSubFileName2:								; L07FE
				MVI  A,DOLLAR					; else replace the Delete with a Dollar Sign
setSubFileName3:								; L0800:
				CALL	upperCaseAcc			; 012DAH
				CPI		PERIOD
				JNZ		setSubFileName5			; jump if not a period
				MOV		A,B						; else check the count
				CPI		004H					; is it where we expect it
				JC		setSubFileName1			; yes keep going
				DCX		D						; else adjust the pointer
setSubFileName4:								; L080F
				MVI		A,SPACE					; put in a space and keep on going
setSubFileName5:								; L0811
				MOV		M,A						; put the char away
				PUSH	H
				LHLD	ptrSubjectFile			; get the pointer
				MOV		A,M						; get character from subject file Name
				POP		H
				PUSH	H
				LHLD	ptrSubjectFile			; get the pointer
				INX		H						; move it up one
				SHLD	ptrSubjectFile			; save the pointer
				POP		H
				CPI		QMARK					; is it a Question mark
				JZ		setSubFileName6			; skip if it is
				CMP		M						; does it match ?
				RNZ								; return - file is not a match
				
setSubFileName6:
				INX		H						; point at next position
				DCR		B						; count down
				JNZ		setSubFileName1			; loop if we are not done
				LXI  B,01500H
				JMP  fillMemWithC
				
				
L0833:
				LDA  00106H
				MOV  B,A
				LXI  H,checkValidFlag		; 0173FH
				CALL in106Not				; 016 has 10 in it so return with Acc =0
				DCR  A
				JNZ  00849H					; ***skip if Acc was 00 ie 106 was NOT 00
				MOV  B,A					;  else put 00 into B
				MOV  M,A					;  clear checkValidFlag or Buffer Pointer ?
				STA  0173EH					; and clear the print flag
				LDA  00107H					; and retrieve the value in 107 (FF)
L0849:	; **
				MOV  C,A					; put (FF) in C
				LDA  targetDrive			; is there a target drive specified?
				ORA  A
				JNZ  00863H					; Skip if yes - there is writing of extracted file on disk
				ORA  M						; or with check Valid Flag
				JZ   008D2H					; ***skip if check Valid Flag not set
				
				LXI  D,messCheckingArch					; 0148EH
				CALL sendStringNL00				; 00F82H
				MVI  A,0FEH
				STA  targetDrive		; 0174FH
				JMP  0088FH
L0863:
				DCR  A
				CMP  B
				LXI  D,0144BH
				JNC  sendErrorMess		; 0059BH
				MOV  E,A
				PUSH D
				ADI  041H
				STA  0148BH
				LXI  D,messOutDriveEquals				; 0147CH
				CALL sendStringNL00				; 00F82H
				MVI  C,vGetCurDisk
				CALL BDOSE
				POP  D
				CMP  E
				PUSH PSW
				MVI  C,vSelectDisk
				CNZ  BDOSE
				CALL calcBlockSize
				POP  PSW
				MOV  E,A
				MVI  C,vSelectDisk
				CNZ  BDOSE
L088F:
				LXI  H,01900H
				MOV  A,H
				CALL 00594H
				LXI  D,0A001H
L0899:
				MOV  A,L
				LXI  B,00800H
L089D:
				ORA  A
				PUSH PSW
				MOV  A,C
				RAR
				INR  A
				DCR  A
				MOV  C,A
				XTHL
				MOV  A,H
				POP  H
				RAR
				JNC  008C5H
				PUSH H
				PUSH PSW
				LHLD 01792H
				XTHL
				SHLD 01792H
				POP  PSW
				POP  H
				MOV  A,C
				XRA  D
				MOV  C,A
				PUSH H
				PUSH PSW
				LHLD 01792H
				XTHL
				SHLD 01792H
				POP  PSW
				POP  H
				XRA  E
L08C5:
				DCR  B
				JNZ  0089DH
				MOV  M,C
				DCR  H
				MOV  M,A
				INR  H
				INR  L
				JNZ  00899H
				RET
				
L08D2:	; ***
				ORA  C				; Acc has target drive
				CNZ  00900H			; Call if no target drive specified and C was 00??
				RZ					; return if there are any QMARKS in Subject files
;
; Subject file is has no QMARKS in it
;
				LXI  D,0010FH
L08DA:
				LXI  H,0174CH		; popint at subject files wxr	
				MVI  B,003H
L08DF:
				LDAX D				; get character
				ORA  A
				JZ   008FBH			; skip if its a NULL
				CPI  QMARK			; is it a QMARK
				JZ   008EAH			; skip if yes
				CMP  M
L08EA:
				INX  D
				JZ   008F5H
				DCR  B
				JNZ  008EAH
				JMP  008DAH
L08F5:
				INX  H
				DCR  B
				JNZ  008DFH
				RET
L08FB:
				DCR  A
				STA  targetDrive		; 0174FH
				RET

L0900:
				LXI  H,subjectFiles
;
;   Are there any QMARKS if the FCB pointed at by HL
;	Return with Zero flag Set if yese
;
anyQMarks:
				LXI  B,FullNameSize	
				MVI  A,QMARK
				CALL haveValue
				RET					; return with Zero Flag set if QMARK found
				
L090C:
				LDA  targetDrive		; 0174FH
				ORA  A
				RZ
				MOV  B,A
				LDA  bufferHeader
				CPI  00AH
				LXI  D,messNeedNewerArch				; 014A2H
				JNC  sendErrorMess		; 0059BH
				MOV  L,A
				MVI  H,000H
				LXI  D,00D99H
				DAD  D
				MOV  A,M
				CALL 00594H
				LXI  H,01796H
				MOV  M,A
				MOV  C,A
				INX  H
				LDA  00595H
				MOV  M,A
				INR  B
				JNZ  0095FH
				LDA  00108H
				ORA  A
				CZ   in106Not
				JZ   00949H
				ADD  C
				JC   00949H
				CMP  M
				JNC  00949H
				MOV  M,A
L0949:
				LDA  0173EH
				ORA  A
				JNZ  0099BH
				LXI  H,OutBuffer1
				LXI  B,04E2DH
				CALL fillMemWithC
				CALL 00F17H
				JMP  0099BH
L095F:
				INR  B
				JZ   0099BH
				LXI  D,01A00H
				CALL setDMA				; 006EFH
				MVI  C,vSearchForFirst
				CALL sysCall0						; 006E7H
				JZ   0098DH
				LXI  D,messReplaceQues				; 014D5H
				CALL sendString00						; 00FBAH
L0977:
				CALL checkConsoleIn					; 006F4H
				JZ   00977H
				MOV  E,A
				CALL sendNL							; 00F85H
				MOV  A,E
				CALL	upperCaseAcc			; 012DAH
				CPI  059H
				RNZ
				MVI  C,vDeleteFile
				CALL sysCall0						; 006E7H
L098D:
				MVI  C,vMakeFile
				CALL sysCall0						; 006E7H
				LXI  D,messDirFull					; 01505H
				JZ  sendErrorMess						; 0059BH
				STA  openSpecFile						; 006DEH
L099B:
				LDA  bufferHeader
				CPI  004H
				JNC  00A01H
				CALL 00D90H
				CPI  003H
				JZ   009BAH
L09AB:
				CALL 00719H
				JC   009C0H
				CALL 00DC3H
				JMP  009ABH
L09B7:
				CALL 00DA3H
L09BA:
				CALL 00719H
				JNC  009B7H
L09C0:
				CALL 00DD5H
				LDA  targetDrive		; 0174FH
				INR  A
				RZ
				ORA  A
				XCHG
				LHLD 01786H
				PUSH PSW
				MOV  A,L
				SBB  E
				MOV  L,A
				MOV  A,H
				SBB  D
				MOV  H,A
				JNZ  009D9H
				INR  L
				DCR  L
L09D9:
				XTHL
				MOV  A,H
				POP  H
				LXI  D,messCRC							; 01593H
				CNZ  00FC4H
				LXI  H,fileLength
				CALL dblWord2Regs				; HL+0 =>E, HL+1 =>D, HL+2 =>C, HL+3=>B
				MOV  A,B
				ORA  C
				ORA  D
				ORA  E
				LXI  D,messLength							; 01597H
				CNZ  00FC4H
				CALL closeSubjectFile
				LXI  H,openSpecFile							; 006DEH
				MVI  M,000H							; reset file open flag
				RNZ
				LXI  D,messCanNotCloseOut					; 01514H
				JMP  sendErrorMess						; 0059BH
L0A01:
				JNZ  00A79H
				LXI  B,003FFH
				CALL 00A6EH
				CALL 00719H
				MOV  C,A
				CALL 00719H
				ORA  C
				JZ   00A28H
L0A15:
				MVI  B,004H
				MOV  A,D
				SUB  B
				MOV  D,A
L0A1A:
				CALL 00719H
				STAX D
				INR  D
				DCR  B
				JNZ  00A1AH
				INR  E
				DCR  C
				JNZ  00A15H
L0A28:
				CALL 00D90H
				PUSH H
L0A2C:
				CALL swapAllRegisters
				XRA  A
L0A30:
				MOV  L,A
				POP  PSW
				ORA  A
				RAR
				INR  A
				DCR  A
				JNZ  00A46H
				PUSH H
				CALL 00716H
				CALL swapAllRegisters
				JC   00A67H
				POP  H
				STC
				RAR
L0A46:
				PUSH PSW
				MVI  H,01AH
				JNC  00A4EH
				INR  H
				INR  H
L0A4E:
				MOV  A,M
				INR  H
				MOV  B,M
				INR  B
				JNZ  00A5FH
				CMA
				CALL swapAllRegisters
				CALL 00DA3H
				JMP  00A2CH
L0A5F:
				DCR  B
				JNZ  00A67H
				ORA  A
				JNZ  00A30H
L0A67:
				POP  H
L0A68:
				CALL swapAllRegisters
				JMP  009C0H
L0A6E:
				LXI  H,01A00H
				MOV  M,L
				MOV  D,H
				MOV  E,L
				INX  D
				CALL moveHLtoDE		; 012FFH
				RET
L0A79:
				LXI  H,00B85H
				MVI  M,010H
				CPI  008H
				JNC  00A9CH
				LXI  D,00D1FH
				LXI  B,04FFFH
				LXI  H,00C74H
				CPI  006H
				MVI  A,055H
				JZ   00ADBH
				JC   00AD0H
				LXI  H,00CCDH
				JMP  00ADBH
L0A9C:
				JZ   00AA9H
				MVI  M,020H
				LXI  B,05FFFH
				MVI  A,020H
				JMP  00ABCH
L0AA9:
				CALL 00719H
				JC   00AB7H
				CPI  00CH
				LXI  D,messInCompatibleCruch					; 0152DH
				JNZ  sendErrorMess							; 0059BH
L0AB7:
				LXI  B,02FFFH
				MVI  A,010H
L0ABC:
				STA  00BB0H
				LXI  H,00000H
				SHLD 01798H
				LXI  D,00BC7H
				LXI  H,00BA1H
				MVI  A,009H
				JZ   00ADBH
L0AD0:
				PUSH H
				LXI  H,00DC3H
				SHLD ptrSubjectFile
				POP  H
				JMP  00AE3H
L0ADB:
				PUSH H
				LXI  H,00DA3H
				SHLD ptrSubjectFile
				POP  H
L0AE3:
				PUSH H
				LHLD ptrSubjectFile
				SHLD 00D8EH
				POP  H
				SHLD 00B91H
				XCHG
				SHLD 00B1BH
				XCHG
				STA  0179AH
				MOV  A,B
				SUI  003H
				STA  00C3AH
				CALL 00A6EH
				PUSH H
				MOV  H,B
				MOV  L,C
				SHLD 0179BH
				POP  H
				DCX  B
				PUSH B
				XRA  A
L0B09:
				POP  B
				PUSH B
				PUSH PSW
				CALL 00B7FH
				POP  PSW
				INR  A
				JNZ  00B09H
				CALL 00D90H
L0B17:
				CALL swapAllRegisters
L0B1A:
				CALL 00000H
				POP  B
				JC   00A68H
				PUSH H
				CALL 00BBEH
				INR  B
				JNZ  00B31H
				INX  H
				MOV  A,M
L0B2B:
				CALL 00D8AH
				JMP  00B17H
L0B31:
				DCR  B
				MOV  A,M
				ORA  A
				PUSH PSW
				JNZ  00B3DH
				MOV  H,B
				MOV  L,C
				CALL 00BBEH
L0B3D:
				MVI  D,001H
L0B3F:
				MOV  A,M
				CPI  01AH
				JC   00B50H
				MOV  M,D
				MOV  D,A
				DCX  H
				MOV  A,M
				MOV  M,E
				MOV  E,A
				INX  H
				XCHG
				JMP  00B3FH
L0B50:
				INX  H
				POP  PSW
				MOV  A,M
				PUSH PSW
				DCX  H
				PUSH D
				PUSH H
				CALL 00B7FH
				POP  H
L0B5B:
				INX  H
				MOV  A,M
				PUSH H
				CALL 00D8AH
				CALL swapAllRegisters
				POP  D
				POP  H
				DCR  H
				JZ   00B78H
				INR  H
				DCX  D
				MOV  A,M
				MOV  M,D
				MOV  D,A
				DCX  H
				MOV  A,M
				MOV  M,E
				MOV  E,A
				INX  H
				PUSH D
				JMP  00B5BH
L0B78:
				POP  PSW
				JNZ  00B1AH
				JMP  00B2BH
L0B7F:
				LHLD 0179BH
				PUSH PSW
				MOV  A,H
				ANI  010H
				XTHL
				MOV  A,H
				POP  H
				RNZ
				INX  H
				SHLD 0179BH
				PUSH PSW
				PUSH B
				CALL 00000H
				XTHL
				CALL 00BBEH
				XCHG
				POP  H
				DCX  H
				MOV  M,E
				INX  H
				MOV  M,D
				INX  H
				POP  PSW
				MOV  M,A
				RET
				MOV  A,L
				DCR  L
				ORA  A
				JNZ  00BBEH
				MOV  A,H
				DCR  H
				LXI  D,0179BH
				JZ   00BBBH
				CPI  010H
				JZ   00BBEH
				ANA  H
				JNZ  00BBEH
				LXI  D,0179AH
				XCHG
				INR  M
				XCHG
L0BBE:
				MOV  D,H
				MOV  E,L
				DAD  H
				DAD  D
				LXI  D,01A01H
				DAD  D
				RET
				LXI  H,01798H
				DCR  M
				INX  H
				MOV  A,M
				INX  H
				MOV  B,M
				LXI  H,07FFFH
				ORA  A
				RAR
				INR  A
				DCR  A
				JZ   00C4EH
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				DCR  B
				JNZ  00BD2H
				ORA  A
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				JC   00BEFH
				STA  01799H
				MOV  A,H
				DCR  A
				ORA  L
				RNZ
				LXI  H,0179AH
				MOV  C,M
				MVI  M,009H
				DCX  H
				MOV  M,A
				DCX  H
				MOV  A,M
				ANI  007H
				JZ   00C35H
				MOV  B,A
				XRA  A
				MOV  M,A
				ADD  C
				DCR  B
				JNZ  00C1EH
				RAR
				RAR
				RAR
				ANI  00FH
				MOV  B,A
				PUSH B
				CALL 00716H
				CALL swapAllRegisters
				POP  B
				DCR  B
				JNZ  00C29H
				LXI  H,01D00H
				LXI  B,02CFFH
				CALL 00A71H
				LXI  H,00101H
				SHLD 0179BH
				POP  H
				XTHL
				LXI  H,0FFFFH
				XTHL
				PUSH H
				JMP  00BC7H
				PUSH B
				PUSH H
				CALL 00716H
				CALL swapAllRegisters
				POP  H
				POP  B
				RC
				PUSH PSW
				MOV  A,B
				ANI  008H
				XTHL
				MOV  A,H
				POP  H
				JNZ  00C68H
				STC
				RAR
				JMP  00BD9H
				MOV  L,H
				MOV  H,A
				MOV  A,B
				SUI  008H
				MOV  B,A
				JNZ  00C4EH
				JMP  00BEFH
				LXI  D,00000H
				MOV  L,A
				MOV  H,D
				DAD  B
				PUSH PSW
				MOV  A,H
				ORI  008H
				MOV  H,A
				POP  PSW
				PUSH PSW
				MOV  A,H
				RLC
				RRC
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				MOV  C,H
				MOV  A,L
				PUSH PSW
				MOV  A,L
				ADC  E
				MOV  L,A
				MOV  A,H
				ADC  D
				MOV  H,A
				JNZ  00CA2H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				JC   00CC2H
				MVI  B,00CH
				ORA  A
				PUSH PSW
				MOV  A,C
				RAR
				INR  A
				DCR  A
				MOV  C,A
				XTHL
				MOV  A,H
				POP  H
				RAR
				JNC  00CBBH
				XCHG
				DAD  D
				XCHG
				DAD  H
				DCR  B
				JNZ  00CAAH
				XCHG
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				MOV  L,H
				JMP  00CE4H
				MOV  L,A
				MVI  H,000H
				DAD  B
				MOV  D,H
				MOV  E,L
				DAD  H
				DAD  H
				DAD  D
				DAD  H
				DAD  H
				DAD  D
				DAD  H
				DAD  D
				DAD  H
				DAD  D
				DAD  H
				DAD  H
				DAD  H
				DAD  H
				DAD  H
				DAD  D
				MOV  A,H
				ANI  00FH
				MOV  H,A
				PUSH H
				CALL 00BBEH
				POP  D
				MOV  A,M
				ORA  A
				RZ
				LXI  B,04A00H
				PUSH H
				POP  H
				XCHG
				PUSH H
				DAD  H
				DAD  B
				MOV  E,M
				INX  H
				MOV  D,M
				MOV  A,D
				ORA  E
				JNZ  00CF3H
				XTHL
				MVI  E,065H
				DAD  D
				PUSH PSW
				MOV  A,H
				ANI  0EFH
				MOV  H,A
				POP  PSW
				PUSH H
				CALL 00BBEH
				POP  D
				MOV  A,M
				ORA  A
				JZ   00D19H
				XCHG
				INX  H
				JMP  00D04H
				XTHL
				MOV  M,D
				DCX  H
				MOV  M,E
				POP  H
				RET
				CALL 00716H
				CALL swapAllRegisters
				RC
				MOV  E,A
				LXI  H,0179AH
				PUSH PSW
				MOV  A,M
				RRC
				INR  A
				DCR  A
				MOV  M,A
				XTHL
				MOV  A,H
				POP  H
				JC   00D3DH
				DCX  H
				MOV  A,M
				ANI  00FH
				XCHG
				MOV  H,A
				RET
				PUSH D
				CALL 00716H
				CALL swapAllRegisters
				POP  H
				RC
				STA  01799H
				ANI  0F0H
				RAL  D
				MOV  H,A
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D59H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D68H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D77H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D86H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				RET
L0D8A:
				CALL swapAllRegisters
				JMP  00000H
L0D90:
				LHLD 01795H
				MVI  L,000H
				XCHG
				MOV  H,E
				MOV  L,E
				MOV  B,E
				RET

;     <New constant fragment-----from 0D9A to 0DA2 ( DA2 : 3490)>
;              ORG  00D9AH
				DB		01AH,01AH,01AH,01EH
				DB		06AH,06AH,06AH,04AH,07AH

;     <New code fragment-----from 0DA3 to 1318 (1318 : 4888)>
;              ORG  00DA3H
L0DA3:
				DCR  B
				JNZ  00DBCH
				MOV  B,A
				ORA  A
				JNZ  00DB5H
				MVI  A,090H
				JMP  00DC3H
L0DB1:
				MOV  A,C
				CALL 00DC3H
L0DB5:
				DCR  B
				JNZ  00DB1H
				RET
L0DBA:
				INR  B
				RET
L0DBC:
				INR  B
				CPI  090H
				JZ   00DBAH
				MOV  C,A
L0DC3:
				STAX D
				XRA  L
				MOV  L,A
				MOV  A,H
				MVI  H,018H
				XRA  M
				INR  H
				MOV  H,M
				MOV  L,A
				INR  E
				RNZ
				INR  D
				LDA  01797H
				CMP  D
				RNZ
L0DD5:
				PUSH H
				LHLD 01795H
				XRA  A
				MOV  L,A
				XCHG
				PUSH PSW
				MOV  A,L
				SBB  E
				MOV  L,A
				MOV  A,H
				SBB  D
				MOV  H,A
				JNZ  00DE8H
				INR  L
				DCR  L
L0DE8:
				XTHL
				MOV  A,H
				POP  H
				JZ   00E16H
				PUSH B
				MOV  B,H
				MOV  C,L
				LHLD fileLength
				PUSH PSW
				MOV  A,L
				SBB  C
				MOV  L,A
				MOV  A,H
				SBB  B
				MOV  H,A
				JNZ  00E00H
				INR  L
				DCR  L
L0E00:
				XTHL
				MOV  A,H
				POP  H
				SHLD fileLength
				JNC  00E10H
				LHLD fileLengthHI
				DCX  H
				SHLD fileLengthHI
L0E10:
				PUSH D
				CALL 00E18H
				POP  D
				POP  B
L0E16:
				POP  H
				RET
L0E18:
				LDA  openSpecFile		;006DEH
				ORA  A
				JZ   00E57H
				MOV  H,D
				MOV  L,E
				DAD  B
				JMP  00E29H
L0E25:
				MVI  M,01AH
				INX  H
				INX  B
L0E29:
				MOV  A,L
				ANI  07FH
				JNZ  00E25H
				ORA  B
				JZ   00E3FH
L0E33:
				PUSH B
				CALL 00E41H
				CALL 00E41H
				POP  B
				DCR  B
				JNZ  00E33H
L0E3F:
				ORA  C
				RZ
L0E41:
				LXI  H,00080H
				DAD  D
				PUSH H
				CALL setDMA				; 006EFH
				MVI  C,vWriteSeq
				CALL sysCall0						; 006E7H
				POP  D
				DCR  A
				RZ
				LXI  D,messDiskFull					; 014FBH
				JMP  sendErrorMess					; 0059BH
L0E57:
				LDA  checkValidFlag					; 0173FH
				ORA  A
				RNZ
				LDA  0173EH
				ORA  A
				JNZ  00EAEH
L0E63:
				LDAX D
				CPI  01AH
				JZ   cleanUp			; 00531H
				PUSH B
				INR  A
				ANI  07FH
				CPI  021H
				DCR  A
				JC   00E7FH
L0E73:
				CALL sendCharOut               ; 00F58H
L0E76:
				INX  D
				POP  B
				DCX  B
				MOV  A,B
				ORA  C
				JNZ  00E63H
				RET
L0E7F:
				CPI  009H
				JZ   00E73H
				JC   00E76H
				CPI  00DH
				JNC  00E76H
				CALL sendNL								; 00F85H
				PUSH D
				CALL checkConsoleIn					; 006F4H
				POP  D
				LXI  H,0173CH
				INR  M
				JZ   00E76H
				LDA  00109H
				CMP  M
				JNZ  00E76H
				CALL in106Not
				JZ   00E76H
				LXI  D,messLineLimitExceeded				; 0154FH
				JMP  sendErrorMess						; 0059BH
L0EAE:
				XCHG
L0EAF:
				MOV  E,M
				PUSH H
				PUSH B
				MVI  C,vListOutput
				CALL BDOSE
				CALL checkConsoleIn					; 006F4H
				POP  B
				POP  H
				INX  H
				DCX  B
				MOV  A,B
				ORA  C
				JNZ  00EAFH
				RET
				
;   display file info????
L0EC4:
				LHLD	fileCounter				; get the file count 
				MOV		A,H						; test if value is 00
				ORA		L
				INX		H
				SHLD	fileCounter				; increment and save the value
				CZ		doFilesHeader			; call if it was zero need the heading
				LXI		D,fileStored			; point at  the size of file as stored
				PUSH	D
				LXI		H,sumFileStored
				CALL	add4BytesDEtoHL			;  add to sunning total of stored file.
				LXI		D,fileLength			; point at the Length
				PUSH	D						; save and rember fileLength (see below)
				LXI		H,sumFileLength
				CALL	add4BytesDEtoHL			; Add length to sumFileLength
				LXI		H,OutBuffer1			; start of output display byffer
				LXI		D,wFileName				; 01750H
				MVI		C,000H
				CALL	trimFullName			; put result in OutBuffer1
				POP		D
				PUSH	D						; save and remember fileLength (see above)
				CALL	hexToAsciiDisplay		; put decimal file length in OutBuffer1
				CALL	doFileSizeK				; calculate and put file size in k into OutBuffer1
				CALL	doMethod				; figure out method and set in outbuffer1
				POP		B
				POP		D
	;******* pick up here			
				CALL doSaved						; BC => Length, DE => Stored, HL=>outBuffer1
				LDA  01782H
				ORA  A
				JNZ  00F0EH
				MVI  B,012H
				CALL fillMemWithSpaces				; count in B
				JMP  00F14H
L0F0E:
				CALL 0119AH
				CALL 011D5H
L0F14:
				CALL 01208H
L0F17:
				LXI  D,OutBuffer1
				JMP  00F53H
L0F1D:
				LXI  H,OutBuffer1
				XCHG
				LHLD buffer1				; 0172EH
				XCHG
				CALL hexToAsciiDisplay520	; length 5, pad Space	
				LXI  D,sumFileLength
				PUSH D
				CALL hexToAsciiDisplay
				XCHG
				LHLD fileSizeK
				XCHG
				CALL fiveSpaceWithK
				MVI  B,00DH
				CALL fillMemWithSpaces				; count in B
				POP  B
				LXI  D,sumFileStored
				CALL doSaved
				MVI  B,014H
				CALL fillMemWithSpaces				; count in B
				XCHG
				LHLD 0173AH
				XCHG
				CALL 01219H
				LXI  D,01656H
L0F53:
				MVI  M,000H
				JMP  sendStringNL00				; 00F82H
sendCharOut:				;L0F58
				CPI  BELL
				JNZ  00F62H 		; skip if BELL
				LXI  H,0010EH
				ANA  M 			; and with 0xFFH
				RZ 				; return if Character is a NULL
L0F62:
				PUSH D			; save, it will be changed
L0F63:
				MOV  E,A 			; move charter to E for output
				DCR  A 			; checking to see it it was SOH (0x01h)
				JZ   00F6FH    	; jump it indeed it was a SOH
				MVI  C,vConsoleOutput
				CALL BDOSE
				POP  D
				RET
L0F6F:
				LXI  D,0014CH
L0F72:
				LDAX D
				CPI  020H
				JZ   00F63H
				CALL sendCharOut								; 00F58H
				INX  D
				JMP  00F72H
				
sendStringNL00NL:								; L0F7F
				CALL sendNL
sendString00NL:									; L0F82
				CALL sendString00								; 00FBAH
sendNL:													; L0F85
				MVI  A,CR
				CALL sendCharOut								; 00F58H
				MVI  A,LF
				CALL sendCharOut								; 00F58H
				LXI  H,pauseCount			 	; 01742
				DCR  M							; decrement pause count
				RNZ								; return if not pausing here
; modified code *****
				DB	0EH							; MVI
pauseFlag:		DB	00H							; 0= no-pause, nn = pauseLimit
				ORA  A							; if it is set for no-pause
				RZ								; then return, don't pause SetA3+1 != 0
				MOV  M,A						; then reset the pauseCount from pauseFlag
				PUSH D							; save for later
				LXI  D,messMore					; Point at the more message [more]
				CALL sendString00				; display
L0FA0:
				CALL checkConsoleIn					; 006F4H
				JZ   00FA0H
				PUSH PSW
				LXI  D,015A5H
				CALL sendString00								; 00FBAH
				POP  PSW
				POP  D
				XRI  020H
				RNZ
				INR  A
				STA  01742H
				RET
sendStringNL00:										; L0FB7:
				CALL sendNL								; 00F85H
sendString00:										; L0FBA
				LDAX D 			; get next byte
				ORA  A 			; if its a NULL
				RZ             	; return, done
				CP   sendCharOut	; send if MSB = 0 (ASCII character) 00F58H
				INX  D
				JMP  sendString00							; 00FBAH
L0FC4:
				PUSH D
				LXI  D,messWarningStart					; 0156BH
				CALL sendString00							; 00FBAH
				POP  D
				JMP  sendStringNL00				; 00F82H

;
; do the 1st line Name etc with the equal signs as underline.
;
doFilesHeader:									; L0FCF
				CALL sendNL
				LXI  D,txtName					; 01607H --
				PUSH D
				LDAX D
doFilesHeader1:
				CPI  EQUAL_SIGN
				JNZ  doFilesHeader2					; skip if not an Equal Sign
				MVI  A,SPACE					; else replace it with  a Space
doFilesHeader2:
				CALL sendCharOut
				INX  D
				LDAX D
				ORA  A
				JNZ  doFilesHeader1				; keep looping until Zero found
				
; just finish displaying header do the underline equal signs;
				POP  D							; pop txtName
				CALL sendNL
doFilesHeader3:
				LDAX D
				ORA  A
				JZ   sendNL						; done if char is NULL (String00)
				CPI  SPACE						; if its a space display it else show Equal Sign
				JZ   doFilesHeader4
				MVI  A,EQUAL_SIGN				; going to display an Equal Sign
doFilesHeader4:
				CALL sendCharOut
				INX  D
				JMP  doFilesHeader3				; go for more
;
;		Trim with char to remove in(C)
;		Source in (DE)
;		Target in (HL)
;		target with put a period in position 4 from the end		
		
trimFullName:							; L0FFE:
				MVI  B,FullNameSize +1	;  name.ext 00CH
trimFullName1:							; L1000:
				MOV  A,B				; get position
				CPI  004H				; is it 4 from the end ?
				MVI  A,PERIOD			; looking for the period
				JZ   trimFullName2		; skip if its 4 from the end - 0100EH
				LDAX D 					; get the character						
				INX  D					; set up for next character
				CMP  C					; is it the target character
				JZ   trimFullName3		; skip if yes
trimFullName2:
				MOV  M,A				; move from source to target location
				INX  H					; set up for next target location
trimFullName3:
				DCR  B					; keep count
				JNZ  trimFullName1		;loop if not doen
				RET
		
doFileSizeK:
				PUSH	H				; save buffer Pointer
				LHLD	fileLength		; point at file length
				LDA		fileLengthHI	; get fileLength + 2
				LXI		D,003FFH
				DAD		D				; add 1K-1 to it ( look for carry )
				ACI		000H
				RAR						; if carry, then it is preserved
				PUSH	PSW				; save the result
				MOV		A,H				; get LSB
				RAR						; divid by two, remember remainder (CY)
				INR		A
				DCR		A				; clear CY ??
				MOV		H,A				; save in H
				XTHL
				MOV		A,H				; get contents fro stack into A
				POP		H				; restore modified result
				RAR		
				PUSH PSW				; save lsb in CY
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				ANI  03FH
				MOV  L,H
				MOV  H,A
				LDA		blockSizeInK		; read from BIOS
				DCR  A
				MOV  E,A
				MVI  D,000H
				DAD  D
				CMA								; complement Acc
				ANA  L
				MOV  E,A
				MOV  D,H
				LHLD	fileSizeK
				DAD  D
				SHLD	fileSizeK			; staore the calculated file size in K 
				POP  H					; point at OutBuffer1 for size in K
fiveSpaceWithK:
				CALL hexToAsciiDisplay520	; length 5, pad Space
				MVI  M,ASCII_LO_K			; put the constant in the buffer
				INX  H						; point at next buffer position
				RET
;
;doMethod - figures out what methos the file has been processed by.
; 00 => Inavalid
; 1-2 => Unpacked
; 4 => Squeezed
; 3, 5-8 => Crunched
;				
doMethod:
				CALL	fillMemWith2Spaces	; into outBuffer1
				XCHG						; DE has pointer into OutBuff1
				LXI		H,methods			; point at the methods
				LDA		bufferHeader
				PUSH	PSW					; save entry type
				LXI		B,00008H			; method text size
				CPI		003H				; is less  than 3 ?
				JC		foundMethod			; jump if yes, Unpacked
				DAD		B
				JZ		foundMethod			; jump if DAD = 0 - packed
				DAD		B
				CPI		004H
				JZ		foundMethod			; jump if type was = 4, Squezed
				DAD		B
				CPI		009H
				JC		foundMethod			; skip if less than 9, Chrunched
				DAD		B
				JZ		foundMethod			; skip Squashed
				DAD		B					; Unknown
foundMethod:
				CALL	moveHLtoDE			; put text into outBuffer1
				XCHG
				POP		PSW					; restore the method in acc
ascii3HexDigits:
				MVI		B,003H
				JMP		hexToAsciiDisplayB20	; Display Version ie Type number
				
				
;; BC => Length, DE => Stored, HL=>outBuffer1
; first multiply stored by 100				
doSaved:
				PUSH	D				; save pointer to stored length
				PUSH	B				; save pointer to file length
				CALL	hexToAsciiDisplay	; move the stored length(DE) to the outbuffer1(HL) 
				POP		D				; get pointer to file length
				XTHL					; save outbuffer1 pointer to stack,get Stored pointer to HL
				PUSH	D				; save pointer to file length
				CALL	dblWord2Regs	; HL+0 =>E, HL+1 =>D, HL+2 =>C, HL+3=>B
				MOV		H,B
				MOV		L,C				; put hi bytes in HL
				PUSH	D				; save the lo bytes
				XTHL					; hi bytes are on stack, lo bytes are in HL & de
				SHLD	storedSubTotal	; save lo bytes for later XX
				POP		H				; retreive the hi bytes
				PUSH	H				; put lo byte back on the stack
				LHLD	storedSubTotal	; retreive the lo bytes from storage XX
				DAD		H				; value * 2
				SHLD	storedSubTotal	; save the doubled value XX
				POP		H				; retrieve original hi byte
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add in caryy from DAD
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into a
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX3		; skip if last add was not Zero
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX3:
				XTHL					; put hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 2 XX
				DAD		D				; add original value
				SHLD	storedSubTotal	; save the value * 3 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		C				; add original hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		B				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX6
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX6:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 3 XX
				DAD		H
				SHLD	storedSubTotal	; save the value * 6 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add  hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ 	storedX12
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX12:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 6 XX
				DAD		H
				SHLD	storedSubTotal	; save the value * 12 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add  hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX24
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX24:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 12 XX
				DAD		H
				SHLD	storedSubTotal	; save the value * 24 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add  hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX25
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX25:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 24 XX
				DAD		D				; add original value
				SHLD	storedSubTotal	; save the value * 25 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		C				; add  original hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		B				; add original with carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX50
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX50:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 25 XX
				DAD		H
				SHLD	storedSubTotal	; save the value * 50 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add  hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedX100
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedX100:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; retreive hi byte to HL
				PUSH	H				; save Hi byte to Stack
				LHLD	storedSubTotal	; get  the value * 25 XX
				DAD		H
				SHLD	storedSubTotal	; save the value * 100 XX
				POP		H				; retreive hi byte to HL
				PUSH	PSW				; save the flags Zero and CY
				MOV		A,L				; get value
				ADC		L				; add  hi byte value
				MOV		L,A				; put back
				MOV		A,H				; get highest byte into Acc
				ADC		H				; add in carry from previous ADC
				MOV		H,A				; put back highest byte
				JNZ		storedXdone
				INR		L
				DCR		L				; some kind of flag adjustment ??
storedXdone:
				XTHL					; put modified hi byte on stack, get saved PSW
				MOV		A,H				; put old Acc in Acc
				POP		H				; get modified hi byte from stack,
				XTHL					; HL=> file Length, top of stack has high value for stored * 100
				CALL	dblWord2Regs	; HL+0 =>E, HL+1 =>D, HL+2 =>C, HL+3=>B
				PUSH	H				; save after the double word
				LHLD	storedSubTotal	; get low word for Stored length	
				XTHL					; put low word for stored length on stack
				POP		H				; get low word for Stored length into HL
				MOV		A,B				; get msb for file length 
				ORA		C
				ORA		D
				ORA		E				; is the value 00?
				JZ		calcPct3		; skip if it is Zero
				MVI		A,065H			; thats 101 decimal
calcPct:
				DCR		A
				PUSH	PSW				; save PSW - some counter
				MOV		A,L				; get lsb of file length * 100
				SBB		E				; subtract lsb of stored length 
				MOV		L,A				; put remainder back into lsb
				MOV		A,H				; get next highest byte
				SBB		D				; subtract it
				MOV		H,A				; put result back
				JNZ		calcPct1
				INR		L
				DCR		L				; some kind of flag adjustment ??
calcPct1:
				XTHL					; save new low word for file length * 100, get old counter
				MOV		A,H				; put counter back in Acc
				POP		H				; restore working result for file length * 100
				XTHL					; save low word to stack, and put hi word in HL
				PUSH	PSW				; save count
				MOV		A,L				; get low byte
				SBB		C				; subtract length low byte
				MOV		L,A				; put result back
				MOV		A,H				; get high byte
				SBB		B				; subtract length hi byte
				MOV		H,A				; put result back
				JNZ		calcPct2
				INR		L
				DCR		L				; some kind of flag adjustment ??
calcPct2:
				XTHL					; restore count, save file length * 100 most significant ward
				MOV		A,H				; put counter back in Acc
				POP		H				; restore working count 
				XTHL					; save low word to stack, and put hi word in HL
				JNC  calcPct			; loop until done, Acc has the percent saved
calcPct3:
				POP  H					; flush old data
				POP  H					; get outbuffer1 pointer
				CALL hexToAsciiDisplay420	; length 4, pad Space, value in Acc
				MVI  M,PERCENT
				INX  H					; adjust the outBuffer1 pointer for date
				RET
				
				
L119A:
				LDA  01782H
				ANI  01FH
				CALL hexToAsciiDisplay420	; length 4, pad Space
				MVI  M,020H
				INX  H
				XCHG
				LHLD 01782H
				PUSH H
				DAD  H
				DAD  H
				DAD  H
				MOV  A,H
				ANI  00FH
				CPI  00DH
				JC   011B6H
				XRA  A
L11B6:
				MOV  C,A
				MVI  B,000H
				LXI  H,mess3Dollar					; 015B0H
				DAD  B
				DAD  B
				DAD  B
				MVI  C,003H
				CALL moveHLtoDE		; 012FFH
				XCHG
				MVI  M,020H
				INX  H
				POP  PSW
				ORA  A
				RAR
				INR  A
				DCR  A
				ADI  050H
L11CF:
				LXI  B,00230H
				JMP  hexToAsciiDisplay1
L11D5:
				XCHG
				LHLD 01784H
				MOV  A,H
				RAR
				RAR
				RAR
				ANI  01FH
				MVI  B,061H
				JZ   011F0H
				CPI  00CH
				JC   011F2H
				MVI  B,070H
				SUI  00CH
				JNZ  011F2H
L11F0:
				MVI  A,00CH
L11F2:
				PUSH B
				DAD  H
				DAD  H
				DAD  H
				PUSH H
				XCHG
				CALL ascii3HexDigits
				MVI  M,03AH
				INX  H
				POP  PSW
				ANI  03FH
				CALL 011CFH
				POP  PSW
				MOV  M,A
				INX  H
				RET
L1208:
				CALL fillMemWith2Spaces
				XCHG
				LHLD 01786H
				XCHG
				PUSH H
				LHLD 0173AH
				DAD  D
				SHLD 0173AH
				POP  H
L1219:
				CALL 0121DH
				MOV  D,E
L121D:
				MOV  M,D
				MOV  A,M
				RLC
				RLC
				RLC
				RLC
				CALL 01227H
				MOV  A,D
L1227:
				ORI  0F0H
				DAA
				CPI  060H
				SBI  01FH
				MOV  M,A
				INX  H
				RET
				
hexToAsciiDisplay520:			; length 5, pad Space
				MVI  B,005H
				MVI  C,020H
				JMP  hexToAsciiDisplay2
				
hexToAsciiDisplay420:			; length 4, pad Space
				MVI  B,004H
hexToAsciiDisplayB20:			; length in B, pad Space
				MVI  C,020H
				JMP  hexToAsciiDisplay1
;
; DE points at the hex value
; HL is where the decimal ascii is put
;				
hexToAsciiDisplay:
				LXI  B,00920H			; B = count, C = value to fill with
				PUSH D					; save value
				CALL swapAllRegisters	; swap out the registers. DE point at file Len,DE display buffer 
				POP  H					; put fileLength into HL
				MOV  E,M
				INX  H
				MOV  D,M				; put actual length in DE
				INX  H
				MOV  A,M				; get next byte into A
				INX  H
				MOV  H,M				; get fourth byte into H
										; length + 0 => E
										; length + 1 => D
										; length + 2 => A
										; length + 3 => H
				XCHG					; HL has actual bytes 1(L) & 2(H), A has 3 , D has 4?
				JMP  hexToAsciiDisplay3
				
hexToAsciiDisplay1:
				MOV  E,A
				MVI  D,000H
hexToAsciiDisplay2:
				PUSH D
				CALL swapAllRegisters
				POP  H
				XRA  A
				MOV  D,A
hexToAsciiDisplay3:
				MOV  E,A				; Lngth = DE & HL or HLDE
				MVI  C,00AH				; are we converting the number to decimal ?
				STC						; set the carry
				PUSH PSW
hexToAsciiDisplay4:
				CALL hexToAsciiDisplay9	; get digit of Length in Decimal from least to most significant
				ORI  030H				; set the ascii
				CALL swapAllRegisters	; swap out the registers. DE point at file Len,DE display buffer 
				DCR  B					; are we done (length = 9)
				JNZ  hexToAsciiDisplay7
				
hexToAsciiDisplay5:
				MOV  M,A				; get the ascii value into the buffer
				INX  H					; point at next location
hexToAsciiDisplay6:
				POP  PSW				; is there any more ?
				JNC  hexToAsciiDisplay5	; loop if yes
				RET
hexToAsciiDisplay7:
				PUSH PSW					; save ASCII valuee
				CALL swapAllRegisters	; swap out the registers. DE point at file Len,DE display buffer 
				MOV  A,H
				ORA  L
				ORA  D
				ORA  E
				JNZ  hexToAsciiDisplay4
				CALL swapAllRegisters	; swap out the registers. DE point at file Len,DE display buffer 
				ORA  C					; put SPACE into Acc
				JZ   hexToAsciiDisplay6	; if more loop else write remaing spaces
hexToAsciiDisplay8:
				MOV  M,A				; put vaue into buffer (SPACE)
				INX  H
				DCR  B					; do until length is complete
				JNZ  hexToAsciiDisplay8
				JMP  hexToAsciiDisplay6
				
hexToAsciiDisplay9:
				MOV  A,D
				ORA  E						; are D and E both Zeros ?
				JZ   hexToAsciiDisplay11	; skip if yes
				XRA  A
				CALL hexToAsciiDisplay10
hexToAsciiDisplay10:
				XCHG
				ORA  A
				JNZ  hexToAsciiDisplay12
hexToAsciiDisplay11:
				MOV  A,H					; get H's value
				CMP  C						; is it bigger than 10 decimal?
				JC   hexToAsciiDisplay13	; jump if not
				XRA  A						; else clear Acc
hexToAsciiDisplay12:
				MVI  B,010H					; put Decimal 16 into B
				JMP  hexToAsciiDisplay14	; and jump
hexToAsciiDisplay13:
				MOV  H,L					; get loByte					
				MVI  L,000H
				MVI  B,008H					; stuff B with decimal 8
hexToAsciiDisplay14:
				DAD  H						; multiply Lo byte by 2
				RAL  D						; any carry ??  --Whats the D there for ??
				CMP  C						; greater than decimal 10
				JC   hexToAsciiDisplay15	; jump if not
				SUB  C						; else take 10 away and
				INR  L						;    carry 1 (decimal)
hexToAsciiDisplay15:
				DCR  B						; keep count
				JNZ  hexToAsciiDisplay14	; if not dome loop for more
				RET
				
; HL points at value to be loaded into registers B,C,D & E
; Hl + 0 =>  E
; Hl + 1 =>  D
; Hl + 2 =>  C
; Hl + 3 =>  B
				
dblWord2Regs:
				MOV  E,M					; Hl + 0 =>  E
				INX  H
				MOV  D,M					; Hl + 1 =>  D
				INX  H						
				MOV  C,M					; Hl + 2 =>  C
				INX  H
				MOV  B,M					; Hl + 3 =>  B
				RET
				
				
add4BytesDEtoHL:						; L12C2
				MVI  B,004H				; load the counter
				ORA  A					; clear Acc
add4BytesDEtoHL1:
				LDAX D					; get the byte
				ADC  M					; with memory content
				MOV  M,A				; save the result
				INX  H					; incremnt both
				INX  D					;   pointers
				DCR  B					; Count down
				JNZ  add4BytesDEtoHL1	; loop until done
				RET
				
fillMemWith2Spaces:
				MVI  B,002H
fillMemWithSpaces:
				MVI  C,020H
; Fill memory with (C) for (B) bytes	L12D3	
fillMemWithC:
				MOV  M,C
				INX  H
				DCR  B
				JNZ  fillMemWithC
				RET
;				
upperCaseAcc:							; L12DA:
				CPI  ASCII_LO_A
				RC						; return if less than 61H
				CPI  LEFT_CURLY
				RNC						; return if greater than 7BH
				ADI  0E0H				; else, make Acc upper case
				RET
				
; 
;	Swap the contents of memory 178C ....
;	With registers BC DE HL
;
swapAllRegisters:						; L12E3:
				PUSH H					; save HL as called
				LHLD storeHL			; get whats in 178c
				XTHL					; put on stack
				SHLD storeHL			; put HL's content into 178c
				PUSH D					; save DE as Called
				LHLD storeDE
				XTHL
				SHLD storeDE			; put DE's content into 178c
				PUSH B					; save BC as called
				LHLD storeBC
				XTHL
				SHLD storeBC
				POP  B
				POP  D
				POP  H
				RET
;
;         move (HL) to (DE) for (BC) bytes
;		  
moveHLtoDE:							; L12FF

				PUSH PSW						; save acc
moveHLtoDE1:						; L1300
				MOV  A,M						; get value from (HL)
				STAX D						; put value in (DE)
				INX  H 						; Incremement HL
				INX  D 						; Incremement DE
				DCX  B						; count down BC
				MOV  A,B
				ORA  C
				JNZ  moveHLtoDE1			; loop until BC = 00  - 01300H
				POP  PSW       				; restore ACC
				RET            				; exit


;		Check for the occurance of a Value (ACC)
;		in Memory(HL)
;		(BC) has byte count
;		
haveValue0:
				POP  PSW			; restore Target value
haveValue:
				CMP  M			; does (HL) = Target?
				INX  H      	; inc Pointer		
				DCX  B         	; couunt down
				RZ             	; return if target found with Zero Flag Set
				PUSH PSW			; save the target value
				MOV  A,B       	; have we counted
				ORA  C         	;    all the way down
				JNZ  haveValue0	; keep goin if not
				POP  PSW       	; else  return flags and target to Acc
				RET            	; and exit with Zero Flag Reset

;     <New literal fragment-----from 1319 to 16AC (16AC : 5804)>
;              ORG  01319H
messZ80:
				DB		'NOTE: The Z80 version is smaller and faster!'
				DB		CR
				DB		LF
				DB		QMARK
messAborted:
				DB		BELL
				DB		SOH
				DB		'aborted!'
				DB		NULL
messVer:
				DB		'CP/M version 2 or higher required'
				DB		NULL
messNEMemory:
				DB		'Not enough memory'
				DB		NULL
messAmbigFile:
				DB		'Ambiguous archive file name'
				DB		NULL
messMissingArchiveFile:
				DB		'Cannot find archive file'
				DB		NULL
messInvalidArcFileFmt:
				DB		'Invalid archive file format'
				DB		NULL
messBadArchHeader:
				DB		BELL
				DB		'Warning  Bad archive file header  bytes skipped   00000'
				DB		NULL
messNoMatchingFile:
				DB		'No matching file(s) in archive'
				DB		NULL
 messBadArchFileDrive:
			   DB		'Invalid archive file drive'
				DB		NULL
 messBadOutputDrive:
			   DB		'Invalid output drive'
				DB		NULL
messArchFileEqual:
				DB		'Archive File = '
messArcFileName:
				DS	12
				DB		NULL
messOutDriveEquals:
				DB		'Output Drive = A:'
				DB		NULL
messCheckingArch:
				DB		'Checking archive...'
				DB		NULL
messNeedNewerArch:
				DB		'Cannot extract file (need newer version of UNARC'
				DB		DOLLAR
				DB		')'
				DB		NULL
messReplaceQues:
				DB		BELL
				DB		'Replace existing output file (y/n)'
				DB		DOLLAR
				DB		' '
				DB		NULL
messDiskFull:
				DB		'Disk full'
				DB		NULL
messDirFull:
				DB		'Directory full'
				DB		NULL
messCanNotCloseOut:
				DB		'Cannot close output file'
				DB		NULL
messInCompatibleCruch:
				DB		'Incompatible crunched file format'
				DB		NULL
messLineLimitExceeded:
				DB		'Typeout line limit exceeded'
				DB		NULL
messWarningStart:
				DB		BELL
				DB		'Warning: Extracted file has incorrect '
				DB		NULL
messCRC:
				DB		'CRC'
				DB		NULL
messLength:
				DB		'length'
				DB		NULL
messMore:
				DB		'[more]'
				DB		NULL
				DB		CR
				DB		'       	'
				DB		CR
				DB		NULL
mess3Dollar:
				DB		DOLLAR
				DB		DOLLAR
				DB		DOLLAR
				DB		'JanFebMarAprMayJunJulAugSepOctNovDec'
methods:
				DB		'Unpacked'
				DB		'  Packed'
				DB		'Squeezed'
				DB		'Crunched'		; type = 08
				DB		'Squashed'
				DB		'Unknown'
				DB		'!'
txtName:		DB		'Name'
				DB		'========  ='
				DB		'Length '
				DB		' Disk  '
				DB		'=Method '
				DB		'= Ver '
				DB		'=Stored '
				DB		'Saved '
				DB		'==='
				DB		'Date'
				DB		'== '
				DB		'=Time= '
				DB		'CRC='
				DB		NULL
				DB		'        ====  =======  ====               =======  ===                    ===='
				DB		CR
				DB		LF
				DB		'Total  '


;              ORG  016ADH
OutBuffer1:
				DS 129
appStack:
fileCounter:						; file count ?????
buffer1:		DS		2
sumFileLength:	DS		4
fileSizeK:		DS		2	
sumFileStored:	DS		6	
L173C:			DS  1			
flagOS:			DS	1			; 0 = MS-DOS , ~0 = CP/M |ARK = CP/M, ARC = MS-DOS

printFlag:		DS	1
;         ORG  0173FH
checkValidFlag:	DS	1
bufferPointer:
L1740:			DS	1			;  flag ???  (was set with -1)
L1741:			DS	1
pauseCount:		DS	1			; L1742	
blockSizeInK:	DS	1			; works out to 2 for us. - L1743		

subjectFiles:	DS 11			; file name with QMARKS and no PERIOD

targetDrive:	DB		NULL	; Target file drive, 0= No write to disk ; 1=A, 2=B, ...

wFileName:		DS		11

L175B:			DS		21

; header info placed here---------
bufferHeader:		DS		1		; entry type 08 or 01		
buffSubjectFileName:	DS		11	; L1771
L177C:			DS		2
fileStored:		DS		4	
;L1780:			DS		2	
L1782:			DS		4	
L1786:			DS		2
fileLength:		DS		2
; header info placed here---------
	
fileLengthHI:	DS		2	
	
								
storeHL:		DS		2		; L178C
storeDE:		DS		2		; L178E
storeBC:		DS		2		; L1790
L1792:			DS		2
storedSubTotal:				
ptrSubjectFile:	DS		2		; L1794:
L1796:			DS		2
L1798:
	



			
CodeEnd:
