;Source File name - binaryCopyOfUnarcca.com-8080
;Generated by - ManualDisassembler V A.0 on Tue Dec 29 11:01:53 EST 2015

ASCII_MASK		EQU		7FH			; Ascii mask 7 bits

NULL			EQU		00H			; Null
SOH				EQU		01H			; Start of Heading
CTRL_C			EQU		03H			; ETX
BELL			EQU		07H			; Bell
LF				EQU		0AH			; Line Feed
CTRL_K			EQU		0BH			; VT - Vertical tab
CR				EQU		0DH			; Carriage Return
CTRL_S			EQU		13H			; X-OFF
SPACE			EQU		20H			; Space
EXCLAIM_POINT	EQU		21H			; Exclamtion Point
DOLLAR			EQU		24H			; Dollar Sign
PERIOD			EQU		2EH			; Period
EQUAL_SIGN		EQU		3DH			; equal Sign
QMARK			EQU		3FH			; Question Mark
ASCII_A			EQU		'A'	
ASCII_C			EQU		'C'	
ASCII_R			EQU		'R'	
ASCII_K			EQU		'K'
ASCII_LO_A		EQU		'a'
LEFT_CURLY		EQU		'{'			; Left curly Bracket	
DEL				EQU		7FH			; Delete Key	

BDOS			EQU		0005H		; bdos vector
DefaultFCB		EQU		5CH			;default file control block.
Pg0Buffer		EQU		80H			; i/o buffer and command line storage.

FullNameSize	EQU		11			; name (8) + Ext (3) = 11

;command line flags
flagNoPause		EQU		'P'			; no screen pause
flagPrint		EQU		'N'			; print flag
flagCheckValidity	EQU	'C'			; check file validity

vGetConInput	EQU		01H			; A <- ASCII char
vConsoleOutput	EQU		02H			; E has Char to output, no return value
vListOutput		EQU		05H			; E has Char to output, no return value
vPrintString	EQU		09H			; DE buffer address, $ terminated, no return value
vGetConStat		EQU		0BH			; A<- 00/non zero
vGetVersion		EQU		0CH			; HL< - Version Number
vSelectDisk		EQU		0EH			; E has Disk number
vOpenfile		EQU		0FH			; DE - FCB | A<- FF if not found
vCloseFile		EQU		10H			; DE - FCB | A<- FF if not found
vSearchForFirst	EQU		11H			; DE - FCB | A<- directory code
vDeleteFile		EQU		13H			; DE - FCB | A<- nothing
vReadSeq		EQU		14H			; DE - FCB | A<-error code
vWriteSeq		EQU		15H			; DE - FCB | A<-error code
vMakeFile		EQU		16H			; DE - FCB | A<- FF if no DIR Space
vGetCurDisk		EQU		19H			; A <- current disk
vSetDMA			EQU		1AH			; DE - DMA address, no return value
vGetDPB			EQU	 	1FH			; HL <- Disk Parameter Block address
vReadRandom		EQU		21H			; DE - FCB | A<- nothing error codes in BA & HL
vSetRandRec		EQu		24H			; DE - FCB | r0,r1,r2


				  ORG  00100H


;     <New code fragment-----from 0100 to 0102 ( 102 :  258)>
;              ORG  00100H
CodeStart:
				JMP		BEGIN ;004B6H

;     <New constant fragment-----from 0103 to 010E ( 10E :  270)>
;              ORG  00103H
pageOverhead:	DB		008H		; read Only - checked to see if there is enough memory to do this
L0104:			DB		000H		; read Only
maxDrive:		DB		010H		; read Only - L0105
L0106:			DB		010H		; read Only
L0107:			DB		0FFH		; read Only
L0108:			DB		000H		; read Only
L0109:			DB		000H		; read Only
L010A:			DW		L0106		; read Only

pauseLimit:		DB		23			; read Only - L010C
L010D:			DB		000H		; read & write  ****
L010E:			DB		0FFH		; read Only


;     <New literal fragment-----from 010F to 013B ( 13B :  315)>
;              ORG  0010FH
				DB		'COMCM'
				DB		0C4H
				DB		'EXEOBJOV'
				DB		DOLLAR
				DB		'REL'
				DB		DOLLAR
				DB		'RLINTSYSBADLBRARCARK'
				DB		DOLLAR
				DB		'Q'
				DB		DOLLAR
				DB		DOLLAR
				DB		'Z'
				DB		DOLLAR

;     <New constant fragment-----from 013C to 014B ( 14B :  331)>
;              ORG  0013CH
				DB		000H
				DB		000H,000H,000H,000H,000H
				DB		000H,000H,000H,000H,000H
				DB		000H,000H,000H,000H,000H

;     <New literal fragment-----from 014C to 0499 ( 499 : 1177)>
;              ORG  0014CH
				DB		'UNARC  1.6  27 Mar 87'
				DB		CR
				DB		LF
				DB		'CP/M Archive File Extractor (8080 Version)'
				DB		CR
				DB		LF
				DB		LF
				DB		'Usage:  '
				DB		SOH
				DB		'[d:]arcfile[.typ] [d:][afn] [N|P|C]'
				DB		CR
				DB		LF
				DB		LF
				DB		'Examples:'
				DB		CR
				DB		LF
				DB		'B>'
				DB		SOH
				DB		'A:SAVE.ARK *.*  # List all files in CP/M archive SAVE on drive A'
				DB		CR
				DB		LF
				DB		'B>'
				DB		SOH
				DB		'A:SAVE.ARC *.*  # List all files in MS-DOS archive SAVE on drive A'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE            # Same as either of above'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.* N      # Same as above (no screen pauses)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.DOC      # List just .DOC files'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE READ.ME    # Typeout the file READ.ME'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE READ.ME N  # Typeout the file READ.ME (no screen pauses)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE A:         # Extract all files to drive A'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE B:*.DOC    # Extract .DOC files to drive B'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE C:READ.ME  # Extract file READ.ME to drive C'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE PRN.DAT P  # Print the file PRN.DAT (no formatting)'
				DB		CR
				DB		LF
				DB		'A>'
				DB		SOH
				DB		'SAVE *.* C      # Check validity of all files in archive'
				DB		CR
				DB		LF
				DB		LF
				DB		'Copyright (C) 1986  1987 by Robert A. Freed'

;     <New unknown fragment-----from 049A to 04B2 ( 4B2 : 1202)>
;              ORG  0049AH
				DS		00019H

;     <New code fragment-----from 04B3 to 0D99 ( D99 : 3481)>
;              ORG  004B3H
				JMP		00000H
BEGIN:
				SUB		A
				MVI		C,vPrintString
				LXI		D,messZ80					; 01319H
				CPO		BDOS						; 00005H - looks like it never makes the call
				LXI		H,00000H
				DAD		SP
				SHLD	StackRestore + 1			; 0053CH
				CALL	checkENV					; 00571H	 checks - CP/M ver, Memory Space
				LXI		SP,buffer1					; 0172EH 		buffer1
				LXI		H,buffer1					; 0172EH
				LXI		B,01200H					; Fill 00 for 12H bytes
				CALL	FillMemWithC
				CALL	parseCmdLine				; 005AAH
				CALL	00833H
				LXI		H,00003H					; load b with a limit count
				MOV		B,L
L04DF:
				CALL getRawData						; returns with first byte in Acc
				CPI  01AH
				JZ   004F3H							; jump if its 1A - Get next byte in buffer
				DCR  B								; count down
				JNZ  004DFH							; loop if not done
L04EB:
				CALL getRawData						; 00738H
				CPI  01AH
				JNZ  0053FH
L04F3:
				CALL getRawData						; is the return byte
				ORA  A								     ; Zero ?
				JZ   0051EH							; jump if it is
L04FA:
				CALL 007B9H							; move data from buffer into 1770
				CALL 007DDH							; move file name to 1750 ??
				JNZ  0050FH
				CALL 00EC4H			; display file info????
				CALL 0090CH
				CALL 00900H
				JNZ  00531H
L050F:
				LXI  H,0177EH
				CALL 012BAH
				CALL 0076BH
				LXI  H,00000H
				JMP  004EBH
L051E:
				LHLD buffer1						; 0172EH
				MOV  A,H
				ORA  A
				JNZ  0052EH
				ORA  L
				LXI  D,messNoMatchingFile			; 01411H
				JZ   sendErrorMess				; 0059BH
				DCR  A
L052E:
				CNZ  00F1DH
L0531:
				CALL 006D2H
				LDA  00103H
				ORA  A
				JZ   00000H
StackRestore:		; really + 1 from		
				LXI  SP,00000H
				RET
L053F:
				CALL 00764H
				CALL getRawData					; 00738H
L0545:
				CPI  01AH
				JNZ  0053FH
				CALL getRawData					; 00738H
				PUSH PSW
				DCR  A
				CPI  009H
				JNC  0056AH
				XCHG
				LXI  H,0140BH
				LXI  B,00000H
				CALL 01255H
				MVI  M,000H
				LXI  D,messBadArchHeader			; 013D8H
				CALL sendStringNL00NL				; 00F7FH
				POP  PSW
				JMP  004FAH
L056A:
				CALL 00764H
				POP  PSW
				JMP  00545H
checkENV:						;L0571:
				XRA		A    			; clear Acc
				STA		SetA1			; 006D6H
				STA		SetA2			; 006DEH
				STA		pauseFlag		; clear the pause Flag (no-Pause);
				MVI		C,vGetVersion
				CALL	BDOS 			; HL has Version Number and  Acc?
				CPI		020H      		; is it at least Ver 2.0 ?
				LXI		D,messVer		; 01353H
				JC		sendErrorMess0	; no , jump - 0059AH 
				LDA		00007H  		; get page numbe of start of DBOS
				LXI		H,pageOverhead	; point at stored value (08) - 00103H 		
				SUB		M  				; subtract fom BDOS page start
				STA		SetB +1			; 00595H  result = 0xE0H, put it away
				MVI		A,017H			; minimum number of pages needed to run
L0594:
SetB:
				CPI  000H 				; is the enough Memory ?
				RC             			; return if there is enough Memory
				LXI  D,messNEMemory		; Else send not enough memory message 01375H
sendErrorMess0:							; L059A:
				POP  H
sendErrorMess:							; L059B:
				CALL sendStringNL00		; 00FB7H
sendAbortMess:							; L059E
				LXI  D,messAborted		; 01348H
sendStringNL00NL:						; L05A1
				CALL sendStringNL00		; 00FB7H
				CALL sendNL				;00F85H
				JMP  00531H
parseCmdLine:							; L05AA
				LXI  H,Pg0Buffer		; 00080H
				MOV  E,M       			; get number of bytes in the buffer
				MVI  D,000H 			; set hibyte to zero
				DAD  D 					; point at the end of the buffer
				DCX  H 					; is the next
				MOV  A,M       			;   to last character
				CPI  SPACE 				;    a Space ?
				JNZ  parseCMDLine2		; skip if no	
				INX  H 					; else look at last char, its a flag
				MOV  A,M       			; get the flag
				CPI  flagNoPause			; is there a No-Pause flag ?
				JZ   parseCMDLine3		; skip if yes - 005D8H
				CPI  flagPrint			; else - is the a Print flag
				JNZ  parseCMDLine1		; skip if no  -	005C7H			
				STA  printFlag			; else store P in the print flag - 0173EH
parseCMDLine1:
				CPI  flagCheckValidity	; Is it a Check Valitity flag ?
				JNZ  parseCMDLine2		; skip if no - 005CFH
				STA  checkValidFlag		; else store if checkValidFlag - 0173FH
parseCMDLine2:
				LDA  pauseLimit			; L010C	
				STA  pauseFlag			; set flag non zero (pauseLimit) else empty for no-pause option
				STA  pauseCount			; set up count down to pause - L1742
; past the cmd line flags [N|P|C]
parseCMDLine3:							; L05D8:
				MVI  A,SPACE
				LXI  H,0006CH			; cmd arg 2 expanded FCB (SPACES & QMARKS)
				LXI  D,L174F			; 0174FH
				PUSH PSW
				MOV  A,M				; a<- (M)
				STAX D 					; (de) <- a
				INX  H
				INX  D
				DCX  B  				; ????????
				POP  PSW       			; get the space back into Acc	
				LXI  D,targetFCB		; 01744H
				LXI  B,FullNameSize		; filename and ext length 8 + 3 = 11 - 0000BH
				CMP  M 					; does FCB2 contain a SPACE ?
				JNZ  parseCMDLine4		; skip if not -  005F7H 				
				MOV  H,D 				; place memory pointer
				MOV  L,E       			;    into from DE to HL
				MVI  M,QMARK			; put QMARK into memory - (1744)
				INX  D  				; point past that location
				DCX  B         			
parseCMDLine4:							; L05F7:
				CALL moveHLtoDE			; 012FFH
				LXI  H,00065H			; point at ext for FCB1
				CMP  M					; if SPACE for ARK extension
				JNZ  parseCMDLine5		; skip , else force to ARK
				MVI  M,ASCII_A
				INX  H
				MVI  M,ASCII_R
				INX  H
				MVI  M,ASCII_K
				STA  flagOS				; 0173DH
parseCMDLine5:							; L060C:
				LXI  H,DefaultFCB +1	; 0005DH
				CMP  M 					; file name start with a SPACE ?
				JZ   00681H 			; skip if Yes - not good
				PUSH H 					; save fcb1 pointer
				CALL anyQMarks			; 00903H
				LXI  D,messAmbigFile	; we dont want any. Only one Archive file!
parseCMDLine6:	
				JZ   sendErrorMess		;  jump if bad file name 0059BH
				POP  D         			; put FCB1 into DE
				LXI  H,messArcFileName	; put target location in HL
				MVI  C,SPACE			; remove spaces and insert Period
				CALL trimFullName		;    and put into location pointed at by HL
				XRA  A					; set Acc = 0
				MOV  M,A				;   terminate the string -messArcFileName- with NULL
				DCR  A
				STA  bufferPointer		; Store -1  as flag to read -01740H
				LXI  H,DefaultFCB		; points at the disk (0= current, 1 = A, 2= B)
				LDA  maxDrive			; 00105H - L0105
				CMP  M					; is it a good drive number ?
				LXI  D,messBadArchFileDrive		; load message if not
				JC   sendErrorMess		; Jump to send error message if drive not valid
				XCHG					; load DE with FCB for the archive file
				MVI  C,vOpenfile
				CALL sysCall			; open it
				JNZ  haveArcFile		; jump if sucsessful open - 00656H				
				LXI  H,flagOS			;   else not valid open 0173DH
				ORA  M
				LXI  D,messMissingArchiveFile			; 013A3H
				JZ   parseCMDLine6		; if (HL) == (flagOs) error out
				MVI  M,000H				; force osFlag to MS-DOS
				LXI  H,DefaultFCB + 11	; point at last char of ext - 00067H
				MVI  M,ASCII_C			; force type to be ARC
				JMP  parseCMDLine5		; retry with file ext of ARC
				
haveArcFile:							; L0656:
				STA  SetA1				; save the return code for late testing - 006D6H
				LXI  D,messArchFileEqual
				CALL sendStringNL00NL	; Display - Archive File = .....
				LDA  00104H
				ORA  A					; if 104 is Zero then
				CZ   006C4H				; check indirect 10A (106) is Zero
				JNZ  0067DH				; set flag and Exit ???
L0669:
				LDA  0010DH				; check if 10D is Zero
				ORA  A
				JNZ  0067DH				; set flag and Exit ??? if not Zero
				MVI  C,vGetDPB
				CALL BDOS				; HL points to the Disk Parameter BlocK
				INX  H
				INX  H					; at BSH (Block Shift)
				INX  H					; at Block Mask
				MOV  A,M				; get the Block Mask
				INR  A
				RRC
				RRC
				RRC
L067D:
				STA  blockMask			; 01743H
				RET
L0681:
				CALL 006C4H
				PUSH PSW
				DCR  A
				JZ   0068DH
				LDA  00106H
				ORA  A
L068D:
				LXI  H,001ABH
				LXI  B,00480H
				CZ   FillMemWithC
				LXI  H,00357H
				MVI  B,09DH
				CZ   FillMemWithC
				POP  PSW
				JZ   006BEH
				LXI  H,001B7H
				MVI  B,004H
				CALL FillMemWithC
				LXI  H,003F4H
				MVI  B,07AH
				CALL FillMemWithC
				LDA  00107H
				ORA  A
				LXI  H,002E6H
				MVI  B,071H
				CZ   FillMemWithC
L06BE:
				LXI  D,0014CH
				JMP  sendStringNL00NL		;005A1H
;
;			Check the value found by indirectly addrssing 10A, ie at location 106
;			If it is zero make Acc = 1 reset Zero flag & return.
;			if it is not Zero make Acc = 0, set Zero flag & return
L06C4:
				PUSH H
				LHLD 0010AH
				MOV  A,M
				POP  H
				ORA  A
				JNZ  006D0H			; if its not 0, jump, zero out and return
				INR  A				; set Acc to 1, reset zero flag
				RET
L06D0:
				XRA  A				; clear register and set Zero flag
				RET
L06D2:
				LXI  D,0005CH
; modified code *****
				DB	0EH							; MVI
SetA1:			DB	00H							; 0= open file fail/ 1,2,3 = goo open

				CALL 006DFH
L06DA:
				LXI  D,L174F				; 0174FH
; modified code *****
				DB	0EH							; MVI
SetA2:			DB	00H							; 0= ***********

L06DF:
				ORA  A
				MVI  C,vCloseFile
				CNZ  BDOS
				INR  A
				RET
sysCall0:									; L06E7:
				LXI  D,L174F				; 0174FH
sysCall:									; L06EA:
				CALL BDOS
				INR  A
				RET
;		SetDMA - called with DE pointing to the Address
setDMA:										;L06EF:
				MVI  C,vSetDMA
				CALL BDOS					; set dma to default 80
checkConsoleIn:								; L06F4:
				MVI  C,vGetConStat
				CALL BDOS
				ORA  A
				RZ							; return if no character pending from Console
				MVI  C,vGetConInput
				CALL BDOS
				ANI  ASCII_MASK
				CPI  CTRL_S					; X-OFF 013H
				MVI  C,vGetConInput
				CZ   BDOS
				ANI  ASCII_MASK
				CPI  CTRL_C					; ETX 003H
				JZ   00713H					; abort if CTRL_C sent
				CPI  CTRL_K					; VT	00BH
				RNZ
L0713:
				JMP  sendAbortMess			; 0059EH
L0716:
				CALL 012E3H
L0719:
				PUSH B
				PUSH D
				PUSH H
				LXI  H,0177EH
				MVI  B,004H
L0721:
				MOV  A,M
				DCR  M
				ORA  A
				JNZ  0073BH
				INX  H
				DCR  B
				JNZ  00721H
				MVI  B,004H
L072E:
				DCX  H
				MOV  M,A
				DCR  B
				JNZ  0072EH
				STC
				JMP  00746H
getRawData:								; L0738:
				PUSH B
				PUSH D
				PUSH H
L073B:
				LHLD bufferPointer		; L1740
				INR  L
				CZ   readSeq			; call read sewq if 1740 was -1 (initialized -1)
				SHLD bufferPointer		; save buffer pointer in 01740H
				MOV  A,M				; get the first byte from buffer
L0746:
				POP  H
				POP  D
				POP  B
				RET
readSeq:								; L074A
				MVI  C,vReadSeq			; 014H
readFile:								; L074C
				LXI  D,00080H			; point at default FCB
				PUSH D
				PUSH B
				CALL setDMA				; 006EFH
				LXI  D,DefaultFCB
				POP  B					; get the kind of read
				CALL BDOS				; do the read
				POP  H
				ORA  A
				RZ
L075E:
				LXI  D,sendStringNL00			;013BCH
				JMP  sendErrorMess		; 0059BH
L0764:
				INX  H
				MOV  A,H
				ORA  L
				RNZ
				JMP  0075EH
L076B:
				MOV  A,B
				ORA  A
				JNZ  0075EH
				MOV  A,E
				MOV  L,D
				MOV  H,C
				ADD  A
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00780H
				INR  L
				DCR  L
L0780:
				XTHL
				MOV  A,H
				POP  H
				JC   0075EH
				RAR
				XCHG
				LXI  H,bufferPointer		; L1740
				ADD  M
				MOV  M,A
				INR  A
				JP   00798H
				MOV  A,D
				ORA  E
				RZ
				DCX  D
				JMP  0079BH
L0798:
				ADI  07FH
				MOV  M,A
L079B:
				PUSH D
				LXI  D,0005CH
				MVI  C,vSetRandRec
				CALL BDOS
				LHLD 0007DH
				POP  D
				DAD  D
				JC   0075EH
				SHLD 0007DH
				MVI  C,vReadRandom				; 021H
				CALL readFile					; 0074CH
				LXI  H,0007CH
				INR  M
				RET
;		get data from buffer and put into 1770.
;       move 18H bytes if Acc= 1, else make it 1CH bytes
L07B9:
				LXI  D,01770H					; point at future FCB ??
				MVI  B,01CH						; put a counter in B ??
				CPI  001H						; does Acc = 01?
				PUSH PSW
				JNZ  007CCH						; skip if != 01
				MVI  B,018H						; put a diferent counter in B ??
				JMP  007CCH
L07C9:
				CALL getRawData					; 00738H
L07CC:
				STAX D
				INX  D
				DCR  B
				JNZ  007C9H						; loop if not done
				POP  PSW
				RNZ
				LXI  H,0177EH
				MVI  C,004H
				CALL moveHLtoDE		; 012FFH
				RET
;		move file name to 1750 ??
L07DD:
				LXI  D,01771H					; point at 1771 data moved from rawBuffer
				LXI  H,wFileName				; load for later 1750
				PUSH H
				LXI  H,targetFCB				; 01744H
				SHLD 01794H
				POP  H
				MVI  B,00BH
;			Most likely we have a file name here
L07ED:
				LDAX D
				ANI  ASCII_MASK
				JZ   0080FH						; skip if its a NULL or 80H
				INX  D	
				CPI  EXCLAIM_POINT				; is it a printable character?
				JC   007FEH						; skip if not
				CPI  DEL						; is it the Delete Key ?
				JNZ  00800H						; skip if not
L07FE:
				MVI  A,DOLLAR					; else replace the Delete with a Dollar Sign
L0800:
				CALL	upperCaseAcc			; 012DAH
				CPI		PERIOD
				JNZ		00811H					; jump if not a period
				MOV		A,B						; else check the count
				CPI		004H					; is it where we expect it
				JC		007EDH					; yes keep going
				DCX		D						; else adjust the pointer
L080F:
				MVI		A,SPACE					; put in a space and keep on going
L0811:
				MOV		M,A						; put the char away
				PUSH	H
				LHLD	01794H					; get the pointer
				MOV		A,M						; put trhe char here also
				POP		H
				PUSH	H
				LHLD	01794H					; get the pointer
				INX		H						; move it up one
				SHLD	01794H					; save the pointer
				POP		H
				CPI		QMARK					; is it a Question mark
				JZ		00828H					; skip if it is
				CMP  M
				RNZ
L0828:
				INX		H						; point at next position
				DCR		B						; count down
				JNZ		007EDH					; loop if we are not done
				LXI  B,01500H
				JMP  FillMemWithC
L0833:
				LDA  00106H
				MOV  B,A
				LXI  H,checkValidFlag		; 0173FH
				CALL 006C4H					; check program values
				DCR  A
				JNZ  00849H					; skip if ????
				MOV  B,A
				MOV  M,A
				STA  0173EH
				LDA  00107H
L0849:
				MOV  C,A
				LDA  L174F				; 0174FH
				ORA  A
				JNZ  00863H				; skip if not Zero.
				ORA  M					; or with check Valid Flag
				JZ   008D2H				; skip if check Valid Flag not set
				LXI  D,messCheckingArch					; 0148EH
				CALL sendStringNL00				; 00F82H
				MVI  A,0FEH
				STA  L174F				; 0174FH
				JMP  0088FH
L0863:
				DCR  A
				CMP  B
				LXI  D,0144BH
				JNC  sendErrorMess		; 0059BH
				MOV  E,A
				PUSH D
				ADI  041H
				STA  0148BH
				LXI  D,messOutDriveEquals				; 0147CH
				CALL sendStringNL00				; 00F82H
				MVI  C,vGetCurDisk
				CALL BDOS
				POP  D
				CMP  E
				PUSH PSW
				MVI  C,vSelectDisk
				CNZ  BDOS
				CALL 00669H
				POP  PSW
				MOV  E,A
				MVI  C,vSelectDisk
				CNZ  BDOS
L088F:
				LXI  H,01900H
				MOV  A,H
				CALL 00594H
				LXI  D,0A001H
L0899:
				MOV  A,L
				LXI  B,00800H
L089D:
				ORA  A
				PUSH PSW
				MOV  A,C
				RAR
				INR  A
				DCR  A
				MOV  C,A
				XTHL
				MOV  A,H
				POP  H
				RAR
				JNC  008C5H
				PUSH H
				PUSH PSW
				LHLD 01792H
				XTHL
				SHLD 01792H
				POP  PSW
				POP  H
				MOV  A,C
				XRA  D
				MOV  C,A
				PUSH H
				PUSH PSW
				LHLD 01792H
				XTHL
				SHLD 01792H
				POP  PSW
				POP  H
				XRA  E
L08C5:
				DCR  B
				JNZ  0089DH
				MOV  M,C
				DCR  H
				MOV  M,A
				INR  H
				INR  L
				JNZ  00899H
				RET
L08D2:
				ORA  C
				CNZ  00900H
				RZ
				LXI  D,0010FH
L08DA:
				LXI  H,0174CH
				MVI  B,003H
L08DF:
				LDAX D
				ORA  A
				JZ   008FBH
				CPI  03FH
				JZ   008EAH
				CMP  M
L08EA:
				INX  D
				JZ   008F5H
				DCR  B
				JNZ  008EAH
				JMP  008DAH
L08F5:
				INX  H
				DCR  B
				JNZ  008DFH
				RET
L08FB:
				DCR  A
				STA  L174F				; 0174FH
				RET
L0900:
				LXI  H,targetFCB				; 01744H
anyQMarks:							; L0903:
				LXI  B,FullNameSize		; 0000BH
				MVI  A,QMARK
				CALL haveValue			; 0130DH
				RET
L090C:
				LDA  L174F				; 0174FH
				ORA  A
				RZ
				MOV  B,A
				LDA  01770H
				CPI  00AH
				LXI  D,messNeedNewerArch				; 014A2H
				JNC  sendErrorMess		; 0059BH
				MOV  L,A
				MVI  H,000H
				LXI  D,00D99H
				DAD  D
				MOV  A,M
				CALL 00594H
				LXI  H,01796H
				MOV  M,A
				MOV  C,A
				INX  H
				LDA  00595H
				MOV  M,A
				INR  B
				JNZ  0095FH
				LDA  00108H
				ORA  A
				CZ   006C4H
				JZ   00949H
				ADD  C
				JC   00949H
				CMP  M
				JNC  00949H
				MOV  M,A
L0949:
				LDA  0173EH
				ORA  A
				JNZ  0099BH
				LXI  H,016ADH
				LXI  B,04E2DH
				CALL FillMemWithC
				CALL 00F17H
				JMP  0099BH
L095F:
				INR  B
				JZ   0099BH
				LXI  D,01A00H
				CALL setDMA				; 006EFH
				MVI  C,vSearchForFirst
				CALL sysCall0						; 006E7H
				JZ   0098DH
				LXI  D,messReplaceQues				; 014D5H
				CALL sendString00						; 00FBAH
L0977:
				CALL checkConsoleIn					; 006F4H
				JZ   00977H
				MOV  E,A
				CALL sendNL							; 00F85H
				MOV  A,E
				CALL	upperCaseAcc			; 012DAH
				CPI  059H
				RNZ
				MVI  C,vDeleteFile
				CALL sysCall0						; 006E7H
L098D:
				MVI  C,vMakeFile
				CALL sysCall0						; 006E7H
				LXI  D,messDirFull					; 01505H
				JZ  sendErrorMess						; 0059BH
				STA  SetA2						; 006DEH
L099B:
				LDA  01770H
				CPI  004H
				JNC  00A01H
				CALL 00D90H
				CPI  003H
				JZ   009BAH
L09AB:
				CALL 00719H
				JC   009C0H
				CALL 00DC3H
				JMP  009ABH
L09B7:
				CALL 00DA3H
L09BA:
				CALL 00719H
				JNC  009B7H
L09C0:
				CALL 00DD5H
				LDA  L174F				; 0174FH
				INR  A
				RZ
				ORA  A
				XCHG
				LHLD 01786H
				PUSH PSW
				MOV  A,L
				SBB  E
				MOV  L,A
				MOV  A,H
				SBB  D
				MOV  H,A
				JNZ  009D9H
				INR  L
				DCR  L
L09D9:
				XTHL
				MOV  A,H
				POP  H
				LXI  D,messCRC							; 01593H
				CNZ  00FC4H
				LXI  H,01788H
				CALL 012BAH
				MOV  A,B
				ORA  C
				ORA  D
				ORA  E
				LXI  D,messLength							; 01597H
				CNZ  00FC4H
				CALL 006DAH
				LXI  H,SetA2							; 006DEH
				MVI  M,000H
				RNZ
				LXI  D,messCanNotCloseOut					; 01514H
				JMP  sendErrorMess						; 0059BH
L0A01:
				JNZ  00A79H
				LXI  B,003FFH
				CALL 00A6EH
				CALL 00719H
				MOV  C,A
				CALL 00719H
				ORA  C
				JZ   00A28H
L0A15:
				MVI  B,004H
				MOV  A,D
				SUB  B
				MOV  D,A
L0A1A:
				CALL 00719H
				STAX D
				INR  D
				DCR  B
				JNZ  00A1AH
				INR  E
				DCR  C
				JNZ  00A15H
L0A28:
				CALL 00D90H
				PUSH H
L0A2C:
				CALL 012E3H
				XRA  A
L0A30:
				MOV  L,A
				POP  PSW
				ORA  A
				RAR
				INR  A
				DCR  A
				JNZ  00A46H
				PUSH H
				CALL 00716H
				CALL 012E3H
				JC   00A67H
				POP  H
				STC
				RAR
L0A46:
				PUSH PSW
				MVI  H,01AH
				JNC  00A4EH
				INR  H
				INR  H
L0A4E:
				MOV  A,M
				INR  H
				MOV  B,M
				INR  B
				JNZ  00A5FH
				CMA
				CALL 012E3H
				CALL 00DA3H
				JMP  00A2CH
L0A5F:
				DCR  B
				JNZ  00A67H
				ORA  A
				JNZ  00A30H
L0A67:
				POP  H
L0A68:
				CALL 012E3H
				JMP  009C0H
L0A6E:
				LXI  H,01A00H
				MOV  M,L
				MOV  D,H
				MOV  E,L
				INX  D
				CALL moveHLtoDE		; 012FFH
				RET
L0A79:
				LXI  H,00B85H
				MVI  M,010H
				CPI  008H
				JNC  00A9CH
				LXI  D,00D1FH
				LXI  B,04FFFH
				LXI  H,00C74H
				CPI  006H
				MVI  A,055H
				JZ   00ADBH
				JC   00AD0H
				LXI  H,00CCDH
				JMP  00ADBH
L0A9C:
				JZ   00AA9H
				MVI  M,020H
				LXI  B,05FFFH
				MVI  A,020H
				JMP  00ABCH
L0AA9:
				CALL 00719H
				JC   00AB7H
				CPI  00CH
				LXI  D,messInCompatibleCruch					; 0152DH
				JNZ  sendErrorMess							; 0059BH
L0AB7:
				LXI  B,02FFFH
				MVI  A,010H
L0ABC:
				STA  00BB0H
				LXI  H,00000H
				SHLD 01798H
				LXI  D,00BC7H
				LXI  H,00BA1H
				MVI  A,009H
				JZ   00ADBH
L0AD0:
				PUSH H
				LXI  H,00DC3H
				SHLD 01794H
				POP  H
				JMP  00AE3H
L0ADB:
				PUSH H
				LXI  H,00DA3H
				SHLD 01794H
				POP  H
L0AE3:
				PUSH H
				LHLD 01794H
				SHLD 00D8EH
				POP  H
				SHLD 00B91H
				XCHG
				SHLD 00B1BH
				XCHG
				STA  0179AH
				MOV  A,B
				SUI  003H
				STA  00C3AH
				CALL 00A6EH
				PUSH H
				MOV  H,B
				MOV  L,C
				SHLD 0179BH
				POP  H
				DCX  B
				PUSH B
				XRA  A
L0B09:
				POP  B
				PUSH B
				PUSH PSW
				CALL 00B7FH
				POP  PSW
				INR  A
				JNZ  00B09H
				CALL 00D90H
L0B17:
				CALL 012E3H
L0B1A:
				CALL 00000H
				POP  B
				JC   00A68H
				PUSH H
				CALL 00BBEH
				INR  B
				JNZ  00B31H
				INX  H
				MOV  A,M
L0B2B:
				CALL 00D8AH
				JMP  00B17H
L0B31:
				DCR  B
				MOV  A,M
				ORA  A
				PUSH PSW
				JNZ  00B3DH
				MOV  H,B
				MOV  L,C
				CALL 00BBEH
L0B3D:
				MVI  D,001H
L0B3F:
				MOV  A,M
				CPI  01AH
				JC   00B50H
				MOV  M,D
				MOV  D,A
				DCX  H
				MOV  A,M
				MOV  M,E
				MOV  E,A
				INX  H
				XCHG
				JMP  00B3FH
L0B50:
				INX  H
				POP  PSW
				MOV  A,M
				PUSH PSW
				DCX  H
				PUSH D
				PUSH H
				CALL 00B7FH
				POP  H
L0B5B:
				INX  H
				MOV  A,M
				PUSH H
				CALL 00D8AH
				CALL 012E3H
				POP  D
				POP  H
				DCR  H
				JZ   00B78H
				INR  H
				DCX  D
				MOV  A,M
				MOV  M,D
				MOV  D,A
				DCX  H
				MOV  A,M
				MOV  M,E
				MOV  E,A
				INX  H
				PUSH D
				JMP  00B5BH
L0B78:
				POP  PSW
				JNZ  00B1AH
				JMP  00B2BH
L0B7F:
				LHLD 0179BH
				PUSH PSW
				MOV  A,H
				ANI  010H
				XTHL
				MOV  A,H
				POP  H
				RNZ
				INX  H
				SHLD 0179BH
				PUSH PSW
				PUSH B
				CALL 00000H
				XTHL
				CALL 00BBEH
				XCHG
				POP  H
				DCX  H
				MOV  M,E
				INX  H
				MOV  M,D
				INX  H
				POP  PSW
				MOV  M,A
				RET
				MOV  A,L
				DCR  L
				ORA  A
				JNZ  00BBEH
				MOV  A,H
				DCR  H
				LXI  D,0179BH
				JZ   00BBBH
				CPI  010H
				JZ   00BBEH
				ANA  H
				JNZ  00BBEH
				LXI  D,0179AH
				XCHG
				INR  M
				XCHG
L0BBE:
				MOV  D,H
				MOV  E,L
				DAD  H
				DAD  D
				LXI  D,01A01H
				DAD  D
				RET
				LXI  H,01798H
				DCR  M
				INX  H
				MOV  A,M
				INX  H
				MOV  B,M
				LXI  H,07FFFH
				ORA  A
				RAR
				INR  A
				DCR  A
				JZ   00C4EH
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				DCR  B
				JNZ  00BD2H
				ORA  A
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				JC   00BEFH
				STA  01799H
				MOV  A,H
				DCR  A
				ORA  L
				RNZ
				LXI  H,0179AH
				MOV  C,M
				MVI  M,009H
				DCX  H
				MOV  M,A
				DCX  H
				MOV  A,M
				ANI  007H
				JZ   00C35H
				MOV  B,A
				XRA  A
				MOV  M,A
				ADD  C
				DCR  B
				JNZ  00C1EH
				RAR
				RAR
				RAR
				ANI  00FH
				MOV  B,A
				PUSH B
				CALL 00716H
				CALL 012E3H
				POP  B
				DCR  B
				JNZ  00C29H
				LXI  H,01D00H
				LXI  B,02CFFH
				CALL 00A71H
				LXI  H,00101H
				SHLD 0179BH
				POP  H
				XTHL
				LXI  H,0FFFFH
				XTHL
				PUSH H
				JMP  00BC7H
				PUSH B
				PUSH H
				CALL 00716H
				CALL 012E3H
				POP  H
				POP  B
				RC
				PUSH PSW
				MOV  A,B
				ANI  008H
				XTHL
				MOV  A,H
				POP  H
				JNZ  00C68H
				STC
				RAR
				JMP  00BD9H
				MOV  L,H
				MOV  H,A
				MOV  A,B
				SUI  008H
				MOV  B,A
				JNZ  00C4EH
				JMP  00BEFH
				LXI  D,00000H
				MOV  L,A
				MOV  H,D
				DAD  B
				PUSH PSW
				MOV  A,H
				ORI  008H
				MOV  H,A
				POP  PSW
				PUSH PSW
				MOV  A,H
				RLC
				RRC
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				RAR
				INR  A
				DCR  A
				MOV  L,A
				XTHL
				MOV  A,H
				POP  H
				MOV  C,H
				MOV  A,L
				PUSH PSW
				MOV  A,L
				ADC  E
				MOV  L,A
				MOV  A,H
				ADC  D
				MOV  H,A
				JNZ  00CA2H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				JC   00CC2H
				MVI  B,00CH
				ORA  A
				PUSH PSW
				MOV  A,C
				RAR
				INR  A
				DCR  A
				MOV  C,A
				XTHL
				MOV  A,H
				POP  H
				RAR
				JNC  00CBBH
				XCHG
				DAD  D
				XCHG
				DAD  H
				DCR  B
				JNZ  00CAAH
				XCHG
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				DAD  H
				RAL  D
				MOV  L,H
				JMP  00CE4H
				MOV  L,A
				MVI  H,000H
				DAD  B
				MOV  D,H
				MOV  E,L
				DAD  H
				DAD  H
				DAD  D
				DAD  H
				DAD  H
				DAD  D
				DAD  H
				DAD  D
				DAD  H
				DAD  D
				DAD  H
				DAD  H
				DAD  H
				DAD  H
				DAD  H
				DAD  D
				MOV  A,H
				ANI  00FH
				MOV  H,A
				PUSH H
				CALL 00BBEH
				POP  D
				MOV  A,M
				ORA  A
				RZ
				LXI  B,04A00H
				PUSH H
				POP  H
				XCHG
				PUSH H
				DAD  H
				DAD  B
				MOV  E,M
				INX  H
				MOV  D,M
				MOV  A,D
				ORA  E
				JNZ  00CF3H
				XTHL
				MVI  E,065H
				DAD  D
				PUSH PSW
				MOV  A,H
				ANI  0EFH
				MOV  H,A
				POP  PSW
				PUSH H
				CALL 00BBEH
				POP  D
				MOV  A,M
				ORA  A
				JZ   00D19H
				XCHG
				INX  H
				JMP  00D04H
				XTHL
				MOV  M,D
				DCX  H
				MOV  M,E
				POP  H
				RET
				CALL 00716H
				CALL 012E3H
				RC
				MOV  E,A
				LXI  H,0179AH
				PUSH PSW
				MOV  A,M
				RRC
				INR  A
				DCR  A
				MOV  M,A
				XTHL
				MOV  A,H
				POP  H
				JC   00D3DH
				DCX  H
				MOV  A,M
				ANI  00FH
				XCHG
				MOV  H,A
				RET
				PUSH D
				CALL 00716H
				CALL 012E3H
				POP  H
				RC
				STA  01799H
				ANI  0F0H
				RAL  D
				MOV  H,A
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D59H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D68H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D77H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  00D86H
				INR  L
				DCR  L
				XTHL
				MOV  A,H
				POP  H
				RET
L0D8A:
				CALL 012E3H
				JMP  00000H
L0D90:
				LHLD 01795H
				MVI  L,000H
				XCHG
				MOV  H,E
				MOV  L,E
				MOV  B,E
				RET

;     <New constant fragment-----from 0D9A to 0DA2 ( DA2 : 3490)>
;              ORG  00D9AH
				DB		01AH,01AH,01AH,01EH
				DB		06AH,06AH,06AH,04AH,07AH

;     <New code fragment-----from 0DA3 to 1318 (1318 : 4888)>
;              ORG  00DA3H
L0DA3:
				DCR  B
				JNZ  00DBCH
				MOV  B,A
				ORA  A
				JNZ  00DB5H
				MVI  A,090H
				JMP  00DC3H
L0DB1:
				MOV  A,C
				CALL 00DC3H
L0DB5:
				DCR  B
				JNZ  00DB1H
				RET
L0DBA:
				INR  B
				RET
L0DBC:
				INR  B
				CPI  090H
				JZ   00DBAH
				MOV  C,A
L0DC3:
				STAX D
				XRA  L
				MOV  L,A
				MOV  A,H
				MVI  H,018H
				XRA  M
				INR  H
				MOV  H,M
				MOV  L,A
				INR  E
				RNZ
				INR  D
				LDA  01797H
				CMP  D
				RNZ
L0DD5:
				PUSH H
				LHLD 01795H
				XRA  A
				MOV  L,A
				XCHG
				PUSH PSW
				MOV  A,L
				SBB  E
				MOV  L,A
				MOV  A,H
				SBB  D
				MOV  H,A
				JNZ  00DE8H
				INR  L
				DCR  L
L0DE8:
				XTHL
				MOV  A,H
				POP  H
				JZ   00E16H
				PUSH B
				MOV  B,H
				MOV  C,L
				LHLD 01788H
				PUSH PSW
				MOV  A,L
				SBB  C
				MOV  L,A
				MOV  A,H
				SBB  B
				MOV  H,A
				JNZ  00E00H
				INR  L
				DCR  L
L0E00:
				XTHL
				MOV  A,H
				POP  H
				SHLD 01788H
				JNC  00E10H
				LHLD 0178AH
				DCX  H
				SHLD 0178AH
L0E10:
				PUSH D
				CALL 00E18H
				POP  D
				POP  B
L0E16:
				POP  H
				RET
L0E18:
				LDA  SetA2		;006DEH
				ORA  A
				JZ   00E57H
				MOV  H,D
				MOV  L,E
				DAD  B
				JMP  00E29H
L0E25:
				MVI  M,01AH
				INX  H
				INX  B
L0E29:
				MOV  A,L
				ANI  07FH
				JNZ  00E25H
				ORA  B
				JZ   00E3FH
L0E33:
				PUSH B
				CALL 00E41H
				CALL 00E41H
				POP  B
				DCR  B
				JNZ  00E33H
L0E3F:
				ORA  C
				RZ
L0E41:
				LXI  H,00080H
				DAD  D
				PUSH H
				CALL setDMA				; 006EFH
				MVI  C,vWriteSeq
				CALL sysCall0						; 006E7H
				POP  D
				DCR  A
				RZ
				LXI  D,messDiskFull					; 014FBH
				JMP  sendErrorMess					; 0059BH
L0E57:
				LDA  checkValidFlag					; 0173FH
				ORA  A
				RNZ
				LDA  0173EH
				ORA  A
				JNZ  00EAEH
L0E63:
				LDAX D
				CPI  01AH
				JZ   00531H
				PUSH B
				INR  A
				ANI  07FH
				CPI  021H
				DCR  A
				JC   00E7FH
L0E73:
				CALL sendCharOut               ; 00F58H
L0E76:
				INX  D
				POP  B
				DCX  B
				MOV  A,B
				ORA  C
				JNZ  00E63H
				RET
L0E7F:
				CPI  009H
				JZ   00E73H
				JC   00E76H
				CPI  00DH
				JNC  00E76H
				CALL sendNL								; 00F85H
				PUSH D
				CALL checkConsoleIn					; 006F4H
				POP  D
				LXI  H,0173CH
				INR  M
				JZ   00E76H
				LDA  00109H
				CMP  M
				JNZ  00E76H
				CALL 006C4H
				JZ   00E76H
				LXI  D,messLineLimitExceeded				; 0154FH
				JMP  sendErrorMess						; 0059BH
L0EAE:
				XCHG
L0EAF:
				MOV  E,M
				PUSH H
				PUSH B
				MVI  C,vListOutput
				CALL BDOS
				CALL checkConsoleIn					; 006F4H
				POP  B
				POP  H
				INX  H
				DCX  B
				MOV  A,B
				ORA  C
				JNZ  00EAFH
				RET
				
;   display file info????
L0EC4:
				LHLD buffer1					; get the value
				MOV  A,H						; test if value is 00
				ORA  L
				INX  H
				SHLD buffer1					; incremnt and save the value
				CZ		doFilesHeader			; call if it was zero - 00FCFH
				LXI  D,0177EH
				PUSH D
				LXI  H,01736H
				CALL add4BytesDEtoHL			; 012C2H
				LXI  D,01788H					; point at the Length
				PUSH D							; save and rember 1788 (see below)
				LXI  H,01730H
				CALL add4BytesDEtoHL			; Add length to 1730
				LXI  H,016ADH
				LXI  D,wFileName				; 01750H
				MVI  C,000H
				CALL trimFullName						; 00FFEH
				POP  D
				PUSH D							; save and rember 1788 (see above)
				CALL 0123FH
				CALL 01015H
				CALL 01055H
				POP  B
				POP  D
				CALL 01087H
				LDA  01782H
				ORA  A
				JNZ  00F0EH
				MVI  B,012H
				CALL 012D1H
				JMP  00F14H
L0F0E:
				CALL 0119AH
				CALL 011D5H
L0F14:
				CALL 01208H
L0F17:
				LXI  D,016ADH
				JMP  00F53H
L0F1D:
				LXI  H,016ADH
				XCHG
				LHLD buffer1				; 0172EH
				XCHG
				CALL 01231H
				LXI  D,01730H
				PUSH D
				CALL 0123FH
				XCHG
				LHLD 01734H
				XCHG
				CALL 0104EH
				MVI  B,00DH
				CALL 012D1H
				POP  B
				LXI  D,01736H
				CALL 01087H
				MVI  B,014H
				CALL 012D1H
				XCHG
				LHLD 0173AH
				XCHG
				CALL 01219H
				LXI  D,01656H
L0F53:
				MVI  M,000H
				JMP  sendStringNL00				; 00F82H
sendCharOut:				;L0F58
				CPI  BELL
				JNZ  00F62H 		; skip if BELL
				LXI  H,0010EH
				ANA  M 			; and with 0xFFH
				RZ 				; return if Character is a NULL
L0F62:
				PUSH D			; save, it will be changed
L0F63:
				MOV  E,A 			; move charter to E for output
				DCR  A 			; checking to see it it was SOH (0x01h)
				JZ   00F6FH    	; jump it indeed it was a SOH
				MVI  C,vConsoleOutput
				CALL BDOS
				POP  D
				RET
L0F6F:
				LXI  D,0014CH
L0F72:
				LDAX D
				CPI  020H
				JZ   00F63H
				CALL sendCharOut								; 00F58H
				INX  D
				JMP  00F72H
				
sendStringNL00NL:								; L0F7F
				CALL sendNL
sendString00NL:									; L0F82
				CALL sendString00								; 00FBAH
sendNL:													; L0F85
				MVI  A,CR
				CALL sendCharOut								; 00F58H
				MVI  A,LF
				CALL sendCharOut								; 00F58H
				LXI  H,pauseCount			 	; 01742
				DCR  M							; decrement pause count
				RNZ								; return if not pausing here
; modified code *****
				DB	0EH							; MVI
pauseFlag:		DB	00H							; 0= no-pause, nn = pauseLimit
				ORA  A							; if it is set for no-pause
				RZ								; then return, don't pause SetA3+1 != 0
				MOV  M,A						; then reset the pauseCount from pauseFlag
				PUSH D							; save for later
				LXI  D,messMore					; Point at the more message [more]
				CALL sendString00				; display
L0FA0:
				CALL checkConsoleIn					; 006F4H
				JZ   00FA0H
				PUSH PSW
				LXI  D,015A5H
				CALL sendString00								; 00FBAH
				POP  PSW
				POP  D
				XRI  020H
				RNZ
				INR  A
				STA  01742H
				RET
sendStringNL00:										; L0FB7:
				CALL sendNL								; 00F85H
sendString00:										; L0FBA
				LDAX D 			; get next byte
				ORA  A 			; if its a NULL
				RZ             	; return, done
				CP   sendCharOut	; send if MSB = 0 (ASCII character) 00F58H
				INX  D
				JMP  sendString00							; 00FBAH
L0FC4:
				PUSH D
				LXI  D,messWarningStart					; 0156BH
				CALL sendString00							; 00FBAH
				POP  D
				JMP  sendStringNL00				; 00F82H
; display - List all files in archive on drive n
; do the 1st line Name etc
doFilesHeader:									; L0FCF
				CALL sendNL
				LXI  D,txtName					; 01607H --
				PUSH D
				LDAX D
doFilesHeader1:
				CPI  EQUAL_SIGN
				JNZ  doFilesHeader2					; skip if not an Equal Sign
				MVI  A,SPACE					; else replace it with  a Space
doFilesHeader2:
				CALL sendCharOut
				INX  D
				LDAX D
				ORA  A
				JNZ  doFilesHeader1				; keep looping until Zero found
				
; just finishe displaying header do the underline equal signs;
				POP  D							; pop txtName
				CALL sendNL
doFilesHeader3:
				LDAX D
				ORA  A
				JZ   sendNL						; done if char is NULL (String00)
				CPI  SPACE						; if its a space display it else show Equal Sign
				JZ   doFilesHeader4
				MVI  A,EQUAL_SIGN				; going to display an Equal Sign
doFilesHeader4:
				CALL sendCharOut
				INX  D
				JMP  doFilesHeader3				; go for more
;
;		Trim with char to remove in(C)
;		Source in (DE)
;		Target in (HL)
;		target with put a period in position 4 from the end		
		
trimFullName:							; L0FFE:
				MVI  B,FullNameSize +1	;  name.ext 00CH
trimFullName1:							; L1000:
				MOV  A,B				; get position
				CPI  004H				; is it 4 from the end ?
				MVI  A,PERIOD			; looking for the period
				JZ   trimFullName2		; skip if its 4 from the end - 0100EH
				LDAX D 					; get the character						
				INX  D					; set up for next character
				CMP  C					; is it the target character
				JZ   trimFullName3		; skip if yes
trimFullName2:
				MOV  M,A				; move from source to target location
				INX  H					; set up for next target location
trimFullName3:
				DCR  B					; keep count
				JNZ  trimFullName1		;loop if not doen
				RET
		
L1015:
				PUSH H
				LHLD 01788H
				LDA  0178AH
				LXI  D,003FFH
				DAD  D
				ACI  000H
				RAR
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				RAR
				PUSH PSW
				MOV  A,H
				RAR
				INR  A
				DCR  A
				MOV  H,A
				XTHL
				MOV  A,H
				POP  H
				ANI  03FH
				MOV  L,H
				MOV  H,A
				LDA  blockMask			; 01743H
				DCR  A
				MOV  E,A
				MVI  D,000H
				DAD  D
				CMA								; complement Acc
				ANA  L
				MOV  E,A
				MOV  D,H
				LHLD 01734H
				DAD  D
				SHLD 01734H
				POP  H
L104E:
				CALL 01231H
				MVI  M,06BH
				INX  H
				RET
L1055:
				CALL 012CFH
				XCHG
				LXI  H,015D7H
				LDA  01770H
				PUSH PSW
				LXI  B,00008H
				CPI  003H
				JC   0107DH
				DAD  B
				JZ   0107DH
				DAD  B
				CPI  004H
				JZ   0107DH
				DAD  B
				CPI  009H
				JC   0107DH
				DAD  B
				JZ   0107DH
				DAD  B
L107D:
				CALL moveHLtoDE		; 012FFH
				XCHG
				POP  PSW
L1082:
				MVI  B,003H
				JMP  0123AH
L1087:
				PUSH D
				PUSH B
				CALL 0123FH
				POP  D
				XTHL
				PUSH D
				CALL 012BAH
				MOV  H,B
				MOV  L,C
				PUSH D
				XTHL
				SHLD 01794H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  010AFH
				INR  L
				DCR  L
L10AF:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  D
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  C
				MOV  L,A
				MOV  A,H
				ADC  B
				MOV  H,A
				JNZ  010C7H
				INR  L
				DCR  L
L10C7:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  010DFH
				INR  L
				DCR  L
L10DF:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  010F7H
				INR  L
				DCR  L
L10F7:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  0110FH
				INR  L
				DCR  L
L110F:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  D
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  C
				MOV  L,A
				MOV  A,H
				ADC  B
				MOV  H,A
				JNZ  01127H
				INR  L
				DCR  L
L1127:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  0113FH
				INR  L
				DCR  L
L113F:
				XTHL
				MOV  A,H
				POP  H
				PUSH H
				LHLD 01794H
				DAD  H
				SHLD 01794H
				POP  H
				PUSH PSW
				MOV  A,L
				ADC  L
				MOV  L,A
				MOV  A,H
				ADC  H
				MOV  H,A
				JNZ  01157H
				INR  L
				DCR  L
L1157:
				XTHL
				MOV  A,H
				POP  H
				XTHL
				CALL 012BAH
				PUSH H
				LHLD 01794H
				XTHL
				POP  H
				MOV  A,B
				ORA  C
				ORA  D
				ORA  E
				JZ   01191H
				MVI  A,065H
L116D:
				DCR  A
				PUSH PSW
				MOV  A,L
				SBB  E
				MOV  L,A
				MOV  A,H
				SBB  D
				MOV  H,A
				JNZ  0117AH
				INR  L
				DCR  L
L117A:
				XTHL
				MOV  A,H
				POP  H
				XTHL
				PUSH PSW
				MOV  A,L
				SBB  C
				MOV  L,A
				MOV  A,H
				SBB  B
				MOV  H,A
				JNZ  0118AH
				INR  L
				DCR  L
L118A:
				XTHL
				MOV  A,H
				POP  H
				XTHL
				JNC  0116DH
L1191:
				POP  H
				POP  H
				CALL 01238H
				MVI  M,025H
				INX  H
				RET
L119A:
				LDA  01782H
				ANI  01FH
				CALL 01238H
				MVI  M,020H
				INX  H
				XCHG
				LHLD 01782H
				PUSH H
				DAD  H
				DAD  H
				DAD  H
				MOV  A,H
				ANI  00FH
				CPI  00DH
				JC   011B6H
				XRA  A
L11B6:
				MOV  C,A
				MVI  B,000H
				LXI  H,mess3Dollar					; 015B0H
				DAD  B
				DAD  B
				DAD  B
				MVI  C,003H
				CALL moveHLtoDE		; 012FFH
				XCHG
				MVI  M,020H
				INX  H
				POP  PSW
				ORA  A
				RAR
				INR  A
				DCR  A
				ADI  050H
L11CF:
				LXI  B,00230H
				JMP  01252H
L11D5:
				XCHG
				LHLD 01784H
				MOV  A,H
				RAR
				RAR
				RAR
				ANI  01FH
				MVI  B,061H
				JZ   011F0H
				CPI  00CH
				JC   011F2H
				MVI  B,070H
				SUI  00CH
				JNZ  011F2H
L11F0:
				MVI  A,00CH
L11F2:
				PUSH B
				DAD  H
				DAD  H
				DAD  H
				PUSH H
				XCHG
				CALL 01082H
				MVI  M,03AH
				INX  H
				POP  PSW
				ANI  03FH
				CALL 011CFH
				POP  PSW
				MOV  M,A
				INX  H
				RET
L1208:
				CALL 012CFH
				XCHG
				LHLD 01786H
				XCHG
				PUSH H
				LHLD 0173AH
				DAD  D
				SHLD 0173AH
				POP  H
L1219:
				CALL 0121DH
				MOV  D,E
L121D:
				MOV  M,D
				MOV  A,M
				RLC
				RLC
				RLC
				RLC
				CALL 01227H
				MOV  A,D
L1227:
				ORI  0F0H
				DAA
				CPI  060H
				SBI  01FH
				MOV  M,A
				INX  H
				RET
				
L1231:
				MVI  B,005H
				MVI  C,020H
				JMP  01255H
				
L1238:
				MVI  B,004H
L123A:
				MVI  C,020H
				JMP  01252H
				
L123F:
				LXI  B,00920H
				PUSH D						; save 1788 ie length
				CALL 012E3H
				POP  H						; put 1788 into HL
				MOV  E,M
				INX  H
				MOV  D,M					; put actual length in DE
				INX  H
				MOV  A,M					; get next byte into A
				INX  H
				MOV  H,M					; get fourth byte into H
				XCHG						; HL has actual length, 3rd byte in A , forth byte in D?
				JMP  0125CH
				
L1252:
				MOV  E,A
				MVI  D,000H
L1255:
				PUSH D
				CALL 012E3H
				POP  H
				XRA  A
				MOV  D,A
L125C:
				MOV  E,A				; HL has  length, DE has next two bytes
				MVI  C,00AH				; are we converting the number to decimal ?
				STC						; set the carry
				PUSH PSW
L1261:
				CALL 0128FH
				ORI  030H
				CALL 012E3H
				DCR  B
				JNZ  01274H
L126D:
				MOV  M,A
				INX  H
L126F:
				POP  PSW
				JNC  0126DH
				RET
L1274:
				PUSH PSW
				CALL 012E3H
				MOV  A,H
				ORA  L
				ORA  D
				ORA  E
				JNZ  01261H
				CALL 012E3H
				ORA  C
				JZ   0126FH
L1286:
				MOV  M,A
				INX  H
				DCR  B
				JNZ  01286H
				JMP  0126FH
L128F:
				MOV  A,D
				ORA  E						; are D and E both Zeros ?
				JZ   0129DH					; skip if yes
				XRA  A
				CALL 01298H
L1298:
				XCHG
				ORA  A
				JNZ  012A3H
L129D:
				MOV  A,H					; get H's value
				CMP  C						; is it bigger than 10 decimal?
				JC   012A8H					; jump if not
				XRA  A						; else clear Acc
L12A3:
				MVI  B,010H					; put Decimal 16 into B
				JMP  012ADH					; and jump
L12A8:
				MOV  H,L					; get loByte					
				MVI  L,000H
				MVI  B,008H					; stuff B with decimal 8
L12AD:
				DAD  H						; multiply Lo byte by 2
				RAL  D						; any carry ??  --Whats the D there for ??
				CMP  C						; greater than decimal 10
				JC   012B5H					; jump if not
				SUB  C						; else take 10 away and
				INR  L						;    carry 1 (decimal)
L12B5:
				DCR  B						; keep count
				JNZ  012ADH					; if not dome loop for more
				RET
				
L12BA:
				MOV  E,M
				INX  H
				MOV  D,M
				INX  H
				MOV  C,M
				INX  H
				MOV  B,M
				RET
add4BytesDEtoHL:						; L12C2
				MVI  B,004H				; load the counter
				ORA  A					; clear Acc
add4BytesDEtoHL1:
				LDAX D					; get the byte
				ADC  M					; with memory content
				MOV  M,A				; save the result
				INX  H					; incremnt both
				INX  D					;   pointers
				DCR  B					; Count down
				JNZ  add4BytesDEtoHL1	; loop until done
				RET
				
L12CF:
				MVI  B,002H
L12D1:
				MVI  C,020H
; Fill memory with (C) for (B) bytes	L12D3	
FillMemWithC:
				MOV  M,C
				INX  H
				DCR  B
				JNZ  FillMemWithC
				RET
;				
upperCaseAcc:							; L12DA:
				CPI  ASCII_LO_A
				RC						; return if less than 61H
				CPI  LEFT_CURLY
				RNC						; return if greater than 7BH
				ADI  0E0H				; else, make Acc upper case
				RET
				
; called a lot
L12E3:
				PUSH H					; save HL as called
				LHLD 0178CH				; get whats in 178c
				XTHL					; put on stack
				SHLD 0178CH				; put HL's content into 178c
				PUSH D					; save DE as Called
				LHLD 0178EH
				XTHL
				SHLD 0178EH				; put DE's content into 178c
				PUSH B					; save BC as called
				LHLD 01790H
				XTHL
				SHLD 01790H
				POP  B
				POP  D
				POP  H
				RET
;
;         move (HL) to (DE) for (BC) bytes
;		  
moveHLtoDE:							; L12FF

				PUSH PSW						; save acc
moveHLtoDE1:						; L1300
				MOV  A,M						; get value from (HL)
				STAX D						; put value in (DE)
				INX  H 						; Incremement HL
				INX  D 						; Incremement DE
				DCX  B						; count down BC
				MOV  A,B
				ORA  C
				JNZ  moveHLtoDE1			; loop until BC = 00  - 01300H
				POP  PSW       				; restore ACC
				RET            				; exit


;		Check for the occurance of a Value (ACC)
;		in Memory(HL)
;		(BC) has byte count
;		
haveValue0:					; L130C
				POP  PSW			; restore Target value
haveValue:					; L130D
				CMP  M			; does (HL) = Target?
				INX  H      		; inc (HL)		
				DCX  B         	; couunt down
				RZ             	; return if target found
				PUSH PSW			; save the target value
				MOV  A,B       	; have we counted
				ORA  C         	;    all the way down
				JNZ  haveValue0	; keep goin if not
				POP  PSW       	; else  return flags and target to Acc
				RET            	; and exxit

;     <New literal fragment-----from 1319 to 16AC (16AC : 5804)>
;              ORG  01319H
messZ80:
				DB		'NOTE: The Z80 version is smaller and faster!'
				DB		CR
				DB		LF
				DB		QMARK
messAborted:
				DB		BELL
				DB		SOH
				DB		'aborted!'
				DB		NULL
messVer:
				DB		'CP/M version 2 or higher required'
				DB		NULL
messNEMemory:
				DB		'Not enough memory'
				DB		NULL
messAmbigFile:
				DB		'Ambiguous archive file name'
				DB		NULL
messMissingArchiveFile:
				DB		'Cannot find archive file'
				DB		NULL
sendStringNL00:
				DB		'Invalid archive file format'
				DB		NULL
messBadArchHeader:
				DB		BELL
				DB		'Warning  Bad archive file header  bytes skipped   00000'
				DB		NULL
messNoMatchingFile:
				DB		'No matching file(s) in archive'
				DB		NULL
 messBadArchFileDrive:
			   DB		'Invalid archive file drive'
				DB		NULL
 messBadOutputDrive:
			   DB		'Invalid output drive'
				DB		NULL
messArchFileEqual:
				DB		'Archive File = '
messArcFileName:
				DS	12
				DB		NULL
messOutDriveEquals:
				DB		'Output Drive = A:'
				DB		NULL
messCheckingArch:
				DB		'Checking archive...'
				DB		NULL
messNeedNewerArch:
				DB		'Cannot extract file (need newer version of UNARC'
				DB		DOLLAR
				DB		')'
				DB		NULL
messReplaceQues:
				DB		BELL
				DB		'Replace existing output file (y/n)'
				DB		DOLLAR
				DB		' '
				DB		NULL
messDiskFull:
				DB		'Disk full'
				DB		NULL
messDirFull:
				DB		'Directory full'
				DB		NULL
messCanNotCloseOut:
				DB		'Cannot close output file'
				DB		NULL
messInCompatibleCruch:
				DB		'Incompatible crunched file format'
				DB		NULL
messLineLimitExceeded:
				DB		'Typeout line limit exceeded'
				DB		NULL
messWarningStart:
				DB		BELL
				DB		'Warning: Extracted file has incorrect '
				DB		NULL
messCRC:
				DB		'CRC'
				DB		NULL
messLength:
				DB		'length'
				DB		NULL
messMore:
				DB		'[more]'
				DB		NULL
				DB		CR
				DB		'       	'
				DB		CR
				DB		NULL
mess3Dollar:
				DB		DOLLAR
				DB		DOLLAR
				DB		DOLLAR
				DB		'JanFebMarAprMayJunJulAugSepOctNovDec'
				DB		'Unpacked Packed SqueezedCrunchedSquashedUnknown'
				DB		'!'
txtName:		DB		'Name'
				DB		'========  ='
				DB		'Length '
				DB		' Disk  '
				DB		'=Method '
				DB		'= Ver '
				DB		'=Stored '
				DB		'Saved '
				DB		'==='
				DB		'Date'
				DB		'== '
				DB		'=Time= '
				DB		'CRC='
				DB		NULL
				DB		'        ====  =======  ====               =======  ===                    ===='
				DB		CR
				DB		LF
				DB		'Total  '

;     <New code fragment-----from 16AD to 1718 (1718 : 5912)>
;              ORG  016ADH

; might not be code fragement ---------
				MVI  C,vGetCurDisk
				CALL BDOS
				MOV  B,A
				ADI  041H
				STA  01782H
				LXI  D,0005CH
				LDAX D
				ORA  A
				JNZ  016DCH
				MOV  A,B
				INR  A
				STA  blockMask			; 01743H
				ADI  040H
				STA  01765H
				LXI  H,01733H
				LXI  B,00037H
				CALL 01723H
				LXI  D,00100H
				LXI  H,0011AH
				LXI  B,015ADH
				CALL 01723H
				STA  00103H
				INR  A
				STA  0010DH
				MVI  A,024H
				STA  0017EH
				STA  0049AH
				LXI  D,01790H
				CALL buffer1				; 0172EH
				LXI  D,0014CH
				CALL buffer1				; 0172EH
				LXI  D,0046CH
				CALL buffer1				; 0172EH
				LXI  D,0176AH
				CALL buffer1				; 0172EH
				JMP  004BFH
				MOV  A,M
				STAX D
				INX  H
				INX  D
				DCX  B
				MOV  A,B
				ORA  C
				JNZ  01723H
				RET
				MVI  C,vPrintString
				JMP  BDOS

;     <New literal fragment-----from 1719 to 1734 (1734 : 5940)>
;              ORG  01719H
				DB		NULL
;              ORG  0171AH
				DB		'UNARC16 COM'
				DB		NULL
;              ORG  01726H
				DB		NULL
				DB		NULL
				DB		NULL
				DB		NULL
				DB		'    '

buffer1:												; L0172E
			   DB	'       '

;     <New unknown fragment-----from 1735 to 173/E/d (173E : 5950)>
;              ORG  01735H
L1735:			DS	1
L1736:			DS	1
L1737:			DS	1
L1738:			DS	1
L1739:			DS	1
L173A:			DS	1
L173B:			DS	1
L173C:			DS	1
flagOS:			DS	1		; K = CP/M | C = MS-DOS

printFlag:		DS	1
;         ORG  0173FH
checkValidFlag:	DS	1
bufferPointer:
L1740:			DS	1		;  flag ???  (was set with -1)
L1741:			DS	1
pauseCount:		DS	1		; L1742	
blockMask:		DS	1		; L1743		

targetFCB:		DS 11

L174F:
				DB		NULL
; might just be buffer and storage area ie DS nn, not DB  xx
wFileName:		DB		CR
				DB		LF
				DB		LF
				DB		'(Self-unpacking file A:UNARC16.COM)'
				DB		CR
				DB		LF
				DB		QMARK
				
				DS		17H
L1790:			DS		2
L1792:			DS		2				
L1794:			DS		2
L1796:			DS		2
L1798:
	



			
CodeEnd:
